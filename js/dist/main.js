/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		0: 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({"1":"vendors~canvg","2":"vendors~pdfmake","3":"vendors~xlsx","4":"xlsx"}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 135);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js
//! version : 2.25.3
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
     true ? module.exports = factory() :
    undefined
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }

    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }

    function map(arr, fn) {
        var res = [],
            i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidEra &&
                    !flags.invalidMonth &&
                    !flags.invalidWeekday &&
                    !flags.weekdayMismatch &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated &&
                    (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key;
                for (i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        return mom.isValid()
            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
            : NaN;
    }

    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (
                unit === 'FullYear' &&
                isLeapYear(mom.year()) &&
                mom.month() === 1 &&
                mom.date() === 29
            ) {
                value = toInt(value);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                    value,
                    mom.month(),
                    daysInMonth(value, mom.month())
                );
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i;
            for (i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                    matched,
                    p1,
                    p2,
                    p3,
                    p4
                ) {
                    return p1 || p2 || p3 || p4;
                })
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
            '_'
        ),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
        input,
        week,
        config,
        token
    ) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
            ? weekdays[m.day()]
            : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &&
            typeof module !== 'undefined' &&
            module &&
            module.exports
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = require;
                __webpack_require__(134)("./" + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                    ? DATE
                    : a[HOUR] < 0 ||
                      a[HOUR] > 24 ||
                      (a[HOUR] === 24 &&
                          (a[MINUTE] !== 0 ||
                              a[SECOND] !== 0 ||
                              a[MILLISECOND] !== 0))
                    ? HOUR
                    : a[MINUTE] < 0 || a[MINUTE] > 59
                    ? MINUTE
                    : a[SECOND] < 0 || a[SECOND] > 59
                    ? SECOND
                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                    ? MILLISECOND
                    : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^)]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged and will be removed in an upcoming major release. Please refer to ' +
            'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');

    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
            ? 'lastWeek'
            : diff < 0
            ? 'lastDay'
            : diff < 1
            ? 'sameDay'
            : diff < 2
            ? 'nextDay'
            : diff < 7
            ? 'nextWeek'
            : 'sameElse';
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break; // 1000
            case 'minute':
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case 'hour':
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
        input,
        array,
        config,
        token
    ) {
        var era = config._locale.erasParse(input, token, config._strict);
        if (era) {
            getParsingFlags(config).era = era;
        } else {
            getParsingFlags(config).invalidEra = input;
        }
    });

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    // truncate time
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    // truncate time
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }

        return '';
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return '';
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return '';
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.startOf('day').valueOf();

            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();

        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));

            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
        input,
        week,
        config,
        token
    ) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y');

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = '2.25.3';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM', // <input type="month" />
    };

    return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(133)(module)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var af = moment.defineLocale('af', {
        months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split(
            '_'
        ),
        weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM: function (input) {
            return /^nm$/i.test(input);
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Vandag om] LT',
            nextDay: '[Môre om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[Gister om] LT',
            lastWeek: '[Laas] dddd [om] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'oor %s',
            past: '%s gelede',
            s: "'n paar sekondes",
            ss: '%d sekondes',
            m: "'n minuut",
            mm: '%d minute',
            h: "'n uur",
            hh: '%d ure',
            d: "'n dag",
            dd: '%d dae',
            M: "'n maand",
            MM: '%d maande',
            y: "'n jaar",
            yy: '%d jaar',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function (number) {
            return (
                number +
                (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
            ); // Thanks to Joris Röling : https://github.com/jjupiter
        },
        week: {
            dow: 1, // Maandag is die eerste dag van die week.
            doy: 4, // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        },
    });

    return af;

})));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '١',
            '2': '٢',
            '3': '٣',
            '4': '٤',
            '5': '٥',
            '6': '٦',
            '7': '٧',
            '8': '٨',
            '9': '٩',
            '0': '٠',
        },
        numberMap = {
            '١': '1',
            '٢': '2',
            '٣': '3',
            '٤': '4',
            '٥': '5',
            '٦': '6',
            '٧': '7',
            '٨': '8',
            '٩': '9',
            '٠': '0',
        },
        pluralForm = function (n) {
            return n === 0
                ? 0
                : n === 1
                ? 1
                : n === 2
                ? 2
                : n % 100 >= 3 && n % 100 <= 10
                ? 3
                : n % 100 >= 11
                ? 4
                : 5;
        },
        plurals = {
            s: [
                'أقل من ثانية',
                'ثانية واحدة',
                ['ثانيتان', 'ثانيتين'],
                '%d ثوان',
                '%d ثانية',
                '%d ثانية',
            ],
            m: [
                'أقل من دقيقة',
                'دقيقة واحدة',
                ['دقيقتان', 'دقيقتين'],
                '%d دقائق',
                '%d دقيقة',
                '%d دقيقة',
            ],
            h: [
                'أقل من ساعة',
                'ساعة واحدة',
                ['ساعتان', 'ساعتين'],
                '%d ساعات',
                '%d ساعة',
                '%d ساعة',
            ],
            d: [
                'أقل من يوم',
                'يوم واحد',
                ['يومان', 'يومين'],
                '%d أيام',
                '%d يومًا',
                '%d يوم',
            ],
            M: [
                'أقل من شهر',
                'شهر واحد',
                ['شهران', 'شهرين'],
                '%d أشهر',
                '%d شهرا',
                '%d شهر',
            ],
            y: [
                'أقل من عام',
                'عام واحد',
                ['عامان', 'عامين'],
                '%d أعوام',
                '%d عامًا',
                '%d عام',
            ],
        },
        pluralize = function (u) {
            return function (number, withoutSuffix, string, isFuture) {
                var f = pluralForm(number),
                    str = plurals[u][pluralForm(number)];
                if (f === 2) {
                    str = str[withoutSuffix ? 0 : 1];
                }
                return str.replace(/%d/i, number);
            };
        },
        months = [
            'يناير',
            'فبراير',
            'مارس',
            'أبريل',
            'مايو',
            'يونيو',
            'يوليو',
            'أغسطس',
            'سبتمبر',
            'أكتوبر',
            'نوفمبر',
            'ديسمبر',
        ];

    var ar = moment.defineLocale('ar', {
        months: months,
        monthsShort: months,
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'D/\u200FM/\u200FYYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /ص|م/,
        isPM: function (input) {
            return 'م' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar: {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'بعد %s',
            past: 'منذ %s',
            s: pluralize('s'),
            ss: pluralize('s'),
            m: pluralize('m'),
            mm: pluralize('m'),
            h: pluralize('h'),
            hh: pluralize('h'),
            d: pluralize('d'),
            dd: pluralize('d'),
            M: pluralize('M'),
            MM: pluralize('M'),
            y: pluralize('y'),
            yy: pluralize('y'),
        },
        preparse: function (string) {
            return string
                .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                    return numberMap[match];
                })
                .replace(/،/g, ',');
        },
        postformat: function (string) {
            return string
                .replace(/\d/g, function (match) {
                    return symbolMap[match];
                })
                .replace(/,/g, '،');
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return ar;

})));


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var arDz = moment.defineLocale('ar-dz', {
        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
            '_'
        ),
        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
            '_'
        ),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'أح_إث_ثلا_أر_خم_جم_سب'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            ss: '%d ثانية',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات',
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return arDz;

})));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Kuwait) [ar-kw]
//! author : Nusret Parlak: https://github.com/nusretparlak

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var arKw = moment.defineLocale('ar-kw', {
        months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
            '_'
        ),
        monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
            '_'
        ),
        weekdays: 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            ss: '%d ثانية',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات',
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return arKw;

})));


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Lybia) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '1',
            '2': '2',
            '3': '3',
            '4': '4',
            '5': '5',
            '6': '6',
            '7': '7',
            '8': '8',
            '9': '9',
            '0': '0',
        },
        pluralForm = function (n) {
            return n === 0
                ? 0
                : n === 1
                ? 1
                : n === 2
                ? 2
                : n % 100 >= 3 && n % 100 <= 10
                ? 3
                : n % 100 >= 11
                ? 4
                : 5;
        },
        plurals = {
            s: [
                'أقل من ثانية',
                'ثانية واحدة',
                ['ثانيتان', 'ثانيتين'],
                '%d ثوان',
                '%d ثانية',
                '%d ثانية',
            ],
            m: [
                'أقل من دقيقة',
                'دقيقة واحدة',
                ['دقيقتان', 'دقيقتين'],
                '%d دقائق',
                '%d دقيقة',
                '%d دقيقة',
            ],
            h: [
                'أقل من ساعة',
                'ساعة واحدة',
                ['ساعتان', 'ساعتين'],
                '%d ساعات',
                '%d ساعة',
                '%d ساعة',
            ],
            d: [
                'أقل من يوم',
                'يوم واحد',
                ['يومان', 'يومين'],
                '%d أيام',
                '%d يومًا',
                '%d يوم',
            ],
            M: [
                'أقل من شهر',
                'شهر واحد',
                ['شهران', 'شهرين'],
                '%d أشهر',
                '%d شهرا',
                '%d شهر',
            ],
            y: [
                'أقل من عام',
                'عام واحد',
                ['عامان', 'عامين'],
                '%d أعوام',
                '%d عامًا',
                '%d عام',
            ],
        },
        pluralize = function (u) {
            return function (number, withoutSuffix, string, isFuture) {
                var f = pluralForm(number),
                    str = plurals[u][pluralForm(number)];
                if (f === 2) {
                    str = str[withoutSuffix ? 0 : 1];
                }
                return str.replace(/%d/i, number);
            };
        },
        months = [
            'يناير',
            'فبراير',
            'مارس',
            'أبريل',
            'مايو',
            'يونيو',
            'يوليو',
            'أغسطس',
            'سبتمبر',
            'أكتوبر',
            'نوفمبر',
            'ديسمبر',
        ];

    var arLy = moment.defineLocale('ar-ly', {
        months: months,
        monthsShort: months,
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'D/\u200FM/\u200FYYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /ص|م/,
        isPM: function (input) {
            return 'م' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar: {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'بعد %s',
            past: 'منذ %s',
            s: pluralize('s'),
            ss: pluralize('s'),
            m: pluralize('m'),
            mm: pluralize('m'),
            h: pluralize('h'),
            hh: pluralize('h'),
            d: pluralize('d'),
            dd: pluralize('d'),
            M: pluralize('M'),
            MM: pluralize('M'),
            y: pluralize('y'),
            yy: pluralize('y'),
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string
                .replace(/\d/g, function (match) {
                    return symbolMap[match];
                })
                .replace(/,/g, '،');
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return arLy;

})));


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var arMa = moment.defineLocale('ar-ma', {
        months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
            '_'
        ),
        monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
            '_'
        ),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            ss: '%d ثانية',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات',
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return arMa;

})));


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '١',
            '2': '٢',
            '3': '٣',
            '4': '٤',
            '5': '٥',
            '6': '٦',
            '7': '٧',
            '8': '٨',
            '9': '٩',
            '0': '٠',
        },
        numberMap = {
            '١': '1',
            '٢': '2',
            '٣': '3',
            '٤': '4',
            '٥': '5',
            '٦': '6',
            '٧': '7',
            '٨': '8',
            '٩': '9',
            '٠': '0',
        };

    var arSa = moment.defineLocale('ar-sa', {
        months: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
            '_'
        ),
        monthsShort: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
            '_'
        ),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /ص|م/,
        isPM: function (input) {
            return 'م' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            ss: '%d ثانية',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات',
        },
        preparse: function (string) {
            return string
                .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                    return numberMap[match];
                })
                .replace(/،/g, ',');
        },
        postformat: function (string) {
            return string
                .replace(/\d/g, function (match) {
                    return symbolMap[match];
                })
                .replace(/,/g, '،');
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return arSa;

})));


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var arTn = moment.defineLocale('ar-tn', {
        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
            '_'
        ),
        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
            '_'
        ),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            ss: '%d ثانية',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return arTn;

})));


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-üncü',
        4: '-üncü',
        100: '-üncü',
        6: '-ncı',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-ıncı',
        90: '-ıncı',
    };

    var az = moment.defineLocale('az', {
        months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split(
            '_'
        ),
        monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays: 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split(
            '_'
        ),
        weekdaysShort: 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
        weekdaysMin: 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[bugün saat] LT',
            nextDay: '[sabah saat] LT',
            nextWeek: '[gələn həftə] dddd [saat] LT',
            lastDay: '[dünən] LT',
            lastWeek: '[keçən həftə] dddd [saat] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s sonra',
            past: '%s əvvəl',
            s: 'birneçə saniyə',
            ss: '%d saniyə',
            m: 'bir dəqiqə',
            mm: '%d dəqiqə',
            h: 'bir saat',
            hh: '%d saat',
            d: 'bir gün',
            dd: '%d gün',
            M: 'bir ay',
            MM: '%d ay',
            y: 'bir il',
            yy: '%d il',
        },
        meridiemParse: /gecə|səhər|gündüz|axşam/,
        isPM: function (input) {
            return /^(gündüz|axşam)$/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gecə';
            } else if (hour < 12) {
                return 'səhər';
            } else if (hour < 17) {
                return 'gündüz';
            } else {
                return 'axşam';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
        ordinal: function (number) {
            if (number === 0) {
                // special case for zero
                return number + '-ıncı';
            }
            var a = number % 10,
                b = (number % 100) - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return az;

})));


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensúle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11
            ? forms[0]
            : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
            ? forms[1]
            : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            ss: withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
            mm: withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
            hh: withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
            dd: 'дзень_дні_дзён',
            MM: 'месяц_месяцы_месяцаў',
            yy: 'год_гады_гадоў',
        };
        if (key === 'm') {
            return withoutSuffix ? 'хвіліна' : 'хвіліну';
        } else if (key === 'h') {
            return withoutSuffix ? 'гадзіна' : 'гадзіну';
        } else {
            return number + ' ' + plural(format[key], +number);
        }
    }

    var be = moment.defineLocale('be', {
        months: {
            format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split(
                '_'
            ),
            standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split(
                '_'
            ),
        },
        monthsShort: 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split(
            '_'
        ),
        weekdays: {
            format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split(
                '_'
            ),
            standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split(
                '_'
            ),
            isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/,
        },
        weekdaysShort: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        weekdaysMin: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY г.',
            LLL: 'D MMMM YYYY г., HH:mm',
            LLLL: 'dddd, D MMMM YYYY г., HH:mm',
        },
        calendar: {
            sameDay: '[Сёння ў] LT',
            nextDay: '[Заўтра ў] LT',
            lastDay: '[Учора ў] LT',
            nextWeek: function () {
                return '[У] dddd [ў] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return '[У мінулую] dddd [ў] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[У мінулы] dddd [ў] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'праз %s',
            past: '%s таму',
            s: 'некалькі секунд',
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: relativeTimeWithPlural,
            hh: relativeTimeWithPlural,
            d: 'дзень',
            dd: relativeTimeWithPlural,
            M: 'месяц',
            MM: relativeTimeWithPlural,
            y: 'год',
            yy: relativeTimeWithPlural,
        },
        meridiemParse: /ночы|раніцы|дня|вечара/,
        isPM: function (input) {
            return /^(дня|вечара)$/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночы';
            } else if (hour < 12) {
                return 'раніцы';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечара';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return (number % 10 === 2 || number % 10 === 3) &&
                        number % 100 !== 12 &&
                        number % 100 !== 13
                        ? number + '-і'
                        : number + '-ы';
                case 'D':
                    return number + '-га';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return be;

})));


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var bg = moment.defineLocale('bg', {
        months: 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split(
            '_'
        ),
        monthsShort: 'яну_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
        weekdays: 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split(
            '_'
        ),
        weekdaysShort: 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
        weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'D.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY H:mm',
            LLLL: 'dddd, D MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[Днес в] LT',
            nextDay: '[Утре в] LT',
            nextWeek: 'dddd [в] LT',
            lastDay: '[Вчера в] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[Миналата] dddd [в] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[Миналия] dddd [в] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'след %s',
            past: 'преди %s',
            s: 'няколко секунди',
            ss: '%d секунди',
            m: 'минута',
            mm: '%d минути',
            h: 'час',
            hh: '%d часа',
            d: 'ден',
            dd: '%d дена',
            M: 'месец',
            MM: '%d месеца',
            y: 'година',
            yy: '%d години',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal: function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-ев';
            } else if (last2Digits === 0) {
                return number + '-ен';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-ти';
            } else if (lastDigit === 1) {
                return number + '-ви';
            } else if (lastDigit === 2) {
                return number + '-ри';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-ми';
            } else {
                return number + '-ти';
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return bg;

})));


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bambara [bm]
//! author : Estelle Comment : https://github.com/estellecomment

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var bm = moment.defineLocale('bm', {
        months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo'.split(
            '_'
        ),
        monthsShort: 'Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des'.split('_'),
        weekdays: 'Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
        weekdaysShort: 'Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib'.split('_'),
        weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'MMMM [tile] D [san] YYYY',
            LLL: 'MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm',
            LLLL: 'dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm',
        },
        calendar: {
            sameDay: '[Bi lɛrɛ] LT',
            nextDay: '[Sini lɛrɛ] LT',
            nextWeek: 'dddd [don lɛrɛ] LT',
            lastDay: '[Kunu lɛrɛ] LT',
            lastWeek: 'dddd [tɛmɛnen lɛrɛ] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s kɔnɔ',
            past: 'a bɛ %s bɔ',
            s: 'sanga dama dama',
            ss: 'sekondi %d',
            m: 'miniti kelen',
            mm: 'miniti %d',
            h: 'lɛrɛ kelen',
            hh: 'lɛrɛ %d',
            d: 'tile kelen',
            dd: 'tile %d',
            M: 'kalo kelen',
            MM: 'kalo %d',
            y: 'san kelen',
            yy: 'san %d',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return bm;

})));


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '১',
            '2': '২',
            '3': '৩',
            '4': '৪',
            '5': '৫',
            '6': '৬',
            '7': '৭',
            '8': '৮',
            '9': '৯',
            '0': '০',
        },
        numberMap = {
            '১': '1',
            '২': '2',
            '৩': '3',
            '৪': '4',
            '৫': '5',
            '৬': '6',
            '৭': '7',
            '৮': '8',
            '৯': '9',
            '০': '0',
        };

    var bn = moment.defineLocale('bn', {
        months: 'জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split(
            '_'
        ),
        monthsShort: 'জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে'.split(
            '_'
        ),
        weekdays: 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split(
            '_'
        ),
        weekdaysShort: 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
        weekdaysMin: 'রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি'.split('_'),
        longDateFormat: {
            LT: 'A h:mm সময়',
            LTS: 'A h:mm:ss সময়',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm সময়',
            LLLL: 'dddd, D MMMM YYYY, A h:mm সময়',
        },
        calendar: {
            sameDay: '[আজ] LT',
            nextDay: '[আগামীকাল] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[গতকাল] LT',
            lastWeek: '[গত] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s পরে',
            past: '%s আগে',
            s: 'কয়েক সেকেন্ড',
            ss: '%d সেকেন্ড',
            m: 'এক মিনিট',
            mm: '%d মিনিট',
            h: 'এক ঘন্টা',
            hh: '%d ঘন্টা',
            d: 'এক দিন',
            dd: '%d দিন',
            M: 'এক মাস',
            MM: '%d মাস',
            y: 'এক বছর',
            yy: '%d বছর',
        },
        preparse: function (string) {
            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                (meridiem === 'রাত' && hour >= 4) ||
                (meridiem === 'দুপুর' && hour < 5) ||
                meridiem === 'বিকাল'
            ) {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'রাত';
            } else if (hour < 10) {
                return 'সকাল';
            } else if (hour < 17) {
                return 'দুপুর';
            } else if (hour < 20) {
                return 'বিকাল';
            } else {
                return 'রাত';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return bn;

})));


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '༡',
            '2': '༢',
            '3': '༣',
            '4': '༤',
            '5': '༥',
            '6': '༦',
            '7': '༧',
            '8': '༨',
            '9': '༩',
            '0': '༠',
        },
        numberMap = {
            '༡': '1',
            '༢': '2',
            '༣': '3',
            '༤': '4',
            '༥': '5',
            '༦': '6',
            '༧': '7',
            '༨': '8',
            '༩': '9',
            '༠': '0',
        };

    var bo = moment.defineLocale('bo', {
        months: 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split(
            '_'
        ),
        monthsShort: 'ཟླ་1_ཟླ་2_ཟླ་3_ཟླ་4_ཟླ་5_ཟླ་6_ཟླ་7_ཟླ་8_ཟླ་9_ཟླ་10_ཟླ་11_ཟླ་12'.split(
            '_'
        ),
        monthsShortRegex: /^(ཟླ་\d{1,2})/,
        monthsParseExact: true,
        weekdays: 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split(
            '_'
        ),
        weekdaysShort: 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split(
            '_'
        ),
        weekdaysMin: 'ཉི_ཟླ_མིག_ལྷག_ཕུར_སངས_སྤེན'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm',
            LLLL: 'dddd, D MMMM YYYY, A h:mm',
        },
        calendar: {
            sameDay: '[དི་རིང] LT',
            nextDay: '[སང་ཉིན] LT',
            nextWeek: '[བདུན་ཕྲག་རྗེས་མ], LT',
            lastDay: '[ཁ་སང] LT',
            lastWeek: '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s ལ་',
            past: '%s སྔན་ལ',
            s: 'ལམ་སང',
            ss: '%d སྐར་ཆ།',
            m: 'སྐར་མ་གཅིག',
            mm: '%d སྐར་མ',
            h: 'ཆུ་ཚོད་གཅིག',
            hh: '%d ཆུ་ཚོད',
            d: 'ཉིན་གཅིག',
            dd: '%d ཉིན་',
            M: 'ཟླ་བ་གཅིག',
            MM: '%d ཟླ་བ',
            y: 'ལོ་གཅིག',
            yy: '%d ལོ',
        },
        preparse: function (string) {
            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                (meridiem === 'མཚན་མོ' && hour >= 4) ||
                (meridiem === 'ཉིན་གུང' && hour < 5) ||
                meridiem === 'དགོང་དག'
            ) {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'མཚན་མོ';
            } else if (hour < 10) {
                return 'ཞོགས་ཀས';
            } else if (hour < 17) {
                return 'ཉིན་གུང';
            } else if (hour < 20) {
                return 'དགོང་དག';
            } else {
                return 'མཚན་མོ';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return bo;

})));


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            mm: 'munutenn',
            MM: 'miz',
            dd: 'devezh',
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
            case 1:
            case 3:
            case 4:
            case 5:
            case 9:
                return number + ' bloaz';
            default:
                return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            m: 'v',
            b: 'v',
            d: 'z',
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = moment.defineLocale('br', {
        months: "Genver_C'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split(
            '_'
        ),
        monthsShort: "Gen_C'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split('_'),
        weekdays: "Sul_Lun_Meurzh_Merc'her_Yaou_Gwener_Sadorn".split('_'),
        weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [a viz] MMMM YYYY',
            LLL: 'D [a viz] MMMM YYYY HH:mm',
            LLLL: 'dddd, D [a viz] MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Hiziv da] LT',
            nextDay: "[Warc'hoazh da] LT",
            nextWeek: 'dddd [da] LT',
            lastDay: "[Dec'h da] LT",
            lastWeek: 'dddd [paset da] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'a-benn %s',
            past: "%s 'zo",
            s: 'un nebeud segondennoù',
            ss: '%d eilenn',
            m: 'ur vunutenn',
            mm: relativeTimeWithMutation,
            h: 'un eur',
            hh: '%d eur',
            d: 'un devezh',
            dd: relativeTimeWithMutation,
            M: 'ur miz',
            MM: relativeTimeWithMutation,
            y: 'ur bloaz',
            yy: specialMutationForYears,
        },
        dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
        ordinal: function (number) {
            var output = number === 1 ? 'añ' : 'vet';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return br;

})));


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Marković

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                if (number === 1) {
                    result += 'sekunda';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sekunde';
                } else {
                    result += 'sekundi';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var bs = moment.defineLocale('bs', {
        months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split(
            '_'
        ),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[jučer u] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prošlu] dddd [u] LT';
                    case 6:
                        return '[prošle] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prošli] dddd [u] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'prije %s',
            s: 'par sekundi',
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: 'dan',
            dd: translate,
            M: 'mjesec',
            MM: translate,
            y: 'godinu',
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return bs;

})));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ca = moment.defineLocale('ca', {
        months: {
            standalone: 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split(
                '_'
            ),
            format: "de gener_de febrer_de març_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split(
                '_'
            ),
            isFormat: /D[oD]?(\s)+MMMM/,
        },
        monthsShort: 'gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split(
            '_'
        ),
        weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM [de] YYYY',
            ll: 'D MMM YYYY',
            LLL: 'D MMMM [de] YYYY [a les] H:mm',
            lll: 'D MMM YYYY, H:mm',
            LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
            llll: 'ddd D MMM YYYY, H:mm',
        },
        calendar: {
            sameDay: function () {
                return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            nextDay: function () {
                return '[demà a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            lastDay: function () {
                return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[el] dddd [passat a ' +
                    (this.hours() !== 1 ? 'les' : 'la') +
                    '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: "d'aquí %s",
            past: 'fa %s',
            s: 'uns segons',
            ss: '%d segons',
            m: 'un minut',
            mm: '%d minuts',
            h: 'una hora',
            hh: '%d hores',
            d: 'un dia',
            dd: '%d dies',
            M: 'un mes',
            MM: '%d mesos',
            y: 'un any',
            yy: '%d anys',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
        ordinal: function (number, period) {
            var output =
                number === 1
                    ? 'r'
                    : number === 2
                    ? 'n'
                    : number === 3
                    ? 'r'
                    : number === 4
                    ? 't'
                    : 'è';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return ca;

})));


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split(
            '_'
        ),
        monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_'),
        monthsParse = [
            /^led/i,
            /^úno/i,
            /^bře/i,
            /^dub/i,
            /^kvě/i,
            /^(čvn|červen$|června)/i,
            /^(čvc|červenec|července)/i,
            /^srp/i,
            /^zář/i,
            /^říj/i,
            /^lis/i,
            /^pro/i,
        ],
        // NOTE: 'červen' is substring of 'červenec'; therefore 'červenec' must precede 'červen' in the regex to be fully matched.
        // Otherwise parser matches '1. červenec' as '1. červen' + 'ec'.
        monthsRegex = /^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i;

    function plural(n) {
        return n > 1 && n < 5 && ~~(n / 10) !== 1;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's': // a few seconds / in a few seconds / a few seconds ago
                return withoutSuffix || isFuture ? 'pár sekund' : 'pár sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'sekund');
                } else {
                    return result + 'sekundami';
                }
            case 'm': // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minuty' : 'minut');
                } else {
                    return result + 'minutami';
                }
            case 'h': // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodin');
                } else {
                    return result + 'hodinami';
                }
            case 'd': // a day / in a day / a day ago
                return withoutSuffix || isFuture ? 'den' : 'dnem';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dny' : 'dní');
                } else {
                    return result + 'dny';
                }
            case 'M': // a month / in a month / a month ago
                return withoutSuffix || isFuture ? 'měsíc' : 'měsícem';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'měsíce' : 'měsíců');
                } else {
                    return result + 'měsíci';
                }
            case 'y': // a year / in a year / a year ago
                return withoutSuffix || isFuture ? 'rok' : 'rokem';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'let');
                } else {
                    return result + 'lety';
                }
        }
    }

    var cs = moment.defineLocale('cs', {
        months: months,
        monthsShort: monthsShort,
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        // NOTE: 'červen' is substring of 'červenec'; therefore 'červenec' must precede 'červen' in the regex to be fully matched.
        // Otherwise parser matches '1. červenec' as '1. červen' + 'ec'.
        monthsStrictRegex: /^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i,
        monthsShortStrictRegex: /^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
        weekdaysShort: 'ne_po_út_st_čt_pá_so'.split('_'),
        weekdaysMin: 'ne_po_út_st_čt_pá_so'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd D. MMMM YYYY H:mm',
            l: 'D. M. YYYY',
        },
        calendar: {
            sameDay: '[dnes v] LT',
            nextDay: '[zítra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v neděli v] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [v] LT';
                    case 3:
                        return '[ve středu v] LT';
                    case 4:
                        return '[ve čtvrtek v] LT';
                    case 5:
                        return '[v pátek v] LT';
                    case 6:
                        return '[v sobotu v] LT';
                }
            },
            lastDay: '[včera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulou neděli v] LT';
                    case 1:
                    case 2:
                        return '[minulé] dddd [v] LT';
                    case 3:
                        return '[minulou středu v] LT';
                    case 4:
                    case 5:
                        return '[minulý] dddd [v] LT';
                    case 6:
                        return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'před %s',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return cs;

})));


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var cv = moment.defineLocale('cv', {
        months: 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split(
            '_'
        ),
        monthsShort: 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
        weekdays: 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split(
            '_'
        ),
        weekdaysShort: 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
        weekdaysMin: 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD-MM-YYYY',
            LL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
            LLL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
            LLLL: 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
        },
        calendar: {
            sameDay: '[Паян] LT [сехетре]',
            nextDay: '[Ыран] LT [сехетре]',
            lastDay: '[Ӗнер] LT [сехетре]',
            nextWeek: '[Ҫитес] dddd LT [сехетре]',
            lastWeek: '[Иртнӗ] dddd LT [сехетре]',
            sameElse: 'L',
        },
        relativeTime: {
            future: function (output) {
                var affix = /сехет$/i.exec(output)
                    ? 'рен'
                    : /ҫул$/i.exec(output)
                    ? 'тан'
                    : 'ран';
                return output + affix;
            },
            past: '%s каялла',
            s: 'пӗр-ик ҫеккунт',
            ss: '%d ҫеккунт',
            m: 'пӗр минут',
            mm: '%d минут',
            h: 'пӗр сехет',
            hh: '%d сехет',
            d: 'пӗр кун',
            dd: '%d кун',
            M: 'пӗр уйӑх',
            MM: '%d уйӑх',
            y: 'пӗр ҫул',
            yy: '%d ҫул',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
        ordinal: '%d-мӗш',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return cv;

})));


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var cy = moment.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split(
            '_'
        ),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split(
            '_'
        ),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split(
            '_'
        ),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact: true,
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn ôl',
            s: 'ychydig eiliadau',
            ss: '%d eiliad',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '',
                    'af',
                    'il',
                    'ydd',
                    'ydd',
                    'ed',
                    'ed',
                    'ed',
                    'fed',
                    'fed',
                    'fed', // 1af to 10fed
                    'eg',
                    'fed',
                    'eg',
                    'eg',
                    'fed',
                    'eg',
                    'eg',
                    'fed',
                    'eg',
                    'fed', // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return cy;

})));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var da = moment.defineLocale('da', {
        months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort: 'søn_man_tir_ons_tor_fre_lør'.split('_'),
        weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm',
        },
        calendar: {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'på dddd [kl.] LT',
            lastDay: '[i går kl.] LT',
            lastWeek: '[i] dddd[s kl.] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'om %s',
            past: '%s siden',
            s: 'få sekunder',
            ss: '%d sekunder',
            m: 'et minut',
            mm: '%d minutter',
            h: 'en time',
            hh: '%d timer',
            d: 'en dag',
            dd: '%d dage',
            M: 'en måned',
            MM: '%d måneder',
            y: 'et år',
            yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return da;

})));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensúle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: ['eine Minute', 'einer Minute'],
            h: ['eine Stunde', 'einer Stunde'],
            d: ['ein Tag', 'einem Tag'],
            dd: [number + ' Tage', number + ' Tagen'],
            M: ['ein Monat', 'einem Monat'],
            MM: [number + ' Monate', number + ' Monaten'],
            y: ['ein Jahr', 'einem Jahr'],
            yy: [number + ' Jahre', number + ' Jahren'],
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment.defineLocale('de', {
        months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
            '_'
        ),
        monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
            '_'
        ),
        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd, D. MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]',
        },
        relativeTime: {
            future: 'in %s',
            past: 'vor %s',
            s: 'ein paar Sekunden',
            ss: '%d Sekunden',
            m: processRelativeTime,
            mm: '%d Minuten',
            h: processRelativeTime,
            hh: '%d Stunden',
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return de;

})));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensúle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: ['eine Minute', 'einer Minute'],
            h: ['eine Stunde', 'einer Stunde'],
            d: ['ein Tag', 'einem Tag'],
            dd: [number + ' Tage', number + ' Tagen'],
            M: ['ein Monat', 'einem Monat'],
            MM: [number + ' Monate', number + ' Monaten'],
            y: ['ein Jahr', 'einem Jahr'],
            yy: [number + ' Jahre', number + ' Jahren'],
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deAt = moment.defineLocale('de-at', {
        months: 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
            '_'
        ),
        monthsShort: 'Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
            '_'
        ),
        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd, D. MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]',
        },
        relativeTime: {
            future: 'in %s',
            past: 'vor %s',
            s: 'ein paar Sekunden',
            ss: '%d Sekunden',
            m: processRelativeTime,
            mm: '%d Minuten',
            h: processRelativeTime,
            hh: '%d Stunden',
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return deAt;

})));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Switzerland) [de-ch]
//! author : sschueller : https://github.com/sschueller

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: ['eine Minute', 'einer Minute'],
            h: ['eine Stunde', 'einer Stunde'],
            d: ['ein Tag', 'einem Tag'],
            dd: [number + ' Tage', number + ' Tagen'],
            M: ['ein Monat', 'einem Monat'],
            MM: [number + ' Monate', number + ' Monaten'],
            y: ['ein Jahr', 'einem Jahr'],
            yy: [number + ' Jahre', number + ' Jahren'],
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deCh = moment.defineLocale('de-ch', {
        months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
            '_'
        ),
        monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
            '_'
        ),
        weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd, D. MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]',
        },
        relativeTime: {
            future: 'in %s',
            past: 'vor %s',
            s: 'ein paar Sekunden',
            ss: '%d Sekunden',
            m: processRelativeTime,
            mm: '%d Minuten',
            h: processRelativeTime,
            hh: '%d Stunden',
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return deCh;

})));


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = [
            'ޖެނުއަރީ',
            'ފެބްރުއަރީ',
            'މާރިޗު',
            'އޭޕްރީލު',
            'މޭ',
            'ޖޫން',
            'ޖުލައި',
            'އޯގަސްޓު',
            'ސެޕްޓެމްބަރު',
            'އޮކްޓޯބަރު',
            'ނޮވެމްބަރު',
            'ޑިސެމްބަރު',
        ],
        weekdays = [
            'އާދިއްތަ',
            'ހޯމަ',
            'އަންގާރަ',
            'ބުދަ',
            'ބުރާސްފަތި',
            'ހުކުރު',
            'ހޮނިހިރު',
        ];

    var dv = moment.defineLocale('dv', {
        months: months,
        monthsShort: months,
        weekdays: weekdays,
        weekdaysShort: weekdays,
        weekdaysMin: 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'D/M/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /މކ|މފ/,
        isPM: function (input) {
            return 'މފ' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'މކ';
            } else {
                return 'މފ';
            }
        },
        calendar: {
            sameDay: '[މިއަދު] LT',
            nextDay: '[މާދަމާ] LT',
            nextWeek: 'dddd LT',
            lastDay: '[އިއްޔެ] LT',
            lastWeek: '[ފާއިތުވި] dddd LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'ތެރޭގައި %s',
            past: 'ކުރިން %s',
            s: 'ސިކުންތުކޮޅެއް',
            ss: 'd% ސިކުންތު',
            m: 'މިނިޓެއް',
            mm: 'މިނިޓު %d',
            h: 'ގަޑިއިރެއް',
            hh: 'ގަޑިއިރު %d',
            d: 'ދުވަހެއް',
            dd: 'ދުވަސް %d',
            M: 'މަހެއް',
            MM: 'މަސް %d',
            y: 'އަހަރެއް',
            yy: 'އަހަރު %d',
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week: {
            dow: 7, // Sunday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return dv;

})));


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    var el = moment.defineLocale('el', {
        monthsNominativeEl: 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split(
            '_'
        ),
        monthsGenitiveEl: 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split(
            '_'
        ),
        months: function (momentToFormat, format) {
            if (!momentToFormat) {
                return this._monthsNominativeEl;
            } else if (
                typeof format === 'string' &&
                /D/.test(format.substring(0, format.indexOf('MMMM')))
            ) {
                // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort: 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
        weekdays: 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split(
            '_'
        ),
        weekdaysShort: 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
        weekdaysMin: 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
        meridiem: function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'μμ' : 'ΜΜ';
            } else {
                return isLower ? 'πμ' : 'ΠΜ';
            }
        },
        isPM: function (input) {
            return (input + '').toLowerCase()[0] === 'μ';
        },
        meridiemParse: /[ΠΜ]\.?Μ?\.?/i,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendarEl: {
            sameDay: '[Σήμερα {}] LT',
            nextDay: '[Αύριο {}] LT',
            nextWeek: 'dddd [{}] LT',
            lastDay: '[Χθες {}] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 6:
                        return '[το προηγούμενο] dddd [{}] LT';
                    default:
                        return '[την προηγούμενη] dddd [{}] LT';
                }
            },
            sameElse: 'L',
        },
        calendar: function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (isFunction(output)) {
                output = output.apply(mom);
            }
            return output.replace('{}', hours % 12 === 1 ? 'στη' : 'στις');
        },
        relativeTime: {
            future: 'σε %s',
            past: '%s πριν',
            s: 'λίγα δευτερόλεπτα',
            ss: '%d δευτερόλεπτα',
            m: 'ένα λεπτό',
            mm: '%d λεπτά',
            h: 'μία ώρα',
            hh: '%d ώρες',
            d: 'μία μέρα',
            dd: '%d μέρες',
            M: 'ένας μήνας',
            MM: '%d μήνες',
            y: 'ένας χρόνος',
            yy: '%d χρόνια',
        },
        dayOfMonthOrdinalParse: /\d{1,2}η/,
        ordinal: '%dη',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4st is the first week of the year.
        },
    });

    return el;

})));


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enAu = moment.defineLocale('en-au', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enAu;

})));


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enCa = moment.defineLocale('en-ca', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'YYYY-MM-DD',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY h:mm A',
            LLLL: 'dddd, MMMM D, YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    return enCa;

})));


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enGb = moment.defineLocale('en-gb', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enGb;

})));


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enIe = moment.defineLocale('en-ie', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enIe;

})));


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Israel) [en-il]
//! author : Chris Gedrim : https://github.com/chrisgedrim

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enIl = moment.defineLocale('en-il', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    return enIl;

})));


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (India) [en-in]
//! author : Jatin Agrawal : https://github.com/jatinag22

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enIn = moment.defineLocale('en-in', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enIn;

})));


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enNz = moment.defineLocale('en-nz', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enNz;

})));


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Singapore) [en-sg]
//! author : Matthew Castrillon-Madrigal : https://github.com/techdimension

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enSg = moment.defineLocale('en-sg', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enSg;

})));


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
//! comment : miestasmia corrected the translation by colindean
//! comment : Vivakvo corrected the translation by colindean and miestasmia

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var eo = moment.defineLocale('eo', {
        months: 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mart_apr_maj_jun_jul_aŭg_sept_okt_nov_dec'.split('_'),
        weekdays: 'dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato'.split('_'),
        weekdaysShort: 'dim_lun_mard_merk_ĵaŭ_ven_sab'.split('_'),
        weekdaysMin: 'di_lu_ma_me_ĵa_ve_sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: '[la] D[-an de] MMMM, YYYY',
            LLL: '[la] D[-an de] MMMM, YYYY HH:mm',
            LLLL: 'dddd[n], [la] D[-an de] MMMM, YYYY HH:mm',
            llll: 'ddd, [la] D[-an de] MMM, YYYY HH:mm',
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar: {
            sameDay: '[Hodiaŭ je] LT',
            nextDay: '[Morgaŭ je] LT',
            nextWeek: 'dddd[n je] LT',
            lastDay: '[Hieraŭ je] LT',
            lastWeek: '[pasintan] dddd[n je] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'post %s',
            past: 'antaŭ %s',
            s: 'kelkaj sekundoj',
            ss: '%d sekundoj',
            m: 'unu minuto',
            mm: '%d minutoj',
            h: 'unu horo',
            hh: '%d horoj',
            d: 'unu tago', //ne 'diurno', ĉar estas uzita por proksimumo
            dd: '%d tagoj',
            M: 'unu monato',
            MM: '%d monatoj',
            y: 'unu jaro',
            yy: '%d jaroj',
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal: '%da',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return eo;

})));


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napurí : https://github.com/julionc

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
            '_'
        ),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
        monthsParse = [
            /^ene/i,
            /^feb/i,
            /^mar/i,
            /^abr/i,
            /^may/i,
            /^jun/i,
            /^jul/i,
            /^ago/i,
            /^sep/i,
            /^oct/i,
            /^nov/i,
            /^dic/i,
        ],
        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var es = moment.defineLocale('es', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY H:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
        },
        calendar: {
            sameDay: function () {
                return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextDay: function () {
                return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastDay: function () {
                return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[el] dddd [pasado a la' +
                    (this.hours() !== 1 ? 's' : '') +
                    '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'en %s',
            past: 'hace %s',
            s: 'unos segundos',
            ss: '%d segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'una hora',
            hh: '%d horas',
            d: 'un día',
            dd: '%d días',
            M: 'un mes',
            MM: '%d meses',
            y: 'un año',
            yy: '%d años',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
        invalidDate: 'Fecha invalida',
    });

    return es;

})));


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
            '_'
        ),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
        monthsParse = [
            /^ene/i,
            /^feb/i,
            /^mar/i,
            /^abr/i,
            /^may/i,
            /^jun/i,
            /^jul/i,
            /^ago/i,
            /^sep/i,
            /^oct/i,
            /^nov/i,
            /^dic/i,
        ],
        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esDo = moment.defineLocale('es-do', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY h:mm A',
            LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
        },
        calendar: {
            sameDay: function () {
                return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextDay: function () {
                return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastDay: function () {
                return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[el] dddd [pasado a la' +
                    (this.hours() !== 1 ? 's' : '') +
                    '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'en %s',
            past: 'hace %s',
            s: 'unos segundos',
            ss: '%d segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'una hora',
            hh: '%d horas',
            d: 'un día',
            dd: '%d días',
            M: 'un mes',
            MM: '%d meses',
            y: 'un año',
            yy: '%d años',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return esDo;

})));


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (United States) [es-us]
//! author : bustta : https://github.com/bustta
//! author : chrisrodz : https://github.com/chrisrodz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
            '_'
        ),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
        monthsParse = [
            /^ene/i,
            /^feb/i,
            /^mar/i,
            /^abr/i,
            /^may/i,
            /^jun/i,
            /^jul/i,
            /^ago/i,
            /^sep/i,
            /^oct/i,
            /^nov/i,
            /^dic/i,
        ],
        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esUs = moment.defineLocale('es-us', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'MM/DD/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY h:mm A',
            LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
        },
        calendar: {
            sameDay: function () {
                return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextDay: function () {
                return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastDay: function () {
                return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[el] dddd [pasado a la' +
                    (this.hours() !== 1 ? 's' : '') +
                    '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'en %s',
            past: 'hace %s',
            s: 'unos segundos',
            ss: '%d segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'una hora',
            hh: '%d horas',
            d: 'un día',
            dd: '%d días',
            M: 'un mes',
            MM: '%d meses',
            y: 'un año',
            yy: '%d años',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return esUs;

})));


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            s: ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
            ss: [number + 'sekundi', number + 'sekundit'],
            m: ['ühe minuti', 'üks minut'],
            mm: [number + ' minuti', number + ' minutit'],
            h: ['ühe tunni', 'tund aega', 'üks tund'],
            hh: [number + ' tunni', number + ' tundi'],
            d: ['ühe päeva', 'üks päev'],
            M: ['kuu aja', 'kuu aega', 'üks kuu'],
            MM: [number + ' kuu', number + ' kuud'],
            y: ['ühe aasta', 'aasta', 'üks aasta'],
            yy: [number + ' aasta', number + ' aastat'],
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = moment.defineLocale('et', {
        months: 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split(
            '_'
        ),
        monthsShort: 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split(
            '_'
        ),
        weekdays: 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split(
            '_'
        ),
        weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[Täna,] LT',
            nextDay: '[Homme,] LT',
            nextWeek: '[Järgmine] dddd LT',
            lastDay: '[Eile,] LT',
            lastWeek: '[Eelmine] dddd LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s pärast',
            past: '%s tagasi',
            s: processRelativeTime,
            ss: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: '%d päeva',
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return et;

})));


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var eu = moment.defineLocale('eu', {
        months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split(
            '_'
        ),
        monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split(
            '_'
        ),
        weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY[ko] MMMM[ren] D[a]',
            LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
            LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
            l: 'YYYY-M-D',
            ll: 'YYYY[ko] MMM D[a]',
            lll: 'YYYY[ko] MMM D[a] HH:mm',
            llll: 'ddd, YYYY[ko] MMM D[a] HH:mm',
        },
        calendar: {
            sameDay: '[gaur] LT[etan]',
            nextDay: '[bihar] LT[etan]',
            nextWeek: 'dddd LT[etan]',
            lastDay: '[atzo] LT[etan]',
            lastWeek: '[aurreko] dddd LT[etan]',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s barru',
            past: 'duela %s',
            s: 'segundo batzuk',
            ss: '%d segundo',
            m: 'minutu bat',
            mm: '%d minutu',
            h: 'ordu bat',
            hh: '%d ordu',
            d: 'egun bat',
            dd: '%d egun',
            M: 'hilabete bat',
            MM: '%d hilabete',
            y: 'urte bat',
            yy: '%d urte',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return eu;

})));


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '۱',
            '2': '۲',
            '3': '۳',
            '4': '۴',
            '5': '۵',
            '6': '۶',
            '7': '۷',
            '8': '۸',
            '9': '۹',
            '0': '۰',
        },
        numberMap = {
            '۱': '1',
            '۲': '2',
            '۳': '3',
            '۴': '4',
            '۵': '5',
            '۶': '6',
            '۷': '7',
            '۸': '8',
            '۹': '9',
            '۰': '0',
        };

    var fa = moment.defineLocale('fa', {
        months: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split(
            '_'
        ),
        monthsShort: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split(
            '_'
        ),
        weekdays: 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split(
            '_'
        ),
        weekdaysShort: 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split(
            '_'
        ),
        weekdaysMin: 'ی_د_س_چ_پ_ج_ش'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        meridiemParse: /قبل از ظهر|بعد از ظهر/,
        isPM: function (input) {
            return /بعد از ظهر/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'قبل از ظهر';
            } else {
                return 'بعد از ظهر';
            }
        },
        calendar: {
            sameDay: '[امروز ساعت] LT',
            nextDay: '[فردا ساعت] LT',
            nextWeek: 'dddd [ساعت] LT',
            lastDay: '[دیروز ساعت] LT',
            lastWeek: 'dddd [پیش] [ساعت] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'در %s',
            past: '%s پیش',
            s: 'چند ثانیه',
            ss: '%d ثانیه',
            m: 'یک دقیقه',
            mm: '%d دقیقه',
            h: 'یک ساعت',
            hh: '%d ساعت',
            d: 'یک روز',
            dd: '%d روز',
            M: 'یک ماه',
            MM: '%d ماه',
            y: 'یک سال',
            yy: '%d سال',
        },
        preparse: function (string) {
            return string
                .replace(/[۰-۹]/g, function (match) {
                    return numberMap[match];
                })
                .replace(/،/g, ',');
        },
        postformat: function (string) {
            return string
                .replace(/\d/g, function (match) {
                    return symbolMap[match];
                })
                .replace(/,/g, '،');
        },
        dayOfMonthOrdinalParse: /\d{1,2}م/,
        ordinal: '%dم',
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return fa;

})));


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(
            ' '
        ),
        numbersFuture = [
            'nolla',
            'yhden',
            'kahden',
            'kolmen',
            'neljän',
            'viiden',
            'kuuden',
            numbersPast[7],
            numbersPast[8],
            numbersPast[9],
        ];
    function translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
            case 's':
                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
            case 'ss':
                return isFuture ? 'sekunnin' : 'sekuntia';
            case 'm':
                return isFuture ? 'minuutin' : 'minuutti';
            case 'mm':
                result = isFuture ? 'minuutin' : 'minuuttia';
                break;
            case 'h':
                return isFuture ? 'tunnin' : 'tunti';
            case 'hh':
                result = isFuture ? 'tunnin' : 'tuntia';
                break;
            case 'd':
                return isFuture ? 'päivän' : 'päivä';
            case 'dd':
                result = isFuture ? 'päivän' : 'päivää';
                break;
            case 'M':
                return isFuture ? 'kuukauden' : 'kuukausi';
            case 'MM':
                result = isFuture ? 'kuukauden' : 'kuukautta';
                break;
            case 'y':
                return isFuture ? 'vuoden' : 'vuosi';
            case 'yy':
                result = isFuture ? 'vuoden' : 'vuotta';
                break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10
            ? isFuture
                ? numbersFuture[number]
                : numbersPast[number]
            : number;
    }

    var fi = moment.defineLocale('fi', {
        months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split(
            '_'
        ),
        monthsShort: 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split(
            '_'
        ),
        weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split(
            '_'
        ),
        weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD.MM.YYYY',
            LL: 'Do MMMM[ta] YYYY',
            LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l: 'D.M.YYYY',
            ll: 'Do MMM YYYY',
            lll: 'Do MMM YYYY, [klo] HH.mm',
            llll: 'ddd, Do MMM YYYY, [klo] HH.mm',
        },
        calendar: {
            sameDay: '[tänään] [klo] LT',
            nextDay: '[huomenna] [klo] LT',
            nextWeek: 'dddd [klo] LT',
            lastDay: '[eilen] [klo] LT',
            lastWeek: '[viime] dddd[na] [klo] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s päästä',
            past: '%s sitten',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return fi;

})));


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Filipino [fil]
//! author : Dan Hagman : https://github.com/hagmandan
//! author : Matthew Co : https://github.com/matthewdeeco

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var fil = moment.defineLocale('fil', {
        months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split(
            '_'
        ),
        monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split(
            '_'
        ),
        weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'MM/D/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY HH:mm',
            LLLL: 'dddd, MMMM DD, YYYY HH:mm',
        },
        calendar: {
            sameDay: 'LT [ngayong araw]',
            nextDay: '[Bukas ng] LT',
            nextWeek: 'LT [sa susunod na] dddd',
            lastDay: 'LT [kahapon]',
            lastWeek: 'LT [noong nakaraang] dddd',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'sa loob ng %s',
            past: '%s ang nakalipas',
            s: 'ilang segundo',
            ss: '%d segundo',
            m: 'isang minuto',
            mm: '%d minuto',
            h: 'isang oras',
            hh: '%d oras',
            d: 'isang araw',
            dd: '%d araw',
            M: 'isang buwan',
            MM: '%d buwan',
            y: 'isang taon',
            yy: '%d taon',
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function (number) {
            return number;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return fil;

})));


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123
//! author : Kristian Sakarisson : https://github.com/sakarisson

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var fo = moment.defineLocale('fo', {
        months: 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays: 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split(
            '_'
        ),
        weekdaysShort: 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
        weekdaysMin: 'su_má_tý_mi_hó_fr_le'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D. MMMM, YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Í dag kl.] LT',
            nextDay: '[Í morgin kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[Í gjár kl.] LT',
            lastWeek: '[síðstu] dddd [kl] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'um %s',
            past: '%s síðani',
            s: 'fá sekund',
            ss: '%d sekundir',
            m: 'ein minuttur',
            mm: '%d minuttir',
            h: 'ein tími',
            hh: '%d tímar',
            d: 'ein dagur',
            dd: '%d dagar',
            M: 'ein mánaður',
            MM: '%d mánaðir',
            y: 'eitt ár',
            yy: '%d ár',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return fo;

})));


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var fr = moment.defineLocale('fr', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split(
            '_'
        ),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Aujourd’hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dans %s',
            past: 'il y a %s',
            s: 'quelques secondes',
            ss: '%d secondes',
            m: 'une minute',
            mm: '%d minutes',
            h: 'une heure',
            hh: '%d heures',
            d: 'un jour',
            dd: '%d jours',
            M: 'un mois',
            MM: '%d mois',
            y: 'un an',
            yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal: function (number, period) {
            switch (period) {
                // TODO: Return 'e' when day of month > 1. Move this case inside
                // block for masculine words below.
                // See https://github.com/moment/moment/issues/3375
                case 'D':
                    return number + (number === 1 ? 'er' : '');

                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return fr;

})));


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var frCa = moment.defineLocale('fr-ca', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split(
            '_'
        ),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Aujourd’hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dans %s',
            past: 'il y a %s',
            s: 'quelques secondes',
            ss: '%d secondes',
            m: 'une minute',
            mm: '%d minutes',
            h: 'une heure',
            hh: '%d heures',
            d: 'un jour',
            dd: '%d jours',
            M: 'un mois',
            MM: '%d mois',
            y: 'un an',
            yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
    });

    return frCa;

})));


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var frCh = moment.defineLocale('fr-ch', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split(
            '_'
        ),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Aujourd’hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dans %s',
            past: 'il y a %s',
            s: 'quelques secondes',
            ss: '%d secondes',
            m: 'une minute',
            mm: '%d minutes',
            h: 'une heure',
            hh: '%d heures',
            d: 'un jour',
            dd: '%d jours',
            M: 'un mois',
            MM: '%d mois',
            y: 'un an',
            yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return frCh;

})));


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split(
            '_'
        ),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split(
            '_'
        );

    var fy = moment.defineLocale('fy', {
        months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact: true,
        weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split(
            '_'
        ),
        weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[ôfrûne] dddd [om] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'oer %s',
            past: '%s lyn',
            s: 'in pear sekonden',
            ss: '%d sekonden',
            m: 'ien minút',
            mm: '%d minuten',
            h: 'ien oere',
            hh: '%d oeren',
            d: 'ien dei',
            dd: '%d dagen',
            M: 'ien moanne',
            MM: '%d moannen',
            y: 'ien jier',
            yy: '%d jierren',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function (number) {
            return (
                number +
                (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
            );
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return fy;

})));


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Irish or Irish Gaelic [ga]
//! author : André Silva : https://github.com/askpt

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = [
            'Eanáir',
            'Feabhra',
            'Márta',
            'Aibreán',
            'Bealtaine',
            'Meitheamh',
            'Iúil',
            'Lúnasa',
            'Meán Fómhair',
            'Deireadh Fómhair',
            'Samhain',
            'Nollaig',
        ],
        monthsShort = [
            'Ean',
            'Feabh',
            'Márt',
            'Aib',
            'Beal',
            'Meith',
            'Iúil',
            'Lún',
            'M.F.',
            'D.F.',
            'Samh',
            'Noll',
        ],
        weekdays = [
            'Dé Domhnaigh',
            'Dé Luain',
            'Dé Máirt',
            'Dé Céadaoin',
            'Déardaoin',
            'Dé hAoine',
            'Dé Sathairn',
        ],
        weekdaysShort = ['Domh', 'Luan', 'Máirt', 'Céad', 'Déar', 'Aoine', 'Sath'],
        weekdaysMin = ['Do', 'Lu', 'Má', 'Cé', 'Dé', 'A', 'Sa'];

    var ga = moment.defineLocale('ga', {
        months: months,
        monthsShort: monthsShort,
        monthsParseExact: true,
        weekdays: weekdays,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Inniu ag] LT',
            nextDay: '[Amárach ag] LT',
            nextWeek: 'dddd [ag] LT',
            lastDay: '[Inné ag] LT',
            lastWeek: 'dddd [seo caite] [ag] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'i %s',
            past: '%s ó shin',
            s: 'cúpla soicind',
            ss: '%d soicind',
            m: 'nóiméad',
            mm: '%d nóiméad',
            h: 'uair an chloig',
            hh: '%d uair an chloig',
            d: 'lá',
            dd: '%d lá',
            M: 'mí',
            MM: '%d míonna',
            y: 'bliain',
            yy: '%d bliain',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return ga;

})));


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = [
            'Am Faoilleach',
            'An Gearran',
            'Am Màrt',
            'An Giblean',
            'An Cèitean',
            'An t-Ògmhios',
            'An t-Iuchar',
            'An Lùnastal',
            'An t-Sultain',
            'An Dàmhair',
            'An t-Samhain',
            'An Dùbhlachd',
        ],
        monthsShort = [
            'Faoi',
            'Gear',
            'Màrt',
            'Gibl',
            'Cèit',
            'Ògmh',
            'Iuch',
            'Lùn',
            'Sult',
            'Dàmh',
            'Samh',
            'Dùbh',
        ],
        weekdays = [
            'Didòmhnaich',
            'Diluain',
            'Dimàirt',
            'Diciadain',
            'Diardaoin',
            'Dihaoine',
            'Disathairne',
        ],
        weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'],
        weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];

    var gd = moment.defineLocale('gd', {
        months: months,
        monthsShort: monthsShort,
        monthsParseExact: true,
        weekdays: weekdays,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[An-diugh aig] LT',
            nextDay: '[A-màireach aig] LT',
            nextWeek: 'dddd [aig] LT',
            lastDay: '[An-dè aig] LT',
            lastWeek: 'dddd [seo chaidh] [aig] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'ann an %s',
            past: 'bho chionn %s',
            s: 'beagan diogan',
            ss: '%d diogan',
            m: 'mionaid',
            mm: '%d mionaidean',
            h: 'uair',
            hh: '%d uairean',
            d: 'latha',
            dd: '%d latha',
            M: 'mìos',
            MM: '%d mìosan',
            y: 'bliadhna',
            yy: '%d bliadhna',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return gd;

})));


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var gl = moment.defineLocale('gl', {
        months: 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split(
            '_'
        ),
        monthsShort: 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mé_xo_ve_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY H:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
        },
        calendar: {
            sameDay: function () {
                return '[hoxe ' + (this.hours() !== 1 ? 'ás' : 'á') + '] LT';
            },
            nextDay: function () {
                return '[mañá ' + (this.hours() !== 1 ? 'ás' : 'á') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [' + (this.hours() !== 1 ? 'ás' : 'a') + '] LT';
            },
            lastDay: function () {
                return '[onte ' + (this.hours() !== 1 ? 'á' : 'a') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[o] dddd [pasado ' + (this.hours() !== 1 ? 'ás' : 'a') + '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: function (str) {
                if (str.indexOf('un') === 0) {
                    return 'n' + str;
                }
                return 'en ' + str;
            },
            past: 'hai %s',
            s: 'uns segundos',
            ss: '%d segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'unha hora',
            hh: '%d horas',
            d: 'un día',
            dd: '%d días',
            M: 'un mes',
            MM: '%d meses',
            y: 'un ano',
            yy: '%d anos',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return gl;

})));


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Devanagari script [gom-deva]
//! author : The Discoverer : https://github.com/WikiDiscoverer

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            s: ['थोडया सॅकंडांनी', 'थोडे सॅकंड'],
            ss: [number + ' सॅकंडांनी', number + ' सॅकंड'],
            m: ['एका मिणटान', 'एक मिनूट'],
            mm: [number + ' मिणटांनी', number + ' मिणटां'],
            h: ['एका वरान', 'एक वर'],
            hh: [number + ' वरांनी', number + ' वरां'],
            d: ['एका दिसान', 'एक दीस'],
            dd: [number + ' दिसांनी', number + ' दीस'],
            M: ['एका म्हयन्यान', 'एक म्हयनो'],
            MM: [number + ' म्हयन्यानी', number + ' म्हयने'],
            y: ['एका वर्सान', 'एक वर्स'],
            yy: [number + ' वर्सांनी', number + ' वर्सां'],
        };
        return isFuture ? format[key][0] : format[key][1];
    }

    var gomDeva = moment.defineLocale('gom-deva', {
        months: {
            standalone: 'जानेवारी_फेब्रुवारी_मार्च_एप्रील_मे_जून_जुलय_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split(
                '_'
            ),
            format: 'जानेवारीच्या_फेब्रुवारीच्या_मार्चाच्या_एप्रीलाच्या_मेयाच्या_जूनाच्या_जुलयाच्या_ऑगस्टाच्या_सप्टेंबराच्या_ऑक्टोबराच्या_नोव्हेंबराच्या_डिसेंबराच्या'.split(
                '_'
            ),
            isFormat: /MMMM(\s)+D[oD]?/,
        },
        monthsShort: 'जाने._फेब्रु._मार्च_एप्री._मे_जून_जुल._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'आयतार_सोमार_मंगळार_बुधवार_बिरेस्तार_सुक्रार_शेनवार'.split('_'),
        weekdaysShort: 'आयत._सोम._मंगळ._बुध._ब्रेस्त._सुक्र._शेन.'.split('_'),
        weekdaysMin: 'आ_सो_मं_बु_ब्रे_सु_शे'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'A h:mm [वाजतां]',
            LTS: 'A h:mm:ss [वाजतां]',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY A h:mm [वाजतां]',
            LLLL: 'dddd, MMMM Do, YYYY, A h:mm [वाजतां]',
            llll: 'ddd, D MMM YYYY, A h:mm [वाजतां]',
        },
        calendar: {
            sameDay: '[आयज] LT',
            nextDay: '[फाल्यां] LT',
            nextWeek: '[फुडलो] dddd[,] LT',
            lastDay: '[काल] LT',
            lastWeek: '[फाटलो] dddd[,] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s',
            past: '%s आदीं',
            s: processRelativeTime,
            ss: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}(वेर)/,
        ordinal: function (number, period) {
            switch (period) {
                // the ordinal 'वेर' only applies to day of the month
                case 'D':
                    return number + 'वेर';
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                case 'w':
                case 'W':
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
        meridiemParse: /राती|सकाळीं|दनपारां|सांजे/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'राती') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'सकाळीं') {
                return hour;
            } else if (meridiem === 'दनपारां') {
                return hour > 12 ? hour : hour + 12;
            } else if (meridiem === 'सांजे') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'राती';
            } else if (hour < 12) {
                return 'सकाळीं';
            } else if (hour < 16) {
                return 'दनपारां';
            } else if (hour < 20) {
                return 'सांजे';
            } else {
                return 'राती';
            }
        },
    });

    return gomDeva;

})));


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Latin script [gom-latn]
//! author : The Discoverer : https://github.com/WikiDiscoverer

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            s: ['thoddea sekondamni', 'thodde sekond'],
            ss: [number + ' sekondamni', number + ' sekond'],
            m: ['eka mintan', 'ek minut'],
            mm: [number + ' mintamni', number + ' mintam'],
            h: ['eka voran', 'ek vor'],
            hh: [number + ' voramni', number + ' voram'],
            d: ['eka disan', 'ek dis'],
            dd: [number + ' disamni', number + ' dis'],
            M: ['eka mhoinean', 'ek mhoino'],
            MM: [number + ' mhoineamni', number + ' mhoine'],
            y: ['eka vorsan', 'ek voros'],
            yy: [number + ' vorsamni', number + ' vorsam'],
        };
        return isFuture ? format[key][0] : format[key][1];
    }

    var gomLatn = moment.defineLocale('gom-latn', {
        months: {
            standalone: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split(
                '_'
            ),
            format: 'Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea'.split(
                '_'
            ),
            isFormat: /MMMM(\s)+D[oD]?/,
        },
        monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split('_'),
        weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
        weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'A h:mm [vazta]',
            LTS: 'A h:mm:ss [vazta]',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY A h:mm [vazta]',
            LLLL: 'dddd, MMMM Do, YYYY, A h:mm [vazta]',
            llll: 'ddd, D MMM YYYY, A h:mm [vazta]',
        },
        calendar: {
            sameDay: '[Aiz] LT',
            nextDay: '[Faleam] LT',
            nextWeek: '[Fuddlo] dddd[,] LT',
            lastDay: '[Kal] LT',
            lastWeek: '[Fattlo] dddd[,] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s',
            past: '%s adim',
            s: processRelativeTime,
            ss: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er)/,
        ordinal: function (number, period) {
            switch (period) {
                // the ordinal 'er' only applies to day of the month
                case 'D':
                    return number + 'er';
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                case 'w':
                case 'W':
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
        meridiemParse: /rati|sokallim|donparam|sanje/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'rati') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'sokallim') {
                return hour;
            } else if (meridiem === 'donparam') {
                return hour > 12 ? hour : hour + 12;
            } else if (meridiem === 'sanje') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'rati';
            } else if (hour < 12) {
                return 'sokallim';
            } else if (hour < 16) {
                return 'donparam';
            } else if (hour < 20) {
                return 'sanje';
            } else {
                return 'rati';
            }
        },
    });

    return gomLatn;

})));


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Gujarati [gu]
//! author : Kaushik Thanki : https://github.com/Kaushik1987

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '૧',
            '2': '૨',
            '3': '૩',
            '4': '૪',
            '5': '૫',
            '6': '૬',
            '7': '૭',
            '8': '૮',
            '9': '૯',
            '0': '૦',
        },
        numberMap = {
            '૧': '1',
            '૨': '2',
            '૩': '3',
            '૪': '4',
            '૫': '5',
            '૬': '6',
            '૭': '7',
            '૮': '8',
            '૯': '9',
            '૦': '0',
        };

    var gu = moment.defineLocale('gu', {
        months: 'જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર'.split(
            '_'
        ),
        monthsShort: 'જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર'.split(
            '_'
        ),
        weekdaysShort: 'રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ'.split('_'),
        weekdaysMin: 'ર_સો_મં_બુ_ગુ_શુ_શ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm વાગ્યે',
            LTS: 'A h:mm:ss વાગ્યે',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm વાગ્યે',
            LLLL: 'dddd, D MMMM YYYY, A h:mm વાગ્યે',
        },
        calendar: {
            sameDay: '[આજ] LT',
            nextDay: '[કાલે] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[ગઇકાલે] LT',
            lastWeek: '[પાછલા] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s મા',
            past: '%s પેહલા',
            s: 'અમુક પળો',
            ss: '%d સેકંડ',
            m: 'એક મિનિટ',
            mm: '%d મિનિટ',
            h: 'એક કલાક',
            hh: '%d કલાક',
            d: 'એક દિવસ',
            dd: '%d દિવસ',
            M: 'એક મહિનો',
            MM: '%d મહિનો',
            y: 'એક વર્ષ',
            yy: '%d વર્ષ',
        },
        preparse: function (string) {
            return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
        meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'રાત') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'સવાર') {
                return hour;
            } else if (meridiem === 'બપોર') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'સાંજ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'રાત';
            } else if (hour < 10) {
                return 'સવાર';
            } else if (hour < 17) {
                return 'બપોર';
            } else if (hour < 20) {
                return 'સાંજ';
            } else {
                return 'રાત';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return gu;

})));


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var he = moment.defineLocale('he', {
        months: 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split(
            '_'
        ),
        monthsShort: 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split(
            '_'
        ),
        weekdays: 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
        weekdaysShort: 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
        weekdaysMin: 'א_ב_ג_ד_ה_ו_ש'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [ב]MMMM YYYY',
            LLL: 'D [ב]MMMM YYYY HH:mm',
            LLLL: 'dddd, D [ב]MMMM YYYY HH:mm',
            l: 'D/M/YYYY',
            ll: 'D MMM YYYY',
            lll: 'D MMM YYYY HH:mm',
            llll: 'ddd, D MMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[היום ב־]LT',
            nextDay: '[מחר ב־]LT',
            nextWeek: 'dddd [בשעה] LT',
            lastDay: '[אתמול ב־]LT',
            lastWeek: '[ביום] dddd [האחרון בשעה] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'בעוד %s',
            past: 'לפני %s',
            s: 'מספר שניות',
            ss: '%d שניות',
            m: 'דקה',
            mm: '%d דקות',
            h: 'שעה',
            hh: function (number) {
                if (number === 2) {
                    return 'שעתיים';
                }
                return number + ' שעות';
            },
            d: 'יום',
            dd: function (number) {
                if (number === 2) {
                    return 'יומיים';
                }
                return number + ' ימים';
            },
            M: 'חודש',
            MM: function (number) {
                if (number === 2) {
                    return 'חודשיים';
                }
                return number + ' חודשים';
            },
            y: 'שנה',
            yy: function (number) {
                if (number === 2) {
                    return 'שנתיים';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' שנה';
                }
                return number + ' שנים';
            },
        },
        meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
        isPM: function (input) {
            return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 5) {
                return 'לפנות בוקר';
            } else if (hour < 10) {
                return 'בבוקר';
            } else if (hour < 12) {
                return isLower ? 'לפנה"צ' : 'לפני הצהריים';
            } else if (hour < 18) {
                return isLower ? 'אחה"צ' : 'אחרי הצהריים';
            } else {
                return 'בערב';
            }
        },
    });

    return he;

})));


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '१',
            '2': '२',
            '3': '३',
            '4': '४',
            '5': '५',
            '6': '६',
            '7': '७',
            '8': '८',
            '9': '९',
            '0': '०',
        },
        numberMap = {
            '१': '1',
            '२': '2',
            '३': '3',
            '४': '4',
            '५': '5',
            '६': '6',
            '७': '7',
            '८': '8',
            '९': '9',
            '०': '0',
        };

    var hi = moment.defineLocale('hi', {
        months: 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split(
            '_'
        ),
        monthsShort: 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort: 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat: {
            LT: 'A h:mm बजे',
            LTS: 'A h:mm:ss बजे',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm बजे',
            LLLL: 'dddd, D MMMM YYYY, A h:mm बजे',
        },
        calendar: {
            sameDay: '[आज] LT',
            nextDay: '[कल] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[कल] LT',
            lastWeek: '[पिछले] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s में',
            past: '%s पहले',
            s: 'कुछ ही क्षण',
            ss: '%d सेकंड',
            m: 'एक मिनट',
            mm: '%d मिनट',
            h: 'एक घंटा',
            hh: '%d घंटे',
            d: 'एक दिन',
            dd: '%d दिन',
            M: 'एक महीने',
            MM: '%d महीने',
            y: 'एक वर्ष',
            yy: '%d वर्ष',
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /रात|सुबह|दोपहर|शाम/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'रात') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'सुबह') {
                return hour;
            } else if (meridiem === 'दोपहर') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'शाम') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'रात';
            } else if (hour < 10) {
                return 'सुबह';
            } else if (hour < 17) {
                return 'दोपहर';
            } else if (hour < 20) {
                return 'शाम';
            } else {
                return 'रात';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return hi;

})));


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Marković : https://github.com/bmarkovic

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                if (number === 1) {
                    result += 'sekunda';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sekunde';
                } else {
                    result += 'sekundi';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var hr = moment.defineLocale('hr', {
        months: {
            format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split(
                '_'
            ),
            standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split(
                '_'
            ),
        },
        monthsShort: 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split(
            '_'
        ),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'Do MMMM YYYY',
            LLL: 'Do MMMM YYYY H:mm',
            LLLL: 'dddd, Do MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[jučer u] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[prošlu] [nedjelju] [u] LT';
                    case 3:
                        return '[prošlu] [srijedu] [u] LT';
                    case 6:
                        return '[prošle] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prošli] dddd [u] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'prije %s',
            s: 'par sekundi',
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: 'dan',
            dd: translate,
            M: 'mjesec',
            MM: translate,
            y: 'godinu',
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return hr;

})));


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(
        ' '
    );
    function translate(number, withoutSuffix, key, isFuture) {
        var num = number;
        switch (key) {
            case 's':
                return isFuture || withoutSuffix
                    ? 'néhány másodperc'
                    : 'néhány másodperce';
            case 'ss':
                return num + (isFuture || withoutSuffix)
                    ? ' másodperc'
                    : ' másodperce';
            case 'm':
                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'mm':
                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'h':
                return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
            case 'hh':
                return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
            case 'd':
                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'dd':
                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'M':
                return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
            case 'MM':
                return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
            case 'y':
                return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
            case 'yy':
                return num + (isFuture || withoutSuffix ? ' év' : ' éve');
        }
        return '';
    }
    function week(isFuture) {
        return (
            (isFuture ? '' : '[múlt] ') +
            '[' +
            weekEndings[this.day()] +
            '] LT[-kor]'
        );
    }

    var hu = moment.defineLocale('hu', {
        months: 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split(
            '_'
        ),
        monthsShort: 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split(
            '_'
        ),
        weekdays: 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
        weekdaysShort: 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
        weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'YYYY.MM.DD.',
            LL: 'YYYY. MMMM D.',
            LLL: 'YYYY. MMMM D. H:mm',
            LLLL: 'YYYY. MMMM D., dddd H:mm',
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar: {
            sameDay: '[ma] LT[-kor]',
            nextDay: '[holnap] LT[-kor]',
            nextWeek: function () {
                return week.call(this, true);
            },
            lastDay: '[tegnap] LT[-kor]',
            lastWeek: function () {
                return week.call(this, false);
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s múlva',
            past: '%s',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return hu;

})));


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var hyAm = moment.defineLocale('hy-am', {
        months: {
            format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split(
                '_'
            ),
            standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split(
                '_'
            ),
        },
        monthsShort: 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
        weekdays: 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split(
            '_'
        ),
        weekdaysShort: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        weekdaysMin: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY թ.',
            LLL: 'D MMMM YYYY թ., HH:mm',
            LLLL: 'dddd, D MMMM YYYY թ., HH:mm',
        },
        calendar: {
            sameDay: '[այսօր] LT',
            nextDay: '[վաղը] LT',
            lastDay: '[երեկ] LT',
            nextWeek: function () {
                return 'dddd [օրը ժամը] LT';
            },
            lastWeek: function () {
                return '[անցած] dddd [օրը ժամը] LT';
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s հետո',
            past: '%s առաջ',
            s: 'մի քանի վայրկյան',
            ss: '%d վայրկյան',
            m: 'րոպե',
            mm: '%d րոպե',
            h: 'ժամ',
            hh: '%d ժամ',
            d: 'օր',
            dd: '%d օր',
            M: 'ամիս',
            MM: '%d ամիս',
            y: 'տարի',
            yy: '%d տարի',
        },
        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
        isPM: function (input) {
            return /^(ցերեկվա|երեկոյան)$/.test(input);
        },
        meridiem: function (hour) {
            if (hour < 4) {
                return 'գիշերվա';
            } else if (hour < 12) {
                return 'առավոտվա';
            } else if (hour < 17) {
                return 'ցերեկվա';
            } else {
                return 'երեկոյան';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'DDD':
                case 'w':
                case 'W':
                case 'DDDo':
                    if (number === 1) {
                        return number + '-ին';
                    }
                    return number + '-րդ';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return hyAm;

})));


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var id = moment.defineLocale('id', {
        months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar: {
            sameDay: '[Hari ini pukul] LT',
            nextDay: '[Besok pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kemarin pukul] LT',
            lastWeek: 'dddd [lalu pukul] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dalam %s',
            past: '%s yang lalu',
            s: 'beberapa detik',
            ss: '%d detik',
            m: 'semenit',
            mm: '%d menit',
            h: 'sejam',
            hh: '%d jam',
            d: 'sehari',
            dd: '%d hari',
            M: 'sebulan',
            MM: '%d bulan',
            y: 'setahun',
            yy: '%d tahun',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return id;

})));


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik Örn Sigurðsson : https://github.com/hinrik

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture
                    ? 'nokkrar sekúndur'
                    : 'nokkrum sekúndum';
            case 'ss':
                if (plural(number)) {
                    return (
                        result +
                        (withoutSuffix || isFuture ? 'sekúndur' : 'sekúndum')
                    );
                }
                return result + 'sekúnda';
            case 'm':
                return withoutSuffix ? 'mínúta' : 'mínútu';
            case 'mm':
                if (plural(number)) {
                    return (
                        result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum')
                    );
                } else if (withoutSuffix) {
                    return result + 'mínúta';
                }
                return result + 'mínútu';
            case 'hh':
                if (plural(number)) {
                    return (
                        result +
                        (withoutSuffix || isFuture
                            ? 'klukkustundir'
                            : 'klukkustundum')
                    );
                }
                return result + 'klukkustund';
            case 'd':
                if (withoutSuffix) {
                    return 'dagur';
                }
                return isFuture ? 'dag' : 'degi';
            case 'dd':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'dagar';
                    }
                    return result + (isFuture ? 'daga' : 'dögum');
                } else if (withoutSuffix) {
                    return result + 'dagur';
                }
                return result + (isFuture ? 'dag' : 'degi');
            case 'M':
                if (withoutSuffix) {
                    return 'mánuður';
                }
                return isFuture ? 'mánuð' : 'mánuði';
            case 'MM':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'mánuðir';
                    }
                    return result + (isFuture ? 'mánuði' : 'mánuðum');
                } else if (withoutSuffix) {
                    return result + 'mánuður';
                }
                return result + (isFuture ? 'mánuð' : 'mánuði');
            case 'y':
                return withoutSuffix || isFuture ? 'ár' : 'ári';
            case 'yy':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
                }
                return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
        }
    }

    var is = moment.defineLocale('is', {
        months: 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
        weekdays: 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split(
            '_'
        ),
        weekdaysShort: 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
        weekdaysMin: 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY [kl.] H:mm',
            LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm',
        },
        calendar: {
            sameDay: '[í dag kl.] LT',
            nextDay: '[á morgun kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[í gær kl.] LT',
            lastWeek: '[síðasta] dddd [kl.] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'eftir %s',
            past: 'fyrir %s síðan',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: 'klukkustund',
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return is;

})));


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz
//! author: Marco : https://github.com/Manfre98

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var it = moment.defineLocale('it', {
        months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
            '_'
        ),
        monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split(
            '_'
        ),
        weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: function () {
                return (
                    '[Oggi a' +
                    (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                    ']LT'
                );
            },
            nextDay: function () {
                return (
                    '[Domani a' +
                    (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                    ']LT'
                );
            },
            nextWeek: function () {
                return (
                    'dddd [a' +
                    (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                    ']LT'
                );
            },
            lastDay: function () {
                return (
                    '[Ieri a' +
                    (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                    ']LT'
                );
            },
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return (
                            '[La scorsa] dddd [a' +
                            (this.hours() > 1
                                ? 'lle '
                                : this.hours() === 0
                                ? ' '
                                : "ll'") +
                            ']LT'
                        );
                    default:
                        return (
                            '[Lo scorso] dddd [a' +
                            (this.hours() > 1
                                ? 'lle '
                                : this.hours() === 0
                                ? ' '
                                : "ll'") +
                            ']LT'
                        );
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: function (s) {
                return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past: '%s fa',
            s: 'alcuni secondi',
            ss: '%d secondi',
            m: 'un minuto',
            mm: '%d minuti',
            h: "un'ora",
            hh: '%d ore',
            d: 'un giorno',
            dd: '%d giorni',
            M: 'un mese',
            MM: '%d mesi',
            y: 'un anno',
            yy: '%d anni',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return it;

})));


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian (Switzerland) [it-ch]
//! author : xfh : https://github.com/xfh

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var itCh = moment.defineLocale('it-ch', {
        months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
            '_'
        ),
        monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split(
            '_'
        ),
        weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: function (s) {
                return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past: '%s fa',
            s: 'alcuni secondi',
            ss: '%d secondi',
            m: 'un minuto',
            mm: '%d minuti',
            h: "un'ora",
            hh: '%d ore',
            d: 'un giorno',
            dd: '%d giorni',
            M: 'un mese',
            MM: '%d mesi',
            y: 'un anno',
            yy: '%d anni',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return itCh;

})));


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ja = moment.defineLocale('ja', {
        eras: [
            {
                since: '2019-05-01',
                offset: 1,
                name: '令和',
                narrow: '㋿',
                abbr: 'R',
            },
            {
                since: '1989-01-08',
                until: '2019-04-30',
                offset: 1,
                name: '平成',
                narrow: '㍻',
                abbr: 'H',
            },
            {
                since: '1926-12-25',
                until: '1989-01-07',
                offset: 1,
                name: '昭和',
                narrow: '㍼',
                abbr: 'S',
            },
            {
                since: '1912-07-30',
                until: '1926-12-24',
                offset: 1,
                name: '大正',
                narrow: '㍽',
                abbr: 'T',
            },
            {
                since: '1873-01-01',
                until: '1912-07-29',
                offset: 6,
                name: '明治',
                narrow: '㍾',
                abbr: 'M',
            },
            {
                since: '0001-01-01',
                until: '1873-12-31',
                offset: 1,
                name: '西暦',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: '紀元前',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        eraYearOrdinalRegex: /(元|\d+)年/,
        eraYearOrdinalParse: function (input, match) {
            return match[1] === '元' ? 1 : parseInt(match[1] || input, 10);
        },
        months: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
            '_'
        ),
        weekdays: '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
        weekdaysShort: '日_月_火_水_木_金_土'.split('_'),
        weekdaysMin: '日_月_火_水_木_金_土'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY年M月D日',
            LLL: 'YYYY年M月D日 HH:mm',
            LLLL: 'YYYY年M月D日 dddd HH:mm',
            l: 'YYYY/MM/DD',
            ll: 'YYYY年M月D日',
            lll: 'YYYY年M月D日 HH:mm',
            llll: 'YYYY年M月D日(ddd) HH:mm',
        },
        meridiemParse: /午前|午後/i,
        isPM: function (input) {
            return input === '午後';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return '午前';
            } else {
                return '午後';
            }
        },
        calendar: {
            sameDay: '[今日] LT',
            nextDay: '[明日] LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    return '[来週]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            lastDay: '[昨日] LT',
            lastWeek: function (now) {
                if (this.week() !== now.week()) {
                    return '[先週]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}日/,
        ordinal: function (number, period) {
            switch (period) {
                case 'y':
                    return number === 1 ? '元年' : number + '年';
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s後',
            past: '%s前',
            s: '数秒',
            ss: '%d秒',
            m: '1分',
            mm: '%d分',
            h: '1時間',
            hh: '%d時間',
            d: '1日',
            dd: '%d日',
            M: '1ヶ月',
            MM: '%dヶ月',
            y: '1年',
            yy: '%d年',
        },
    });

    return ja;

})));


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var jv = moment.defineLocale('jv', {
        months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar: {
            sameDay: '[Dinten puniko pukul] LT',
            nextDay: '[Mbenjang pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kala wingi pukul] LT',
            lastWeek: 'dddd [kepengker pukul] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'wonten ing %s',
            past: '%s ingkang kepengker',
            s: 'sawetawis detik',
            ss: '%d detik',
            m: 'setunggal menit',
            mm: '%d menit',
            h: 'setunggal jam',
            hh: '%d jam',
            d: 'sedinten',
            dd: '%d dinten',
            M: 'sewulan',
            MM: '%d wulan',
            y: 'setaun',
            yy: '%d taun',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return jv;

})));


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/IrakliJani

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ka = moment.defineLocale('ka', {
        months: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split(
            '_'
        ),
        monthsShort: 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
        weekdays: {
            standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split(
                '_'
            ),
            format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split(
                '_'
            ),
            isFormat: /(წინა|შემდეგ)/,
        },
        weekdaysShort: 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
        weekdaysMin: 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[დღეს] LT[-ზე]',
            nextDay: '[ხვალ] LT[-ზე]',
            lastDay: '[გუშინ] LT[-ზე]',
            nextWeek: '[შემდეგ] dddd LT[-ზე]',
            lastWeek: '[წინა] dddd LT-ზე',
            sameElse: 'L',
        },
        relativeTime: {
            future: function (s) {
                return s.replace(/(წამ|წუთ|საათ|წელ|დღ|თვ)(ი|ე)/, function (
                    $0,
                    $1,
                    $2
                ) {
                    return $2 === 'ი' ? $1 + 'ში' : $1 + $2 + 'ში';
                });
            },
            past: function (s) {
                if (/(წამი|წუთი|საათი|დღე|თვე)/.test(s)) {
                    return s.replace(/(ი|ე)$/, 'ის წინ');
                }
                if (/წელი/.test(s)) {
                    return s.replace(/წელი$/, 'წლის წინ');
                }
                return s;
            },
            s: 'რამდენიმე წამი',
            ss: '%d წამი',
            m: 'წუთი',
            mm: '%d წუთი',
            h: 'საათი',
            hh: '%d საათი',
            d: 'დღე',
            dd: '%d დღე',
            M: 'თვე',
            MM: '%d თვე',
            y: 'წელი',
            yy: '%d წელი',
        },
        dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
        ordinal: function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-ლი';
            }
            if (
                number < 20 ||
                (number <= 100 && number % 20 === 0) ||
                number % 100 === 0
            ) {
                return 'მე-' + number;
            }
            return number + '-ე';
        },
        week: {
            dow: 1,
            doy: 7,
        },
    });

    return ka;

})));


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        0: '-ші',
        1: '-ші',
        2: '-ші',
        3: '-ші',
        4: '-ші',
        5: '-ші',
        6: '-шы',
        7: '-ші',
        8: '-ші',
        9: '-шы',
        10: '-шы',
        20: '-шы',
        30: '-шы',
        40: '-шы',
        50: '-ші',
        60: '-шы',
        70: '-ші',
        80: '-ші',
        90: '-шы',
        100: '-ші',
    };

    var kk = moment.defineLocale('kk', {
        months: 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split(
            '_'
        ),
        monthsShort: 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
        weekdays: 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split(
            '_'
        ),
        weekdaysShort: 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
        weekdaysMin: 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Бүгін сағат] LT',
            nextDay: '[Ертең сағат] LT',
            nextWeek: 'dddd [сағат] LT',
            lastDay: '[Кеше сағат] LT',
            lastWeek: '[Өткен аптаның] dddd [сағат] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s ішінде',
            past: '%s бұрын',
            s: 'бірнеше секунд',
            ss: '%d секунд',
            m: 'бір минут',
            mm: '%d минут',
            h: 'бір сағат',
            hh: '%d сағат',
            d: 'бір күн',
            dd: '%d күн',
            M: 'бір ай',
            MM: '%d ай',
            y: 'бір жыл',
            yy: '%d жыл',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
        ordinal: function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return kk;

})));


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '១',
            '2': '២',
            '3': '៣',
            '4': '៤',
            '5': '៥',
            '6': '៦',
            '7': '៧',
            '8': '៨',
            '9': '៩',
            '0': '០',
        },
        numberMap = {
            '១': '1',
            '២': '2',
            '៣': '3',
            '៤': '4',
            '៥': '5',
            '៦': '6',
            '៧': '7',
            '៨': '8',
            '៩': '9',
            '០': '0',
        };

    var km = moment.defineLocale('km', {
        months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split(
            '_'
        ),
        monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split(
            '_'
        ),
        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        weekdaysShort: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
        weekdaysMin: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        meridiemParse: /ព្រឹក|ល្ងាច/,
        isPM: function (input) {
            return input === 'ល្ងាច';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ព្រឹក';
            } else {
                return 'ល្ងាច';
            }
        },
        calendar: {
            sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
            nextDay: '[ស្អែក ម៉ោង] LT',
            nextWeek: 'dddd [ម៉ោង] LT',
            lastDay: '[ម្សិលមិញ ម៉ោង] LT',
            lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%sទៀត',
            past: '%sមុន',
            s: 'ប៉ុន្មានវិនាទី',
            ss: '%d វិនាទី',
            m: 'មួយនាទី',
            mm: '%d នាទី',
            h: 'មួយម៉ោង',
            hh: '%d ម៉ោង',
            d: 'មួយថ្ងៃ',
            dd: '%d ថ្ងៃ',
            M: 'មួយខែ',
            MM: '%d ខែ',
            y: 'មួយឆ្នាំ',
            yy: '%d ឆ្នាំ',
        },
        dayOfMonthOrdinalParse: /ទី\d{1,2}/,
        ordinal: 'ទី%d',
        preparse: function (string) {
            return string.replace(/[១២៣៤៥៦៧៨៩០]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return km;

})));


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kannada [kn]
//! author : Rajeev Naik : https://github.com/rajeevnaikte

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '೧',
            '2': '೨',
            '3': '೩',
            '4': '೪',
            '5': '೫',
            '6': '೬',
            '7': '೭',
            '8': '೮',
            '9': '೯',
            '0': '೦',
        },
        numberMap = {
            '೧': '1',
            '೨': '2',
            '೩': '3',
            '೪': '4',
            '೫': '5',
            '೬': '6',
            '೭': '7',
            '೮': '8',
            '೯': '9',
            '೦': '0',
        };

    var kn = moment.defineLocale('kn', {
        months: 'ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್'.split(
            '_'
        ),
        monthsShort: 'ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ'.split(
            '_'
        ),
        weekdaysShort: 'ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ'.split('_'),
        weekdaysMin: 'ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm',
            LLLL: 'dddd, D MMMM YYYY, A h:mm',
        },
        calendar: {
            sameDay: '[ಇಂದು] LT',
            nextDay: '[ನಾಳೆ] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[ನಿನ್ನೆ] LT',
            lastWeek: '[ಕೊನೆಯ] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s ನಂತರ',
            past: '%s ಹಿಂದೆ',
            s: 'ಕೆಲವು ಕ್ಷಣಗಳು',
            ss: '%d ಸೆಕೆಂಡುಗಳು',
            m: 'ಒಂದು ನಿಮಿಷ',
            mm: '%d ನಿಮಿಷ',
            h: 'ಒಂದು ಗಂಟೆ',
            hh: '%d ಗಂಟೆ',
            d: 'ಒಂದು ದಿನ',
            dd: '%d ದಿನ',
            M: 'ಒಂದು ತಿಂಗಳು',
            MM: '%d ತಿಂಗಳು',
            y: 'ಒಂದು ವರ್ಷ',
            yy: '%d ವರ್ಷ',
        },
        preparse: function (string) {
            return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ರಾತ್ರಿ') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ಬೆಳಿಗ್ಗೆ') {
                return hour;
            } else if (meridiem === 'ಮಧ್ಯಾಹ್ನ') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'ಸಂಜೆ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ರಾತ್ರಿ';
            } else if (hour < 10) {
                return 'ಬೆಳಿಗ್ಗೆ';
            } else if (hour < 17) {
                return 'ಮಧ್ಯಾಹ್ನ';
            } else if (hour < 20) {
                return 'ಸಂಜೆ';
            } else {
                return 'ರಾತ್ರಿ';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
        ordinal: function (number) {
            return number + 'ನೇ';
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return kn;

})));


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ko = moment.defineLocale('ko', {
        months: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        monthsShort: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split(
            '_'
        ),
        weekdays: '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
        weekdaysShort: '일_월_화_수_목_금_토'.split('_'),
        weekdaysMin: '일_월_화_수_목_금_토'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'YYYY.MM.DD.',
            LL: 'YYYY년 MMMM D일',
            LLL: 'YYYY년 MMMM D일 A h:mm',
            LLLL: 'YYYY년 MMMM D일 dddd A h:mm',
            l: 'YYYY.MM.DD.',
            ll: 'YYYY년 MMMM D일',
            lll: 'YYYY년 MMMM D일 A h:mm',
            llll: 'YYYY년 MMMM D일 dddd A h:mm',
        },
        calendar: {
            sameDay: '오늘 LT',
            nextDay: '내일 LT',
            nextWeek: 'dddd LT',
            lastDay: '어제 LT',
            lastWeek: '지난주 dddd LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s 후',
            past: '%s 전',
            s: '몇 초',
            ss: '%d초',
            m: '1분',
            mm: '%d분',
            h: '한 시간',
            hh: '%d시간',
            d: '하루',
            dd: '%d일',
            M: '한 달',
            MM: '%d달',
            y: '일 년',
            yy: '%d년',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(일|월|주)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '일';
                case 'M':
                    return number + '월';
                case 'w':
                case 'W':
                    return number + '주';
                default:
                    return number;
            }
        },
        meridiemParse: /오전|오후/,
        isPM: function (token) {
            return token === '오후';
        },
        meridiem: function (hour, minute, isUpper) {
            return hour < 12 ? '오전' : '오후';
        },
    });

    return ko;

})));


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kurdish [ku]
//! author : Shahram Mebashar : https://github.com/ShahramMebashar

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '١',
            '2': '٢',
            '3': '٣',
            '4': '٤',
            '5': '٥',
            '6': '٦',
            '7': '٧',
            '8': '٨',
            '9': '٩',
            '0': '٠',
        },
        numberMap = {
            '١': '1',
            '٢': '2',
            '٣': '3',
            '٤': '4',
            '٥': '5',
            '٦': '6',
            '٧': '7',
            '٨': '8',
            '٩': '9',
            '٠': '0',
        },
        months = [
            'کانونی دووەم',
            'شوبات',
            'ئازار',
            'نیسان',
            'ئایار',
            'حوزەیران',
            'تەمموز',
            'ئاب',
            'ئەیلوول',
            'تشرینی یەكەم',
            'تشرینی دووەم',
            'كانونی یەکەم',
        ];

    var ku = moment.defineLocale('ku', {
        months: months,
        monthsShort: months,
        weekdays: 'یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌'.split(
            '_'
        ),
        weekdaysShort: 'یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌'.split(
            '_'
        ),
        weekdaysMin: 'ی_د_س_چ_پ_ه_ش'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        meridiemParse: /ئێواره‌|به‌یانی/,
        isPM: function (input) {
            return /ئێواره‌/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'به‌یانی';
            } else {
                return 'ئێواره‌';
            }
        },
        calendar: {
            sameDay: '[ئه‌مرۆ كاتژمێر] LT',
            nextDay: '[به‌یانی كاتژمێر] LT',
            nextWeek: 'dddd [كاتژمێر] LT',
            lastDay: '[دوێنێ كاتژمێر] LT',
            lastWeek: 'dddd [كاتژمێر] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'له‌ %s',
            past: '%s',
            s: 'چه‌ند چركه‌یه‌ك',
            ss: 'چركه‌ %d',
            m: 'یه‌ك خوله‌ك',
            mm: '%d خوله‌ك',
            h: 'یه‌ك كاتژمێر',
            hh: '%d كاتژمێر',
            d: 'یه‌ك ڕۆژ',
            dd: '%d ڕۆژ',
            M: 'یه‌ك مانگ',
            MM: '%d مانگ',
            y: 'یه‌ك ساڵ',
            yy: '%d ساڵ',
        },
        preparse: function (string) {
            return string
                .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                    return numberMap[match];
                })
                .replace(/،/g, ',');
        },
        postformat: function (string) {
            return string
                .replace(/\d/g, function (match) {
                    return symbolMap[match];
                })
                .replace(/,/g, '،');
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return ku;

})));


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        0: '-чү',
        1: '-чи',
        2: '-чи',
        3: '-чү',
        4: '-чү',
        5: '-чи',
        6: '-чы',
        7: '-чи',
        8: '-чи',
        9: '-чу',
        10: '-чу',
        20: '-чы',
        30: '-чу',
        40: '-чы',
        50: '-чү',
        60: '-чы',
        70: '-чи',
        80: '-чи',
        90: '-чу',
        100: '-чү',
    };

    var ky = moment.defineLocale('ky', {
        months: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split(
            '_'
        ),
        monthsShort: 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split(
            '_'
        ),
        weekdays: 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split(
            '_'
        ),
        weekdaysShort: 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
        weekdaysMin: 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Бүгүн саат] LT',
            nextDay: '[Эртең саат] LT',
            nextWeek: 'dddd [саат] LT',
            lastDay: '[Кечээ саат] LT',
            lastWeek: '[Өткөн аптанын] dddd [күнү] [саат] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s ичинде',
            past: '%s мурун',
            s: 'бирнече секунд',
            ss: '%d секунд',
            m: 'бир мүнөт',
            mm: '%d мүнөт',
            h: 'бир саат',
            hh: '%d саат',
            d: 'бир күн',
            dd: '%d күн',
            M: 'бир ай',
            MM: '%d ай',
            y: 'бир жыл',
            yy: '%d жыл',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
        ordinal: function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return ky;

})));


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: ['eng Minutt', 'enger Minutt'],
            h: ['eng Stonn', 'enger Stonn'],
            d: ['een Dag', 'engem Dag'],
            M: ['ee Mount', 'engem Mount'],
            y: ['ee Joer', 'engem Joer'],
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10,
                firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = moment.defineLocale('lb', {
        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split(
            '_'
        ),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split(
            '_'
        ),
        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm [Auer]',
            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]',
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gëschter um] LT',
            lastWeek: function () {
                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            },
        },
        relativeTime: {
            future: processFutureTime,
            past: processPastTime,
            s: 'e puer Sekonnen',
            ss: '%d Sekonnen',
            m: processRelativeTime,
            mm: '%d Minutten',
            h: processRelativeTime,
            hh: '%d Stonnen',
            d: processRelativeTime,
            dd: '%d Deeg',
            M: processRelativeTime,
            MM: '%d Méint',
            y: processRelativeTime,
            yy: '%d Joer',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return lb;

})));


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var lo = moment.defineLocale('lo', {
        months: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split(
            '_'
        ),
        monthsShort: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split(
            '_'
        ),
        weekdays: 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysShort: 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysMin: 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'ວັນdddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
        isPM: function (input) {
            return input === 'ຕອນແລງ';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ຕອນເຊົ້າ';
            } else {
                return 'ຕອນແລງ';
            }
        },
        calendar: {
            sameDay: '[ມື້ນີ້ເວລາ] LT',
            nextDay: '[ມື້ອື່ນເວລາ] LT',
            nextWeek: '[ວັນ]dddd[ໜ້າເວລາ] LT',
            lastDay: '[ມື້ວານນີ້ເວລາ] LT',
            lastWeek: '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'ອີກ %s',
            past: '%sຜ່ານມາ',
            s: 'ບໍ່ເທົ່າໃດວິນາທີ',
            ss: '%d ວິນາທີ',
            m: '1 ນາທີ',
            mm: '%d ນາທີ',
            h: '1 ຊົ່ວໂມງ',
            hh: '%d ຊົ່ວໂມງ',
            d: '1 ມື້',
            dd: '%d ມື້',
            M: '1 ເດືອນ',
            MM: '%d ເດືອນ',
            y: '1 ປີ',
            yy: '%d ປີ',
        },
        dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
        ordinal: function (number) {
            return 'ທີ່' + number;
        },
    });

    return lo;

})));


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozūras : https://github.com/mmozuras

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var units = {
        ss: 'sekundė_sekundžių_sekundes',
        m: 'minutė_minutės_minutę',
        mm: 'minutės_minučių_minutes',
        h: 'valanda_valandos_valandą',
        hh: 'valandos_valandų_valandas',
        d: 'diena_dienos_dieną',
        dd: 'dienos_dienų_dienas',
        M: 'mėnuo_mėnesio_mėnesį',
        MM: 'mėnesiai_mėnesių_mėnesius',
        y: 'metai_metų_metus',
        yy: 'metai_metų_metus',
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekundės';
        } else {
            return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix
            ? forms(key)[0]
            : isFuture
            ? forms(key)[1]
            : forms(key)[2];
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return units[key].split('_');
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return (
                result + translateSingular(number, withoutSuffix, key[0], isFuture)
            );
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    var lt = moment.defineLocale('lt', {
        months: {
            format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split(
                '_'
            ),
            standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split(
                '_'
            ),
            isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/,
        },
        monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays: {
            format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split(
                '_'
            ),
            standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split(
                '_'
            ),
            isFormat: /dddd HH:mm/,
        },
        weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
        weekdaysMin: 'S_P_A_T_K_Pn_Š'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY [m.] MMMM D [d.]',
            LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
            l: 'YYYY-MM-DD',
            ll: 'YYYY [m.] MMMM D [d.]',
            lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]',
        },
        calendar: {
            sameDay: '[Šiandien] LT',
            nextDay: '[Rytoj] LT',
            nextWeek: 'dddd LT',
            lastDay: '[Vakar] LT',
            lastWeek: '[Praėjusį] dddd LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'po %s',
            past: 'prieš %s',
            s: translateSeconds,
            ss: translate,
            m: translateSingular,
            mm: translate,
            h: translateSingular,
            hh: translate,
            d: translateSingular,
            dd: translate,
            M: translateSingular,
            MM: translate,
            y: translateSingular,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
        ordinal: function (number) {
            return number + '-oji';
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return lt;

})));


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jānis Elmeris : https://github.com/JanisE

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var units = {
        ss: 'sekundes_sekundēm_sekunde_sekundes'.split('_'),
        m: 'minūtes_minūtēm_minūte_minūtes'.split('_'),
        mm: 'minūtes_minūtēm_minūte_minūtes'.split('_'),
        h: 'stundas_stundām_stunda_stundas'.split('_'),
        hh: 'stundas_stundām_stunda_stundas'.split('_'),
        d: 'dienas_dienām_diena_dienas'.split('_'),
        dd: 'dienas_dienām_diena_dienas'.split('_'),
        M: 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
        MM: 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
        y: 'gada_gadiem_gads_gadi'.split('_'),
        yy: 'gada_gadiem_gads_gadi'.split('_'),
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 minūte", "3 minūtes".
            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 minūtes" as in "pēc 21 minūtes".
            // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
        }
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + format(units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format(units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
    }

    var lv = moment.defineLocale('lv', {
        months: 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split(
            '_'
        ),
        weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY.',
            LL: 'YYYY. [gada] D. MMMM',
            LLL: 'YYYY. [gada] D. MMMM, HH:mm',
            LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm',
        },
        calendar: {
            sameDay: '[Šodien pulksten] LT',
            nextDay: '[Rīt pulksten] LT',
            nextWeek: 'dddd [pulksten] LT',
            lastDay: '[Vakar pulksten] LT',
            lastWeek: '[Pagājušā] dddd [pulksten] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'pēc %s',
            past: 'pirms %s',
            s: relativeSeconds,
            ss: relativeTimeWithPlural,
            m: relativeTimeWithSingular,
            mm: relativeTimeWithPlural,
            h: relativeTimeWithSingular,
            hh: relativeTimeWithPlural,
            d: relativeTimeWithSingular,
            dd: relativeTimeWithPlural,
            M: relativeTimeWithSingular,
            MM: relativeTimeWithPlural,
            y: relativeTimeWithSingular,
            yy: relativeTimeWithPlural,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return lv;

})));


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var translator = {
        words: {
            //Different grammatical cases
            ss: ['sekund', 'sekunda', 'sekundi'],
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina'],
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1
                ? wordKey[0]
                : number >= 2 && number <= 4
                ? wordKey[1]
                : wordKey[2];
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return (
                    number +
                    ' ' +
                    translator.correctGrammaticalCase(number, wordKey)
                );
            }
        },
    };

    var me = moment.defineLocale('me', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split(
            '_'
        ),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[juče u] LT',
            lastWeek: function () {
                var lastWeekDays = [
                    '[prošle] [nedjelje] [u] LT',
                    '[prošlog] [ponedjeljka] [u] LT',
                    '[prošlog] [utorka] [u] LT',
                    '[prošle] [srijede] [u] LT',
                    '[prošlog] [četvrtka] [u] LT',
                    '[prošlog] [petka] [u] LT',
                    '[prošle] [subote] [u] LT',
                ];
                return lastWeekDays[this.day()];
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'prije %s',
            s: 'nekoliko sekundi',
            ss: translator.translate,
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: 'dan',
            dd: translator.translate,
            M: 'mjesec',
            MM: translator.translate,
            y: 'godinu',
            yy: translator.translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return me;

})));


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var mi = moment.defineLocale('mi', {
        months: 'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split(
            '_'
        ),
        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split(
            '_'
        ),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
        weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
        weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [i] HH:mm',
            LLLL: 'dddd, D MMMM YYYY [i] HH:mm',
        },
        calendar: {
            sameDay: '[i teie mahana, i] LT',
            nextDay: '[apopo i] LT',
            nextWeek: 'dddd [i] LT',
            lastDay: '[inanahi i] LT',
            lastWeek: 'dddd [whakamutunga i] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'i roto i %s',
            past: '%s i mua',
            s: 'te hēkona ruarua',
            ss: '%d hēkona',
            m: 'he meneti',
            mm: '%d meneti',
            h: 'te haora',
            hh: '%d haora',
            d: 'he ra',
            dd: '%d ra',
            M: 'he marama',
            MM: '%d marama',
            y: 'he tau',
            yy: '%d tau',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return mi;

})));


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0
//! author : Sashko Todorov : https://github.com/bkyceh

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var mk = moment.defineLocale('mk', {
        months: 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split(
            '_'
        ),
        monthsShort: 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
        weekdays: 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split(
            '_'
        ),
        weekdaysShort: 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
        weekdaysMin: 'нe_пo_вт_ср_че_пе_сa'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'D.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY H:mm',
            LLLL: 'dddd, D MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[Денес во] LT',
            nextDay: '[Утре во] LT',
            nextWeek: '[Во] dddd [во] LT',
            lastDay: '[Вчера во] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[Изминатата] dddd [во] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[Изминатиот] dddd [во] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'за %s',
            past: 'пред %s',
            s: 'неколку секунди',
            ss: '%d секунди',
            m: 'една минута',
            mm: '%d минути',
            h: 'еден час',
            hh: '%d часа',
            d: 'еден ден',
            dd: '%d дена',
            M: 'еден месец',
            MM: '%d месеци',
            y: 'една година',
            yy: '%d години',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal: function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-ев';
            } else if (last2Digits === 0) {
                return number + '-ен';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-ти';
            } else if (lastDigit === 1) {
                return number + '-ви';
            } else if (lastDigit === 2) {
                return number + '-ри';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-ми';
            } else {
                return number + '-ти';
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return mk;

})));


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ml = moment.defineLocale('ml', {
        months: 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split(
            '_'
        ),
        monthsShort: 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split(
            '_'
        ),
        weekdaysShort: 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
        weekdaysMin: 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm -നു',
            LTS: 'A h:mm:ss -നു',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm -നു',
            LLLL: 'dddd, D MMMM YYYY, A h:mm -നു',
        },
        calendar: {
            sameDay: '[ഇന്ന്] LT',
            nextDay: '[നാളെ] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[ഇന്നലെ] LT',
            lastWeek: '[കഴിഞ്ഞ] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s കഴിഞ്ഞ്',
            past: '%s മുൻപ്',
            s: 'അൽപ നിമിഷങ്ങൾ',
            ss: '%d സെക്കൻഡ്',
            m: 'ഒരു മിനിറ്റ്',
            mm: '%d മിനിറ്റ്',
            h: 'ഒരു മണിക്കൂർ',
            hh: '%d മണിക്കൂർ',
            d: 'ഒരു ദിവസം',
            dd: '%d ദിവസം',
            M: 'ഒരു മാസം',
            MM: '%d മാസം',
            y: 'ഒരു വർഷം',
            yy: '%d വർഷം',
        },
        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                (meridiem === 'രാത്രി' && hour >= 4) ||
                meridiem === 'ഉച്ച കഴിഞ്ഞ്' ||
                meridiem === 'വൈകുന്നേരം'
            ) {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'രാത്രി';
            } else if (hour < 12) {
                return 'രാവിലെ';
            } else if (hour < 17) {
                return 'ഉച്ച കഴിഞ്ഞ്';
            } else if (hour < 20) {
                return 'വൈകുന്നേരം';
            } else {
                return 'രാത്രി';
            }
        },
    });

    return ml;

})));


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Mongolian [mn]
//! author : Javkhlantugs Nyamdorj : https://github.com/javkhaanj7

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function translate(number, withoutSuffix, key, isFuture) {
        switch (key) {
            case 's':
                return withoutSuffix ? 'хэдхэн секунд' : 'хэдхэн секундын';
            case 'ss':
                return number + (withoutSuffix ? ' секунд' : ' секундын');
            case 'm':
            case 'mm':
                return number + (withoutSuffix ? ' минут' : ' минутын');
            case 'h':
            case 'hh':
                return number + (withoutSuffix ? ' цаг' : ' цагийн');
            case 'd':
            case 'dd':
                return number + (withoutSuffix ? ' өдөр' : ' өдрийн');
            case 'M':
            case 'MM':
                return number + (withoutSuffix ? ' сар' : ' сарын');
            case 'y':
            case 'yy':
                return number + (withoutSuffix ? ' жил' : ' жилийн');
            default:
                return number;
        }
    }

    var mn = moment.defineLocale('mn', {
        months: 'Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар'.split(
            '_'
        ),
        monthsShort: '1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба'.split('_'),
        weekdaysShort: 'Ням_Дав_Мяг_Лха_Пүр_Баа_Бям'.split('_'),
        weekdaysMin: 'Ня_Да_Мя_Лх_Пү_Ба_Бя'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY оны MMMMын D',
            LLL: 'YYYY оны MMMMын D HH:mm',
            LLLL: 'dddd, YYYY оны MMMMын D HH:mm',
        },
        meridiemParse: /ҮӨ|ҮХ/i,
        isPM: function (input) {
            return input === 'ҮХ';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ҮӨ';
            } else {
                return 'ҮХ';
            }
        },
        calendar: {
            sameDay: '[Өнөөдөр] LT',
            nextDay: '[Маргааш] LT',
            nextWeek: '[Ирэх] dddd LT',
            lastDay: '[Өчигдөр] LT',
            lastWeek: '[Өнгөрсөн] dddd LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s дараа',
            past: '%s өмнө',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2} өдөр/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + ' өдөр';
                default:
                    return number;
            }
        },
    });

    return mn;

})));


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '१',
            '2': '२',
            '3': '३',
            '4': '४',
            '5': '५',
            '6': '६',
            '7': '७',
            '8': '८',
            '9': '९',
            '0': '०',
        },
        numberMap = {
            '१': '1',
            '२': '2',
            '३': '3',
            '४': '4',
            '५': '5',
            '६': '6',
            '७': '7',
            '८': '8',
            '९': '9',
            '०': '0',
        };

    function relativeTimeMr(number, withoutSuffix, string, isFuture) {
        var output = '';
        if (withoutSuffix) {
            switch (string) {
                case 's':
                    output = 'काही सेकंद';
                    break;
                case 'ss':
                    output = '%d सेकंद';
                    break;
                case 'm':
                    output = 'एक मिनिट';
                    break;
                case 'mm':
                    output = '%d मिनिटे';
                    break;
                case 'h':
                    output = 'एक तास';
                    break;
                case 'hh':
                    output = '%d तास';
                    break;
                case 'd':
                    output = 'एक दिवस';
                    break;
                case 'dd':
                    output = '%d दिवस';
                    break;
                case 'M':
                    output = 'एक महिना';
                    break;
                case 'MM':
                    output = '%d महिने';
                    break;
                case 'y':
                    output = 'एक वर्ष';
                    break;
                case 'yy':
                    output = '%d वर्षे';
                    break;
            }
        } else {
            switch (string) {
                case 's':
                    output = 'काही सेकंदां';
                    break;
                case 'ss':
                    output = '%d सेकंदां';
                    break;
                case 'm':
                    output = 'एका मिनिटा';
                    break;
                case 'mm':
                    output = '%d मिनिटां';
                    break;
                case 'h':
                    output = 'एका तासा';
                    break;
                case 'hh':
                    output = '%d तासां';
                    break;
                case 'd':
                    output = 'एका दिवसा';
                    break;
                case 'dd':
                    output = '%d दिवसां';
                    break;
                case 'M':
                    output = 'एका महिन्या';
                    break;
                case 'MM':
                    output = '%d महिन्यां';
                    break;
                case 'y':
                    output = 'एका वर्षा';
                    break;
                case 'yy':
                    output = '%d वर्षां';
                    break;
            }
        }
        return output.replace(/%d/i, number);
    }

    var mr = moment.defineLocale('mr', {
        months: 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split(
            '_'
        ),
        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort: 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat: {
            LT: 'A h:mm वाजता',
            LTS: 'A h:mm:ss वाजता',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm वाजता',
            LLLL: 'dddd, D MMMM YYYY, A h:mm वाजता',
        },
        calendar: {
            sameDay: '[आज] LT',
            nextDay: '[उद्या] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[काल] LT',
            lastWeek: '[मागील] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%sमध्ये',
            past: '%sपूर्वी',
            s: relativeTimeMr,
            ss: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr,
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /पहाटे|सकाळी|दुपारी|सायंकाळी|रात्री/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'पहाटे' || meridiem === 'सकाळी') {
                return hour;
            } else if (
                meridiem === 'दुपारी' ||
                meridiem === 'सायंकाळी' ||
                meridiem === 'रात्री'
            ) {
                return hour >= 12 ? hour : hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour >= 0 && hour < 6) {
                return 'पहाटे';
            } else if (hour < 12) {
                return 'सकाळी';
            } else if (hour < 17) {
                return 'दुपारी';
            } else if (hour < 20) {
                return 'सायंकाळी';
            } else {
                return 'रात्री';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return mr;

})));


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ms = moment.defineLocale('ms', {
        months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar: {
            sameDay: '[Hari ini pukul] LT',
            nextDay: '[Esok pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kelmarin pukul] LT',
            lastWeek: 'dddd [lepas pukul] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dalam %s',
            past: '%s yang lepas',
            s: 'beberapa saat',
            ss: '%d saat',
            m: 'seminit',
            mm: '%d minit',
            h: 'sejam',
            hh: '%d jam',
            d: 'sehari',
            dd: '%d hari',
            M: 'sebulan',
            MM: '%d bulan',
            y: 'setahun',
            yy: '%d tahun',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return ms;

})));


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var msMy = moment.defineLocale('ms-my', {
        months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar: {
            sameDay: '[Hari ini pukul] LT',
            nextDay: '[Esok pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kelmarin pukul] LT',
            lastWeek: 'dddd [lepas pukul] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dalam %s',
            past: '%s yang lepas',
            s: 'beberapa saat',
            ss: '%d saat',
            m: 'seminit',
            mm: '%d minit',
            h: 'sejam',
            hh: '%d jam',
            d: 'sehari',
            dd: '%d hari',
            M: 'sebulan',
            MM: '%d bulan',
            y: 'setahun',
            yy: '%d tahun',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return msMy;

})));


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maltese (Malta) [mt]
//! author : Alessandro Maruccia : https://github.com/alesma

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var mt = moment.defineLocale('mt', {
        months: 'Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru'.split(
            '_'
        ),
        monthsShort: 'Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ'.split('_'),
        weekdays: 'Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt'.split(
            '_'
        ),
        weekdaysShort: 'Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib'.split('_'),
        weekdaysMin: 'Ħa_Tn_Tl_Er_Ħa_Ġi_Si'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Illum fil-]LT',
            nextDay: '[Għada fil-]LT',
            nextWeek: 'dddd [fil-]LT',
            lastDay: '[Il-bieraħ fil-]LT',
            lastWeek: 'dddd [li għadda] [fil-]LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'f’ %s',
            past: '%s ilu',
            s: 'ftit sekondi',
            ss: '%d sekondi',
            m: 'minuta',
            mm: '%d minuti',
            h: 'siegħa',
            hh: '%d siegħat',
            d: 'ġurnata',
            dd: '%d ġranet',
            M: 'xahar',
            MM: '%d xhur',
            y: 'sena',
            yy: '%d sni',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return mt;

})));


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '၁',
            '2': '၂',
            '3': '၃',
            '4': '၄',
            '5': '၅',
            '6': '၆',
            '7': '၇',
            '8': '၈',
            '9': '၉',
            '0': '၀',
        },
        numberMap = {
            '၁': '1',
            '၂': '2',
            '၃': '3',
            '၄': '4',
            '၅': '5',
            '၆': '6',
            '၇': '7',
            '၈': '8',
            '၉': '9',
            '၀': '0',
        };

    var my = moment.defineLocale('my', {
        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split(
            '_'
        ),
        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split(
            '_'
        ),
        weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
        weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[ယနေ.] LT [မှာ]',
            nextDay: '[မနက်ဖြန်] LT [မှာ]',
            nextWeek: 'dddd LT [မှာ]',
            lastDay: '[မနေ.က] LT [မှာ]',
            lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'လာမည့် %s မှာ',
            past: 'လွန်ခဲ့သော %s က',
            s: 'စက္ကန်.အနည်းငယ်',
            ss: '%d စက္ကန့်',
            m: 'တစ်မိနစ်',
            mm: '%d မိနစ်',
            h: 'တစ်နာရီ',
            hh: '%d နာရီ',
            d: 'တစ်ရက်',
            dd: '%d ရက်',
            M: 'တစ်လ',
            MM: '%d လ',
            y: 'တစ်နှစ်',
            yy: '%d နှစ်',
        },
        preparse: function (string) {
            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return my;

})));


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Norwegian Bokmål [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga
//!           Stephen Ramthun : https://github.com/stephenramthun

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var nb = moment.defineLocale('nb', {
        months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort: 'sø._ma._ti._on._to._fr._lø.'.split('_'),
        weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY [kl.] HH:mm',
            LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
        },
        calendar: {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i går kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'om %s',
            past: '%s siden',
            s: 'noen sekunder',
            ss: '%d sekunder',
            m: 'ett minutt',
            mm: '%d minutter',
            h: 'en time',
            hh: '%d timer',
            d: 'en dag',
            dd: '%d dager',
            M: 'en måned',
            MM: '%d måneder',
            y: 'ett år',
            yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return nb;

})));


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '१',
            '2': '२',
            '3': '३',
            '4': '४',
            '5': '५',
            '6': '६',
            '7': '७',
            '8': '८',
            '9': '९',
            '0': '०',
        },
        numberMap = {
            '१': '1',
            '२': '2',
            '३': '3',
            '४': '4',
            '५': '5',
            '६': '6',
            '७': '7',
            '८': '8',
            '९': '9',
            '०': '0',
        };

    var ne = moment.defineLocale('ne', {
        months: 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split(
            '_'
        ),
        monthsShort: 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split(
            '_'
        ),
        weekdaysShort: 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
        weekdaysMin: 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'Aको h:mm बजे',
            LTS: 'Aको h:mm:ss बजे',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, Aको h:mm बजे',
            LLLL: 'dddd, D MMMM YYYY, Aको h:mm बजे',
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'राति') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'बिहान') {
                return hour;
            } else if (meridiem === 'दिउँसो') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'साँझ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 3) {
                return 'राति';
            } else if (hour < 12) {
                return 'बिहान';
            } else if (hour < 16) {
                return 'दिउँसो';
            } else if (hour < 20) {
                return 'साँझ';
            } else {
                return 'राति';
            }
        },
        calendar: {
            sameDay: '[आज] LT',
            nextDay: '[भोलि] LT',
            nextWeek: '[आउँदो] dddd[,] LT',
            lastDay: '[हिजो] LT',
            lastWeek: '[गएको] dddd[,] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%sमा',
            past: '%s अगाडि',
            s: 'केही क्षण',
            ss: '%d सेकेण्ड',
            m: 'एक मिनेट',
            mm: '%d मिनेट',
            h: 'एक घण्टा',
            hh: '%d घण्टा',
            d: 'एक दिन',
            dd: '%d दिन',
            M: 'एक महिना',
            MM: '%d महिना',
            y: 'एक बर्ष',
            yy: '%d बर्ष',
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return ne;

})));


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Röling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split(
            '_'
        ),
        monthsParse = [
            /^jan/i,
            /^feb/i,
            /^maart|mrt.?$/i,
            /^apr/i,
            /^mei$/i,
            /^jun[i.]?$/i,
            /^jul[i.]?$/i,
            /^aug/i,
            /^sep/i,
            /^okt/i,
            /^nov/i,
            /^dec/i,
        ],
        monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nl = moment.defineLocale('nl', {
        months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,

        weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split(
            '_'
        ),
        weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'over %s',
            past: '%s geleden',
            s: 'een paar seconden',
            ss: '%d seconden',
            m: 'één minuut',
            mm: '%d minuten',
            h: 'één uur',
            hh: '%d uur',
            d: 'één dag',
            dd: '%d dagen',
            M: 'één maand',
            MM: '%d maanden',
            y: 'één jaar',
            yy: '%d jaar',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function (number) {
            return (
                number +
                (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
            );
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return nl;

})));


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Röling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split(
            '_'
        ),
        monthsParse = [
            /^jan/i,
            /^feb/i,
            /^maart|mrt.?$/i,
            /^apr/i,
            /^mei$/i,
            /^jun[i.]?$/i,
            /^jul[i.]?$/i,
            /^aug/i,
            /^sep/i,
            /^okt/i,
            /^nov/i,
            /^dec/i,
        ],
        monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nlBe = moment.defineLocale('nl-be', {
        months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,

        weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split(
            '_'
        ),
        weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'over %s',
            past: '%s geleden',
            s: 'een paar seconden',
            ss: '%d seconden',
            m: 'één minuut',
            mm: '%d minuten',
            h: 'één uur',
            hh: '%d uur',
            d: 'één dag',
            dd: '%d dagen',
            M: 'één maand',
            MM: '%d maanden',
            y: 'één jaar',
            yy: '%d jaar',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function (number) {
            return (
                number +
                (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
            );
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return nlBe;

})));


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! authors : https://github.com/mechuwind
//!           Stephen Ramthun : https://github.com/stephenramthun

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var nn = moment.defineLocale('nn', {
        months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort: 'su._må._ty._on._to._fr._lau.'.split('_'),
        weekdaysMin: 'su_må_ty_on_to_fr_la'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY [kl.] H:mm',
            LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
        },
        calendar: {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I går klokka] LT',
            lastWeek: '[Føregåande] dddd [klokka] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'om %s',
            past: '%s sidan',
            s: 'nokre sekund',
            ss: '%d sekund',
            m: 'eit minutt',
            mm: '%d minutt',
            h: 'ein time',
            hh: '%d timar',
            d: 'ein dag',
            dd: '%d dagar',
            M: 'ein månad',
            MM: '%d månader',
            y: 'eit år',
            yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return nn;

})));


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Occitan, lengadocian dialecte [oc-lnc]
//! author : Quentin PAGÈS : https://github.com/Quenty31

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ocLnc = moment.defineLocale('oc-lnc', {
        months: {
            standalone: 'genièr_febrièr_març_abril_mai_junh_julhet_agost_setembre_octòbre_novembre_decembre'.split(
                '_'
            ),
            format: "de genièr_de febrièr_de març_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octòbre_de novembre_de decembre".split(
                '_'
            ),
            isFormat: /D[oD]?(\s)+MMMM/,
        },
        monthsShort: 'gen._febr._març_abr._mai_junh_julh._ago._set._oct._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'dimenge_diluns_dimars_dimècres_dijòus_divendres_dissabte'.split(
            '_'
        ),
        weekdaysShort: 'dg._dl._dm._dc._dj._dv._ds.'.split('_'),
        weekdaysMin: 'dg_dl_dm_dc_dj_dv_ds'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM [de] YYYY',
            ll: 'D MMM YYYY',
            LLL: 'D MMMM [de] YYYY [a] H:mm',
            lll: 'D MMM YYYY, H:mm',
            LLLL: 'dddd D MMMM [de] YYYY [a] H:mm',
            llll: 'ddd D MMM YYYY, H:mm',
        },
        calendar: {
            sameDay: '[uèi a] LT',
            nextDay: '[deman a] LT',
            nextWeek: 'dddd [a] LT',
            lastDay: '[ièr a] LT',
            lastWeek: 'dddd [passat a] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: "d'aquí %s",
            past: 'fa %s',
            s: 'unas segondas',
            ss: '%d segondas',
            m: 'una minuta',
            mm: '%d minutas',
            h: 'una ora',
            hh: '%d oras',
            d: 'un jorn',
            dd: '%d jorns',
            M: 'un mes',
            MM: '%d meses',
            y: 'un an',
            yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
        ordinal: function (number, period) {
            var output =
                number === 1
                    ? 'r'
                    : number === 2
                    ? 'n'
                    : number === 3
                    ? 'r'
                    : number === 4
                    ? 't'
                    : 'è';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4,
        },
    });

    return ocLnc;

})));


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '੧',
            '2': '੨',
            '3': '੩',
            '4': '੪',
            '5': '੫',
            '6': '੬',
            '7': '੭',
            '8': '੮',
            '9': '੯',
            '0': '੦',
        },
        numberMap = {
            '੧': '1',
            '੨': '2',
            '੩': '3',
            '੪': '4',
            '੫': '5',
            '੬': '6',
            '੭': '7',
            '੮': '8',
            '੯': '9',
            '੦': '0',
        };

    var paIn = moment.defineLocale('pa-in', {
        // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
        months: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split(
            '_'
        ),
        monthsShort: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split(
            '_'
        ),
        weekdays: 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split(
            '_'
        ),
        weekdaysShort: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
        weekdaysMin: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm ਵਜੇ',
            LTS: 'A h:mm:ss ਵਜੇ',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm ਵਜੇ',
            LLLL: 'dddd, D MMMM YYYY, A h:mm ਵਜੇ',
        },
        calendar: {
            sameDay: '[ਅਜ] LT',
            nextDay: '[ਕਲ] LT',
            nextWeek: '[ਅਗਲਾ] dddd, LT',
            lastDay: '[ਕਲ] LT',
            lastWeek: '[ਪਿਛਲੇ] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s ਵਿੱਚ',
            past: '%s ਪਿਛਲੇ',
            s: 'ਕੁਝ ਸਕਿੰਟ',
            ss: '%d ਸਕਿੰਟ',
            m: 'ਇਕ ਮਿੰਟ',
            mm: '%d ਮਿੰਟ',
            h: 'ਇੱਕ ਘੰਟਾ',
            hh: '%d ਘੰਟੇ',
            d: 'ਇੱਕ ਦਿਨ',
            dd: '%d ਦਿਨ',
            M: 'ਇੱਕ ਮਹੀਨਾ',
            MM: '%d ਮਹੀਨੇ',
            y: 'ਇੱਕ ਸਾਲ',
            yy: '%d ਸਾਲ',
        },
        preparse: function (string) {
            return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ਰਾਤ') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ਸਵੇਰ') {
                return hour;
            } else if (meridiem === 'ਦੁਪਹਿਰ') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'ਸ਼ਾਮ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ਰਾਤ';
            } else if (hour < 10) {
                return 'ਸਵੇਰ';
            } else if (hour < 17) {
                return 'ਦੁਪਹਿਰ';
            } else if (hour < 20) {
                return 'ਸ਼ਾਮ';
            } else {
                return 'ਰਾਤ';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return paIn;

})));


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split(
            '_'
        ),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split(
            '_'
        );
    function plural(n) {
        return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
    }
    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                return result + (plural(number) ? 'sekundy' : 'sekund');
            case 'm':
                return withoutSuffix ? 'minuta' : 'minutę';
            case 'mm':
                return result + (plural(number) ? 'minuty' : 'minut');
            case 'h':
                return withoutSuffix ? 'godzina' : 'godzinę';
            case 'hh':
                return result + (plural(number) ? 'godziny' : 'godzin');
            case 'MM':
                return result + (plural(number) ? 'miesiące' : 'miesięcy');
            case 'yy':
                return result + (plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = moment.defineLocale('pl', {
        months: function (momentToFormat, format) {
            if (!momentToFormat) {
                return monthsNominative;
            } else if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return (
                    '(' +
                    monthsSubjective[momentToFormat.month()] +
                    '|' +
                    monthsNominative[momentToFormat.month()] +
                    ')'
                );
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
        weekdays: 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split(
            '_'
        ),
        weekdaysShort: 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
        weekdaysMin: 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Dziś o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W niedzielę o] LT';

                    case 2:
                        return '[We wtorek o] LT';

                    case 3:
                        return '[W środę o] LT';

                    case 6:
                        return '[W sobotę o] LT';

                    default:
                        return '[W] dddd [o] LT';
                }
            },
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W zeszłą niedzielę o] LT';
                    case 3:
                        return '[W zeszłą środę o] LT';
                    case 6:
                        return '[W zeszłą sobotę o] LT';
                    default:
                        return '[W zeszły] dddd [o] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: '%s temu',
            s: 'kilka sekund',
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: '1 dzień',
            dd: '%d dni',
            M: 'miesiąc',
            MM: translate,
            y: 'rok',
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return pl;

})));


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var pt = moment.defineLocale('pt', {
        months: 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
            '_'
        ),
        monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
        weekdays: 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split(
            '_'
        ),
        weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY HH:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return this.day() === 0 || this.day() === 6
                    ? '[Último] dddd [às] LT' // Saturday + Sunday
                    : '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'em %s',
            past: 'há %s',
            s: 'segundos',
            ss: '%d segundos',
            m: 'um minuto',
            mm: '%d minutos',
            h: 'uma hora',
            hh: '%d horas',
            d: 'um dia',
            dd: '%d dias',
            M: 'um mês',
            MM: '%d meses',
            y: 'um ano',
            yy: '%d anos',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return pt;

})));


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ptBr = moment.defineLocale('pt-br', {
        months: 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
            '_'
        ),
        monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
        weekdays: 'domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado'.split(
            '_'
        ),
        weekdaysShort: 'dom_seg_ter_qua_qui_sex_sáb'.split('_'),
        weekdaysMin: 'do_2ª_3ª_4ª_5ª_6ª_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY [às] HH:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY [às] HH:mm',
        },
        calendar: {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return this.day() === 0 || this.day() === 6
                    ? '[Último] dddd [às] LT' // Saturday + Sunday
                    : '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'em %s',
            past: 'há %s',
            s: 'poucos segundos',
            ss: '%d segundos',
            m: 'um minuto',
            mm: '%d minutos',
            h: 'uma hora',
            hh: '%d horas',
            d: 'um dia',
            dd: '%d dias',
            M: 'um mês',
            MM: '%d meses',
            y: 'um ano',
            yy: '%d anos',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
    });

    return ptBr;

})));


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly
//! author : Emanuel Cepoi : https://github.com/cepem

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                ss: 'secunde',
                mm: 'minute',
                hh: 'ore',
                dd: 'zile',
                MM: 'luni',
                yy: 'ani',
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = moment.defineLocale('ro', {
        months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split(
            '_'
        ),
        monthsShort: 'ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
        weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
        weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY H:mm',
            LLLL: 'dddd, D MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[azi la] LT',
            nextDay: '[mâine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'peste %s',
            past: '%s în urmă',
            s: 'câteva secunde',
            ss: relativeTimeWithPlural,
            m: 'un minut',
            mm: relativeTimeWithPlural,
            h: 'o oră',
            hh: relativeTimeWithPlural,
            d: 'o zi',
            dd: relativeTimeWithPlural,
            M: 'o lună',
            MM: relativeTimeWithPlural,
            y: 'un an',
            yy: relativeTimeWithPlural,
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return ro;

})));


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! Author : Menelion Elensúle : https://github.com/Oire
//! author : Коренберг Марк : https://github.com/socketpair

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11
            ? forms[0]
            : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
            ? forms[1]
            : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            ss: withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
            mm: withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
            hh: 'час_часа_часов',
            dd: 'день_дня_дней',
            MM: 'месяц_месяца_месяцев',
            yy: 'год_года_лет',
        };
        if (key === 'm') {
            return withoutSuffix ? 'минута' : 'минуту';
        } else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    var monthsParse = [
        /^янв/i,
        /^фев/i,
        /^мар/i,
        /^апр/i,
        /^ма[йя]/i,
        /^июн/i,
        /^июл/i,
        /^авг/i,
        /^сен/i,
        /^окт/i,
        /^ноя/i,
        /^дек/i,
    ];

    // http://new.gramota.ru/spravka/rules/139-prop : § 103
    // Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
    var ru = moment.defineLocale('ru', {
        months: {
            format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split(
                '_'
            ),
            standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split(
                '_'
            ),
        },
        monthsShort: {
            // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку ?
            format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split(
                '_'
            ),
            standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split(
                '_'
            ),
        },
        weekdays: {
            standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split(
                '_'
            ),
            format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split(
                '_'
            ),
            isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/,
        },
        weekdaysShort: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,

        // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
        monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

        // копия предыдущего
        monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

        // полные названия с падежами
        monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

        // Выражение, которое соотвествует только сокращённым формам
        monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY г.',
            LLL: 'D MMMM YYYY г., H:mm',
            LLLL: 'dddd, D MMMM YYYY г., H:mm',
        },
        calendar: {
            sameDay: '[Сегодня, в] LT',
            nextDay: '[Завтра, в] LT',
            lastDay: '[Вчера, в] LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[В следующее] dddd, [в] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[В следующий] dddd, [в] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[В следующую] dddd, [в] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[Во] dddd, [в] LT';
                    } else {
                        return '[В] dddd, [в] LT';
                    }
                }
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[В прошлое] dddd, [в] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[В прошлый] dddd, [в] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[В прошлую] dddd, [в] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[Во] dddd, [в] LT';
                    } else {
                        return '[В] dddd, [в] LT';
                    }
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'через %s',
            past: '%s назад',
            s: 'несколько секунд',
            ss: relativeTimeWithPlural,
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: 'час',
            hh: relativeTimeWithPlural,
            d: 'день',
            dd: relativeTimeWithPlural,
            M: 'месяц',
            MM: relativeTimeWithPlural,
            y: 'год',
            yy: relativeTimeWithPlural,
        },
        meridiemParse: /ночи|утра|дня|вечера/i,
        isPM: function (input) {
            return /^(дня|вечера)$/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночи';
            } else if (hour < 12) {
                return 'утра';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечера';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                    return number + '-й';
                case 'D':
                    return number + '-го';
                case 'w':
                case 'W':
                    return number + '-я';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return ru;

})));


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sindhi [sd]
//! author : Narain Sagar : https://github.com/narainsagar

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = [
            'جنوري',
            'فيبروري',
            'مارچ',
            'اپريل',
            'مئي',
            'جون',
            'جولاءِ',
            'آگسٽ',
            'سيپٽمبر',
            'آڪٽوبر',
            'نومبر',
            'ڊسمبر',
        ],
        days = ['آچر', 'سومر', 'اڱارو', 'اربع', 'خميس', 'جمع', 'ڇنڇر'];

    var sd = moment.defineLocale('sd', {
        months: months,
        monthsShort: months,
        weekdays: days,
        weekdaysShort: days,
        weekdaysMin: days,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd، D MMMM YYYY HH:mm',
        },
        meridiemParse: /صبح|شام/,
        isPM: function (input) {
            return 'شام' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'صبح';
            }
            return 'شام';
        },
        calendar: {
            sameDay: '[اڄ] LT',
            nextDay: '[سڀاڻي] LT',
            nextWeek: 'dddd [اڳين هفتي تي] LT',
            lastDay: '[ڪالهه] LT',
            lastWeek: '[گزريل هفتي] dddd [تي] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s پوء',
            past: '%s اڳ',
            s: 'چند سيڪنڊ',
            ss: '%d سيڪنڊ',
            m: 'هڪ منٽ',
            mm: '%d منٽ',
            h: 'هڪ ڪلاڪ',
            hh: '%d ڪلاڪ',
            d: 'هڪ ڏينهن',
            dd: '%d ڏينهن',
            M: 'هڪ مهينو',
            MM: '%d مهينا',
            y: 'هڪ سال',
            yy: '%d سال',
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return sd;

})));


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Bård Rolstad Henriksen : https://github.com/karamell

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var se = moment.defineLocale('se', {
        months: 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split(
            '_'
        ),
        monthsShort: 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split(
            '_'
        ),
        weekdays: 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split(
            '_'
        ),
        weekdaysShort: 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
        weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'MMMM D. [b.] YYYY',
            LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
            LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm',
        },
        calendar: {
            sameDay: '[otne ti] LT',
            nextDay: '[ihttin ti] LT',
            nextWeek: 'dddd [ti] LT',
            lastDay: '[ikte ti] LT',
            lastWeek: '[ovddit] dddd [ti] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s geažes',
            past: 'maŋit %s',
            s: 'moadde sekunddat',
            ss: '%d sekunddat',
            m: 'okta minuhta',
            mm: '%d minuhtat',
            h: 'okta diimmu',
            hh: '%d diimmut',
            d: 'okta beaivi',
            dd: '%d beaivvit',
            M: 'okta mánnu',
            MM: '%d mánut',
            y: 'okta jahki',
            yy: '%d jagit',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return se;

})));


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    /*jshint -W100*/
    var si = moment.defineLocale('si', {
        months: 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split(
            '_'
        ),
        monthsShort: 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split(
            '_'
        ),
        weekdays: 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split(
            '_'
        ),
        weekdaysShort: 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
        weekdaysMin: 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'a h:mm',
            LTS: 'a h:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY MMMM D',
            LLL: 'YYYY MMMM D, a h:mm',
            LLLL: 'YYYY MMMM D [වැනි] dddd, a h:mm:ss',
        },
        calendar: {
            sameDay: '[අද] LT[ට]',
            nextDay: '[හෙට] LT[ට]',
            nextWeek: 'dddd LT[ට]',
            lastDay: '[ඊයේ] LT[ට]',
            lastWeek: '[පසුගිය] dddd LT[ට]',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%sකින්',
            past: '%sකට පෙර',
            s: 'තත්පර කිහිපය',
            ss: 'තත්පර %d',
            m: 'මිනිත්තුව',
            mm: 'මිනිත්තු %d',
            h: 'පැය',
            hh: 'පැය %d',
            d: 'දිනය',
            dd: 'දින %d',
            M: 'මාසය',
            MM: 'මාස %d',
            y: 'වසර',
            yy: 'වසර %d',
        },
        dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
        ordinal: function (number) {
            return number + ' වැනි';
        },
        meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
        isPM: function (input) {
            return input === 'ප.ව.' || input === 'පස් වරු';
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'ප.ව.' : 'පස් වරු';
            } else {
                return isLower ? 'පෙ.ව.' : 'පෙර වරු';
            }
        },
    });

    return si;

})));


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split(
            '_'
        ),
        monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
    function plural(n) {
        return n > 1 && n < 5;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's': // a few seconds / in a few seconds / a few seconds ago
                return withoutSuffix || isFuture ? 'pár sekúnd' : 'pár sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'sekúnd');
                } else {
                    return result + 'sekundami';
                }
            case 'm': // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minúta' : isFuture ? 'minútu' : 'minútou';
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minúty' : 'minút');
                } else {
                    return result + 'minútami';
                }
            case 'h': // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodín');
                } else {
                    return result + 'hodinami';
                }
            case 'd': // a day / in a day / a day ago
                return withoutSuffix || isFuture ? 'deň' : 'dňom';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dni' : 'dní');
                } else {
                    return result + 'dňami';
                }
            case 'M': // a month / in a month / a month ago
                return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'mesiace' : 'mesiacov');
                } else {
                    return result + 'mesiacmi';
                }
            case 'y': // a year / in a year / a year ago
                return withoutSuffix || isFuture ? 'rok' : 'rokom';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'rokov');
                } else {
                    return result + 'rokmi';
                }
        }
    }

    var sk = moment.defineLocale('sk', {
        months: months,
        monthsShort: monthsShort,
        weekdays: 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
        weekdaysShort: 'ne_po_ut_st_št_pi_so'.split('_'),
        weekdaysMin: 'ne_po_ut_st_št_pi_so'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v nedeľu o] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [o] LT';
                    case 3:
                        return '[v stredu o] LT';
                    case 4:
                        return '[vo štvrtok o] LT';
                    case 5:
                        return '[v piatok o] LT';
                    case 6:
                        return '[v sobotu o] LT';
                }
            },
            lastDay: '[včera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulú nedeľu o] LT';
                    case 1:
                    case 2:
                        return '[minulý] dddd [o] LT';
                    case 3:
                        return '[minulú stredu o] LT';
                    case 4:
                    case 5:
                        return '[minulý] dddd [o] LT';
                    case 6:
                        return '[minulú sobotu o] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'pred %s',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return sk;

})));


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovšek : https://github.com/sedovsek

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture
                    ? 'nekaj sekund'
                    : 'nekaj sekundami';
            case 'ss':
                if (number === 1) {
                    result += withoutSuffix ? 'sekundo' : 'sekundi';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
                } else {
                    result += 'sekund';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'ena minuta' : 'eno minuto';
            case 'mm':
                if (number === 1) {
                    result += withoutSuffix ? 'minuta' : 'minuto';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';
                } else {
                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'ena ura' : 'eno uro';
            case 'hh':
                if (number === 1) {
                    result += withoutSuffix ? 'ura' : 'uro';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'uri' : 'urama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'ure' : 'urami';
                } else {
                    result += withoutSuffix || isFuture ? 'ur' : 'urami';
                }
                return result;
            case 'd':
                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
            case 'dd':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
                } else {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
                }
                return result;
            case 'M':
                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
            case 'MM':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
                } else {
                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
                }
                return result;
            case 'y':
                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
            case 'yy':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'leto' : 'letom';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'leta' : 'leti';
                } else {
                    result += withoutSuffix || isFuture ? 'let' : 'leti';
                }
                return result;
        }
    }

    var sl = moment.defineLocale('sl', {
        months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
        weekdaysShort: 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
        weekdaysMin: 'ne_po_to_sr_če_pe_so'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[danes ob] LT',
            nextDay: '[jutri ob] LT',

            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v] [nedeljo] [ob] LT';
                    case 3:
                        return '[v] [sredo] [ob] LT';
                    case 6:
                        return '[v] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[v] dddd [ob] LT';
                }
            },
            lastDay: '[včeraj ob] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[prejšnjo] [nedeljo] [ob] LT';
                    case 3:
                        return '[prejšnjo] [sredo] [ob] LT';
                    case 6:
                        return '[prejšnjo] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prejšnji] dddd [ob] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'čez %s',
            past: 'pred %s',
            s: processRelativeTime,
            ss: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return sl;

})));


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakërim Ismani : https://github.com/flakerimi
//! author : Menelion Elensúle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var sq = moment.defineLocale('sq', {
        months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split(
            '_'
        ),
        monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
        weekdays: 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split(
            '_'
        ),
        weekdaysShort: 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
        weekdaysMin: 'D_H_Ma_Më_E_P_Sh'.split('_'),
        weekdaysParseExact: true,
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem: function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Sot në] LT',
            nextDay: '[Nesër në] LT',
            nextWeek: 'dddd [në] LT',
            lastDay: '[Dje në] LT',
            lastWeek: 'dddd [e kaluar në] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'në %s',
            past: '%s më parë',
            s: 'disa sekonda',
            ss: '%d sekonda',
            m: 'një minutë',
            mm: '%d minuta',
            h: 'një orë',
            hh: '%d orë',
            d: 'një ditë',
            dd: '%d ditë',
            M: 'një muaj',
            MM: '%d muaj',
            y: 'një vit',
            yy: '%d vite',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return sq;

})));


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var translator = {
        words: {
            //Different grammatical cases
            ss: ['sekunda', 'sekunde', 'sekundi'],
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina'],
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1
                ? wordKey[0]
                : number >= 2 && number <= 4
                ? wordKey[1]
                : wordKey[2];
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return (
                    number +
                    ' ' +
                    translator.correctGrammaticalCase(number, wordKey)
                );
            }
        },
    };

    var sr = moment.defineLocale('sr', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split(
            '_'
        ),
        weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedelju] [u] LT';
                    case 3:
                        return '[u] [sredu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[juče u] LT',
            lastWeek: function () {
                var lastWeekDays = [
                    '[prošle] [nedelje] [u] LT',
                    '[prošlog] [ponedeljka] [u] LT',
                    '[prošlog] [utorka] [u] LT',
                    '[prošle] [srede] [u] LT',
                    '[prošlog] [četvrtka] [u] LT',
                    '[prošlog] [petka] [u] LT',
                    '[prošle] [subote] [u] LT',
                ];
                return lastWeekDays[this.day()];
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'pre %s',
            s: 'nekoliko sekundi',
            ss: translator.translate,
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: 'dan',
            dd: translator.translate,
            M: 'mesec',
            MM: translator.translate,
            y: 'godinu',
            yy: translator.translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return sr;

})));


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var translator = {
        words: {
            //Different grammatical cases
            ss: ['секунда', 'секунде', 'секунди'],
            m: ['један минут', 'једне минуте'],
            mm: ['минут', 'минуте', 'минута'],
            h: ['један сат', 'једног сата'],
            hh: ['сат', 'сата', 'сати'],
            dd: ['дан', 'дана', 'дана'],
            MM: ['месец', 'месеца', 'месеци'],
            yy: ['година', 'године', 'година'],
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1
                ? wordKey[0]
                : number >= 2 && number <= 4
                ? wordKey[1]
                : wordKey[2];
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return (
                    number +
                    ' ' +
                    translator.correctGrammaticalCase(number, wordKey)
                );
            }
        },
    };

    var srCyrl = moment.defineLocale('sr-cyrl', {
        months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split(
            '_'
        ),
        monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
        weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
        weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[данас у] LT',
            nextDay: '[сутра у] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[у] [недељу] [у] LT';
                    case 3:
                        return '[у] [среду] [у] LT';
                    case 6:
                        return '[у] [суботу] [у] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[у] dddd [у] LT';
                }
            },
            lastDay: '[јуче у] LT',
            lastWeek: function () {
                var lastWeekDays = [
                    '[прошле] [недеље] [у] LT',
                    '[прошлог] [понедељка] [у] LT',
                    '[прошлог] [уторка] [у] LT',
                    '[прошле] [среде] [у] LT',
                    '[прошлог] [четвртка] [у] LT',
                    '[прошлог] [петка] [у] LT',
                    '[прошле] [суботе] [у] LT',
                ];
                return lastWeekDays[this.day()];
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'за %s',
            past: 'пре %s',
            s: 'неколико секунди',
            ss: translator.translate,
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: 'дан',
            dd: translator.translate,
            M: 'месец',
            MM: translator.translate,
            y: 'годину',
            yy: translator.translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return srCyrl;

})));


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ss = moment.defineLocale('ss', {
        months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split(
            '_'
        ),
        monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split(
            '_'
        ),
        weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Namuhla nga] LT',
            nextDay: '[Kusasa nga] LT',
            nextWeek: 'dddd [nga] LT',
            lastDay: '[Itolo nga] LT',
            lastWeek: 'dddd [leliphelile] [nga] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'nga %s',
            past: 'wenteka nga %s',
            s: 'emizuzwana lomcane',
            ss: '%d mzuzwana',
            m: 'umzuzu',
            mm: '%d emizuzu',
            h: 'lihora',
            hh: '%d emahora',
            d: 'lilanga',
            dd: '%d emalanga',
            M: 'inyanga',
            MM: '%d tinyanga',
            y: 'umnyaka',
            yy: '%d iminyaka',
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem: function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'ekuseni';
            } else if (hours < 15) {
                return 'emini';
            } else if (hours < 19) {
                return 'entsambama';
            } else {
                return 'ebusuku';
            }
        },
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ekuseni') {
                return hour;
            } else if (meridiem === 'emini') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                if (hour === 0) {
                    return 0;
                }
                return hour + 12;
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return ss;

})));


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var sv = moment.defineLocale('sv', {
        months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
        weekdaysShort: 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
        weekdaysMin: 'sö_må_ti_on_to_fr_lö'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [kl.] HH:mm',
            LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
            lll: 'D MMM YYYY HH:mm',
            llll: 'ddd D MMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igår] LT',
            nextWeek: '[På] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'om %s',
            past: 'för %s sedan',
            s: 'några sekunder',
            ss: '%d sekunder',
            m: 'en minut',
            mm: '%d minuter',
            h: 'en timme',
            hh: '%d timmar',
            d: 'en dag',
            dd: '%d dagar',
            M: 'en månad',
            MM: '%d månader',
            y: 'ett år',
            yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? ':e'
                        : b === 1
                        ? ':a'
                        : b === 2
                        ? ':a'
                        : b === 3
                        ? ':e'
                        : ':e';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return sv;

})));


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var sw = moment.defineLocale('sw', {
        months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split(
            '_'
        ),
        weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[leo saa] LT',
            nextDay: '[kesho saa] LT',
            nextWeek: '[wiki ijayo] dddd [saat] LT',
            lastDay: '[jana] LT',
            lastWeek: '[wiki iliyopita] dddd [saat] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s baadaye',
            past: 'tokea %s',
            s: 'hivi punde',
            ss: 'sekunde %d',
            m: 'dakika moja',
            mm: 'dakika %d',
            h: 'saa limoja',
            hh: 'masaa %d',
            d: 'siku moja',
            dd: 'masiku %d',
            M: 'mwezi mmoja',
            MM: 'miezi %d',
            y: 'mwaka mmoja',
            yy: 'miaka %d',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return sw;

})));


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            '1': '௧',
            '2': '௨',
            '3': '௩',
            '4': '௪',
            '5': '௫',
            '6': '௬',
            '7': '௭',
            '8': '௮',
            '9': '௯',
            '0': '௦',
        },
        numberMap = {
            '௧': '1',
            '௨': '2',
            '௩': '3',
            '௪': '4',
            '௫': '5',
            '௬': '6',
            '௭': '7',
            '௮': '8',
            '௯': '9',
            '௦': '0',
        };

    var ta = moment.defineLocale('ta', {
        months: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split(
            '_'
        ),
        monthsShort: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split(
            '_'
        ),
        weekdays: 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split(
            '_'
        ),
        weekdaysShort: 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split(
            '_'
        ),
        weekdaysMin: 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, HH:mm',
            LLLL: 'dddd, D MMMM YYYY, HH:mm',
        },
        calendar: {
            sameDay: '[இன்று] LT',
            nextDay: '[நாளை] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[நேற்று] LT',
            lastWeek: '[கடந்த வாரம்] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s இல்',
            past: '%s முன்',
            s: 'ஒரு சில விநாடிகள்',
            ss: '%d விநாடிகள்',
            m: 'ஒரு நிமிடம்',
            mm: '%d நிமிடங்கள்',
            h: 'ஒரு மணி நேரம்',
            hh: '%d மணி நேரம்',
            d: 'ஒரு நாள்',
            dd: '%d நாட்கள்',
            M: 'ஒரு மாதம்',
            MM: '%d மாதங்கள்',
            y: 'ஒரு வருடம்',
            yy: '%d ஆண்டுகள்',
        },
        dayOfMonthOrdinalParse: /\d{1,2}வது/,
        ordinal: function (number) {
            return number + 'வது';
        },
        preparse: function (string) {
            return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
        meridiem: function (hour, minute, isLower) {
            if (hour < 2) {
                return ' யாமம்';
            } else if (hour < 6) {
                return ' வைகறை'; // வைகறை
            } else if (hour < 10) {
                return ' காலை'; // காலை
            } else if (hour < 14) {
                return ' நண்பகல்'; // நண்பகல்
            } else if (hour < 18) {
                return ' எற்பாடு'; // எற்பாடு
            } else if (hour < 22) {
                return ' மாலை'; // மாலை
            } else {
                return ' யாமம்';
            }
        },
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'யாமம்') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
                return hour;
            } else if (meridiem === 'நண்பகல்') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return ta;

})));


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var te = moment.defineLocale('te', {
        months: 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జులై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split(
            '_'
        ),
        monthsShort: 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జులై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split(
            '_'
        ),
        weekdaysShort: 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
        weekdaysMin: 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm',
            LLLL: 'dddd, D MMMM YYYY, A h:mm',
        },
        calendar: {
            sameDay: '[నేడు] LT',
            nextDay: '[రేపు] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[నిన్న] LT',
            lastWeek: '[గత] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s లో',
            past: '%s క్రితం',
            s: 'కొన్ని క్షణాలు',
            ss: '%d సెకన్లు',
            m: 'ఒక నిమిషం',
            mm: '%d నిమిషాలు',
            h: 'ఒక గంట',
            hh: '%d గంటలు',
            d: 'ఒక రోజు',
            dd: '%d రోజులు',
            M: 'ఒక నెల',
            MM: '%d నెలలు',
            y: 'ఒక సంవత్సరం',
            yy: '%d సంవత్సరాలు',
        },
        dayOfMonthOrdinalParse: /\d{1,2}వ/,
        ordinal: '%dవ',
        meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'రాత్రి') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ఉదయం') {
                return hour;
            } else if (meridiem === 'మధ్యాహ్నం') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'సాయంత్రం') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'రాత్రి';
            } else if (hour < 10) {
                return 'ఉదయం';
            } else if (hour < 17) {
                return 'మధ్యాహ్నం';
            } else if (hour < 20) {
                return 'సాయంత్రం';
            } else {
                return 'రాత్రి';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return te;

})));


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo
//! author : Sonia Simoes : https://github.com/soniasimoes

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var tet = moment.defineLocale('tet', {
        months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split(
            '_'
        ),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
        weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
        weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Ohin iha] LT',
            nextDay: '[Aban iha] LT',
            nextWeek: 'dddd [iha] LT',
            lastDay: '[Horiseik iha] LT',
            lastWeek: 'dddd [semana kotuk] [iha] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'iha %s',
            past: '%s liuba',
            s: 'segundu balun',
            ss: 'segundu %d',
            m: 'minutu ida',
            mm: 'minutu %d',
            h: 'oras ida',
            hh: 'oras %d',
            d: 'loron ida',
            dd: 'loron %d',
            M: 'fulan ida',
            MM: 'fulan %d',
            y: 'tinan ida',
            yy: 'tinan %d',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return tet;

})));


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tajik [tg]
//! author : Orif N. Jr. : https://github.com/orif-jr

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        0: '-ум',
        1: '-ум',
        2: '-юм',
        3: '-юм',
        4: '-ум',
        5: '-ум',
        6: '-ум',
        7: '-ум',
        8: '-ум',
        9: '-ум',
        10: '-ум',
        12: '-ум',
        13: '-ум',
        20: '-ум',
        30: '-юм',
        40: '-ум',
        50: '-ум',
        60: '-ум',
        70: '-ум',
        80: '-ум',
        90: '-ум',
        100: '-ум',
    };

    var tg = moment.defineLocale('tg', {
        months: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split(
            '_'
        ),
        monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
        weekdays: 'якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе'.split(
            '_'
        ),
        weekdaysShort: 'яшб_дшб_сшб_чшб_пшб_ҷум_шнб'.split('_'),
        weekdaysMin: 'яш_дш_сш_чш_пш_ҷм_шб'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Имрӯз соати] LT',
            nextDay: '[Пагоҳ соати] LT',
            lastDay: '[Дирӯз соати] LT',
            nextWeek: 'dddd[и] [ҳафтаи оянда соати] LT',
            lastWeek: 'dddd[и] [ҳафтаи гузашта соати] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'баъди %s',
            past: '%s пеш',
            s: 'якчанд сония',
            m: 'як дақиқа',
            mm: '%d дақиқа',
            h: 'як соат',
            hh: '%d соат',
            d: 'як рӯз',
            dd: '%d рӯз',
            M: 'як моҳ',
            MM: '%d моҳ',
            y: 'як сол',
            yy: '%d сол',
        },
        meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'шаб') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'субҳ') {
                return hour;
            } else if (meridiem === 'рӯз') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'бегоҳ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'шаб';
            } else if (hour < 11) {
                return 'субҳ';
            } else if (hour < 16) {
                return 'рӯз';
            } else if (hour < 19) {
                return 'бегоҳ';
            } else {
                return 'шаб';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
        ordinal: function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 1th is the first week of the year.
        },
    });

    return tg;

})));


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var th = moment.defineLocale('th', {
        months: 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split(
            '_'
        ),
        monthsShort: 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
        weekdaysShort: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
        weekdaysMin: 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY เวลา H:mm',
            LLLL: 'วันddddที่ D MMMM YYYY เวลา H:mm',
        },
        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
        isPM: function (input) {
            return input === 'หลังเที่ยง';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ก่อนเที่ยง';
            } else {
                return 'หลังเที่ยง';
            }
        },
        calendar: {
            sameDay: '[วันนี้ เวลา] LT',
            nextDay: '[พรุ่งนี้ เวลา] LT',
            nextWeek: 'dddd[หน้า เวลา] LT',
            lastDay: '[เมื่อวานนี้ เวลา] LT',
            lastWeek: '[วัน]dddd[ที่แล้ว เวลา] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'อีก %s',
            past: '%sที่แล้ว',
            s: 'ไม่กี่วินาที',
            ss: '%d วินาที',
            m: '1 นาที',
            mm: '%d นาที',
            h: '1 ชั่วโมง',
            hh: '%d ชั่วโมง',
            d: '1 วัน',
            dd: '%d วัน',
            M: '1 เดือน',
            MM: '%d เดือน',
            y: '1 ปี',
            yy: '%d ปี',
        },
    });

    return th;

})));


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var tlPh = moment.defineLocale('tl-ph', {
        months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split(
            '_'
        ),
        monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split(
            '_'
        ),
        weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'MM/D/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY HH:mm',
            LLLL: 'dddd, MMMM DD, YYYY HH:mm',
        },
        calendar: {
            sameDay: 'LT [ngayong araw]',
            nextDay: '[Bukas ng] LT',
            nextWeek: 'LT [sa susunod na] dddd',
            lastDay: 'LT [kahapon]',
            lastWeek: 'LT [noong nakaraang] dddd',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'sa loob ng %s',
            past: '%s ang nakalipas',
            s: 'ilang segundo',
            ss: '%d segundo',
            m: 'isang minuto',
            mm: '%d minuto',
            h: 'isang oras',
            hh: '%d oras',
            d: 'isang araw',
            dd: '%d araw',
            M: 'isang buwan',
            MM: '%d buwan',
            y: 'isang taon',
            yy: '%d taon',
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function (number) {
            return number;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return tlPh;

})));


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

    function translateFuture(output) {
        var time = output;
        time =
            output.indexOf('jaj') !== -1
                ? time.slice(0, -3) + 'leS'
                : output.indexOf('jar') !== -1
                ? time.slice(0, -3) + 'waQ'
                : output.indexOf('DIS') !== -1
                ? time.slice(0, -3) + 'nem'
                : time + ' pIq';
        return time;
    }

    function translatePast(output) {
        var time = output;
        time =
            output.indexOf('jaj') !== -1
                ? time.slice(0, -3) + 'Hu’'
                : output.indexOf('jar') !== -1
                ? time.slice(0, -3) + 'wen'
                : output.indexOf('DIS') !== -1
                ? time.slice(0, -3) + 'ben'
                : time + ' ret';
        return time;
    }

    function translate(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
            case 'ss':
                return numberNoun + ' lup';
            case 'mm':
                return numberNoun + ' tup';
            case 'hh':
                return numberNoun + ' rep';
            case 'dd':
                return numberNoun + ' jaj';
            case 'MM':
                return numberNoun + ' jar';
            case 'yy':
                return numberNoun + ' DIS';
        }
    }

    function numberAsNoun(number) {
        var hundred = Math.floor((number % 1000) / 100),
            ten = Math.floor((number % 100) / 10),
            one = number % 10,
            word = '';
        if (hundred > 0) {
            word += numbersNouns[hundred] + 'vatlh';
        }
        if (ten > 0) {
            word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
        }
        if (one > 0) {
            word += (word !== '' ? ' ' : '') + numbersNouns[one];
        }
        return word === '' ? 'pagh' : word;
    }

    var tlh = moment.defineLocale('tlh', {
        months: 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split(
            '_'
        ),
        monthsShort: 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
            '_'
        ),
        weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
            '_'
        ),
        weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
            '_'
        ),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[DaHjaj] LT',
            nextDay: '[wa’leS] LT',
            nextWeek: 'LLL',
            lastDay: '[wa’Hu’] LT',
            lastWeek: 'LLL',
            sameElse: 'L',
        },
        relativeTime: {
            future: translateFuture,
            past: translatePast,
            s: 'puS lup',
            ss: translate,
            m: 'wa’ tup',
            mm: translate,
            h: 'wa’ rep',
            hh: translate,
            d: 'wa’ jaj',
            dd: translate,
            M: 'wa’ jar',
            MM: translate,
            y: 'wa’ DIS',
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return tlh;

})));


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiğit Kaya: https://github.com/BYK

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        1: "'inci",
        5: "'inci",
        8: "'inci",
        70: "'inci",
        80: "'inci",
        2: "'nci",
        7: "'nci",
        20: "'nci",
        50: "'nci",
        3: "'üncü",
        4: "'üncü",
        100: "'üncü",
        6: "'ncı",
        9: "'uncu",
        10: "'uncu",
        30: "'uncu",
        60: "'ıncı",
        90: "'ıncı",
    };

    var tr = moment.defineLocale('tr', {
        months: 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split(
            '_'
        ),
        monthsShort: 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays: 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split(
            '_'
        ),
        weekdaysShort: 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
        weekdaysMin: 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[bugün saat] LT',
            nextDay: '[yarın saat] LT',
            nextWeek: '[gelecek] dddd [saat] LT',
            lastDay: '[dün] LT',
            lastWeek: '[geçen] dddd [saat] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s sonra',
            past: '%s önce',
            s: 'birkaç saniye',
            ss: '%d saniye',
            m: 'bir dakika',
            mm: '%d dakika',
            h: 'bir saat',
            hh: '%d saat',
            d: 'bir gün',
            dd: '%d gün',
            M: 'bir ay',
            MM: '%d ay',
            y: 'bir yıl',
            yy: '%d yıl',
        },
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'Do':
                case 'DD':
                    return number;
                default:
                    if (number === 0) {
                        // special case for zero
                        return number + "'ıncı";
                    }
                    var a = number % 10,
                        b = (number % 100) - a,
                        c = number >= 100 ? 100 : null;
                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return tr;

})));


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iustì Canun

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
    // This is currently too difficult (maybe even impossible) to add.
    var tzl = moment.defineLocale('tzl', {
        months: 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split(
            '_'
        ),
        monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays: 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
        weekdaysShort: 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
        weekdaysMin: 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM [dallas] YYYY',
            LLL: 'D. MMMM [dallas] YYYY HH.mm',
            LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm',
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM: function (input) {
            return "d'o" === input.toLowerCase();
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "d'o" : "D'O";
            } else {
                return isLower ? "d'a" : "D'A";
            }
        },
        calendar: {
            sameDay: '[oxhi à] LT',
            nextDay: '[demà à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[ieiri à] LT',
            lastWeek: '[sür el] dddd [lasteu à] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'osprei %s',
            past: 'ja%s',
            s: processRelativeTime,
            ss: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            s: ['viensas secunds', "'iensas secunds"],
            ss: [number + ' secunds', '' + number + ' secunds'],
            m: ["'n míut", "'iens míut"],
            mm: [number + ' míuts', '' + number + ' míuts'],
            h: ["'n þora", "'iensa þora"],
            hh: [number + ' þoras', '' + number + ' þoras'],
            d: ["'n ziua", "'iensa ziua"],
            dd: [number + ' ziuas', '' + number + ' ziuas'],
            M: ["'n mes", "'iens mes"],
            MM: [number + ' mesen', '' + number + ' mesen'],
            y: ["'n ar", "'iens ar"],
            yy: [number + ' ars', '' + number + ' ars'],
        };
        return isFuture
            ? format[key][0]
            : withoutSuffix
            ? format[key][0]
            : format[key][1];
    }

    return tzl;

})));


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var tzm = moment.defineLocale('tzm', {
        months: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split(
            '_'
        ),
        monthsShort: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split(
            '_'
        ),
        weekdays: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysShort: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysMin: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
            nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
            nextWeek: 'dddd [ⴴ] LT',
            lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
            lastWeek: 'dddd [ⴴ] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
            past: 'ⵢⴰⵏ %s',
            s: 'ⵉⵎⵉⴽ',
            ss: '%d ⵉⵎⵉⴽ',
            m: 'ⵎⵉⵏⵓⴺ',
            mm: '%d ⵎⵉⵏⵓⴺ',
            h: 'ⵙⴰⵄⴰ',
            hh: '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
            d: 'ⴰⵙⵙ',
            dd: '%d oⵙⵙⴰⵏ',
            M: 'ⴰⵢoⵓⵔ',
            MM: '%d ⵉⵢⵢⵉⵔⵏ',
            y: 'ⴰⵙⴳⴰⵙ',
            yy: '%d ⵉⵙⴳⴰⵙⵏ',
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return tzm;

})));


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var tzmLatn = moment.defineLocale('tzm-latn', {
        months: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split(
            '_'
        ),
        monthsShort: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split(
            '_'
        ),
        weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dadkh s yan %s',
            past: 'yan %s',
            s: 'imik',
            ss: '%d imik',
            m: 'minuḍ',
            mm: '%d minuḍ',
            h: 'saɛa',
            hh: '%d tassaɛin',
            d: 'ass',
            dd: '%d ossan',
            M: 'ayowr',
            MM: '%d iyyirn',
            y: 'asgas',
            yy: '%d isgasn',
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return tzmLatn;

})));


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js language configuration
//! locale : Uyghur (China) [ug-cn]
//! author: boyaq : https://github.com/boyaq

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js language configuration

    var ugCn = moment.defineLocale('ug-cn', {
        months: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split(
            '_'
        ),
        monthsShort: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split(
            '_'
        ),
        weekdays: 'يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە'.split(
            '_'
        ),
        weekdaysShort: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
        weekdaysMin: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY-يىلىM-ئاينىڭD-كۈنى',
            LLL: 'YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm',
            LLLL: 'dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm',
        },
        meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                meridiem === 'يېرىم كېچە' ||
                meridiem === 'سەھەر' ||
                meridiem === 'چۈشتىن بۇرۇن'
            ) {
                return hour;
            } else if (meridiem === 'چۈشتىن كېيىن' || meridiem === 'كەچ') {
                return hour + 12;
            } else {
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return 'يېرىم كېچە';
            } else if (hm < 900) {
                return 'سەھەر';
            } else if (hm < 1130) {
                return 'چۈشتىن بۇرۇن';
            } else if (hm < 1230) {
                return 'چۈش';
            } else if (hm < 1800) {
                return 'چۈشتىن كېيىن';
            } else {
                return 'كەچ';
            }
        },
        calendar: {
            sameDay: '[بۈگۈن سائەت] LT',
            nextDay: '[ئەتە سائەت] LT',
            nextWeek: '[كېلەركى] dddd [سائەت] LT',
            lastDay: '[تۆنۈگۈن] LT',
            lastWeek: '[ئالدىنقى] dddd [سائەت] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s كېيىن',
            past: '%s بۇرۇن',
            s: 'نەچچە سېكونت',
            ss: '%d سېكونت',
            m: 'بىر مىنۇت',
            mm: '%d مىنۇت',
            h: 'بىر سائەت',
            hh: '%d سائەت',
            d: 'بىر كۈن',
            dd: '%d كۈن',
            M: 'بىر ئاي',
            MM: '%d ئاي',
            y: 'بىر يىل',
            yy: '%d يىل',
        },

        dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '-كۈنى';
                case 'w':
                case 'W':
                    return number + '-ھەپتە';
                default:
                    return number;
            }
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week: {
            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 1st is the first week of the year.
        },
    });

    return ugCn;

})));


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensúle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11
            ? forms[0]
            : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
            ? forms[1]
            : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            ss: withoutSuffix ? 'секунда_секунди_секунд' : 'секунду_секунди_секунд',
            mm: withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
            hh: withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
            dd: 'день_дні_днів',
            MM: 'місяць_місяці_місяців',
            yy: 'рік_роки_років',
        };
        if (key === 'm') {
            return withoutSuffix ? 'хвилина' : 'хвилину';
        } else if (key === 'h') {
            return withoutSuffix ? 'година' : 'годину';
        } else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
                nominative: 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split(
                    '_'
                ),
                accusative: 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split(
                    '_'
                ),
                genitive: 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split(
                    '_'
                ),
            },
            nounCase;

        if (m === true) {
            return weekdays['nominative']
                .slice(1, 7)
                .concat(weekdays['nominative'].slice(0, 1));
        }
        if (!m) {
            return weekdays['nominative'];
        }

        nounCase = /(\[[ВвУу]\]) ?dddd/.test(format)
            ? 'accusative'
            : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(format)
            ? 'genitive'
            : 'nominative';
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
        };
    }

    var uk = moment.defineLocale('uk', {
        months: {
            format: 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split(
                '_'
            ),
            standalone: 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split(
                '_'
            ),
        },
        monthsShort: 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split(
            '_'
        ),
        weekdays: weekdaysCaseReplace,
        weekdaysShort: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY р.',
            LLL: 'D MMMM YYYY р., HH:mm',
            LLLL: 'dddd, D MMMM YYYY р., HH:mm',
        },
        calendar: {
            sameDay: processHoursFunction('[Сьогодні '),
            nextDay: processHoursFunction('[Завтра '),
            lastDay: processHoursFunction('[Вчора '),
            nextWeek: processHoursFunction('[У] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return processHoursFunction('[Минулої] dddd [').call(this);
                    case 1:
                    case 2:
                    case 4:
                        return processHoursFunction('[Минулого] dddd [').call(this);
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'за %s',
            past: '%s тому',
            s: 'декілька секунд',
            ss: relativeTimeWithPlural,
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: 'годину',
            hh: relativeTimeWithPlural,
            d: 'день',
            dd: relativeTimeWithPlural,
            M: 'місяць',
            MM: relativeTimeWithPlural,
            y: 'рік',
            yy: relativeTimeWithPlural,
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /ночі|ранку|дня|вечора/,
        isPM: function (input) {
            return /^(дня|вечора)$/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночі';
            } else if (hour < 12) {
                return 'ранку';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечора';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return number + '-й';
                case 'D':
                    return number + '-го';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return uk;

})));


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Urdu [ur]
//! author : Sawood Alam : https://github.com/ibnesayeed
//! author : Zack : https://github.com/ZackVision

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = [
            'جنوری',
            'فروری',
            'مارچ',
            'اپریل',
            'مئی',
            'جون',
            'جولائی',
            'اگست',
            'ستمبر',
            'اکتوبر',
            'نومبر',
            'دسمبر',
        ],
        days = ['اتوار', 'پیر', 'منگل', 'بدھ', 'جمعرات', 'جمعہ', 'ہفتہ'];

    var ur = moment.defineLocale('ur', {
        months: months,
        monthsShort: months,
        weekdays: days,
        weekdaysShort: days,
        weekdaysMin: days,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd، D MMMM YYYY HH:mm',
        },
        meridiemParse: /صبح|شام/,
        isPM: function (input) {
            return 'شام' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'صبح';
            }
            return 'شام';
        },
        calendar: {
            sameDay: '[آج بوقت] LT',
            nextDay: '[کل بوقت] LT',
            nextWeek: 'dddd [بوقت] LT',
            lastDay: '[گذشتہ روز بوقت] LT',
            lastWeek: '[گذشتہ] dddd [بوقت] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s بعد',
            past: '%s قبل',
            s: 'چند سیکنڈ',
            ss: '%d سیکنڈ',
            m: 'ایک منٹ',
            mm: '%d منٹ',
            h: 'ایک گھنٹہ',
            hh: '%d گھنٹے',
            d: 'ایک دن',
            dd: '%d دن',
            M: 'ایک ماہ',
            MM: '%d ماہ',
            y: 'ایک سال',
            yy: '%d سال',
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return ur;

})));


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var uz = moment.defineLocale('uz', {
        months: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split(
            '_'
        ),
        monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
        weekdays: 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
        weekdaysShort: 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
        weekdaysMin: 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'D MMMM YYYY, dddd HH:mm',
        },
        calendar: {
            sameDay: '[Бугун соат] LT [да]',
            nextDay: '[Эртага] LT [да]',
            nextWeek: 'dddd [куни соат] LT [да]',
            lastDay: '[Кеча соат] LT [да]',
            lastWeek: '[Утган] dddd [куни соат] LT [да]',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'Якин %s ичида',
            past: 'Бир неча %s олдин',
            s: 'фурсат',
            ss: '%d фурсат',
            m: 'бир дакика',
            mm: '%d дакика',
            h: 'бир соат',
            hh: '%d соат',
            d: 'бир кун',
            dd: '%d кун',
            M: 'бир ой',
            MM: '%d ой',
            y: 'бир йил',
            yy: '%d йил',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return uz;

})));


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek Latin [uz-latn]
//! author : Rasulbek Mirzayev : github.com/Rasulbeeek

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var uzLatn = moment.defineLocale('uz-latn', {
        months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split(
            '_'
        ),
        monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
        weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split(
            '_'
        ),
        weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
        weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'D MMMM YYYY, dddd HH:mm',
        },
        calendar: {
            sameDay: '[Bugun soat] LT [da]',
            nextDay: '[Ertaga] LT [da]',
            nextWeek: 'dddd [kuni soat] LT [da]',
            lastDay: '[Kecha soat] LT [da]',
            lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
            sameElse: 'L',
        },
        relativeTime: {
            future: 'Yaqin %s ichida',
            past: 'Bir necha %s oldin',
            s: 'soniya',
            ss: '%d soniya',
            m: 'bir daqiqa',
            mm: '%d daqiqa',
            h: 'bir soat',
            hh: '%d soat',
            d: 'bir kun',
            dd: '%d kun',
            M: 'bir oy',
            MM: '%d oy',
            y: 'bir yil',
            yy: '%d yil',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return uzLatn;

})));


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk
//! author : Chien Kira : https://github.com/chienkira

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var vi = moment.defineLocale('vi', {
        months: 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split(
            '_'
        ),
        monthsShort: 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split(
            '_'
        ),
        weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact: true,
        meridiemParse: /sa|ch/i,
        isPM: function (input) {
            return /^ch$/i.test(input);
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'sa' : 'SA';
            } else {
                return isLower ? 'ch' : 'CH';
            }
        },
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM [năm] YYYY',
            LLL: 'D MMMM [năm] YYYY HH:mm',
            LLLL: 'dddd, D MMMM [năm] YYYY HH:mm',
            l: 'DD/M/YYYY',
            ll: 'D MMM YYYY',
            lll: 'D MMM YYYY HH:mm',
            llll: 'ddd, D MMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Hôm nay lúc] LT',
            nextDay: '[Ngày mai lúc] LT',
            nextWeek: 'dddd [tuần tới lúc] LT',
            lastDay: '[Hôm qua lúc] LT',
            lastWeek: 'dddd [tuần trước lúc] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s tới',
            past: '%s trước',
            s: 'vài giây',
            ss: '%d giây',
            m: 'một phút',
            mm: '%d phút',
            h: 'một giờ',
            hh: '%d giờ',
            d: 'một ngày',
            dd: '%d ngày',
            M: 'một tháng',
            MM: '%d tháng',
            y: 'một năm',
            yy: '%d năm',
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function (number) {
            return number;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return vi;

})));


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var xPseudo = moment.defineLocale('x-pseudo', {
        months: 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split(
            '_'
        ),
        monthsShort: 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split(
            '_'
        ),
        weekdaysShort: 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
        weekdaysMin: 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[T~ódá~ý át] LT',
            nextDay: '[T~ómó~rró~w át] LT',
            nextWeek: 'dddd [át] LT',
            lastDay: '[Ý~ést~érdá~ý át] LT',
            lastWeek: '[L~ást] dddd [át] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'í~ñ %s',
            past: '%s á~gó',
            s: 'á ~féw ~sécó~ñds',
            ss: '%d s~écóñ~ds',
            m: 'á ~míñ~úté',
            mm: '%d m~íñú~tés',
            h: 'á~ñ hó~úr',
            hh: '%d h~óúrs',
            d: 'á ~dáý',
            dd: '%d d~áýs',
            M: 'á ~móñ~th',
            MM: '%d m~óñt~hs',
            y: 'á ~ýéár',
            yy: '%d ý~éárs',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return xPseudo;

})));


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var yo = moment.defineLocale('yo', {
        months: 'Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀'.split(
            '_'
        ),
        monthsShort: 'Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀'.split('_'),
        weekdays: 'Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta'.split('_'),
        weekdaysShort: 'Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá'.split('_'),
        weekdaysMin: 'Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Ònì ni] LT',
            nextDay: '[Ọ̀la ni] LT',
            nextWeek: "dddd [Ọsẹ̀ tón'bọ] [ni] LT",
            lastDay: '[Àna ni] LT',
            lastWeek: 'dddd [Ọsẹ̀ tólọ́] [ni] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'ní %s',
            past: '%s kọjá',
            s: 'ìsẹjú aayá die',
            ss: 'aayá %d',
            m: 'ìsẹjú kan',
            mm: 'ìsẹjú %d',
            h: 'wákati kan',
            hh: 'wákati %d',
            d: 'ọjọ́ kan',
            dd: 'ọjọ́ %d',
            M: 'osù kan',
            MM: 'osù %d',
            y: 'ọdún kan',
            yy: 'ọdún %d',
        },
        dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/,
        ordinal: 'ọjọ́ %d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return yo;

})));


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var zhCn = moment.defineLocale('zh-cn', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
            '_'
        ),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
            '_'
        ),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY年M月D日',
            LLL: 'YYYY年M月D日Ah点mm分',
            LLLL: 'YYYY年M月D日ddddAh点mm分',
            l: 'YYYY/M/D',
            ll: 'YYYY年M月D日',
            lll: 'YYYY年M月D日 HH:mm',
            llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            } else {
                // '中午'
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar: {
            sameDay: '[今天]LT',
            nextDay: '[明天]LT',
            nextWeek: '[下]ddddLT',
            lastDay: '[昨天]LT',
            lastWeek: '[上]ddddLT',
            sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                case 'M':
                    return number + '月';
                case 'w':
                case 'W':
                    return number + '周';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s后',
            past: '%s前',
            s: '几秒',
            ss: '%d 秒',
            m: '1 分钟',
            mm: '%d 分钟',
            h: '1 小时',
            hh: '%d 小时',
            d: '1 天',
            dd: '%d 天',
            M: '1 个月',
            MM: '%d 个月',
            y: '1 年',
            yy: '%d 年',
        },
        week: {
            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return zhCn;

})));


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd
//! author : Anthony : https://github.com/anthonylau

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var zhHk = moment.defineLocale('zh-hk', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
            '_'
        ),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
            '_'
        ),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY年M月D日',
            LLL: 'YYYY年M月D日 HH:mm',
            LLLL: 'YYYY年M月D日dddd HH:mm',
            l: 'YYYY/M/D',
            ll: 'YYYY年M月D日',
            lll: 'YYYY年M月D日 HH:mm',
            llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1200) {
                return '上午';
            } else if (hm === 1200) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar: {
            sameDay: '[今天]LT',
            nextDay: '[明天]LT',
            nextWeek: '[下]ddddLT',
            lastDay: '[昨天]LT',
            lastWeek: '[上]ddddLT',
            sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                case 'M':
                    return number + '月';
                case 'w':
                case 'W':
                    return number + '週';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s後',
            past: '%s前',
            s: '幾秒',
            ss: '%d 秒',
            m: '1 分鐘',
            mm: '%d 分鐘',
            h: '1 小時',
            hh: '%d 小時',
            d: '1 天',
            dd: '%d 天',
            M: '1 個月',
            MM: '%d 個月',
            y: '1 年',
            yy: '%d 年',
        },
    });

    return zhHk;

})));


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Macau) [zh-mo]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Tan Yuanhong : https://github.com/le0tan

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var zhMo = moment.defineLocale('zh-mo', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
            '_'
        ),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
            '_'
        ),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'YYYY年M月D日',
            LLL: 'YYYY年M月D日 HH:mm',
            LLLL: 'YYYY年M月D日dddd HH:mm',
            l: 'D/M/YYYY',
            ll: 'YYYY年M月D日',
            lll: 'YYYY年M月D日 HH:mm',
            llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar: {
            sameDay: '[今天] LT',
            nextDay: '[明天] LT',
            nextWeek: '[下]dddd LT',
            lastDay: '[昨天] LT',
            lastWeek: '[上]dddd LT',
            sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                case 'M':
                    return number + '月';
                case 'w':
                case 'W':
                    return number + '週';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s內',
            past: '%s前',
            s: '幾秒',
            ss: '%d 秒',
            m: '1 分鐘',
            mm: '%d 分鐘',
            h: '1 小時',
            hh: '%d 小時',
            d: '1 天',
            dd: '%d 天',
            M: '1 個月',
            MM: '%d 個月',
            y: '1 年',
            yy: '%d 年',
        },
    });

    return zhMo;

})));


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris

;(function (global, factory) {
    true ? factory(__webpack_require__(0)) :
   undefined
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var zhTw = moment.defineLocale('zh-tw', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
            '_'
        ),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
            '_'
        ),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY年M月D日',
            LLL: 'YYYY年M月D日 HH:mm',
            LLLL: 'YYYY年M月D日dddd HH:mm',
            l: 'YYYY/M/D',
            ll: 'YYYY年M月D日',
            lll: 'YYYY年M月D日 HH:mm',
            llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar: {
            sameDay: '[今天] LT',
            nextDay: '[明天] LT',
            nextWeek: '[下]dddd LT',
            lastDay: '[昨天] LT',
            lastWeek: '[上]dddd LT',
            sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                case 'M':
                    return number + '月';
                case 'w':
                case 'W':
                    return number + '週';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s後',
            past: '%s前',
            s: '幾秒',
            ss: '%d 秒',
            m: '1 分鐘',
            mm: '%d 分鐘',
            h: '1 小時',
            hh: '%d 小時',
            d: '1 天',
            dd: '%d 天',
            M: '1 個月',
            MM: '%d 個月',
            y: '1 年',
            yy: '%d 年',
        },
    });

    return zhTw;

})));


/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 1,
	"./af.js": 1,
	"./ar": 2,
	"./ar-dz": 3,
	"./ar-dz.js": 3,
	"./ar-kw": 4,
	"./ar-kw.js": 4,
	"./ar-ly": 5,
	"./ar-ly.js": 5,
	"./ar-ma": 6,
	"./ar-ma.js": 6,
	"./ar-sa": 7,
	"./ar-sa.js": 7,
	"./ar-tn": 8,
	"./ar-tn.js": 8,
	"./ar.js": 2,
	"./az": 9,
	"./az.js": 9,
	"./be": 10,
	"./be.js": 10,
	"./bg": 11,
	"./bg.js": 11,
	"./bm": 12,
	"./bm.js": 12,
	"./bn": 13,
	"./bn.js": 13,
	"./bo": 14,
	"./bo.js": 14,
	"./br": 15,
	"./br.js": 15,
	"./bs": 16,
	"./bs.js": 16,
	"./ca": 17,
	"./ca.js": 17,
	"./cs": 18,
	"./cs.js": 18,
	"./cv": 19,
	"./cv.js": 19,
	"./cy": 20,
	"./cy.js": 20,
	"./da": 21,
	"./da.js": 21,
	"./de": 22,
	"./de-at": 23,
	"./de-at.js": 23,
	"./de-ch": 24,
	"./de-ch.js": 24,
	"./de.js": 22,
	"./dv": 25,
	"./dv.js": 25,
	"./el": 26,
	"./el.js": 26,
	"./en-au": 27,
	"./en-au.js": 27,
	"./en-ca": 28,
	"./en-ca.js": 28,
	"./en-gb": 29,
	"./en-gb.js": 29,
	"./en-ie": 30,
	"./en-ie.js": 30,
	"./en-il": 31,
	"./en-il.js": 31,
	"./en-in": 32,
	"./en-in.js": 32,
	"./en-nz": 33,
	"./en-nz.js": 33,
	"./en-sg": 34,
	"./en-sg.js": 34,
	"./eo": 35,
	"./eo.js": 35,
	"./es": 36,
	"./es-do": 37,
	"./es-do.js": 37,
	"./es-us": 38,
	"./es-us.js": 38,
	"./es.js": 36,
	"./et": 39,
	"./et.js": 39,
	"./eu": 40,
	"./eu.js": 40,
	"./fa": 41,
	"./fa.js": 41,
	"./fi": 42,
	"./fi.js": 42,
	"./fil": 43,
	"./fil.js": 43,
	"./fo": 44,
	"./fo.js": 44,
	"./fr": 45,
	"./fr-ca": 46,
	"./fr-ca.js": 46,
	"./fr-ch": 47,
	"./fr-ch.js": 47,
	"./fr.js": 45,
	"./fy": 48,
	"./fy.js": 48,
	"./ga": 49,
	"./ga.js": 49,
	"./gd": 50,
	"./gd.js": 50,
	"./gl": 51,
	"./gl.js": 51,
	"./gom-deva": 52,
	"./gom-deva.js": 52,
	"./gom-latn": 53,
	"./gom-latn.js": 53,
	"./gu": 54,
	"./gu.js": 54,
	"./he": 55,
	"./he.js": 55,
	"./hi": 56,
	"./hi.js": 56,
	"./hr": 57,
	"./hr.js": 57,
	"./hu": 58,
	"./hu.js": 58,
	"./hy-am": 59,
	"./hy-am.js": 59,
	"./id": 60,
	"./id.js": 60,
	"./is": 61,
	"./is.js": 61,
	"./it": 62,
	"./it-ch": 63,
	"./it-ch.js": 63,
	"./it.js": 62,
	"./ja": 64,
	"./ja.js": 64,
	"./jv": 65,
	"./jv.js": 65,
	"./ka": 66,
	"./ka.js": 66,
	"./kk": 67,
	"./kk.js": 67,
	"./km": 68,
	"./km.js": 68,
	"./kn": 69,
	"./kn.js": 69,
	"./ko": 70,
	"./ko.js": 70,
	"./ku": 71,
	"./ku.js": 71,
	"./ky": 72,
	"./ky.js": 72,
	"./lb": 73,
	"./lb.js": 73,
	"./lo": 74,
	"./lo.js": 74,
	"./lt": 75,
	"./lt.js": 75,
	"./lv": 76,
	"./lv.js": 76,
	"./me": 77,
	"./me.js": 77,
	"./mi": 78,
	"./mi.js": 78,
	"./mk": 79,
	"./mk.js": 79,
	"./ml": 80,
	"./ml.js": 80,
	"./mn": 81,
	"./mn.js": 81,
	"./mr": 82,
	"./mr.js": 82,
	"./ms": 83,
	"./ms-my": 84,
	"./ms-my.js": 84,
	"./ms.js": 83,
	"./mt": 85,
	"./mt.js": 85,
	"./my": 86,
	"./my.js": 86,
	"./nb": 87,
	"./nb.js": 87,
	"./ne": 88,
	"./ne.js": 88,
	"./nl": 89,
	"./nl-be": 90,
	"./nl-be.js": 90,
	"./nl.js": 89,
	"./nn": 91,
	"./nn.js": 91,
	"./oc-lnc": 92,
	"./oc-lnc.js": 92,
	"./pa-in": 93,
	"./pa-in.js": 93,
	"./pl": 94,
	"./pl.js": 94,
	"./pt": 95,
	"./pt-br": 96,
	"./pt-br.js": 96,
	"./pt.js": 95,
	"./ro": 97,
	"./ro.js": 97,
	"./ru": 98,
	"./ru.js": 98,
	"./sd": 99,
	"./sd.js": 99,
	"./se": 100,
	"./se.js": 100,
	"./si": 101,
	"./si.js": 101,
	"./sk": 102,
	"./sk.js": 102,
	"./sl": 103,
	"./sl.js": 103,
	"./sq": 104,
	"./sq.js": 104,
	"./sr": 105,
	"./sr-cyrl": 106,
	"./sr-cyrl.js": 106,
	"./sr.js": 105,
	"./ss": 107,
	"./ss.js": 107,
	"./sv": 108,
	"./sv.js": 108,
	"./sw": 109,
	"./sw.js": 109,
	"./ta": 110,
	"./ta.js": 110,
	"./te": 111,
	"./te.js": 111,
	"./tet": 112,
	"./tet.js": 112,
	"./tg": 113,
	"./tg.js": 113,
	"./th": 114,
	"./th.js": 114,
	"./tl-ph": 115,
	"./tl-ph.js": 115,
	"./tlh": 116,
	"./tlh.js": 116,
	"./tr": 117,
	"./tr.js": 117,
	"./tzl": 118,
	"./tzl.js": 118,
	"./tzm": 119,
	"./tzm-latn": 120,
	"./tzm-latn.js": 120,
	"./tzm.js": 119,
	"./ug-cn": 121,
	"./ug-cn.js": 121,
	"./uk": 122,
	"./uk.js": 122,
	"./ur": 123,
	"./ur.js": 123,
	"./uz": 124,
	"./uz-latn": 125,
	"./uz-latn.js": 125,
	"./uz.js": 124,
	"./vi": 126,
	"./vi.js": 126,
	"./x-pseudo": 127,
	"./x-pseudo.js": 127,
	"./yo": 128,
	"./yo.js": 128,
	"./zh-cn": 129,
	"./zh-cn.js": 129,
	"./zh-hk": 130,
	"./zh-hk.js": 130,
	"./zh-mo": 131,
	"./zh-mo.js": 131,
	"./zh-tw": 132,
	"./zh-tw.js": 132
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 134;

/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/moment/moment.js
var moment = __webpack_require__(0);
var moment_default = /*#__PURE__*/__webpack_require__.n(moment);

// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

const __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

const __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}

// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Percent.js
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Represents a relative value (percent).
 *
 * The Percent object, can be instantiated using two ways:
 *
 * * Via `new Percent(X)`.
 * * Via `am4core.percent(X)`.
 *
 * `Percent` type objects can be used in a number of dual-measuring or
 * positioning properties, like `width`. E.g.:
 *
 * ```TypeScript
 * chart.paddingRight = new Percent(10);
 * // or
 * chart.paddingRight = am4core.percent(10);
 * ```
 * ```JavaScript
 * chart.paddingRight = new Percent(10);
 * // or
 * chart.paddingRight = am4core.percent(10);
 * ```
 * ```JSON
 * {
 *   // ...
 *   "paddingRight": "10%"
 * }
 * ```
 */
var Percent = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param percent  Percent value
     */
    function Percent(percent) {
        this._value = percent;
    }
    Object.defineProperty(Percent.prototype, "value", {
        /**
         * Relative value.
         *
         * E.g. 100% is 1, 50% is 0.5, etc.
         *
         * This is useful to apply transformations to other values. E.g.:
         *
         * ```TypeScript
         * let value = 256;
         * let percent = new am4core.Percent(50);
         * console.log(value * percent.value); // outputs 128
         * ```
         * ```JavaScript
         * var value = 256;
         * var percent = new am4core.Percent(50);
         * console.log(value * percent.value); // outputs 128
         * ```
         *
         * Alternatively, you can use `am4core.percent()` helper function:
         *
         * ```TypeScript
         * let value = 256;
         * let percent = am4core.percent(50);
         * console.log(value * percent.value); // outputs 128
         * ```
         * ```JavaScript
         * var value = 256;
         * var percent = am4core.percent(50);
         * console.log(value * percent.value); // outputs 128
         * ```
         *
         * @readonly
         * @return Relative value
         */
        get: function () {
            return this._value / 100;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Percent.prototype, "percent", {
        /**
         * Value in percent.
         *
         * @return Percent
         */
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    Percent.prototype.toString = function () {
        return "" + this._value + "%";
    };
    return Percent;
}());

/**
 * Converts numeric percent value to a proper [[Percent]] object.
 *
 * ```TypeScript
 * pieSeries.radius = am4core.percent(80);
 * ```
 * ```JavaScript
 * pieSeries.radius = am4core.percent(80);
 * ```
 *
 * @param value  Percent
 * @return Percent object
 */
function Percent_percent(value) {
    return new Percent(value);
}
/**
 * Checks if value is a [[Percent]] object.
 *
 * @ignore Exclude from docs
 * @param value  Input value
 * @return Is percent?
 */
function isPercent(value) {
    return value instanceof Percent;
}
//# sourceMappingURL=Percent.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Type.js
/**
 * A collection of utility functions for various type checks and conversion
 * @todo Review unused functions for removal
 * @hidden
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * ============================================================================
 * TYPE CHECK
 * ============================================================================
 * @hidden
 */
/**
 * Returns `true` if value is not a number (NaN).
 *
 * @param value Input value
 * @return Is NaN?
 * @deprecated Is not used anywhere. JS built-in isNaN is used everywhere. Maybe we don't need this, or if we do, then we should use it everywhere
 */
function Type_isNaN(value) {
    return Number(value) !== value;
}
/**
 * Returns a type of the value.
 *
 * @param value  Input value
 * @return Type of the value
 */
function getType(value) {
    return ({}).toString.call(value);
}
/**
 * Returns a default value if the passed in value is empty.
 *
 * @param value     Input value
 * @param optional  Default value
 * @return Value or default value whichever is available
 * @deprecated Not used anywhere
 */
function getDefault(value, optional) {
    return value || optional;
}
/**
 * Checks if the passed in value is a string.
 *
 * @param value  Value
 * @return Is string?
 * @throws {Error}
 * @deprecated Not used anywhere
 */
function checkString(value) {
    if (typeof value === "string") {
        return true;
    }
    else {
        throw new Error("Expected a string but got " + getType(value));
    }
}
/**
 * Checks if the passed in value is a boolean.
 *
 * @param value  Value
 * @return Is boolean?
 * @throws {Error}
 * @deprecated Not used anywhere
 */
function checkBoolean(value) {
    if (typeof value === "boolean") {
        return true;
    }
    else {
        throw new Error("Expected a boolean but got " + getType(value));
    }
}
/**
 * Checks if the passed in value is a number.
 *
 * @param value  Value
 * @return Is number?
 * @throws {Error}
 */
function checkNumber(value) {
    if (typeof value === "number") {
        if (Type_isNaN(value)) {
            throw new Error("Expected a number but got NaN");
        }
    }
    else {
        throw new Error("Expected a number but got " + getType(value));
    }
    return true;
}
/**
 * Checks if the passed in value is an object.
 *
 * @param value  Value
 * @return Is object?
 * @throws {Error}
 * @todo Is the input type correct?
 * @deprecated Not used anywhere
 */
function checkObject(value) {
    var t = getType(value);
    if (t === "[object Object]") {
        return true;
    }
    else {
        throw new Error("Expected an object but got " + t);
    }
}
/**
 * Checks if the passed in value is an array.
 *
 * @param value  Value
 * @return Is array?
 * @throws {Error}
 * @deprecated Not used anywhere
 */
function checkArray(value) {
    if (Array.isArray(value)) {
        return true;
    }
    else {
        throw new Error("Expected an array but got " + getType(value));
    }
}
/**
 * Checks if the passed in value is a Date object.
 *
 * @param value  Value
 * @return Is Date object?
 * @throws {Error}
 * @deprecated Not used anywhere
 */
function checkDate(value) {
    var t = getType(value);
    if (t === "[object Date]") {
        return true;
    }
    else {
        throw new Error("Expected a date but got " + t);
    }
}
/**
 * ============================================================================
 * TYPE CASTING
 * ============================================================================
 * @hidden
 */
/**
 * Casts string or a number into string.
 *
 * @param value  Input
 * @return String value
 * @deprecated Not used anywhere
 */
function castString(value) {
    if (typeof value === "string") {
        return value;
    }
    else if (typeof value === "number") {
        return "" + value;
    }
    else {
        throw new Error("Expected a string or number but got " + getType(value));
    }
}
/**
 * Casts string or a number into a number.
 *
 * @param value   Input value
 * @return Number  value
 * @throws {Error}
 */
function castNumber(value) {
    if (typeof value === "string") {
        var number = +value;
        if (Type_isNaN(number)) {
            throw new Error("Cannot cast string " + JSON.stringify(value) + " to a number");
        }
        else {
            return number;
        }
    }
    else if (typeof value === "number") {
        if (Type_isNaN(value)) {
            throw new Error("Expected a number but got NaN");
        }
        else {
            return value;
        }
    }
    else {
        var t = getType(value);
        if (t === "[object Date]") {
            return value.getTime();
        }
        else {
            throw new Error("Expected a string, number, or date but got " + t);
        }
    }
}
/**
 * Casts number, string or Date into a Date object.
 *
 * @param value  Input value
 * @return Date object
 * @deprecated Not used anywhere
 * @throws {Error}
 * @hidden
 * @deprecated
 */
/*export function castDate(value: string | number | Date, formatter?: DateFormatter): Date {
    if (typeof value === "string") {
        if (formatter) {
            return formatter.parse(value);
        }
        return new Date(value);

    } else if (typeof value === "number") {
        return new Date(value);

    } else {
        const t = getType(value);

        if (t === "[object Date]") {
            return value;

        } else {
            throw new Error("Expected a string, number, or date but got " + t);
        }
    }
}*/
/**
 * ============================================================================
 * QUICK CONVERSION
 * ============================================================================
 * @hidden
 */
/**
 * Converts any value into `boolean`.
 *
 * @param value  Source value
 * @return `true` or `false`
 */
function toBoolean(value) {
    return value ? true : false;
}
/**
 * Converts any value into a `number`.
 *
 * @param value  Source value
 * @return Number representation of value
 */
function toNumber(value) {
    if (hasValue(value) && !isNumber(value)) {
        var converted = Number(value);
        if (Type_isNaN(converted) && isString(value) && value != "") {
            return toNumber(value.replace(/[^0-9.\-]+/g, ''));
        }
        return converted;
    }
    return value;
}
/**
 * Converts any value into a string (text).
 *
 * @param value  Source value
 * @return String representation of the input
 */
function toText(value) {
    if (hasValue(value) && !isString(value)) {
        if (isNumber(value)) {
            return castString(value);
        }
        else if (isObject(value)) {
            return value.toString();
        }
    }
    return value;
}
/**
 * Converts any value to a number or [[Percent]].
 *
 * If the parameter is a string and contains "%", it will
 * convert it into a [[Percent]].
 *
 * Otherwise, it will convert into a number.
 *
 * @param value  Number or percent
 * @return Percent object
 */
function toNumberOrPercent(value) {
    if (!hasValue(value) || isNumber(value) || isPercent(value)) {
        return value;
    }
    if (isString(value) && value.indexOf("%") != -1) {
        return Percent_percent(toNumber(value));
    }
    return toNumber(value);
}
/**
 * Checks if a variable has a value.
 *
 * @param a  Input value
 * @returns                        Has value?
 */
function hasValue(a) {
    return a != null;
}
/**
 * Returns a value or throws an {Error} exception if the variable has not
 * value.
 *
 * @param a  Input value
 * @returns                        Value
 */
function getValue(a) {
    if (hasValue(a)) {
        return a;
    }
    else {
        throw new Error("Value doesn't exist");
    }
}
/**
 * Returns a value, or returns the default value if it doesn't have a value.
 *
 * @param a  Input value
 * @returns                        Value
 */
function getValueDefault(a, defaultValue) {
    if (hasValue(a)) {
        return a;
    }
    else {
        return defaultValue;
    }
}
/**
 * ============================================================================
 * TYPE CHECK
 * ============================================================================
 * @hidden
 */
/**
 * Checks if parameter is `Date`.
 *
 * @param value  Input value
 * @return Is Date?
 */
function isDate(value) {
    return getType(value) === "[object Date]";
}
/**
 * Checks if parameter is `string`.
 *
 * @param value  Input value
 * @return Is string?
 */
function isString(value) {
    return typeof value === "string";
}
/**
 * Checks if parameter is `number`.
 *
 * @param value  Input value
 * @return Is number?
 */
function isNumber(value) {
    return typeof value === "number" && Number(value) == value;
}
/**
 * Checks if parameter is `object`.
 *
 * @param value  Input value
 * @return Is object?
 */
function isObject(value) {
    return typeof value === "object" && value != null;
}
/**
 * Checks if parameter is `Array`.
 *
 * @param value  Input value
 * @return Is Array?
 */
function isArray(value) {
    return Array.isArray(value);
}
//# sourceMappingURL=Type.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Math.js
/**
 * A collection of Math-related functions
 *
 * @todo Comment trigonometric functions?
 */

/**
 * ============================================================================
 * CONSTANTS
 * ============================================================================
 * @hidden
 */
var PI = Math.PI;
var HALFPI = PI / 2;
var RADIANS = PI / 180;
var DEGREES = 180 / PI;
/**
 * Converts any value and fits it into a specific value range.
 *
 * @param value  Source value
 * @param min    Minimum allowable value
 * @param max    Maximum allowable value
 * @return Number
 */
function toNumberRange(value, min, max) {
    if (hasValue(value)) {
        value = toNumber(value);
        return fitToRange(value, min, max);
    }
    return value;
}
/**
 * Rounds the numeric value to whole number or specific precision of set.
 *
 * @param value      Value
 * @param precision  Precision (number of decimal points)
 * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.
 * @return Rounded value
 */
function Math_round(value, precision, floor) {
    if (!isNumber(precision) || precision <= 0) {
        var rounded = Math.round(value);
        if (floor) {
            if (rounded - value == 0.5) {
                rounded--;
            }
        }
        return rounded;
    }
    else {
        var d = Math.pow(10, precision);
        return Math.round(value * d) / d;
    }
}
/**
 * Ceils the numeric value to whole number or specific precision of set.
 *
 * @param value      Value
 * @param precision  Precision (number of decimal points)
 * @return Rounded value
 */
function ceil(value, precision) {
    if (!isNumber(precision) || precision <= 0) {
        return Math.ceil(value);
    }
    else {
        var d = Math.pow(10, precision);
        return Math.ceil(value * d) / d;
    }
}
/**
 * Stretches `t` so that it will always be between `from` and `to`.
 *
 * @param t     Number from 0 to 1
 * @param from  Lowest possible value
 * @param to    Highest possible value
 * @return Adjusted value
 */
function stretch(t, from, to) {
    return (t * (to - from)) + from;
}
/**
 * Adjust numeric value so it fits to specific value range.
 *
 * @param value     Value
 * @param minValue  Lowest possible value
 * @param maxValue  Highest possible value
 * @return Adjusted value
 */
function fitToRange(value, minValue, maxValue) {
    if (isNumber(minValue)) {
        if (isNumber(maxValue) && maxValue < minValue) {
            var temp = maxValue;
            maxValue = minValue;
            minValue = temp;
        }
        if (value < minValue) {
            value = minValue;
        }
    }
    if (isNumber(maxValue)) {
        if (value > maxValue) {
            value = maxValue;
        }
    }
    return value;
}
/**
 * Returns sine of a number.
 *
 * @param value  Value
 * @return Sine
 */
function Math_sin(value) {
    return Math_round(Math.sin(RADIANS * value), 10);
}
/**
 * Returns tan of a number.
 *
 * @param value  Value
 * @return Sine
 */
function tan(value) {
    return Math_round(Math.tan(RADIANS * value), 10);
}
/**
 * Returns cosine of a number.
 *
 * @param value  Value
 * @return Cosine
 */
function Math_cos(value) {
    return Math_round(Math.cos(RADIANS * value), 10);
}
function Math_max(left, right) {
    if (isNumber(left)) {
        if (isNumber(right)) {
            if (right > left) {
                return right;
            }
            else {
                return left;
            }
        }
        else {
            return left;
        }
    }
    else if (isNumber(right)) {
        return right;
    }
    else {
        return null;
    }
}
function Math_min(left, right) {
    if (isNumber(left)) {
        if (isNumber(right)) {
            if (right < left) {
                return right;
            }
            else {
                return left;
            }
        }
        else {
            return left;
        }
    }
    else if (isNumber(right)) {
        return right;
    }
    else {
        return null;
    }
}
/**
 * Returns the closest value from the array of values to the reference value.
 *
 * @param values  Array of values
 * @param value   Reference value
 * @return Closes value from the array
 */
function Math_closest(values, referenceValue) {
    return values.reduce(function (prev, curr) {
        return (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);
    });
}
/**
 * Checks whether two ranges of values intersect.
 *
 * @param range1  Range 1
 * @param range2  Range 2
 * @return Any intersecting numbers?
 */
function intersect(range1, range2) {
    var start1 = getValue(range1.start);
    var start2 = getValue(range2.start);
    var end1 = getValue(range1.end);
    var end2 = getValue(range2.end);
    return Math.max(start1, start2) <= Math.min(end1, end2);
}
/**
 * Inverts the range of values.
 *
 * @param range  Range
 */
function invertRange(range) {
    var start = getValue(range.start);
    var end = getValue(range.end);
    return { start: 1 - end, end: 1 - start };
}
/**
 * Returns an intersection range between two ranges of values.
 *
 * @param range1  Range 1
 * @param range2  Range 2
 * @return Intersecting value range
 */
function Math_intersection(range1, range2) {
    var start1 = getValue(range1.start);
    var start2 = getValue(range2.start);
    var end1 = getValue(range1.end);
    var end2 = getValue(range2.end);
    var startMax = Math.max(start1, start2);
    var endMin = Math.min(end1, end2);
    if (endMin < startMax) {
        return undefined;
    }
    else {
        return { start: startMax, end: endMin };
    }
}
/**
 * Returns pixel "distance" between two points.
 *
 * If second point is not specified, distance from {x:0, y:0} point is
 * calculated.
 *
 * @param point1  Point 1
 * @param point2  Point 2
 * @return Distance in relative pixels
 */
function getDistance(point1, point2) {
    if (!point1) {
        return 0;
    }
    if (!point2) {
        point2 = { x: 0, y: 0 };
    }
    return Math.sqrt(Math.pow(Math.abs(point1.x - point2.x), 2) + Math.pow(Math.abs(point1.y - point2.y), 2));
}
/**
 * Returns pixel "horizontal distance" between two points.
 *
 * If second point is not specified, distance from {x:0, y:0} point is
 * calculated.
 *
 * @param point1  Point 1
 * @param point2  Point 2
 * @return Distance in relative pixels
 */
function getHorizontalDistance(point1, point2) {
    if (!point1) {
        return 0;
    }
    if (!point2) {
        point2 = { x: 0, y: 0 };
    }
    return Math.abs(point1.x - point2.x);
}
/**
 * Returns pixel "vertical distance" between two points.
 *
 * If second point is not specified, distance from {x:0, y:0} point is
 * calculated.
 *
 * @param point1  Point 1
 * @param point2  Point 2
 * @return Distance in relative pixels
 */
function getVerticalDistance(point1, point2) {
    if (!point1) {
        return 0;
    }
    if (!point2) {
        point2 = { x: 0, y: 0 };
    }
    return Math.abs(point1.y - point2.y);
}
/**
 * Returns approximate pixel "distance" between two points of cubic curve
 *
 * If second point is not specified, distance from {x:0, y:0} point is
 * calculated.
 *
 * @param point1  Point 1
 * @param point2  Point 2
 * @param controlPointA  Control Point 1
 * @param controlPointB  Control Point 2
 * @param stepCount  number of steps (the more, the more accurate result)
 * @return Distance in relative pixels
 */
function getCubicCurveDistance(point1, point2, controlPointA, controlPointB, stepCount) {
    if (!point1) {
        return 0;
    }
    if (!point2) {
        point2 = { x: 0, y: 0 };
    }
    var distance = 0;
    var prevPoint = point1;
    if (stepCount > 0) {
        for (var s = 0; s <= stepCount; s++) {
            var point = getPointOnCubicCurve(point1, point2, controlPointA, controlPointB, s / stepCount);
            distance += getDistance(prevPoint, point);
            prevPoint = point;
        }
    }
    return distance;
}
/**
 * Returns scale based on original and end position of the two points.
 *
 * @param point1       Current position of point 1
 * @param startPoint1  Start position of point 1
 * @param point2       Current position of point 1
 * @param startPoint2  Start position of point 2
 * @return Scale        Calculated scale
 */
function getScale(point1, startPoint1, point2, startPoint2) {
    var initialDistance = getDistance(startPoint1, startPoint2);
    var currentDistance = getDistance(point1, point2);
    return Math.abs(currentDistance / initialDistance);
}
/**
 * Returns an exact mid point between two points.
 *
 * @param point1     Position of point 1
 * @param point2     Position of point 2
 * @return Mid point  Position of mid-point
 */
function getMidPoint(point1, point2, position) {
    if (!isNumber(position)) {
        position = 0.5;
    }
    return {
        "x": (point1.x + (point2.x - point1.x) * position),
        "y": (point1.y + (point2.y - point1.y) * position)
    };
}
/**
 * Returns difference in angles between starting and ending position of two
 * vectors.
 *
 * @param point1       Current position of point 1
 * @param startPoint1  Start position of point 1
 * @param point2       Current position of point 1
 * @param startPoint2  Start position of point 2
 * @return Angle difference in degrees
 */
function getRotation(point1, startPoint1, point2, startPoint2) {
    // Get start and end angles
    var startAngle = getAngle(startPoint1, startPoint2);
    var angle = getAngle(point1, point2);
    // Calculate angle
    var diff = startAngle - angle;
    if (diff < 0) {
        diff += 360;
    }
    return diff;
}
/**
 * Calculates angle of the vector based on two or one point.
 *
 * @param point1  Point 1
 * @param point2  Point 2
 * @return Angle in degrees
 */
function getAngle(point1, point2) {
    if (!point2) {
        point2 = { x: point1.x * 2, y: point1.y * 2 };
    }
    var diffX = point2.x - point1.x;
    var diffY = point2.y - point1.y;
    var angle = Math.atan2(diffY, diffX) * DEGREES;
    if (angle < 0) {
        angle += 360;
    }
    return normalizeAngle(angle);
}
/**
 * Returns the shift in coordinates of the center when item is rotated, moved
 * and scaled at the same time.
 *
 * @param center       Current center
 * @param point1       Frst reference point
 * @param startPoint1  Original position of the first reference point
 * @param point2       Second reference point
 * @param startPoint2  Original position of the first reference point
 * @return Shift in center point coordinates
 */
function getCenterShift(center, point1, startPoint1, point2, startPoint2) {
    // Get angle
    var angle = getRotation(point1, startPoint1, point2, startPoint2) - 90;
    if (angle < 0) {
        angle += 360;
    }
    // Get distance between new position
    var distance = getDistance(point1, point2);
    // Calculate new X
    var x = Math.cos(angle) / distance + point1.x;
    var y = Math.cos(angle) / distance + point1.y;
    var shift = {
        "x": x - center.x,
        "y": y - center.y
    };
    return shift;
}
/**
 * Converts an array of points into a bounding box rectangle.
 *
 * Array can contain any number of points.
 *
 * @param points  Points
 * @return Bounding box rectangle
 */
function getBBox(points) {
    if (points) {
        var length_1 = points.length;
        if (length_1 !== 0) {
            var left = void 0;
            var right = void 0;
            var top_1;
            var bottom = void 0;
            for (var i = 0; i < length_1; i++) {
                var point = points[i];
                if (!isNumber(right) || (point.x > right)) {
                    right = point.x;
                }
                if (!isNumber(left) || (point.x < left)) {
                    left = point.x;
                }
                if (!isNumber(top_1) || (point.y < top_1)) {
                    top_1 = point.y;
                }
                if (!isNumber(bottom) || (point.y > bottom)) {
                    bottom = point.y;
                }
            }
            return { x: left, y: top_1, width: right - left, height: bottom - top_1 };
        }
    }
    return { x: 0, y: 0, width: 0, height: 0 };
}
/**
 * Returns a [[IRectangle]] object representing a common rectangle that fits
 * all passed in rectangles in it.
 *
 * @param rectangles  An array of rectangles
 * @return Common rectangle
 */
function getCommonRectangle(rectangles) {
    var length = rectangles.length;
    if (length !== 0) {
        var minX = void 0;
        var minY = void 0;
        var maxX = void 0;
        var maxY = void 0;
        for (var i = 0; i < length; i++) {
            var rectangle = rectangles[i];
            minX = Math_min(rectangle.x, minX);
            minY = Math_min(rectangle.y, minY);
            maxX = Math_max(rectangle.x + rectangle.width, maxX);
            maxY = Math_max(rectangle.y + rectangle.height, maxY);
        }
        return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
}
/**
 * [getPointOnQuadraticCurve description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param pointA        [description]
 * @param pointB        [description]
 * @param controlPoint  [description]
 * @param position      [description]
 * @return [description]
 */
function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {
    var x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;
    var y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;
    return { x: x, y: y };
}
/**
 * [getPointOnCubicCurve description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param pointA         [description]
 * @param pointB         [description]
 * @param controlPointA  [description]
 * @param controlPointB  [description]
 * @param position       [description]
 * @return [description]
 */
function getPointOnCubicCurve(pointA, pointB, controlPointA, controlPointB, position) {
    var point = { x: 0, y: 0 };
    var mt1 = 1 - position;
    var mt2 = mt1 * mt1;
    var mt3 = mt2 * mt1;
    point.x = pointA.x * mt3 + controlPointA.x * 3 * mt2 * position + controlPointB.x * 3 * mt1 * position * position + pointB.x * position * position * position;
    point.y = pointA.y * mt3 + controlPointA.y * 3 * mt2 * position + controlPointB.y * 3 * mt1 * position * position + pointB.y * position * position * position;
    return point;
}
/**
 * [getCubicControlPointA description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param p0        [description]
 * @param p1        [description]
 * @param p2        [description]
 * @param p3        [description]
 * @param tensionX  [description]
 * @param tensionY  [description]
 * @return [description]
 */
function getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY) {
    tensionX = adjustTension(tensionX);
    tensionY = adjustTension(tensionY);
    return { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };
}
/**
 * [getCubicControlPointB description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param p0        [description]
 * @param p1        [description]
 * @param p2        [description]
 * @param p3        [description]
 * @param tensionX  [description]
 * @param tensionY  [description]
 * @return [description]
 */
function getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY) {
    tensionX = adjustTension(tensionX);
    tensionY = adjustTension(tensionY);
    return { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };
}
/**
 * [adjustTension description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param tension  [description]
 * @return [description]
 */
function adjustTension(tension) {
    return 1 - tension + 0.00001;
}
/**
 * [normalizeAngle description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param value  [description]
 * @return [description]
 */
function normalizeAngle(value) {
    if (value == 360) {
        return 360;
    }
    return value % 360;
}
/**
 * [normalizeAngleToRange description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @todo review this with various angles, can be tested on radar chart with custom start/end angles
 * @param value       [description]
 * @param startAngle  [description]
 * @param endAngle    [description]
 * @return [description]
 */
function fitAngleToRange(value, startAngle, endAngle) {
    if (startAngle > endAngle) {
        var temp = startAngle;
        startAngle = endAngle;
        endAngle = temp;
    }
    value = normalizeAngle(value);
    var count = (startAngle - normalizeAngle(startAngle)) / 360;
    if (value < startAngle) {
        value += 360 * (count + 1);
    }
    var maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;
    var maxStart = startAngle + (endAngle - startAngle) / 2 - 180;
    if (value > endAngle) {
        if (value - 360 > startAngle) {
            value -= 360;
        }
        else {
            if (value < maxEnd) {
                value = endAngle;
            }
            else {
                value = startAngle;
            }
        }
    }
    if (value < startAngle) {
        if (value > maxStart) {
            value = startAngle;
        }
        else {
            value = endAngle;
        }
    }
    return value;
}
/**
 * Returns [[IRectangle]] of an arc in relative values, assuming that the
 * center is at the circle center.
 *
 * Used to find out max radius of an arc.
 *
 * @ignore Exclude from docs
 * @param startAngle  Start angle
 * @param endAngle    End angle
 * @param radius    	 Relative radius
 * @return Rectangle
 */
function getArcRect(startAngle, endAngle, radius) {
    var minX = Number.MAX_VALUE;
    var minY = Number.MAX_VALUE;
    var maxX = -Number.MAX_VALUE;
    var maxY = -Number.MAX_VALUE;
    var bpoints = [];
    if (!isNumber(radius)) {
        radius = 1;
    }
    bpoints.push(getArcPoint(radius, startAngle));
    bpoints.push(getArcPoint(radius, endAngle));
    var fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);
    var toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);
    for (var angle = fromAngle; angle <= toAngle; angle += 90) {
        if (angle >= startAngle && angle <= endAngle) {
            bpoints.push(getArcPoint(radius, angle));
        }
    }
    for (var i = 0; i < bpoints.length; i++) {
        var pt = bpoints[i];
        if (pt.x < minX) {
            minX = pt.x;
        }
        if (pt.y < minY) {
            minY = pt.y;
        }
        if (pt.x > maxX) {
            maxX = pt.x;
        }
        if (pt.y > maxY) {
            maxY = pt.y;
        }
    }
    return ({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });
}
/**
 * Returns point on arc
 *
 * @param center point
 * @param radius
 * @param arc
 * @return {boolean}
 */
function getArcPoint(radius, arc) {
    return ({ x: radius * Math_cos(arc), y: radius * Math_sin(arc) });
}
/**
 * Returns true if a point is within rectangle
 *
 * @param point
 * @param rectangle
 * @return {boolean}
 */
function isInRectangle(point, rectangle) {
    if (point.x >= rectangle.x && point.x <= rectangle.x + rectangle.width && point.y > rectangle.y && point.y < rectangle.y + rectangle.height) {
        return true;
    }
    return false;
}
function getLineIntersection(pointA1, pointA2, pointB1, pointB2) {
    var x = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.x - pointB2.x) - (pointA1.x - pointA2.x) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));
    var y = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));
    return { x: x, y: y };
}
//# sourceMappingURL=Math.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Array.js


/**
 * ============================================================================
 * UTILITY FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Searches `array` for `value`.
 *
 * Returns -1 if not found.
 *
 * @param array  Source array
 * @param value  Value to search
 * @returns Index
 */
function indexOf(array, value) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        // TODO handle NaN
        if (array[i] === value) {
            return i;
        }
    }
    return -1;
}
/**
 * Calls `test` for each element in `array`.
 *
 * If `test` returns `true` then it immediately returns `true`.
 *
 * If `test` returns `false` for all of the elements in `array` then it returns `false`.
 *
 * @param array  Source array
 * @param test   Function which is called on each element
 * @returns Whether `test` returned true or not
 */
function any(array, test) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        if (test(array[i])) {
            return true;
        }
    }
    return false;
}
/**
 * Calls `fn` function for every member of array and returns a new array out
 * of all outputs.
 *
 * @param array  Source array
 * @param fn     Callback function
 * @returns New array
 */
function map(array, fn) {
    var length = array.length;
    var output = new Array(length);
    for (var i = 0; i < length; ++i) {
        output[i] = fn(array[i], i);
    }
    return output;
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function each(array, fn) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        fn(array[i], i);
    }
}
/**
 * Iterates through all items in array in reverse order and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function eachReverse(array, fn) {
    var i = array.length;
    while (i--) {
        fn(array[i], i);
    }
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * If `fn` call evaluates to `false`, further iteration is cancelled.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function eachContinue(array, fn) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        if (!fn(array[i], i)) {
            break;
        }
    }
}
/**
 * Shifts an item at `index` towards beginning of the array.
 *
 * @param array  Source array
 * @param index  Target element index
 */
function shiftLeft(array, index) {
    var length = array.length;
    for (var i = index; i < length; ++i) {
        array[i - index] = array[i];
    }
    array.length = length - index;
}
/**
 * Returns the last item of the array.
 *
 * @param array  Source array
 * @returns Last item
 */
function Array_last(array) {
    var length = array.length;
    return length ? array[length - 1] : undefined;
}
/**
 * Returns the first item of the array.
 *
 * @param array  Source array
 * @returns Last item
 */
function Array_first(array) {
    return array[0];
}
/**
 * Inserts `element` into `array` at `index`.
 *
 * Caps `index` to be between `0` and `array.length`
 *
 * @param array    Source array
 * @param element  Item to insert
 * @param array    Index to insert item at
 */
function insert(array, element, index) {
    //if (array) {
    index = fitToRange(index, 0, array.length);
    array.splice(index, 0, element);
    //}
}
/**
 * Removes all copies of `element` from `array` (if they exist) and then
 * inserts `element` at `index`.
 *
 * @param array    Source array
 * @param element  Item
 * @param array    Index to move item to
 */
function setIndex(array, element, index) {
    remove(array, element);
    insert(array, element, index);
}
/**
 * Pushes all of the elements from `input` into `array`.
 *
 * @param array  Output array
 * @param input  Input array
 */
function pushAll(array, input) {
    var length = input.length;
    for (var i = 0; i < length; ++i) {
        array.push(input[i]);
    }
}
/**
 * Removes `element` from `array`.
 *
 * If there are multiple copies of `element`, they are all removed.
 *
 * @param array    Source array
 * @param element  Item to remove
 */
function remove(array, element) {
    var found = false;
    var index = array.indexOf(element);
    if (index !== -1) {
        found = true;
        array.splice(index, 1);
        var length_1 = array.length;
        while (index < length_1) {
            // TODO handle NaN
            if (array[index] === element) {
                array.splice(index, 1);
                --length_1;
            }
            else {
                ++index;
            }
        }
    }
    return found;
}
/**
 * Adds an `element` to `array`.
 *
 * If array already contains and item like this, it is removed before adding
 * it again.
 *
 * Optionally `toIndex` can be specified to add element at specific index.
 *
 * @param array    Source array
 * @param element  Item to add
 * @param array    Index to move item to
 */
function move(array, element, toIndex) {
    // @todo this implementation must be the same as the List.moveValue method
    // @todo don't do anything if the desired index is the same as the current index
    var index = indexOf(array, element);
    // @todo remove all old values rather than only the first ?
    if (index !== -1) {
        removeIndex(array, index);
    }
    if (toIndex == null) {
        array.push(element);
    }
    else {
        insertIndex(array, toIndex, element);
    }
}
/**
 * Inserts `element` into `array` at `index`.
 *
 * If `index` is not provided, it will insert `element` at the end of `array`.
 *
 * @param array    Source array
 * @param element  Item to add
 * @param array    Index to add item at
 */
function Array_add(array, element, index) {
    // Append to the end if index is not set
    if (!isNumber(index)) {
        array.push(element);
    }
    // Add to the beginning of array if index is 0
    else if (index === 0) {
        array.unshift(element);
    }
    // Add to indicated place if index is set
    else {
        array.splice(index, 0, element);
    }
}
/**
 * Removes `element` from `array` (if it exists) and then inserts `element` at
 * `index`.
 *
 * If `index` is not provided, it will insert `element` at the end of `array`.
 *
 * @param array    Source array
 * @param element  Item to remove
 * @param array    Index to move item to
 */
function replace(array, element, index) {
    // check if exists
    var ind = array.indexOf(element);
    // remove if exists
    if (ind !== -1) {
        array.splice(ind, 1);
    }
    // add to end if index is not set
    if (!isNumber(index)) {
        array.push(element);
    }
    // add to indicated place if index is set
    else {
        array.splice(index, 0, element);
    }
}
/**
 * Wraps `input` in an array, if it isn't already an array.
 *
 * @param input  Source value
 * @return An array
 */
function toArray(input) {
    if (Array.isArray(input)) {
        return input;
    }
    else {
        return [input];
    }
}
/**
 * Returns `true` if `element` exists in `array`.
 *
 * @param array    Source array
 * @param element  Item to search for
 * @returns Item in array?
 */
function has(array, element) {
    return indexOf(array, element) !== -1;
}
/**
 * Returns a shallow copy of `array`.
 *
 * @param array  Source array
 * @returns Copy of the array
 */
function copy(array) {
    var length = array.length;
    // It's faster to create the array with a pre-defined length
    var output = new Array(length);
    for (var i = 0; i < length; ++i) {
        // Because the array has a pre-defined length, we have to assign rather than push
        // This is also faster than pushing
        output[i] = array[i];
    }
    return output;
}
/**
 * Returns a copy of `array` which contains all the elements between `start`
 * and `end`. (including `start` and excluding `end`)
 *
 * If `end` is not provided, it defaults to `array.length`.
 *
 * @param array  Source array
 * @param start  Start index
 * @param end    End index
 * @returns Part of the array
 */
function Array_slice(array, start, end) {
    if (end === void 0) { end = array.length; }
    var output = new Array(end - start);
    for (var i = start; i < end; ++i) {
        output[i - start] = array[i];
    }
    return output;
}
/**
 * Inserts a value into array at specific index.
 *
 * @param array  Source array
 * @param index  Index
 * @param value  Value to insert
 */
function insertIndex(array, index, value) {
    array.splice(index, 0, value);
}
/**
 * Removes a value from array at specific index.
 *
 * @param array  Source array
 * @param index  Index
 */
function removeIndex(array, index) {
    array.splice(index, 1);
}
/**
 * Orders an array using specific `ordering` function and returns index of
 * the `value`.
 *
 * @ignore Exclude from docs
 * @param array     Source array
 * @param ordering  An ordering function
 * @param value     Value to search for
 * @returns Result of the search
 */
function getSortedIndex(array, ordering, value) {
    var start = 0;
    var end = array.length;
    var found = false;
    while (start < end) {
        // TODO is this faster/slower than using Math.floor ?
        var pivot = (start + end) >> 1;
        var order = ordering(value, array[pivot]);
        // less
        if (order < 0) {
            end = pivot;
            // equal
        }
        else if (order === 0) {
            found = true;
            start = pivot + 1;
            // more
        }
        else {
            start = pivot + 1;
        }
    }
    return {
        found: found,
        index: (found ? start - 1 : start)
    };
}
/**
 * Searches the array using custom function and returns index of the item if
 * found.
 *
 * Will call `matches` function on all items of the array. If return value
 * evaluates to `true`, index is returned.
 *
 * Otherwise returns -1.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Index of the item if found
 */
function findIndex(array, matches) {
    var length = array.length;
    for (var i = 0; i < length; ++i) {
        if (matches(array[i], i)) {
            return i;
        }
    }
    return -1;
}
/**
 * Searches the array using custom function and returns item if found.
 *
 * Will call `matches` function on all items of the array. If return value
 * evaluates to `true`, index is returned.
 *
 * Otherwise returns `undefined`.
 *
 * @param array    Source array
 * @param matches  Search function
 * @returns Item if found
 */
function find(array, matches) {
    var index = findIndex(array, matches);
    if (index !== -1) {
        return array[index];
    }
}
/**
 * Iterates through all items in array and calls `fn` function for each of
 * them.
 *
 * @param array  Source array
 * @param fn     Callback function
 */
function shuffle(array) {
    // https://stackoverflow.com/a/2450976/449477
    var currentIndex = array.length, temporaryValue, randomIndex;
    // While there remain elements to shuffle...
    while (0 !== currentIndex) {
        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
}
function keepIf(array, keep) {
    var length = array.length;
    var i = 0;
    while (i < length) {
        if (keep(array[i])) {
            ++i;
        }
        else {
            array.splice(i, 1);
            --length;
        }
    }
}
//# sourceMappingURL=Array.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Disposer.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * A base class for disposable objects.
 *
 * @ignore Exclude from docs
 */
var Disposer = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param dispose  Function that disposes object
     */
    function Disposer(dispose) {
        this._disposed = false;
        this._dispose = dispose;
    }
    /**
     * Checks if object is disposed.
     *
     * @return Disposed?
     */
    Disposer.prototype.isDisposed = function () {
        return this._disposed;
    };
    /**
     * Disposes the object.
     */
    Disposer.prototype.dispose = function () {
        if (!this._disposed) {
            this._disposed = true;
            this._dispose();
        }
    };
    return Disposer;
}());

/**
 * A collection of related disposers that can be disposed in one go.
 *
 * @ignore Exclude from docs
 */
var Disposer_MultiDisposer = /** @class */ (function (_super) {
    __extends(MultiDisposer, _super);
    function MultiDisposer(disposers) {
        return _super.call(this, function () {
            each(disposers, function (x) {
                x.dispose();
            });
        }) || this;
    }
    return MultiDisposer;
}(Disposer));

/**
 * A special kind of Disposer that has attached value set.
 *
 * If a new value is set using `set()` method, the old disposer value is
 * disposed.
 *
 * @ignore Exclude from docs
 * @todo Description
 */
var Disposer_MutableValueDisposer = /** @class */ (function (_super) {
    __extends(MutableValueDisposer, _super);
    /**
     * Constructor.
     */
    function MutableValueDisposer() {
        var _this = _super.call(this, function () {
            if (hasValue(_this._disposer)) {
                _this._disposer.dispose();
                _this._disposer = undefined;
            }
        }) || this;
        return _this;
    }
    /**
     * Returns current value.
     *
     * @return Value
     */
    MutableValueDisposer.prototype.get = function () {
        return this._value;
    };
    /**
     * Sets value and disposes previous disposer if it was set.
     *
     * @param value     New value
     * @param disposer  Disposer
     */
    MutableValueDisposer.prototype.set = function (value, disposer) {
        if (hasValue(this._disposer)) {
            this._disposer.dispose();
        }
        this._disposer = disposer;
        this._value = value;
    };
    /**
     * Resets the disposer value.
     */
    MutableValueDisposer.prototype.reset = function () {
        this.set(undefined, undefined);
    };
    return MutableValueDisposer;
}(Disposer));

/**
 * @ignore Exclude from docs
 * @todo Description
 */
var Disposer_CounterDisposer = /** @class */ (function (_super) {
    __extends(CounterDisposer, _super);
    function CounterDisposer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * [_counter description]
         *
         * @todo Description
         */
        _this._counter = 0;
        return _this;
    }
    /**
     * [increment description]
     *
     * @todo Description
     */
    CounterDisposer.prototype.increment = function () {
        var _this = this;
        // TODO throw an error if it is disposed
        ++this._counter;
        // TODO make this more efficient
        return new Disposer(function () {
            --_this._counter;
            if (_this._counter === 0) {
                _this.dispose();
            }
        });
    };
    return CounterDisposer;
}(Disposer));

//# sourceMappingURL=Disposer.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/AsyncPending.js
/**
 * A collection of low-level async operation stuff.
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

var pendingFrame = false;
var nextQueue = [];
var readQueue = [];
var writeQueue = [];
var idleQueue = [];
var fps = 1000 / 60;
/**
 * [raf description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
var raf = (typeof requestAnimationFrame === "function"
    ? function (fn) {
        requestAnimationFrame(fn);
    }
    : function (fn) {
        setTimeout(fn, fps);
    });
/**
 * [frameLoop description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function frameLoop() {
    var now = Date.now();
    var length = nextQueue.length;
    for (var i = 0; i < length; ++i) {
        nextQueue[i](now);
    }
    shiftLeft(nextQueue, length);
    for (var i = 0; i < readQueue.length; ++i) {
        readQueue[i](now);
    }
    readQueue.length = 0;
    for (var i = 0; i < writeQueue.length; ++i) {
        writeQueue[i](now);
    }
    writeQueue.length = 0;
    if (nextQueue.length === 0 && readQueue.length === 0) {
        pendingFrame = false;
    }
    else {
        raf(frameLoop);
    }
}
/**
 * [pendFrame description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function pendFrame() {
    if (!pendingFrame) {
        pendingFrame = true;
        raf(frameLoop);
    }
}
/**
 * [nextFrame description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param fn [description]
 */
function nextFrame(fn) {
    nextQueue.push(fn);
    pendFrame();
}
/**
 * [readFrame description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param fn [description]
 */
function readFrame(fn) {
    readQueue.push(fn);
    pendFrame();
}
/**
 * [writeFrame description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param fn [description]
 */
function writeFrame(fn) {
    writeQueue.push(fn);
    pendFrame();
}
/**
 * [whenIdle description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param fn [description]
 */
function whenIdle(fn) {
    idleQueue.push(fn);
}
/**
 * [triggerIdle description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @todo Maybe don't trigger a callback which was added while in the middle of triggering?
 */
function triggerIdle() {
    var now = Date.now();
    var length = idleQueue.length;
    for (var i = 0; i < length; ++i) {
        idleQueue.shift()(now);
    }
}
//# sourceMappingURL=AsyncPending.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/EventDispatcher.js
/**
 * Event Dispatcher module is used for registering listeners and dispatching
 * events across amCharts system.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/*export interface IEventDispatcher<T> {
    isDisposed(): boolean;
    dispose(): void;
    hasListeners(): boolean;
    enable(): void;
    disable(): void;
    enableType<Key extends keyof T>(type: Key): void;
    disableType<Key extends keyof T>(type: Key, amount?: number): void;
    isEnabled<Key extends keyof T>(type: Key): boolean;
    has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean;
    dispatchImmediately<Key extends keyof T>(type: Key, event: T[Key]): void;
    dispatch<Key extends keyof T>(type: Key, event: T[Key]): void;
    onAll<C, Key extends keyof T>(callback: (this: C, type: Key, event: T[Key]) => void, context?: C): IDisposer;
    on<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;
    once<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): IDisposer;
    off<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;
    off<C, Key extends keyof T>(type: Key, callback: (this: C, event: T[Key]) => void, context?: C): void;
    copyFrom(source: this): void;
}*/
/**
 * Universal Event Dispatcher.
 *
 * @important
 */
var EventDispatcher_EventDispatcher = /** @class */ (function () {
    /**
     * Constructor
     */
    function EventDispatcher() {
        this._listeners = [];
        this._killed = [];
        this._disabled = {};
        this._iterating = 0;
        this._enabled = true;
        this._disposed = false;
    }
    /**
     * Returns if this object has been already disposed.
     *
     * @return Disposed?
     */
    EventDispatcher.prototype.isDisposed = function () {
        return this._disposed;
    };
    /**
     * Dispose (destroy) this object.
     */
    EventDispatcher.prototype.dispose = function () {
        if (!this._disposed) {
            this._disposed = true;
            var a = this._listeners;
            this._iterating = 1;
            this._listeners = null;
            this._disabled = null;
            try {
                each(a, function (x) {
                    x.disposer.dispose();
                });
            }
            finally {
                this._killed = null;
                this._iterating = null;
            }
        }
    };
    /**
     * Checks if this particular event dispatcher has any listeners set.
     *
     * @return Has listeners?
     */
    EventDispatcher.prototype.hasListeners = function () {
        return this._listeners.length !== 0;
    };
    /**
     * Checks if this particular event dispatcher has any particular listeners set.
     *
     * @return Has particular event listeners?
     */
    EventDispatcher.prototype.hasListenersByType = function (type) {
        return any(this._listeners, function (x) { return (x.type === null || x.type === type) && !x.killed; });
    };
    /**
     * Enable dispatching of events if they were previously disabled by
     * `disable()`.
     */
    EventDispatcher.prototype.enable = function () {
        this._enabled = true;
    };
    /**
     * Disable dispatching of events until re-enabled by `enable()`.
     */
    EventDispatcher.prototype.disable = function () {
        this._enabled = false;
    };
    /**
     * Enable dispatching particular event, if it was disabled before by
     * `disableType()`.
     *
     * @param type Event type
     */
    EventDispatcher.prototype.enableType = function (type) {
        delete this._disabled[type];
    };
    /**
     * Disable dispatching of events for a certain event type.
     *
     * Optionally, can set how many dispatches to skip before automatically
     * re-enabling the dispatching.
     *
     * @param type    Event type
     * @param amount  Number of event dispatches to skip
     */
    EventDispatcher.prototype.disableType = function (type, amount) {
        if (amount === void 0) { amount = Infinity; }
        this._disabled[type] = amount;
    };
    /**
     * Removes listener from dispatcher.
     *
     * Will throw an exception if such listener does not exists.
     *
     * @param listener Listener to remove
     */
    EventDispatcher.prototype._removeListener = function (listener) {
        if (this._iterating === 0) {
            var index = this._listeners.indexOf(listener);
            if (index === -1) {
                throw new Error("Invalid state: could not remove listener");
            }
            this._listeners.splice(index, 1);
        }
        else {
            this._killed.push(listener);
        }
    };
    /**
     * Removes existing listener by certain parameters.
     *
     * @param once         Listener's once setting
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     */
    EventDispatcher.prototype._removeExistingListener = function (once, type, callback, context) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        this._eachListener(function (info) {
            if (info.once === once && // TODO is this correct ?
                info.type === type &&
                (callback == null || info.callback === callback) &&
                info.context === context) {
                info.disposer.dispose();
            }
        });
    };
    /**
     * Checks if dispatching for particular event type is enabled.
     *
     * @param type  Event type
     * @return Enabled?
     */
    EventDispatcher.prototype.isEnabled = function (type) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        // TODO is this check correct ?
        return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] == null;
    };
    /**
     * Checks if there's already a listener with specific parameters.
     *
     * @param type      Listener's type
     * @param callback  Callback function
     * @param context   Callback context
     * @return Has listener?
     */
    EventDispatcher.prototype.has = function (type, callback, context) {
        var index = findIndex(this._listeners, function (info) {
            return info.once !== true && // Ignoring "once" listeners
                info.type === type &&
                (callback == null || info.callback === callback) &&
                info.context === context;
        });
        return index !== -1;
    };
    /**
     * Checks whether event of the particular type should be dispatched.
     *
     * @param type  Event type
     * @return Dispatch?
     */
    EventDispatcher.prototype._shouldDispatch = function (type) {
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        var count = this._disabled[type];
        if (!isNumber(count)) {
            return this._enabled;
        }
        else {
            if (count <= 1) {
                delete this._disabled[type];
            }
            else {
                --this._disabled[type];
            }
            return false;
        }
    };
    /**
     * [_eachListener description]
     *
     * All of this extra code is needed when a listener is removed while iterating
     *
     * @todo Description
     * @param fn [description]
     */
    EventDispatcher.prototype._eachListener = function (fn) {
        var _this = this;
        ++this._iterating;
        try {
            each(this._listeners, fn);
        }
        finally {
            --this._iterating;
            // TODO should this be inside or outside the finally ?
            if (this._iterating === 0 && this._killed.length !== 0) {
                // Remove killed listeners
                each(this._killed, function (killed) {
                    _this._removeListener(killed);
                });
                this._killed.length = 0;
            }
        }
    };
    /**
     * Dispatches an event immediately without waiting for next cycle.
     *
     * @param type   Event type
     * @param event  Event object
     * @todo automatically add in type and target properties if they are missing
     */
    EventDispatcher.prototype.dispatchImmediately = function (type, event) {
        if (this._shouldDispatch(type)) {
            // TODO check if it's faster to use an object of listeners rather than a single big array
            // TODO if the function throws, maybe it should keep going ?
            this._eachListener(function (listener) {
                if (!listener.killed && (listener.type === null || listener.type === type)) {
                    listener.dispatch(type, event);
                }
            });
        }
    };
    /**
     * Shelves the event to be dispatched within next update cycle.
     *
     * @param type   Event type
     * @param event  Event object
     * @todo automatically add in type and target properties if they are missing
     */
    EventDispatcher.prototype.dispatch = function (type, event) {
        if (this._shouldDispatch(type)) {
            this._eachListener(function (listener) {
                // TODO check if it's faster to use an object of listeners rather than a single big array
                if (!listener.killed && (listener.type === null || listener.type === type)) {
                    // TODO if the function throws, maybe it should keep going ?
                    // TODO dispatch during the update cycle, rather than using whenIdle
                    whenIdle(function () {
                        if (!listener.killed) {
                            listener.dispatch(type, event);
                        }
                    });
                }
            });
        }
    };
    /**
     * Creates, catalogs and returns an [[EventListener]].
     *
     * Event listener can be disposed.
     *
     * @param once         Listener's once setting
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @param dispatch
     * @returns An event listener
     */
    EventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {
        var _this = this;
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        this._removeExistingListener(once, type, callback, context);
        var info = {
            type: type,
            callback: callback,
            context: context,
            shouldClone: shouldClone,
            dispatch: dispatch,
            killed: false,
            once: once,
            disposer: new Disposer(function () {
                info.killed = true;
                _this._removeListener(info);
            })
        };
        this._listeners.push(info);
        return info;
    };
    /**
     * Creates an event listener to be invoked on **any** event.
     *
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     * @todo what if `listen` is called on the same function twice ?
     */
    EventDispatcher.prototype.onAll = function (callback, context, shouldClone) {
        if (shouldClone === void 0) { shouldClone = true; }
        return this._on(false, null, callback, context, shouldClone, function (type, event) { return callback.call(context, type, event); }).disposer;
    };
    /**
     * Creates an event listener to be invoked on a specific event type.
     *
     * ```TypeScript
     * series.events.on("hidden", (ev) => {
     *   console.log("Series hidden: " + ev.target.name);
     * }, this);
     * ```
     * ```JavaScript
     * series.events.on("hidden", function(ev) {
     *   console.log("Series hidden: " + ev.target.name);
     * }, this);
     * ```
     * ```JSON
     * {
     *   // ...
     *   "series": [{
     *     // ...
     *     "events": {
     *     	"hidden": function(ev) {
     *     	  console.log("Series hidden: " + ev.target.name);
     *     	}
     *     }
     *   }]
     * }
     * ```
     *
     * The above will invoke our custom event handler whenever series we put
     * event on is hidden.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     * @todo what if `listen` is called on the same function twice ?
     */
    EventDispatcher.prototype.on = function (type, callback, context, shouldClone) {
        if (shouldClone === void 0) { shouldClone = true; }
        return this._on(false, type, callback, context, shouldClone, function (type, event) { return callback.call(context, event); }).disposer;
    };
    /**
     * Creates an event listener to be invoked on a specific event type once.
     *
     * Once the event listener is invoked, it is automatically disposed.
     *
     * ```TypeScript
     * series.events.on("hidden", (ev) => {
     *   console.log("Series hidden: " + ev.target.name);
     * }, this);
     * ```
     * ```JavaScript
     * series.events.on("hidden", function(ev) {
     *   console.log("Series hidden: " + ev.target.name);
     * }, this);
     * ```
     * ```JSON
     * {
     *   // ...
     *   "series": [{
     *     // ...
     *     "events": {
     *     	"hidden": function(ev) {
     *     	  console.log("Series hidden: " + ev.target.name);
     *     	}
     *     }
     *   }]
     * }
     * ```
     *
     * The above will invoke our custom event handler the first time series we
     * put event on is hidden.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
     * @returns A disposable event listener
     * @todo what if `listen` is called on the same function twice ?
     */
    EventDispatcher.prototype.once = function (type, callback, context, shouldClone) {
        if (shouldClone === void 0) { shouldClone = true; }
        var x = this._on(true, type, callback, context, shouldClone, function (type, event) {
            x.disposer.dispose();
            callback.call(context, event);
        });
        // TODO maybe this should return a different Disposer ?
        return x.disposer;
    };
    /**
     * Removes the event listener with specific parameters.
     *
     * @param type         Listener's type
     * @param callback     Callback function
     * @param context      Callback context
     */
    EventDispatcher.prototype.off = function (type, callback, context) {
        this._removeExistingListener(false, type, callback, context);
    };
    /**
     * Copies all dispatcher parameters, including listeners, from another event
     * dispatcher.
     *
     * @param source Source event dispatcher
     */
    EventDispatcher.prototype.copyFrom = function (source) {
        var _this = this;
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        if (source === this) {
            throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
        }
        each(source._listeners, function (x) {
            // TODO is this correct ?
            if (!x.killed && x.shouldClone) {
                if (x.type === null) {
                    _this.onAll(x.callback, x.context);
                }
                else if (x.once) {
                    _this.once(x.type, x.callback, x.context);
                }
                else {
                    _this.on(x.type, x.callback, x.context);
                }
            }
        });
    };
    return EventDispatcher;
}());

/**
 * A version of the [[EventDispatcher]] that dispatches events for a specific
 * target object.
 *
 * @important
 */
var EventDispatcher_TargetedEventDispatcher = /** @class */ (function (_super) {
    __extends(TargetedEventDispatcher, _super);
    /**
     * Constructor
     *
     * @param target Event dispatcher target
     */
    function TargetedEventDispatcher(target) {
        var _this = _super.call(this) || this;
        _this.target = target;
        return _this;
    }
    /**
     * Copies all dispatcher parameters, including listeners, from another event
     * dispatcher.
     *
     * @param source Source event dispatcher
     */
    TargetedEventDispatcher.prototype.copyFrom = function (source) {
        var _this = this;
        if (this._disposed) {
            throw new Error("EventDispatcher is disposed");
        }
        if (source === this) {
            throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
        }
        each(source._listeners, function (x) {
            // TODO very hacky
            if (x.context === source.target) {
                return;
            }
            // TODO is this correct ?
            if (!x.killed && x.shouldClone) {
                if (x.type === null) {
                    _this.onAll(x.callback, x.context);
                }
                else if (x.once) {
                    _this.once(x.type, x.callback, x.context);
                }
                else {
                    _this.on(x.type, x.callback, x.context);
                }
            }
        });
    };
    return TargetedEventDispatcher;
}(EventDispatcher_EventDispatcher));

//# sourceMappingURL=EventDispatcher.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Object.js
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * UTILITY FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Returns an iterator for all entries in object.
 *
 * Can be used to safely iterate through all properties of the object.
 *
 * @param object  Source object
 * @returns Iterator
 */
function Object_entries(object) {
    return function (push) {
        // TODO make this more efficient ?
        for (var key in object) {
            if (hasKey(object, key)) {
                if (!push([key, object[key]])) {
                    break;
                }
            }
        }
    };
}
/**
 * Returns an array of object's property names.
 *
 * @param object  Source object
 * @returns Object property names
 */
function Object_keys(object) {
    var output = [];
    for (var key in object) {
        if (hasKey(object, key)) {
            output.push(key);
        }
    }
    return output;
}
/**
 * Returns an array of object's property names ordered using specific ordering
 * function.
 *
 * @param object  Source object
 * @param order   Ordering function
 * @returns Object property names
 */
function keysOrdered(object, order) {
    return Object_keys(object).sort(order);
}
/**
 * Checks if `object` has a specific `key`.
 *
 * @param object  Source object
 * @param key     Property name
 * @returns Has key?
 */
function hasKey(object, key) {
    return {}.hasOwnProperty.call(object, key);
}
/**
 * Returns value of the specific `key`.
 *
 * @param object  Source object
 * @param key     Property name
 * @returns Key value
 */
function Object_getKey(object, key) {
    return object[key];
}
/**
 * Iterates through all properties of the object calling `fn` for each of them.
 *
 * If return value of the function evaluates to `false` further iteration is
 * cancelled.
 *
 * @param object  Source object
 * @param fn      Callback function
 */
function Object_eachContinue(object, fn) {
    for (var key in object) {
        if (hasKey(object, key)) {
            if (!fn(key, object[key])) {
                break;
            }
        }
    }
}
/**
 * Iterates through all properties of the object calling `fn` for each of them.
 *
 * @param object  Source object
 * @param fn      Callback function
 */
function Object_each(object, fn) {
    Object_eachContinue(object, function (key, value) {
        fn(key, value);
        return true;
    });
}
/**
 * Orders object properties using custom `ord` function and iterates through
 * them calling `fn` for each of them.
 *
 * @param object  Source object
 * @param fn      Callback function
 * @param order   Ordering function
 */
function eachOrdered(object, fn, ord) {
    each(keysOrdered(object, ord), function (key) {
        fn(key, object[key]);
    });
}
/**
 * Returns a copy of the object.
 *
 * @param object  Source object
 * @returns Copy of the object
 */
function Object_copy(object) {
    return Object.assign({}, object);
}
/**
 * Merges two objects and returns a new object that contains properties from
 * both source objects.
 *
 * @param object1  Source object #1
 * @param object2  Source object #2
 * @returns Combined object
 */
function merge(object1, object2) {
    return Object.assign({}, object1, object2);
}
/**
 * Returns object clone.
 *
 * @param object  Source object
 * @returns       Clone
 */
function Object_clone(object) {
    return JSON.parse(JSON.stringify(object));
}
/**
 * Copies a list of properties from one object to another.
 *
 * Will not copy empty properties.
 *
 * @param source  Source object
 * @param target    Target object
 * @param keys  List of keys to copy
 */
function copyProperties(source, target, keys) {
    each(keys, function (key) {
        if (hasValue(source[key])) {
            target[key] = source[key];
        }
    });
}
/**
 * Copies a list of properties from one object to another only if target does't have value of the property set.
 *
 * Will not copy empty properties.
 *
 * @param source  Source object
 * @param target    Target object
 * @param keys  List of keys to copy
 */
function softCopyProperties(source, target, keys) {
    each(keys, function (key) {
        if (hasValue(source[key]) && !(hasValue(target[key]))) {
            target[key] = source[key];
        }
    });
}
/**
 * Copies a list of properties from one object to another.
 *
 * Will copy empty properties.
 *
 * @param source  Source object
 * @param target    Target object
 * @param keys  List of keys to copy
 */
function forceCopyProperties(source, target, keys) {
    each(keys, function (key) {
        target[key] = source[key];
    });
}
/**
 * Copies all properties from one object to another.
 *
 * @param from  Source object
 * @param to    Target object
 */
function copyAllProperties(from, to) {
    copyProperties(from, to, Object_keys(from));
}
//# sourceMappingURL=Object.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Iterator.js

/**
 * @ignore Exclude from docs
 * @todo Description
 */
function fromArray(array) {
    return function (push) {
        var length = array.length;
        for (var i = 0; i < length; ++i) {
            if (!push(array[i])) {
                break;
            }
        }
    };
}
/**
 * @ignore Exclude from docs
 * @todo Description
 */
function Iterator_length(iter) {
    var sum = 0;
    iter(function (_) {
        ++sum;
        return true;
    });
    return sum;
}
/**
 * @ignore Exclude from docs
 * @todo Description
 */
function Iterator_toArray(iter) {
    var output = [];
    iter(function (value) {
        output.push(value);
        return true;
    });
    return output;
}
/**
 * [iter description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function Iterator_eachContinue(iter, fn) {
    iter(fn);
}
/**
 * [iter description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function Iterator_each(iter, fn) {
    iter(function (value) {
        fn(value);
        return true;
    });
}
/**
 * [iter description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function Iterator_sort(iter, fn) {
    return fromArray(Iterator_toArray(iter).sort(fn));
}
/**
 * [A description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function Iterator_map(iter, fn) {
    return function (push) { return iter(function (value) { return push(fn(value)); }); };
}
/**
 * [iter description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function Iterator_filter(iter, fn) {
    return function (push) { return iter(function (value) {
        if (fn(value)) {
            return push(value);
        }
        else {
            return true;
        }
    }); };
}
/**
 * @ignore Exclude from docs
 * @todo Description
 */
function concat() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (push) {
        var go = true;
        var push2 = function (value) { return (go = push(value)); };
        var length = args.length;
        for (var i = 0; i < length; ++i) {
            args[i](push2);
            if (!go) {
                break;
            }
        }
    };
}
/**
 * @ignore Exclude from docs
 * @todo Description
 */
function flatten(iter) {
    return function (push) {
        var go = true;
        var push2 = function (value) { return (go = push(value)); };
        iter(function (value) {
            value(push2);
            return go;
        });
    };
}
/**
 * [number description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function indexed(iter) {
    return function (push) {
        var index = 0;
        iter(function (value) { return push([index++, value]); });
    };
}
/**
 * [iter description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function Iterator_findIndex(iter, matches) {
    var found = false;
    var i = 0;
    iter(function (value) {
        if (matches(value)) {
            found = true;
            return false;
        }
        else {
            ++i;
            return true;
        }
    });
    return (found ? i : -1);
}
/**
 * [iter description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function Iterator_find(iter, matches) {
    var output;
    iter(function (value) {
        if (matches(value)) {
            output = value;
            return false;
        }
        else {
            return true;
        }
    });
    return output;
}
/**
 * [A description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function findMap(iter, matches) {
    var output;
    iter(function (value) {
        var v = matches(value);
        if (v !== null) {
            output = v;
            return false;
        }
        else {
            return true;
        }
    });
    return output;
}
/**
 * [iter description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function contains(iter, matches) {
    var output = false;
    iter(function (value) {
        if (matches(value)) {
            output = true;
            return false;
        }
        else {
            return true;
        }
    });
    return output;
}
/**
 * [A description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
function foldl(iter, init, fn) {
    iter(function (value) {
        init = fn(init, value);
        return true;
    });
    return init;
}
/**
 * [min2 description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param left [description]
 * @param right [description]
 * @return [description]
 */
function min2(left, right) {
    if (left == null || right < left) {
        return right;
    }
    else {
        return left;
    }
}
/**
 * [min description]
 *
 * @ignore Exclude from docs
 * @todo Verify that this works correctly
 * @todo Description
 * @param a [description]
 * @return [description]
 */
function Iterator_min(a) {
    return foldl(a, null, min2);
}
/**
 * [max2 description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param left [description]
 * @param right [description]
 * @return [description]
 */
function max2(left, right) {
    if (left == null || right > left) {
        return right;
    }
    else {
        return left;
    }
}
/**
 * [max description]
 *
 * @ignore Exclude from docs
 * @todo Verify that this works correctly
 * @todo Description
 * @param a [description]
 * @return [description]
 */
function Iterator_max(a) {
    return foldl(a, null, max2);
}
/**
 * [join description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param iter [description]
 * @param separator [description]
 * @return [description]
 */
function Iterator_join(iter, separator) {
    if (separator === void 0) { separator = ""; }
    var first = true;
    var init = "";
    iter(function (value) {
        if (first) {
            first = false;
        }
        else {
            init += separator;
        }
        init += value;
        return true;
    });
    return init;
}
/**
 * @ignore Exclude from docs
 * @todo Description
 */
var Iterator_ListIterator = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param list [description]
     * @param create [description]
     */
    function ListIterator(list, create) {
        // flag specifies if iterator should create new list item if it is reqested for a nextItem but there is no more left in the list
        this.createNewItems = false;
        this.list = list;
        this._create = create;
        this.reset();
    }
    ListIterator.prototype.reset = function () {
        this._listCopy = Iterator_toArray(this.list.iterator());
    };
    ListIterator.prototype.clear = function () {
        this._listCopy.length = 0;
    };
    ListIterator.prototype.getFirst = function () {
        return this.returnItem(0);
    };
    ListIterator.prototype.getLast = function () {
        return this.returnItem(this._listCopy.length - 1);
    };
    ListIterator.prototype.find = function (fn) {
        var index = findIndex(this._listCopy, fn);
        if (index !== -1) {
            var item = this._listCopy[index];
            // TODO use removeIndex instead ?
            remove(this._listCopy, item);
            return item;
        }
        else {
            return this.getLast();
        }
    };
    ListIterator.prototype.removeItem = function (item) {
        return remove(this._listCopy, item);
    };
    ListIterator.prototype.returnItem = function (index) {
        if (index >= 0 && index < this._listCopy.length) {
            var item = this._listCopy[index];
            // TODO use removeIndex instead ?
            remove(this._listCopy, item);
            return item;
        }
        else if (this.createNewItems) {
            return this._create();
        }
    };
    ListIterator.prototype.iterator = function () {
        return fromArray(this._listCopy);
    };
    return ListIterator;
}());

//# sourceMappingURL=Iterator.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/String.js
/**
 * ============================================================================
 * COMPARING FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Comparing function used for ordering.
 *
 * @ignore Exclude from docs
 * @todo Use localeCompare
 * @param a  Item 1
 * @param b  Item 2
 * @return Result
 */
function order(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
/**
 * ============================================================================
 * OTHER FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Repeats a `string` number of times as set in `amount`.
 *
 * @ignore Exclude from docs
 * @todo Make this faster
 * @param string  Source string
 * @param amount  Number of times to repeat string
 * @return New string
 */
function repeat(string, amount) {
    return new Array(amount + 1).join(string);
}
/**
 * Generates a random string `characters` length.
 *
 * @param chars  Number of characters
 * @return Random string
 */
function random(chars) {
    var res = "";
    var choice = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (var i = 0; i < chars; i++) {
        res += choice.charAt(Math.floor(Math.random() * choice.length));
    }
    return res;
}
//# sourceMappingURL=String.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Dictionary.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * A disposable dictionary, which when disposed itself will call `dispose()`
 * method on all its items.
 */
var Dictionary_DictionaryDisposer = /** @class */ (function (_super) {
    __extends(DictionaryDisposer, _super);
    function DictionaryDisposer(dict) {
        var _this = this;
        var disposer = dict.events.on("removed", function (x) {
            x.oldValue.dispose();
        }, undefined, false);
        _this = _super.call(this, function () {
            disposer.dispose();
            // TODO clear the dictionary ?
            Iterator_each(dict.iterator(), function (a) {
                var v = a[1];
                v.dispose();
            });
        }) || this;
        return _this;
    }
    return DictionaryDisposer;
}(Disposer));

/**
 * A Dictionary is collection where values of some type can be mapped to
 * string keys.
 *
 * You might call it an "associative list" or "associative array".
 */
var Dictionary_Dictionary = /** @class */ (function () {
    /**
     * Constructor
     */
    function Dictionary() {
        /**
         * Event dispatcher.
         */
        this.events = new EventDispatcher_EventDispatcher();
        this._dictionary = {};
    }
    /**
     * Returns `true` if key exists in Dictionary.
     *
     * @param key  The key to search for
     * @return `true` if key exists, `false` if it doesn't
     */
    Dictionary.prototype.hasKey = function (key) {
        return hasKey(this._dictionary, key);
    };
    /**
     * Returns the value for a specific key.
     *
     * @param key  The key to search for
     * @return Value for the key, or `undefined` if it doesn't exist
     */
    Dictionary.prototype.getKey = function (key) {
        return this._dictionary[key];
    };
    /**
     * Inserts value at specific key.
     *
     * Will thrown an exception if the key already exists in the dictionary.
     *
     * @param key    Key
     * @param value  Value
     */
    Dictionary.prototype.insertKey = function (key, value) {
        if (hasKey(this._dictionary, key)) {
            throw new Error("Key " + key + " already exists in dictionary");
        }
        else {
            this._dictionary[key] = value;
            if (this.events.isEnabled("insertKey")) {
                this.events.dispatchImmediately("insertKey", {
                    type: "insertKey",
                    target: this,
                    key: key,
                    newValue: value
                });
            }
        }
    };
    /**
     * Adds or updates key/value into dictionary.
     *
     * If the key already exists, the old value will be overwritten.
     *
     * If the new value is exactly the same as the old value (using ===), it won't do anything.
     *
     * @param key    Key
     * @param value  Value
     */
    Dictionary.prototype.setKey = function (key, value) {
        if (hasKey(this._dictionary, key)) {
            var oldValue = this._dictionary[key];
            if (oldValue !== value) {
                this._dictionary[key] = value;
                if (this.events.isEnabled("setKey")) {
                    this.events.dispatchImmediately("setKey", {
                        type: "setKey",
                        target: this,
                        key: key,
                        oldValue: oldValue,
                        newValue: value
                    });
                }
                if (this.events.isEnabled("removed")) {
                    this.events.dispatchImmediately("removed", {
                        type: "removed",
                        target: this,
                        oldValue: oldValue
                    });
                }
            }
        }
        else {
            this._dictionary[key] = value;
            if (this.events.isEnabled("insertKey")) {
                this.events.dispatchImmediately("insertKey", {
                    type: "insertKey",
                    target: this,
                    key: key,
                    newValue: value
                });
            }
        }
    };
    /**
     * Updates the value at specific `key` using custom function.
     *
     * Passes in current value into the function, and uses its output as a new
     * value.
     *
     * If the new value is exactly the same as the old value (using ===), it won't do anything.
     *
     * @ignore Exclude from docs
     * @param key  Key
     * @param fn   Function to transform the value
     */
    Dictionary.prototype.updateKey = function (key, fn) {
        if (hasKey(this._dictionary, key)) {
            var oldValue = this._dictionary[key];
            var newValue = fn(oldValue);
            if (oldValue !== newValue) {
                this._dictionary[key] = newValue;
                if (this.events.isEnabled("setKey")) {
                    this.events.dispatchImmediately("setKey", {
                        type: "setKey",
                        target: this,
                        key: key,
                        oldValue: oldValue,
                        newValue: newValue
                    });
                }
                if (this.events.isEnabled("removed")) {
                    this.events.dispatchImmediately("removed", {
                        type: "removed",
                        target: this,
                        oldValue: oldValue
                    });
                }
            }
        }
        else {
            throw new Error("Key " + key + " doesn't exist in dictionary");
        }
    };
    /**
     * Removes value at specific `key` from dictionary.
     *
     * @param key  Key to remove
     */
    Dictionary.prototype.removeKey = function (key) {
        if (hasKey(this._dictionary, key)) {
            var oldValue = this._dictionary[key];
            delete this._dictionary[key];
            if (this.events.isEnabled("removeKey")) {
                this.events.dispatchImmediately("removeKey", {
                    type: "removeKey",
                    target: this,
                    key: key,
                    oldValue: oldValue
                });
            }
            if (this.events.isEnabled("removed")) {
                this.events.dispatchImmediately("removed", {
                    type: "removed",
                    target: this,
                    oldValue: oldValue
                });
            }
        }
    };
    /**
     * [insertKeyIfEmpty description]
     *
     * @ignore Exclude from docs
     * @todo description
     * @param key      [description]
     * @param ifEmpty  [description]
     * @return [description]
     */
    Dictionary.prototype.insertKeyIfEmpty = function (key, ifEmpty) {
        if (!this.hasKey(key)) {
            this.insertKey(key, ifEmpty());
        }
        return this.getKey(key);
    };
    /**
     * Removes all items from the dictionary.
     */
    Dictionary.prototype.clear = function () {
        var _this = this;
        // TODO dispatch this after clear
        if (this.events.isEnabled("removed")) {
            Object_each(this._dictionary, function (key, value) {
                _this.events.dispatchImmediately("removed", {
                    type: "removed",
                    target: _this,
                    oldValue: value
                });
            });
        }
        this._dictionary = {};
        if (this.events.isEnabled("cleared")) {
            this.events.dispatchImmediately("cleared", {
                type: "cleared",
                target: this
            });
        }
    };
    /**
     * Copies items from another Dictionary.
     *
     * @param source  A Dictionary to copy items from
     */
    Dictionary.prototype.copyFrom = function (source) {
        var _this = this;
        Iterator_each(source.iterator(), function (a) {
            // TODO fix this type cast
            _this.setKey(a[0], a[1]);
        });
    };
    /**
     * Returns an interator that can be used to iterate through all items in
     * the dictionary.
     *
     * @return Iterator
     */
    Dictionary.prototype.iterator = function () {
        // @todo fix this type after the Iterator bug is fixed
        // https://github.com/Microsoft/TypeScript/issues/16730
        return Object_entries(this._dictionary);
    };
    /**
     * Returns an ES6 iterator for the keys/values of the dictionary.
     */
    Dictionary.prototype[Symbol.iterator] = function () {
        var _a, _b, _i, key;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _a = [];
                    for (_b in this._dictionary)
                        _a.push(_b);
                    _i = 0;
                    _c.label = 1;
                case 1:
                    if (!(_i < _a.length)) return [3 /*break*/, 4];
                    key = _a[_i];
                    if (!hasKey(this._dictionary, key)) return [3 /*break*/, 3];
                    return [4 /*yield*/, [key, this._dictionary[key]]];
                case 2:
                    _c.sent();
                    _c.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    };
    /**
     * Calls `f` for each key/value in the dictionary.
     */
    Dictionary.prototype.each = function (f) {
        Iterator_each(this.iterator(), function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            return f(key, value);
        });
    };
    /**
     * Returns an iterator that can be used to iterate through all items in
     * the dictionary, ordered by key.
     *
     * @ignore Exclude from docs
     * @return Iterator
     */
    Dictionary.prototype.sortedIterator = function () {
        return Iterator_sort(this.iterator(), function (x, y) { return order(x[0], y[0]); });
    };
    return Dictionary;
}());

/**
 * A version of a [[Dictionary]] that has a "template".
 *
 * A template is an instance of an object, that can be used to create new
 * elements in the list without actually needing to create instances for those.
 *
 * When new element is created in the list, e.g. by calling its `create()`
 * method, an exact copy of the element is created (including properties and
 * other attributes), inserted into the list and returned.
 */
var Dictionary_DictionaryTemplate = /** @class */ (function (_super) {
    __extends(DictionaryTemplate, _super);
    /**
     * Constructor
     *
     * @param t Template object
     */
    function DictionaryTemplate(t) {
        var _this = _super.call(this) || this;
        _this.template = t;
        return _this;
    }
    Object.defineProperty(DictionaryTemplate.prototype, "template", {
        /**
         * @return Template object
         */
        get: function () {
            return this._template;
        },
        /**
         * A "template" object to copy all properties from when creating new list
         * items.
         *
         * @param v  Template object
         */
        set: function (v) {
            v.isTemplate = true;
            this._template = v;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all elements from other dictionary.
     *
     * @param source  Source dictionary
     */
    DictionaryTemplate.prototype.copyFrom = function (source) {
        var _this = this;
        Iterator_each(source.iterator(), function (a) {
            // TODO fix this type cast
            // TODO why does this need to clone ?
            _this.setKey(a[0], a[1].clone());
        });
    };
    /**
     * Instantiates a new object of the specified type, adds it to specified
     * `key` in the dictionary, and returns it.
     *
     * @param make  Item type to use. Will use the default type for the dictionary if not specified.
     * @return      Newly created item
     */
    DictionaryTemplate.prototype.create = function (key) {
        var _this = this;
        return this.insertKeyIfEmpty(key, function () { return _this.template.clone(); });
    };
    return DictionaryTemplate;
}(Dictionary_Dictionary));

//# sourceMappingURL=Dictionary.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Cache.js
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Represents object cache.
 *
 * @ignore Exclude from docs
 * @todo Better storage
 * @todo TTL logging
 * @todo Garbage collector
 */
var Cache_Cache = /** @class */ (function () {
    function Cache() {
        /**
         * Storage for cache items.
         */
        this._storage = new Dictionary_Dictionary();
        /**
         * Default TTL in milliseconds.
         */
        this.ttl = 1000;
    }
    /**
     * Caches or updates cached value, resets TTL.
     *
     * If `ttl` is set to zero, item will never expire.
     *
     * @param owner  An id of the object that owns this cache
     * @param key    Index key
     * @param value  Value
     * @param ttl    TTL of the cache to live in milliseconds
     */
    Cache.prototype.set = function (owner, key, value, ttl) {
        // Create if storage does not exist for this owner
        var ownerStorage = this._storage.insertKeyIfEmpty(owner, function () { return new Dictionary_Dictionary(); });
        // Create cache item
        var item = {
            "touched": new Date().getTime(),
            "ttl": isNumber(ttl) ? ttl : this.ttl,
            "value": value
        };
        // Set
        ownerStorage.setKey(key, item);
    };
    /**
     * Rerturns cached item, respecting TTL.
     *
     * @param owner  An id of the object that owns this cache
     * @param key    Index key
     * @param value  Value to return if cache not available
     * @return Value, or `undefined` if not set
     */
    Cache.prototype.get = function (owner, key, value) {
        if (value === void 0) { value = undefined; }
        // 		 || ypeof this._storage[owner][key] === "undefined" || this._storage[owner][key].expired === true) {
        if (this._storage.hasKey(owner)) {
            var ownerStorage = this._storage.getKey(owner);
            if (ownerStorage.hasKey(key)) {
                var cacheItem = ownerStorage.getKey(key);
                if (cacheItem.ttl && ((cacheItem.touched + cacheItem.ttl) < new Date().getTime())) {
                    cacheItem.expired = true;
                }
                if (cacheItem.expired) {
                    ownerStorage.removeKey(key);
                    return value;
                }
                return cacheItem.value;
            }
            else {
                return value;
            }
        }
        else {
            return value;
        }
    };
    /**
     * Clears cache for specific owner or everything.
     *
     * @param owner Owner to clear cache for
     */
    Cache.prototype.clear = function (owner) {
        if (owner) {
            this._storage.removeKey(owner);
        }
        else {
            this._storage.clear();
        }
    };
    return Cache;
}());

/**
 * ============================================================================
 * GLOBAL INSTANCE
 * ============================================================================
 * @hidden
 */
/**
 * A global instance of cache. Use this instance to cache any values.
 *
 * @ignore Exclude from docs
 */
var Cache_cache = new Cache_Cache();
//# sourceMappingURL=Cache.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/Registry.js






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Registry is used to store miscellaneous system-wide information, like ids,
 * maps, themes, and registered classes.
 *
 * @ignore Exclude from docs
 */
var Registry_Registry = /** @class */ (function () {
    function Registry() {
        /**
         * Event dispacther.
         */
        this.events = new EventDispatcher_EventDispatcher();
        /**
         * All currently applied themes. All new chart instances created will
         * automatically inherit and retain System's themes.
         */
        this.themes = [];
        /**
         * List of all loaded available themes.
         *
         * Whenever a theme loads, it registers itself in System's `loadedThemes`
         * collection.
         */
        this.loadedThemes = {};
        /**
         * An indeternal counter used to generate unique IDs.
         *
         * @ignore Exclude from docs
         */
        this._uidCount = 0;
        /**
         * Keeps register of class references so that they can be instnatiated using
         * string key.
         *
         * @ignore Exclude from docs
         */
        this.registeredClasses = {};
        /**
         * Holds all generated placeholders.
         */
        this._placeholders = {};
        /**
         * A list of invalid(ated) [[Sprite]] objects that need to be re-validated
         * during next cycle.
         *
         * @ignore Exclude from docs
         */
        this.invalidSprites = {};
        /**
         * Components are added to this list when their data provider changes to
         * a new one or data is added/removed from their data provider.
         *
         * @ignore Exclude from docs
         */
        this.invalidDatas = {};
        /**
         * Components are added to this list when values of their raw data change.
         * Used when we want a smooth animation from one set of values to another.
         *
         * @ignore Exclude from docs
         */
        this.invalidRawDatas = [];
        /**
         * Components are added to this list when values of their data changes
         * (but not data provider itself).
         *
         * @ignore Exclude from docs
         */
        this.invalidDataItems = [];
        /**
         * Components are added to this list when their data range (selection) is
         * changed, e.g. zoomed.
         *
         * @ignore Exclude from docs
         */
        this.invalidDataRange = [];
        /**
         * A list of [[Sprite]] objects that have invalid(ated) positions, that need
         * to be recalculated.
         *
         * @ignore Exclude from docs
         */
        this.invalidPositions = {};
        /**
         * A list of [[Container]] objects with invalid(ated) layouts.
         *
         * @ignore Exclude from docs
         */
        this.invalidLayouts = {};
        /**
         * An array holding all active (non-disposed) top level elemens.
         *
         * When, for example, a new chart is created, its instance will be added to
         * this array, and will be removed when the chart is disposed.
         */
        this.baseSprites = [];
        this.baseSpritesByUid = {};
        this.queue = [];
        this.uid = this.getUniqueId();
        this.invalidSprites.noBase = [];
        this.invalidDatas.noBase = [];
        this.invalidLayouts.noBase = [];
        this.invalidPositions.noBase = [];
    }
    /**
     * Generates a unique chart system-wide ID.
     *
     * @return Generated ID
     */
    Registry.prototype.getUniqueId = function () {
        var uid = this._uidCount;
        this._uidCount += 1;
        return "id-" + uid;
    };
    Object.defineProperty(Registry.prototype, "map", {
        /**
         * Returns a universal collection for mapping ids with objects.
         *
         * @ignore Exclude from docs
         * @return Map collection
         */
        get: function () {
            if (!this._map) {
                this._map = new Dictionary_Dictionary();
            }
            return this._map;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Caches value in object's cache.
     *
     * @ignore Exclude from docs
     * @param key    Key
     * @param value  Value
     * @param ttl    TTL in seconds
     */
    Registry.prototype.setCache = function (key, value, ttl) {
        Cache_cache.set(this.uid, key, value, ttl);
    };
    /**
     * Retrieves cached value.
     *
     * @ignore Exclude from docs
     * @param key    Key
     * @param value  Value to return if cache is not available
     * @return Value
     */
    Registry.prototype.getCache = function (key, value) {
        if (value === void 0) { value = undefined; }
        return Cache_cache.get(this.uid, key, value);
    };
    /**
     * Dispatches an event using own event dispatcher. Will automatically
     * populate event data object with event type and target (this element).
     * It also checks if there are any handlers registered for this sepecific
     * event.
     *
     * @param eventType Event type (name)
     * @param data      Data to pass into event handler(s)
     */
    Registry.prototype.dispatch = function (eventType, data) {
        // @todo Implement proper type check
        if (this.events.isEnabled(eventType)) {
            if (data) {
                data.type = eventType;
                data.target = data.target || this;
                this.events.dispatch(eventType, {
                    type: eventType,
                    target: this
                });
            }
            else {
                this.events.dispatch(eventType, {
                    type: eventType,
                    target: this
                });
            }
        }
    };
    /**
     * Works like `dispatch`, except event is triggered immediately, without
     * waiting for the next frame cycle.
     *
     * @param eventType Event type (name)
     * @param data      Data to pass into event handler(s)
     */
    Registry.prototype.dispatchImmediately = function (eventType, data) {
        // @todo Implement proper type check
        if (this.events.isEnabled(eventType)) {
            if (data) {
                data.type = eventType;
                data.target = data.target || this;
                this.events.dispatchImmediately(eventType, data);
            }
            else {
                this.events.dispatchImmediately(eventType, {
                    type: eventType,
                    target: this
                });
            }
        }
    };
    /**
     * Returns a unique placeholder suitable for the key.
     *
     * @param key  Key
     * @return Random string to be used as placeholder
     */
    Registry.prototype.getPlaceholder = function (key) {
        if (hasValue(this._placeholders[key])) {
            return this._placeholders[key];
        }
        this._placeholders[key] = "__amcharts_" + key + "_" + random(8) + "__";
        return this._placeholders[key];
    };
    /**
     * @ignore
     */
    Registry.prototype.addToInvalidComponents = function (component) {
        if (component.baseId) {
            move(this.invalidDatas[component.baseId], component);
        }
        else {
            move(this.invalidDatas["noBase"], component);
        }
    };
    /**
     * @ignore
     */
    Registry.prototype.removeFromInvalidComponents = function (component) {
        if (component.baseId) {
            remove(this.invalidDatas[component.baseId], component);
        }
        remove(this.invalidDatas["noBase"], component);
    };
    /**
     * @ignore
     */
    Registry.prototype.addToInvalidSprites = function (sprite) {
        if (sprite.baseId) {
            Array_add(this.invalidSprites[sprite.baseId], sprite);
        }
        else {
            Array_add(this.invalidSprites["noBase"], sprite);
        }
    };
    /**
     * @ignore
     */
    Registry.prototype.removeFromInvalidSprites = function (sprite) {
        if (sprite.baseId) {
            remove(this.invalidSprites[sprite.baseId], sprite);
        }
        remove(this.invalidSprites["noBase"], sprite);
    };
    /**
     * @ignore
     */
    Registry.prototype.addToInvalidPositions = function (sprite) {
        if (sprite.baseId) {
            Array_add(this.invalidPositions[sprite.baseId], sprite);
        }
        else {
            Array_add(this.invalidPositions["noBase"], sprite);
        }
    };
    /**
     * @ignore
     */
    Registry.prototype.removeFromInvalidPositions = function (sprite) {
        if (sprite.baseId) {
            remove(this.invalidPositions[sprite.baseId], sprite);
        }
        remove(this.invalidPositions["noBase"], sprite);
    };
    /**
     * @ignore
     */
    Registry.prototype.addToInvalidLayouts = function (sprite) {
        if (sprite.baseId) {
            Array_add(this.invalidLayouts[sprite.baseId], sprite);
        }
        else {
            Array_add(this.invalidLayouts["noBase"], sprite);
        }
    };
    /**
     * @ignore
     */
    Registry.prototype.removeFromInvalidLayouts = function (sprite) {
        if (sprite.baseId) {
            remove(this.invalidLayouts[sprite.baseId], sprite);
        }
        remove(this.invalidLayouts["noBase"], sprite);
    };
    return Registry;
}());

/**
 * A singleton global instance of [[Registry]].
 *
 * @ignore Exclude from docs
 */
var registry = new Registry_Registry();
/**
 * Returns `true` if object is an instance of the class. It's the same as `instanceof` except it doesn't need to import the class.
 *
 * @param object Object
 * @param name Class name
 * @return Is instance of class
 */
function is(object, name) {
    var x = registry.registeredClasses[name];
    return x != null && object instanceof x;
}
//# sourceMappingURL=Registry.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/List.js





/**
 * @todo Description
 */
var IndexedIterable = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param array  List items
     * @param start  Start index
     * @param end    End index
     */
    function IndexedIterable(array, start, end) {
        this._array = array;
        this._start = start;
        this._end = end;
    }
    /**
     * Returns a list item iterator.
     *
     * @return Iterator
     */
    IndexedIterable.prototype.iterator = function () {
        var _this = this;
        return function (push) {
            if (_this._start !== _this._end) {
                if (_this._start < _this._end) {
                    for (var i = _this._start; i < _this._end; ++i) {
                        if (!push(_this._array[i])) {
                            break;
                        }
                    }
                }
                else {
                    for (var i = _this._start - 1; i >= _this._end; --i) {
                        if (!push(_this._array[i])) {
                            break;
                        }
                    }
                }
            }
        };
    };
    /**
     * Returns an interable list sorted backwards than current list.
     *
     * @return List
     */
    IndexedIterable.prototype.backwards = function () {
        return new IndexedIterable(this._array, this._end, this._start);
    };
    /**
     * Returns a new list consisting only of specific range of items between
     * `start` and `end` indexes.
     *
     * @param start  Start index
     * @param end    End index
     * @return List
     */
    IndexedIterable.prototype.range = function (start, end) {
        if (start <= end) {
            if (this._start === this._end) {
                return this;
            }
            else if (this._start < this._end) {
                var diff = end - start;
                start = Math.max(this._start + start, this._start);
                end = Math.min(start + diff, this._end);
                return new IndexedIterable(this._array, start, end);
            }
            else {
                var diff = end - start;
                start = Math.max(this._start - start, this._end);
                end = Math.max(start - diff, this._end);
                return new IndexedIterable(this._array, start, end);
            }
        }
        else {
            throw new Error("Start index must be lower than end index");
        }
    };
    return IndexedIterable;
}());

/**
 * ListGrouper organizes [[List]] items into groups.
 *
 * @ignore Exclude from docs
 */
var List_ListGrouper = /** @class */ (function (_super) {
    __extends(ListGrouper, _super);
    /**
     * Constructor.
     */
    function ListGrouper(list, getKey, sort) {
        var _this = _super.call(this, [
            list.events.on("inserted", function (x) {
                var value = x.newValue;
                var key = _this._getKey(value);
                var index = 0;
                Iterator_eachContinue(list.iterator(), function (x) {
                    if (x === value) {
                        return false;
                    }
                    else if (_this._getKey(x) === key) {
                        ++index;
                    }
                    return true;
                });
                _this._insert(value, key, index);
            }, undefined, false),
            list.events.on("removed", function (x) {
                _this._remove(x.oldValue);
            }, undefined, false)
        ]) || this;
        /**
         * Grouping keys.
         */
        _this._keys = [];
        /**
         * List item groups.
         */
        _this._groups = {};
        _this._getKey = getKey;
        _this._sort = sort;
        Iterator_each(list.iterator(), function (x) {
            _this._insert(x, getKey(x));
        });
        return _this;
    }
    /**
     * Inserts an item (`x`) to a specific group (`key`) and specific `index`.
     *
     * @param x      Item
     * @param key    Group name
     * @param index  Index
     */
    ListGrouper.prototype._insert = function (x, key, index) {
        if (this._groups[key] == null) {
            this._groups[key] = [];
            // TODO code duplication with SortedList
            var _a = getSortedIndex(this._keys, this._sort, key), found = _a.found, index_1 = _a.index;
            if (found) {
                throw new Error("Key already exists: " + key);
            }
            else {
                insertIndex(this._keys, index_1, key);
            }
        }
        if (index == null) {
            this._groups[key].push(x);
        }
        else {
            insertIndex(this._groups[key], index, x);
        }
    };
    /**
     * Removes an item from the list.
     *
     * @param x Item to remove
     */
    ListGrouper.prototype._remove = function (x) {
        var key = this._getKey(x);
        var values = this._groups[key];
        if (values != null) {
            remove(values, x);
            if (values.length === 0) {
                delete this._groups[key];
                var _a = getSortedIndex(this._keys, this._sort, key), found = _a.found, index = _a.index;
                if (found) {
                    removeIndex(this._keys, index);
                }
                else {
                    throw new Error("Key doesn't exist: " + key);
                }
            }
        }
    };
    /**
     * Returns an iterator for the list.
     *
     * The iterator will iterate through all items in all groups.
     *
     * @return Iterator
     */
    ListGrouper.prototype.iterator = function () {
        var _this = this;
        return flatten(Iterator_map(fromArray(this._keys), function (key) {
            return fromArray(_this._groups[key]);
        }));
    };
    return ListGrouper;
}(Disposer_MultiDisposer));

/**
 * A disposable list, which when disposed itself will call `dispose()` method
 * on all its items.
 */
var List_ListDisposer = /** @class */ (function (_super) {
    __extends(ListDisposer, _super);
    function ListDisposer(list, disposeOnRemove) {
        if (disposeOnRemove === void 0) { disposeOnRemove = true; }
        var _this = this;
        if (disposeOnRemove) {
            var disposer_1 = list.events.on("removed", function (x) {
                x.oldValue.dispose();
            }, undefined, false);
            _this = _super.call(this, function () {
                disposer_1.dispose();
                // TODO clear the list ?
                Iterator_each(list.iterator(), function (x) {
                    x.dispose();
                });
            }) || this;
        }
        else {
            _this = _super.call(this, function () {
                // TODO clear the list ?
                Iterator_each(list.iterator(), function (x) {
                    x.dispose();
                });
            }) || this;
        }
        return _this;
    }
    return ListDisposer;
}(Disposer));

/**
 * Checks if specific index fits into length.
 *
 * @param index  Index
 * @param len    Length
 */
function checkBounds(index, len) {
    if (!(index >= 0 && index < len)) {
        throw new Error("Index out of bounds: " + index);
    }
}
/**
 * A List class is used to hold a number of indexed items of the same type.
 */
var List_List = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param initial  Inital list of values to add to list
     */
    function List(initial) {
        if (initial === void 0) { initial = []; }
        /**
         * Event dispatcher.
         */
        this.events = new EventDispatcher_EventDispatcher();
        this._values = initial;
    }
    Object.defineProperty(List.prototype, "values", {
        /**
         * An array of values in the list.
         *
         * Do not use this property to add values. Rather use dedicated methods, like
         * `push()`, `removeIndex()`, etc.
         *
         * @readonly
         * @return List values
         */
        get: function () {
            return this._values;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if list contains specific item reference.
     *
     * @param item  Item to search for
     * @return `true` if found, `false` if not found
     */
    List.prototype.contains = function (value) {
        return this._values.indexOf(value) !== -1;
    };
    /**
     * Removes specific item from the list.
     *
     * @param item An item to remove
     */
    List.prototype.removeValue = function (value) {
        var i = 0;
        var length = this._values.length;
        while (i < length) {
            // TODO handle NaN
            if (this._values[i] === value) {
                this.removeIndex(i);
                --length;
            }
            else {
                ++i;
            }
        }
    };
    /**
     * Searches the list for specific item and returns its index.
     *
     * @param item  An item to search for
     * @return Index or -1 if not found
     */
    List.prototype.indexOf = function (value) {
        return indexOf(this._values, value);
    };
    Object.defineProperty(List.prototype, "length", {
        /**
         * Number of items in list.
         *
         * @readonly
         * @return Number of items
         */
        get: function () {
            return this._values.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if there's a value at specific index.
     *
     * @param index  Index
     * @return Value exists?
     */
    List.prototype.hasIndex = function (index) {
        return index >= 0 && index < this._values.length;
    };
    /**
     * Returns an item at specified index.
     *
     * @param index  Index
     * @return List item
     */
    List.prototype.getIndex = function (index) {
        return this._values[index];
    };
    /**
     * Sets value at specific index.
     *
     * If there's already a value at the index, it is overwritten.
     *
     * @param index  Index
     * @param value  New value
     * @return New value
     */
    List.prototype.setIndex = function (index, value) {
        checkBounds(index, this._values.length);
        var oldValue = this._values[index];
        // Do nothing if the old value and the new value are the same
        if (oldValue !== value) {
            this._values[index] = value;
            if (this.events.isEnabled("setIndex")) {
                this.events.dispatchImmediately("setIndex", {
                    type: "setIndex",
                    target: this,
                    index: index,
                    oldValue: oldValue,
                    newValue: value
                });
            }
            if (this.events.isEnabled("removed")) {
                this.events.dispatchImmediately("removed", {
                    type: "removed",
                    target: this,
                    oldValue: oldValue
                });
            }
            if (this.events.isEnabled("inserted")) {
                this.events.dispatchImmediately("inserted", {
                    type: "inserted",
                    target: this,
                    newValue: value
                });
            }
        }
        return oldValue;
    };
    /**
     * Adds an item to the list at a specific index, which pushes all the other
     * items further down the list.
     *
     * @param index Index
     * @param item  An item to add
     */
    List.prototype.insertIndex = function (index, value) {
        checkBounds(index, this._values.length + 1);
        insertIndex(this._values, index, value);
        if (this.events.isEnabled("insertIndex")) {
            this.events.dispatchImmediately("insertIndex", {
                type: "insertIndex",
                target: this,
                index: index,
                newValue: value
            });
        }
        if (this.events.isEnabled("inserted")) {
            this.events.dispatchImmediately("inserted", {
                type: "inserted",
                target: this,
                newValue: value
            });
        }
    };
    /**
     * [_sortQuicksort description]
     *
     * @todo Description
     * @param low    [description]
     * @param high   [description]
     * @param order  [description]
     */
    List.prototype._sortQuicksort = function (low, high, order) {
        if (low < high) {
            var p = this._sortPartition(low, high, order);
            this._sortQuicksort(low, p, order);
            this._sortQuicksort(p + 1, high, order);
        }
    };
    /**
     * [_sortPartition description]
     *
     * @todo Description
     * @param low    [description]
     * @param high   [description]
     * @param order  [description]
     * @return [description]
     */
    List.prototype._sortPartition = function (low, high, order) {
        var values = this._values;
        var pivot = values[low];
        var i = low - 1;
        var j = high + 1;
        for (;;) {
            do {
                ++i;
            } while (order(values[i], pivot) < 0);
            do {
                --j;
            } while (order(values[j], pivot) > 0);
            if (i >= j) {
                return j;
            }
            else {
                this.swap(i, j);
            }
        }
    };
    /**
     * Reorders list items according to specific ordering function.
     *
     * @param order  Ordering function
     */
    List.prototype.sort = function (order) {
        // https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme
        // @todo faster implementation of this
        // @todo test this
        this._sortQuicksort(0, this._values.length - 1, order);
    };
    /**
     * Swaps indexes of two items in the list.
     *
     * @param a  Item 1
     * @param b  Item 2
     */
    List.prototype.swap = function (a, b) {
        var len = this._values.length;
        checkBounds(a, len);
        checkBounds(b, len);
        if (a !== b) {
            var value_a = this._values[a];
            var value_b = this._values[b];
            this._values[a] = value_b;
            if (this.events.isEnabled("setIndex")) {
                this.events.dispatchImmediately("setIndex", {
                    type: "setIndex",
                    target: this,
                    index: a,
                    oldValue: value_a,
                    newValue: value_b
                });
            }
            this._values[b] = value_a;
            if (this.events.isEnabled("setIndex")) {
                this.events.dispatchImmediately("setIndex", {
                    type: "setIndex",
                    target: this,
                    index: b,
                    oldValue: value_b,
                    newValue: value_a
                });
            }
        }
    };
    /**
     * Removes a value at specific index.
     *
     * @param index  Index of value to remove
     * @return Removed value
     */
    List.prototype.removeIndex = function (index) {
        checkBounds(index, this._values.length);
        var oldValue = this._values[index];
        removeIndex(this._values, index);
        if (this.events.isEnabled("removeIndex")) {
            this.events.dispatchImmediately("removeIndex", {
                type: "removeIndex",
                target: this,
                index: index,
                oldValue: oldValue
            });
        }
        if (this.events.isEnabled("removed")) {
            this.events.dispatchImmediately("removed", {
                type: "removed",
                target: this,
                oldValue: oldValue
            });
        }
        return oldValue;
    };
    /**
     * Moves an item to a specific index within the list.
     *
     * If the index is not specified it will move the item to the end of the
     * list.
     *
     * @param value  Item to move
     * @param index  Index to place item at
     */
    List.prototype.moveValue = function (value, toIndex) {
        // TODO don't do anything if the desired index is the same as the current index
        var index = this.indexOf(value);
        // TODO remove all old values rather than only the first ?
        if (index !== -1) {
            var oldValue = this._values[index];
            removeIndex(this._values, index);
            if (this.events.isEnabled("removeIndex")) {
                this.events.dispatchImmediately("removeIndex", {
                    type: "removeIndex",
                    target: this,
                    index: index,
                    oldValue: oldValue
                });
            }
        }
        if (toIndex == null) {
            toIndex = this._values.length;
            this._values.push(value);
        }
        else {
            insertIndex(this._values, toIndex, value);
        }
        if (this.events.isEnabled("insertIndex")) {
            this.events.dispatchImmediately("insertIndex", {
                type: "insertIndex",
                target: this,
                index: toIndex,
                newValue: value
            });
        }
        if (index === -1) {
            if (this.events.isEnabled("inserted")) {
                this.events.dispatchImmediately("inserted", {
                    type: "inserted",
                    target: this,
                    newValue: value
                });
            }
        }
    };
    /**
     * Adds an item to the end of the list.
     *
     * @param item  An item to add
     */
    List.prototype.push = function (value) {
        var index = this._values.push(value) - 1;
        if (this.events.isEnabled("insertIndex")) {
            this.events.dispatchImmediately("insertIndex", {
                type: "insertIndex",
                target: this,
                index: index,
                newValue: value
            });
        }
        if (this.events.isEnabled("inserted")) {
            this.events.dispatchImmediately("inserted", {
                type: "inserted",
                target: this,
                newValue: value
            });
        }
        return value;
    };
    /**
     * Adds an item as a first item in the list.
     *
     * @param item  An item to add
     */
    List.prototype.unshift = function (value) {
        this.insertIndex(0, value);
    };
    /**
     * Adds multiple items to the list.
     *
     * @param items  An Array of items to add
     */
    List.prototype.pushAll = function (values) {
        var _this = this;
        each(values, function (value) {
            _this.push(value);
        });
    };
    /**
     * Copies and adds items from abother list.
     *
     * @param source  A list top copy items from
     */
    List.prototype.copyFrom = function (source) {
        this.pushAll(source._values);
    };
    /**
     * Returns the last item from the list, and removes it.
     *
     * @return Item
     */
    List.prototype.pop = function () {
        var index = this._values.length - 1;
        return index < 0 ? undefined : this.removeIndex(this._values.length - 1);
    };
    /**
     * Returns the first item from the list, and removes it.
     *
     * @return Item
     */
    List.prototype.shift = function () {
        return this._values.length ? this.removeIndex(0) : undefined;
    };
    /**
     * Sets multiple items to the list.
     *
     * All current items are removed.
     *
     * @param newArray  New items
     */
    List.prototype.setAll = function (newArray) {
        var _this = this;
        // @tod if a value exists in both the new and old arrays, don't send remove/insert events
        var oldArray = copy(this._values);
        this._values.length = 0;
        each(newArray, function (value) {
            _this._values.push(value);
        });
        if (this.events.isEnabled("setAll")) {
            this.events.dispatchImmediately("setAll", {
                type: "setAll",
                target: this,
                oldArray: oldArray,
                newArray: this._values // TODO make a copy ?
            });
        }
        if (this.events.isEnabled("removed")) {
            each(oldArray, function (x) {
                _this.events.dispatchImmediately("removed", {
                    type: "removed",
                    target: _this,
                    oldValue: x
                });
            });
        }
        if (this.events.isEnabled("inserted")) {
            each(this._values, function (x) {
                _this.events.dispatchImmediately("inserted", {
                    type: "inserted",
                    target: _this,
                    newValue: x
                });
            });
        }
    };
    /**
     * Removes all items from the list.
     */
    List.prototype.clear = function () {
        this.setAll([]);
    };
    /**
     * Returns a list iterator.
     *
     * @return Iterator
     */
    List.prototype.iterator = function () {
        return fromArray(this._values);
    };
    /**
     * Returns an ES6 iterator for the list.
     */
    List.prototype[Symbol.iterator] = function () {
        var length, i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    length = this._values.length;
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < length)) return [3 /*break*/, 4];
                    return [4 /*yield*/, this._values[i]];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    ++i;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    };
    /**
     * Calls `f` for each element in the list.
     *
     * `f` should have at least one parameter defined which will get a current
     * item, with optional second argument - index.
     */
    List.prototype.each = function (f) {
        each(this._values, f);
    };
    /**
     * Returns a specific range of list items, which can be iterated.
     *
     * @ignore Exclude from docs
     * @todo Code duplication with IndexedIterable
     * @param start  Start index
     * @param end    End index
     * @return Range
     */
    List.prototype.range = function (start, end) {
        if (start <= end) {
            var diff = end - start;
            start = Math.max(start, 0);
            end = Math.min(start + diff, this._values.length);
            return new IndexedIterable(this._values, start, end);
        }
        else {
            throw new Error("Start index must be lower than end index");
        }
    };
    /**
     * Returns an iterator that has list items sorted backwards.
     *
     * @ignore Exclude from docs
     * @return List
     */
    List.prototype.backwards = function () {
        return new IndexedIterable(this._values, this._values.length, 0);
    };
    return List;
}());

/**
 * A version of a [[List]] that has a "template".
 *
 * A template is an instance of an object, that can be used to create new
 * elements in the list without actually needing to create instances for those.
 *
 * When new element is created in the list, e.g. by calling its `create()`
 * method, an exact copy of the element is created (including properties and
 * other attributes), inserted into the list and returned.
 */
var List_ListTemplate = /** @class */ (function (_super) {
    __extends(ListTemplate, _super);
    /**
     * Constructor
     *
     * @param t Template object
     */
    function ListTemplate(t) {
        var _this = _super.call(this) || this;
        _this.template = t;
        return _this;
    }
    Object.defineProperty(ListTemplate.prototype, "template", {
        /**
         * @return Template object
         */
        get: function () {
            return this._template;
        },
        /**
         * A "template" object to copy all properties from when creating new list
         * items.
         *
         * @param v  Template object
         */
        set: function (v) {
            v.isTemplate = true;
            this._template = v;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all elements from other list.
     *
     * @param source  Source list
     */
    ListTemplate.prototype.copyFrom = function (source) {
        var _this = this;
        Iterator_each(source.iterator(), function (value) {
            _this.push(value.clone());
        });
    };
    ListTemplate.prototype.create = function (make) {
        var clone = (make != null
            ? new make()
            : this.template.clone());
        this.push(clone);
        return clone;
    };
    /**
     * Creates an exact clone of the list, including its items and template.
     *
     * @return New list
     */
    ListTemplate.prototype.clone = function () {
        var out = new ListTemplate(this.template);
        var values = this.values;
        var length = values.length;
        for (var i = 0; i < length; ++i) {
            out.push(values[i].clone());
        }
        return out;
    };
    return ListTemplate;
}(List_List));

//# sourceMappingURL=List.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/SortedList.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * Ordered list contains values of any type in an indexed array.
 */
var SortedList_OrderedList = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param initial  Inital list of values to add to list
     */
    function OrderedList(initial) {
        /**
         * Holds list values.
         */
        this._values = [];
        /**
         * Event dispatcher.
         */
        this.events = new EventDispatcher_EventDispatcher();
        if (initial != null) {
            this.setAll(initial);
        }
    }
    Object.defineProperty(OrderedList.prototype, "values", {
        /**
         * All items of the list.
         *
         * Do not modify the list directly. Rather use `insert()` and `remove()`
         * methods.
         *
         * @return List values
         */
        get: function () {
            return this._values;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Inserts a value into list item array.
     *
     * @param value  Value
     */
    OrderedList.prototype._insert = function (value) {
        this._values.push(value);
        return this._values.length - 1;
    };
    Object.defineProperty(OrderedList.prototype, "length", {
        /**
         * Number of items in the list.
         *
         * @readonly
         * @return Length
         */
        get: function () {
            return this._values.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the index of the specific `value`.
     *
     * -1 if not found.
     *
     * @param value  Value
     * @return Index
     */
    OrderedList.prototype.indexOf = function (value) {
        return indexOf(this._values, value);
    };
    /**
     * Checks if list contains the `value`.
     *
     * @param value  Value
     * @return In the list?
     */
    OrderedList.prototype.contains = function (value) {
        return this.indexOf(value) !== -1;
    };
    /**
     * Returns an item at specific `index`.
     *
     * @param index  Index
     * @return Item
     */
    OrderedList.prototype.getIndex = function (index) {
        return this._values[index];
    };
    Object.defineProperty(OrderedList.prototype, "first", {
        /**
         * First item in the list.
         *
         * @return Item
         */
        get: function () {
            return this._values[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OrderedList.prototype, "last", {
        /**
         * Last item in the list.
         *
         * @return Item
         */
        get: function () {
            return this._values[this._values.length - 1];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Inserts a value into list.
     *
     * @param value  Value
     */
    OrderedList.prototype.insert = function (value) {
        var index = this._insert(value);
        if (this.events.isEnabled("inserted")) {
            this.events.dispatchImmediately("inserted", {
                type: "inserted",
                target: this,
                index: index,
                newValue: value
            });
        }
    };
    /**
     * Removes an item with the `value` from the list.
     *
     * @param value  Value
     */
    OrderedList.prototype.remove = function (value) {
        var index = this.indexOf(value);
        if (index !== -1) {
            var oldValue = this._values[index];
            removeIndex(this._values, index);
            if (this.events.isEnabled("removed")) {
                this.events.dispatchImmediately("removed", {
                    type: "removed",
                    target: this,
                    index: index,
                    oldValue: oldValue,
                });
            }
        }
    };
    /**
     * Sets multiple items to the list.
     *
     * All current items are removed.
     *
     * @param newArray  New items
     */
    OrderedList.prototype.setAll = function (newArray) {
        var _this = this;
        eachReverse(this._values, function (x, i) {
            _this._values.pop();
            if (_this.events.isEnabled("removed")) {
                _this.events.dispatchImmediately("removed", {
                    type: "removed",
                    target: _this,
                    index: i,
                    oldValue: x
                });
            }
        });
        each(newArray, function (value) {
            _this.insert(value);
        });
    };
    /**
     * Removes all items from the list.
     */
    OrderedList.prototype.clear = function () {
        this.setAll([]);
    };
    /**
     * Returns part of the list between `start` and `end` indexes, as a new
     * [[OrderedList]].
     *
     * @param start  Start index
     * @param end    End index
     * @return Items in range
     */
    OrderedList.prototype.slice = function (start, end) {
        var out = new OrderedList();
        out._values = this._values.slice(start, end);
        return out;
    };
    /**
     * Finds a closest available index to the `value` in specified direction.
     *
     * @ignore exclude from docs
     * @param value      value to search for
     * @param fn         A callback function that returns value of the item
     * @param direction  Direciton
     * @return Index
     */
    OrderedList.prototype.findClosestIndex = function (value, fn, direction) {
        if (direction === void 0) { direction = "any"; }
        // Init temporary values
        var closestIndex = -1;
        var closestValue;
        var closestDifference;
        var i = 0;
        Iterator_eachContinue(this.iterator(), function (element) {
            var item = fn(element);
            // Calc difference
            if (direction === "any") {
                // Exact match?
                if (item === value) {
                    // Found exact value - don't bother searching further
                    closestIndex = i;
                    return false;
                }
                var difference = Math.abs(value - item);
                if (!hasValue(closestDifference) || (closestDifference > difference)) {
                    closestIndex = i;
                    closestValue = item;
                    closestDifference = difference;
                }
            }
            else if (direction === "left" && (item < value)) {
                if (!hasValue(closestValue) || (closestValue < item)) {
                    closestIndex = i;
                    closestValue = item;
                }
            }
            else if (direction === "right" && (item >= value)) {
                if (!hasValue(closestValue) || (closestValue >= item)) {
                    closestIndex = i;
                    closestValue = item;
                }
            }
            ++i;
            return true;
        });
        // Found nothing?
        if (closestIndex === -1) {
            if (direction === "left") {
                // Use First one
                closestIndex = 0;
            }
            else if (direction === "right") {
                // Use last item
                closestIndex = this.length - 1;
            }
        }
        return closestIndex;
    };
    /**
     * Returns a list iterator.
     *
     * @return Iterator
     */
    OrderedList.prototype.iterator = function () {
        return fromArray(this._values);
    };
    /**
     * Returns an ES6 iterator for the list.
     */
    OrderedList.prototype[Symbol.iterator] = function () {
        var length, i;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    length = this._values.length;
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < length)) return [3 /*break*/, 4];
                    return [4 /*yield*/, this._values[i]];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    ++i;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    };
    /**
     * Calls `f` for each element in the list.
     */
    OrderedList.prototype.each = function (f) {
        each(this._values, f);
    };
    return OrderedList;
}());

/**
 * A list where all items are ordered according to specific ordering function,
 * which is passed in via constructor parameter, when creating an instance of
 * [[SortedList]].
 */
var SortedList_SortedList = /** @class */ (function (_super) {
    __extends(SortedList, _super);
    /**
     * Constructor.
     *
     * @param sort  Ordering function
     */
    function SortedList(sort) {
        var _this = _super.call(this) || this;
        _this._ordering = sort;
        return _this;
    }
    /**
     * Inserts item into the list.
     *
     * @param value  Item
     */
    SortedList.prototype._insert = function (value) {
        var index = getSortedIndex(this._values, this._ordering, value).index;
        insertIndex(this._values, index, value);
        return index;
    };
    /**
     * Returns index of the item in list if found.
     *
     * -1 if item is not in the list.
     *
     * @param value  Item to search for
     * @return Index
     */
    SortedList.prototype.indexOf = function (value) {
        var _a = getSortedIndex(this._values, this._ordering, value), found = _a.found, index = _a.index;
        if (found) {
            return index;
        }
        else {
            return -1;
        }
    };
    /**
     * [udpate description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param value [description]
     */
    SortedList.prototype.update = function (value) {
        // @todo test this
        var index = indexOf(this._values, value);
        // @todo throw an error if it doesn't exist ?
        if (index !== -1) {
            var last = this._values.length - 1;
            // Check if the current ordering is correct
            if (!((index === 0 || this._ordering(this._values[index - 1], value) < 0) &&
                (index === last || this._ordering(value, this._values[index + 1]) < 0))) {
                // TODO send remove/insert/move events
                removeIndex(this._values, index);
                this._insert(value);
            }
        }
    };
    return SortedList;
}(SortedList_OrderedList));

/**
 * A version of a [[OrderedList]] that has a "template".
 *
 * A template is an instance of an object, that can be used to create new
 * elements in the list without actually needing to create instances for those.
 *
 * When new element is created in the list, e.g. by calling its `create()`
 * method, an exact copy of the element is created (including properties and
 * other attributes), inserted into the list and returned.
 */
var SortedList_OrderedListTemplate = /** @class */ (function (_super) {
    __extends(OrderedListTemplate, _super);
    /**
     * Constructor
     *
     * @param t Template object
     */
    function OrderedListTemplate(t) {
        var _this = _super.call(this) || this;
        _this.template = t;
        return _this;
    }
    Object.defineProperty(OrderedListTemplate.prototype, "template", {
        /**
         * @return Template object
         */
        get: function () {
            return this._template;
        },
        /**
         * A "template" object to copy all properties from when creating new list
         * items.
         *
         * @param v  Template object
         */
        set: function (v) {
            v.isTemplate = true;
            this._template = v;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all elements from other list.
     *
     * @param source  Source list
     */
    OrderedListTemplate.prototype.copyFrom = function (source) {
        var _this = this;
        Iterator_each(source.iterator(), function (value) {
            _this.insert(value.clone());
        });
    };
    /**
     * Returns part of the list, starting at `start` and ending at `end` indexes,
     * as a new [[OrderedListTemplate]].
     *
     * @param start  Start index
     * @param end    End index
     * @return New list
     */
    OrderedListTemplate.prototype.slice = function (start, end) {
        var out = new OrderedListTemplate(this.template);
        out._values = this._values.slice(start, end);
        return out;
    };
    OrderedListTemplate.prototype.create = function (make) {
        var clone = (make != null
            ? new make()
            : this.template.clone());
        this.insert(clone);
        return clone;
    };
    return OrderedListTemplate;
}(SortedList_OrderedList));

/**
 * A version of a [[SortedList]] that has a "template".
 *
 * A template is an instance of an object, that can be used to create new
 * elements in the list without actually needing to create instances for those.
 *
 * When new element is created in the list, e.g. by calling its `create()`
 * method, an exact copy of the element is created (including properties and
 * other attributes), inserted into the list and returned.
 */
var SortedList_SortedListTemplate = /** @class */ (function (_super) {
    __extends(SortedListTemplate, _super);
    /**
     * Constructor
     *
     * @param t     Template object
     * @param sort  Ordering function
     */
    function SortedListTemplate(t, sort) {
        var _this = _super.call(this, sort) || this;
        _this.template = t;
        return _this;
    }
    Object.defineProperty(SortedListTemplate.prototype, "template", {
        /**
         * @return Template object
         */
        get: function () {
            return this._template;
        },
        /**
         * A "template" object to copy all properties from when creating new list
         * items.
         *
         * @param v  Template object
         */
        set: function (v) {
            v.isTemplate = true;
            this._template = v;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all elements from other list.
     *
     * @param source  Source list
     */
    SortedListTemplate.prototype.copyFrom = function (source) {
        var _this = this;
        Iterator_each(source.iterator(), function (value) {
            _this.insert(value.clone());
        });
    };
    SortedListTemplate.prototype.create = function (make) {
        var clone = (make != null
            ? new make()
            : this.template.clone());
        this.insert(clone);
        return clone;
    };
    return SortedListTemplate;
}(SortedList_SortedList));

//# sourceMappingURL=SortedList.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Number.js
/**
 * ============================================================================
 * COMPARING FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Comparing function used for ordering.
 *
 * @ignore Exclude from docs
 * @param a  Number 1
 * @param b  Number 2
 * @return Result
 */
function Number_order(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
//# sourceMappingURL=Number.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Order.js
/**
 * A collection of functions for ordering.
 */
/**
 * [reverse description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param a  [description]
 * @return [description]
 */
function reverse(a) {
    switch (a) {
        case 0:
            return 0;
        case -1:
            return 1;
        case 1:
            return -1;
    }
}
/**
 * [or description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param a  Item 1
 * @param b  Item 2
 * @return [description]
 */
function or(a, b) {
    if (a === 0) {
        return b;
    }
    else {
        return a;
    }
}
//# sourceMappingURL=Order.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Adapter.js
/**
 * An Adapter can be used to apply chained synchronous transformations to any
 * value at runtime.
 *
 * Each type class using Adapters must have `adapters` property and adapter
 * interface defined.
 *
 * Adapters can be used to allow external code to apply transformations to any
 * value at any time.
 *
 * For example we have a Weather class which has a method `now()` which returns
 * current temperature.
 *
 * ```
 * function now() {
 *   // ... calculate temperature
 *   let temp = "Temperature now is " + degrees + "F";
 *   return temp;
 * }
 * ```
 *
 * Now, supposed we want to let other classes to modify the output of the
 * `now()`? We just apply an adapter to the `temp` before it is returned:
 *
 * ```
 * temp = this.adapters.apply("now", {
 *   temp: temp,
 *   degrees: degrees
 * }).temp;
 * ```
 *
 * Some other class might tap onto it by defining an Adapter that calculates
 * the temperature in Celsius:
 *
 * weather.adapters.add("now", (arg) => {
 *   arg.temp += "(" + farenheitToCelsius(arg.degrees) + "C)";
 *   return arh;
 * });
 *
 * Furthermore some time-related class could add time:
 *
 * weather.adapters.add("now", (arg) => {
 *   arg.temp += "; the time now is " + (new Date().toLocaleString());
 *   return arh;
 * });
 *
 * So without adapters we would get output like this:
 *
 * ```
 * Temperature now is 90F
 * ```
 *
 * With adapters applied we now have:
 *
 * ```
 * Temperature now is 90F (32C); the time now is 12/11/2012, 7:00:00 PM
 * ```
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * GLOBAL ADAPTER
 * ============================================================================
 * @hidden
 */
/**
 * A global adapter is an adpater that is attached to a class type rather than
 * specific object instance.
 *
 * @ignore Exclude from docs
 */
var Adapter_GlobalAdapter = /** @class */ (function () {
    function GlobalAdapter() {
        /**
         * Callback id iterator.
         */
        this._callbackId = 0;
        /**
         * A list of if callbacks (adapters).
         */
        this._callbacks = new SortedList_SortedList(function (left, right) {
            return or(Number_order(left.priority, right.priority), Number_order(left.id, right.id));
        });
    }
    /**
     * Adds a global callback which is not specific to any particular object.
     * Whenever an adapter in any object of the specific class type is invoked
     * global adapters will kick in.
     *
     * @param type      Class type
     * @param key       Adapter key
     * @param callback  Callback function
     * @param priority  Priority (higher priority meaning adapter will be applied later)
     * @param scope     Callback function scaope
     */
    GlobalAdapter.prototype.addAll = function (type, key, callback, priority, scope) {
        if (priority === void 0) { priority = 0; }
        this._callbacks.insert({
            id: ++this._callbackId,
            key: key,
            callback: callback,
            priority: priority,
            scope: scope,
            type: type
        });
    };
    /**
     * Returns if there are adapters for specific type available.
     *
     * @param type  Adapter type
     * @param key   Adapter key
     * @return {boolean}
     */
    GlobalAdapter.prototype.isEnabled = function (type, key) {
        return any(this._callbacks.values, function (x) { return x.key === key && type instanceof x.type; });
    };
    /**
     * Applies global adapters for the object of the specific type.
     *
     * @param type   Class type
     * @param key    Adapter key
     * @param value  Value
     */
    GlobalAdapter.prototype.applyAll = function (type, key, value) {
        // This is needed to improve the performance and reduce garbage collection
        var callbacks = this._callbacks.values;
        var length = callbacks.length;
        if (length == 0) {
            return value;
        }
        // Cycle through all callbacks and find the ones we need to use
        for (var i = 0; i < length; ++i) {
            var item = callbacks[i];
            if (item.key === key && type instanceof item.type) {
                value = item.callback.call(item.scope, value, type, key);
            }
        }
        return value;
    };
    return GlobalAdapter;
}());

/**
 * A global Adapter for plugins that want to add specific
 * functionality for any chart, not just specific instance.
 *
 * If you want to add an adapter which applies to all instances of the same
 * object type, like, for instance all slices in PieSeries, you can use
 * global adapter.
 *
 * Global adapter is a system-wide instance, accessible via `globalAdapter`.
 *
 * ```TypeScript
 * am4core.globalAdapter.addAll<am4charts.IPieSeriesAdapters, am4charts.PieSeries, "fill">(am4charts.PieSeries, "fill", (value, target, key) => {
 *   return am4core.color("#005500");
 * });
 * ```
 * ```JavaScript
 * am4core.globalAdapter.addAll(am4charts.PieSeries, "fill", (value, target, key) => {
 *   return am4core.color("#005500");
 * });
 * ```
 *
 * @todo Description (improve)
 */
var globalAdapter = new Adapter_GlobalAdapter();
/**
 * ============================================================================
 * REGULAR ADAPTER
 * ============================================================================
 * @hidden
 */
/**
 * Adapter allows adding ordered callback functions and associating them with a
 * string-based key. An Adapter user can then easily invoke those callbacks to
 * apply custom functions on its input, output or intermediate values.
 *
 * Custom code and plugins can add their own callbacks to modify and enhance
 * core functionality.
 *
 * See the description of `add()` for an example.
 *
 * Almost any object in amCharts4 has own adapter, accessible with `adapter`
 * property.
 *
 * Any adapters added to it will be applied to that object only.
 *
 * ### Global Adapters
 *
 * If you want to add an adapter which applies to all instances of the same
 * object type, like, for instance all slices in PieSeries, you can use
 * global adapter.
 *
 * Global adapter is a system-wide instance, accessible via `globalAdapter`.
 *
 * ```TypeScript
 * am4core.globalAdapter.addAll<am4charts.IPieSeriesAdapters, am4charts.PieSeries, "fill">(am4charts.PieSeries. "fill", (value, target, key) => {
 *   return am4core.color("#005500");
 * });
 * ```
 * ```JavaScript
 * am4core.globalAdapter.addAll(am4charts.PieSeries. "fill", (value, target, key) => {
 *   return am4core.color("#005500");
 * });
 * ```
 *
 * {@link https://www.amcharts.com/docs/v4/reference/adapter_module/#globalAdapter_property More info}.
 *
 * @important
 */
var Adapter_Adapter = /** @class */ (function () {
    /**
     * Constructor, sets the object referece this Adapter should be used for.
     *
     * @param c Object
     */
    function Adapter(c) {
        /**
         * Internal counter for callback ids.
         */
        this._callbackId = 0;
        /**
         * A list of adapter callbacks.
         *
         * @param $number.order(left.priority, right.priority) [description]
         * @param $number.order(left.id,       right.id));	}  [description]
         */
        this._callbacks = new SortedList_SortedList(function (left, right) {
            return or(Number_order(left.priority, right.priority), Number_order(left.id, right.id));
        });
        this._disabled = {};
        this.object = c;
        // TODO this exposes the internal events
        this.events = this._callbacks.events;
    }
    /**
     * Adds a callback for a specific key.
     *
     * ```TypeScript
     * // Override fill color value and make all slices green
     * chart.series.template.adapter.add("fill", (value, target, key) => {
     *   return am4core.color("#005500");
     * });
     * ```
     * ```JavaScript
     * // Override fill color value and make all slices green
     * chart.series.template.adapter.add("fill", function(value, target, key) {
     *   return am4core.color("#005500");
     * });
     * ```
     * ```JSON
     * {
     *   // ...
     *   "series": [{
     *     // ...
     *     "adapter": {
     *     	// Override fill color value and make all slices green
     *     	"fill": function(value, target, key) {
     *     	  return am4core.color("#005500");
     *     	}
     *     }
     *   }]
     * }
     * ```
     *
     * The above will call user-defined function (adapter) whenever `fill` value
     * is requested from the Pie series, allowing it to override the default
     * using custom code and any fuzzy logic.
     *
     * There can be any number of adapters set on one property key.
     *
     * In this case adapters will be applied in daisy-chain fashion. The first
     * adapter in queue will make its transformation. The next one will have
     * the output of the first adapter as a starting value, etc.
     *
     * The order of the adapters are determined either by the order they were
     * added in, or their `priority` value.
     *
     * The heigher the `priority`, the later in the game adapter will be applied.
     *
     * @param key       Key
     * @param callback  A callback function
     * @param priority  The higher priority, the more chance the adapter will be applied last
     * @param scope     Scope for the callback function
     */
    Adapter.prototype.add = function (key, callback, priority, scope) {
        if (priority === void 0) { priority = 0; }
        this._callbacks.insert({
            id: ++this._callbackId,
            key: key,
            callback: callback,
            priority: priority,
            scope: scope
        });
    };
    /**
     * Checks whether specific adapter is already set.
     *
     * @param key       Key
     * @param callback  A callback function
     * @param priority  The higher priority, the more chance the adapter will be applied last
     * @param scope     Scope for the callback function
     * @returns                            Adapter set?
     */
    Adapter.prototype.has = function (key, callback, priority, scope) {
        if (priority === void 0) { priority = 0; }
        return contains(this._callbacks.iterator(), function (item) {
            return item.key === key && item.callback === callback && item.priority === priority && item.scope === scope;
        });
    };
    /**
     * Removes adapter callbacks for the specific `key`.
     *
     * If `priority` is specified, only callbacks for that priority are removed.
     *
     * @param key      Key
     * @param priority Priority
     * @todo Implement
     */
    Adapter.prototype.remove = function (key, priority) {
        var _this = this;
        // It has to make a copy because it removes the elements while iterating
        // TODO inefficient
        // TODO should this re-enable the key ?
        each(Iterator_toArray(this._callbacks.iterator()), function (item) {
            // TODO test this
            if (item.key === key && (!isNumber(priority) || priority === item.priority)) {
                _this._callbacks.remove(item);
            }
        });
    };
    /**
     * Enable applying adapters for a certain key, if it was disabled before by
     * `disableKey()`.
     *
     * @param key Key
     */
    Adapter.prototype.enableKey = function (key) {
        delete this._disabled[key];
    };
    /**
     * Disable applying adapters for a certain key.
     *
     * Optionally, can set how many applies to skip before automatically
     * re-enabling the applying.
     *
     * @param key     Key
     * @param amount  Number of applies to skip
     */
    Adapter.prototype.disableKey = function (key, amount) {
        if (amount === void 0) { amount = Infinity; }
        this._disabled[key] = amount;
    };
    Adapter.prototype._hasListenersByType = function (key) {
        return any(this._callbacks.values, function (x) { return x.key === key; });
    };
    /**
     * Returns if there are any enabled adapters set for the specific `key`.
     *
     * @returns Are there any adapters for the key?
     */
    Adapter.prototype.isEnabled = function (key) {
        return this._disabled[key] == null && (this._hasListenersByType(key) || globalAdapter.isEnabled(this.object, key));
    };
    Adapter.prototype._shouldDispatch = function (key) {
        var count = this._disabled[key];
        if (!isNumber(count)) {
            return true;
        }
        else {
            if (count <= 1) {
                delete this._disabled[key];
            }
            else {
                --this._disabled[key];
            }
            return false;
        }
    };
    /**
     * Passes the input value through all the callbacks for the defined `key`.
     *
     * @param key      Key
     * @param value    Input value
     * @param ...rest  Rest of the parameters to be passed into callback
     * @return Output value
     */
    Adapter.prototype.apply = function (key, value) {
        if (this._shouldDispatch(key)) {
            // This is needed to improve the performance and reduce garbage collection
            var callbacks = this._callbacks.values;
            var length_1 = callbacks.length;
            if (length_1 > 0) {
                for (var i = 0; i < length_1; ++i) {
                    var item = callbacks[i];
                    if (item.key === key) {
                        value = item.callback.call(item.scope, value, this.object, key);
                    }
                }
            }
            // Apply global adapters
            value = globalAdapter.applyAll(this.object, key, value);
            return value;
        }
        else {
            return value;
        }
    };
    /**
     * Returns all adapter keys which are in this adapter.
     *
     * @return Adapter keys
     */
    Adapter.prototype.keys = function () {
        // TODO inefficient
        return Iterator_toArray(Iterator_map(this._callbacks.iterator(), function (x) { return x.key; }));
    };
    /**
     * Copies all the adapter callbacks from `source`.
     *
     * @param source  An Adapter to copy items from
     */
    Adapter.prototype.copyFrom = function (source) {
        var _this = this;
        Iterator_each(source._callbacks.iterator(), function (x) {
            _this.add(x.key, x.callback, x.priority, x.scope);
        });
    };
    /**
     * Clears all callbacks from this Adapter.
     */
    Adapter.prototype.clear = function () {
        // TODO should this also re-enable all the keys ?
        this._callbacks.clear();
    };
    return Adapter;
}());

//# sourceMappingURL=Adapter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Colors.js
/**
 * A collection of color-related functions
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * Define named colors for easy resolution to RGB.
 */
var namedColors = {
    aliceblue: { r: 240, g: 248, b: 255 },
    antiquewhite: { r: 250, g: 235, b: 215 },
    aqua: { r: 0, g: 255, b: 255 },
    aquamarine: { r: 127, g: 255, b: 212 },
    azure: { r: 240, g: 255, b: 255 },
    beige: { r: 245, g: 245, b: 220 },
    bisque: { r: 255, g: 228, b: 196 },
    black: { r: 0, g: 0, b: 0 },
    blanchedalmond: { r: 255, g: 235, b: 205 },
    blue: { r: 0, g: 0, b: 255 },
    blueviolet: { r: 138, g: 43, b: 226 },
    brown: { r: 165, g: 42, b: 42 },
    burlywood: { r: 222, g: 184, b: 135 },
    cadetblue: { r: 95, g: 158, b: 160 },
    chartreuse: { r: 127, g: 255, b: 0 },
    chocolate: { r: 210, g: 105, b: 30 },
    coral: { r: 255, g: 127, b: 80 },
    cornflowerblue: { r: 100, g: 149, b: 237 },
    cornsilk: { r: 255, g: 248, b: 220 },
    crimson: { r: 220, g: 20, b: 60 },
    cyan: { r: 0, g: 255, b: 255 },
    darkblue: { r: 0, g: 0, b: 139 },
    darkcyan: { r: 0, g: 139, b: 139 },
    darkgoldenrod: { r: 184, g: 134, b: 11 },
    darkgray: { r: 169, g: 169, b: 169 },
    darkgrey: { r: 169, g: 169, b: 169 },
    darkgreen: { r: 0, g: 100, b: 0 },
    darkkhaki: { r: 189, g: 183, b: 107 },
    darkmagenta: { r: 139, g: 0, b: 139 },
    darkolivegreen: { r: 85, g: 107, b: 47 },
    darkorange: { r: 255, g: 140, b: 0 },
    darkorchid: { r: 153, g: 50, b: 204 },
    darkred: { r: 139, g: 0, b: 0 },
    darksalmon: { r: 233, g: 150, b: 122 },
    darkseagreen: { r: 143, g: 188, b: 143 },
    darkslateblue: { r: 72, g: 61, b: 139 },
    darkslategray: { r: 47, g: 79, b: 79 },
    darkslategrey: { r: 47, g: 79, b: 79 },
    darkturquoise: { r: 0, g: 206, b: 209 },
    darkviolet: { r: 148, g: 0, b: 211 },
    deeppink: { r: 255, g: 20, b: 147 },
    deepskyblue: { r: 0, g: 191, b: 255 },
    dimgray: { r: 105, g: 105, b: 105 },
    dimgrey: { r: 105, g: 105, b: 105 },
    dodgerblue: { r: 30, g: 144, b: 255 },
    firebrick: { r: 178, g: 34, b: 34 },
    floralwhite: { r: 255, g: 250, b: 240 },
    forestgreen: { r: 34, g: 139, b: 34 },
    fuchsia: { r: 255, g: 0, b: 255 },
    gainsboro: { r: 220, g: 220, b: 220 },
    ghostwhite: { r: 248, g: 248, b: 255 },
    gold: { r: 255, g: 215, b: 0 },
    goldenrod: { r: 218, g: 165, b: 32 },
    gray: { r: 128, g: 128, b: 128 },
    grey: { r: 128, g: 128, b: 128 },
    green: { r: 0, g: 128, b: 0 },
    greenyellow: { r: 173, g: 255, b: 47 },
    honeydew: { r: 240, g: 255, b: 240 },
    hotpink: { r: 255, g: 105, b: 180 },
    indianred: { r: 205, g: 92, b: 92 },
    indigo: { r: 75, g: 0, b: 130 },
    ivory: { r: 255, g: 255, b: 240 },
    khaki: { r: 240, g: 230, b: 140 },
    lavender: { r: 230, g: 230, b: 250 },
    lavenderblush: { r: 255, g: 240, b: 245 },
    lawngreen: { r: 124, g: 252, b: 0 },
    lemonchiffon: { r: 255, g: 250, b: 205 },
    lightblue: { r: 173, g: 216, b: 230 },
    lightcoral: { r: 240, g: 128, b: 128 },
    lightcyan: { r: 224, g: 255, b: 255 },
    lightgoldenrodyellow: { r: 250, g: 250, b: 210 },
    lightgray: { r: 211, g: 211, b: 211 },
    lightgrey: { r: 211, g: 211, b: 211 },
    lightgreen: { r: 144, g: 238, b: 144 },
    lightpink: { r: 255, g: 182, b: 193 },
    lightsalmon: { r: 255, g: 160, b: 122 },
    lightseagreen: { r: 32, g: 178, b: 170 },
    lightskyblue: { r: 135, g: 206, b: 250 },
    lightslategray: { r: 119, g: 136, b: 153 },
    lightslategrey: { r: 119, g: 136, b: 153 },
    lightsteelblue: { r: 176, g: 196, b: 222 },
    lightyellow: { r: 255, g: 255, b: 224 },
    lime: { r: 0, g: 255, b: 0 },
    limegreen: { r: 50, g: 205, b: 50 },
    linen: { r: 250, g: 240, b: 230 },
    magenta: { r: 255, g: 0, b: 255 },
    maroon: { r: 128, g: 0, b: 0 },
    mediumaquamarine: { r: 102, g: 205, b: 170 },
    mediumblue: { r: 0, g: 0, b: 205 },
    mediumorchid: { r: 186, g: 85, b: 211 },
    mediumpurple: { r: 147, g: 112, b: 219 },
    mediumseagreen: { r: 60, g: 179, b: 113 },
    mediumslateblue: { r: 123, g: 104, b: 238 },
    mediumspringgreen: { r: 0, g: 250, b: 154 },
    mediumturquoise: { r: 72, g: 209, b: 204 },
    mediumvioletred: { r: 199, g: 21, b: 133 },
    midnightblue: { r: 25, g: 25, b: 112 },
    mintcream: { r: 245, g: 255, b: 250 },
    mistyrose: { r: 255, g: 228, b: 225 },
    moccasin: { r: 255, g: 228, b: 181 },
    navajowhite: { r: 255, g: 222, b: 173 },
    navy: { r: 0, g: 0, b: 128 },
    oldlace: { r: 253, g: 245, b: 230 },
    olive: { r: 128, g: 128, b: 0 },
    olivedrab: { r: 107, g: 142, b: 35 },
    orange: { r: 255, g: 165, b: 0 },
    orangered: { r: 255, g: 69, b: 0 },
    orchid: { r: 218, g: 112, b: 214 },
    palegoldenrod: { r: 238, g: 232, b: 170 },
    palegreen: { r: 152, g: 251, b: 152 },
    paleturquoise: { r: 175, g: 238, b: 238 },
    palevioletred: { r: 219, g: 112, b: 147 },
    papayawhip: { r: 255, g: 239, b: 213 },
    peachpuff: { r: 255, g: 218, b: 185 },
    peru: { r: 205, g: 133, b: 63 },
    pink: { r: 255, g: 192, b: 203 },
    plum: { r: 221, g: 160, b: 221 },
    powderblue: { r: 176, g: 224, b: 230 },
    purple: { r: 128, g: 0, b: 128 },
    rebeccapurple: { r: 102, g: 51, b: 153 },
    red: { r: 255, g: 0, b: 0 },
    rosybrown: { r: 188, g: 143, b: 143 },
    royalblue: { r: 65, g: 105, b: 225 },
    saddlebrown: { r: 139, g: 69, b: 19 },
    salmon: { r: 250, g: 128, b: 114 },
    sandybrown: { r: 244, g: 164, b: 96 },
    seagreen: { r: 46, g: 139, b: 87 },
    seashell: { r: 255, g: 245, b: 238 },
    sienna: { r: 160, g: 82, b: 45 },
    silver: { r: 192, g: 192, b: 192 },
    skyblue: { r: 135, g: 206, b: 235 },
    slateblue: { r: 106, g: 90, b: 205 },
    slategray: { r: 112, g: 128, b: 144 },
    slategrey: { r: 112, g: 128, b: 144 },
    snow: { r: 255, g: 250, b: 250 },
    springgreen: { r: 0, g: 255, b: 127 },
    steelblue: { r: 70, g: 130, b: 180 },
    tan: { r: 210, g: 180, b: 140 },
    teal: { r: 0, g: 128, b: 128 },
    thistle: { r: 216, g: 191, b: 216 },
    tomato: { r: 255, g: 99, b: 71 },
    turquoise: { r: 64, g: 224, b: 208 },
    violet: { r: 238, g: 130, b: 238 },
    wheat: { r: 245, g: 222, b: 179 },
    white: { r: 255, g: 255, b: 255 },
    whitesmoke: { r: 245, g: 245, b: 245 },
    yellow: { r: 255, g: 255, b: 0 },
    yellowgreen: { r: 154, g: 205, b: 50 }
};
/**
 * Tries to resolve a named color into a hex color representation.
 *
 * @ignore Exclude from docs
 * @param value  Color name
 * @return Color
 * @deprecated
 * @hidden
 */
/*export function resolveNamedColor(value: string): Color {
    return (<any>namedColors)[value] ? (<any>namedColors)[value] : undefined;
}*/
/**
 * Converts a proper color hex code (i.e. "#FF5500") or named color (i.e. "red")
 * into an {iRGB} object. If the code is not correctly formatted, an RGB of
 * black is returned.
 *
 * @ignore Exclude from docs
 * @param color  Color code
 * @param alpha  Alpha (0-1)
 * @return RGB
 */
function Colors_rgb(color, alpha) {
    // Init return value
    var rgb;
    // Try resolving color format
    // Named color?
    if (namedColors[color]) {
        rgb = namedColors[color];
    }
    // Hex code?
    else if (color.charAt(0) === "#") {
        rgb = hexToRgb(color);
    }
    // rgb() format?
    else if (color.match(/^rgba?\(/)) {
        rgb = rgbaToRgb(color);
    }
    // Was not able to resolve?
    if (!rgb) {
        rgb = { r: 0, g: 0, b: 0, a: 1 };
    }
    // Set alpha
    if (hasValue(alpha)) {
        rgb.a = alpha;
    }
    return rgb;
}
/**
 * Converts a hex color code (i.e. "#FF5500") to an [[iRGB]] object.
 *
 * @ignore Exclude from docs
 * @param hex  Hex color code
 * @return RGB
 */
function hexToRgb(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
    });
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : undefined;
}
/**
 * Converts color strings in format like `rgb()` and `rgba()` to [[iRGB]].
 *
 * @ignore Exclude from docs
 * @param color  Color code
 * @return RGB
 */
function rgbaToRgb(color) {
    color = color.replace(/[ ]/g, "");
    // Init
    var matches = color.match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i);
    // Try rgb() format
    if (matches) {
        matches.push("1");
    }
    else {
        matches = color.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i);
        if (!matches) {
            return;
        }
    }
    return {
        r: parseInt(matches[1]),
        g: parseInt(matches[2]),
        b: parseInt(matches[3]),
        a: parseFloat(matches[4])
    };
}
/**
 * Converts an [[iRGB]] object into a hex color code.
 *
 * @ignore Exclude from docs
 * @param rgb  RGB
 * @return Hex color code
 */
function rgbToHex(rgb) {
    return "#" + pad2(rgb.r.toString(16)) + pad2(rgb.g.toString(16)) + pad2(rgb.b.toString(16));
}
/**
 * Converts an [[iRGB]] object into its `rgb()` or `rgba()` representation.
 *
 * @ignore Exclude from docs
 * @param rgb  RGB
 * @return `rgba()` syntax
 */
function rgbToRGBA(rgb) {
    if (hasValue(rgb.a) && rgb.a !== 1) {
        return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + rgb.a + ")";
    }
    else {
        return "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
    }
}
/**
 * Pads a 1-digit string with a zero.
 *
 * @ignore Exclude from docs
 * @param c  Input string
 * @return Padded string
 */
function pad2(c) {
    return c.length == 1 ? "0" + c : "" + c;
}
/**
 * Returns an intermediate color between two colors based on the relative
 * position. Position needs to be in range between 0 and 1. Zero meaning the
 * resulting color will be closest to the first reference color.
 *
 * @ignore Exclude from docs
 * @param color1   First reference color
 * @param color2   Second reference color
 * @param percent  Relative position (0-1)
 * @return Interpolated color
 */
function interpolate(rgb1, rgb2, percent) {
    percent = fitToRange(percent, 0, 1);
    if (rgb1) {
        if (rgb2) {
            return {
                r: rgb1.r + Math.round((rgb2.r - rgb1.r) * percent),
                g: rgb1.g + Math.round((rgb2.g - rgb1.g) * percent),
                b: rgb1.b + Math.round((rgb2.b - rgb1.b) * percent),
                a: (rgb1.a || 1) + Math.round(((rgb2.a || 1) - (rgb1.a || 1)) * percent)
            };
        }
        else {
            return rgb1;
        }
    }
    else if (rgb2) {
        return rgb2;
    }
    else {
        return rgb1;
    }
}
/**
 * Returns a color that is `percent` brighter than the reference color.
 *
 * @ignore Exclude from docs
 * @param color    Reference color
 * @param percent  Brightness percent
 * @return Hex code of the new color
 */
function Colors_lighten(rgb, percent) {
    if (rgb) {
        return {
            r: Math.max(0, Math.min(255, rgb.r + getLightnessStep(rgb.r, percent))),
            g: Math.max(0, Math.min(255, rgb.g + getLightnessStep(rgb.g, percent))),
            b: Math.max(0, Math.min(255, rgb.b + getLightnessStep(rgb.b, percent))),
            a: rgb.a
        };
    }
    else {
        // TODO is this correct ?
        return rgb;
    }
}
;
/**
 * Gets lightness step.
 *
 * @ignore Exclude from docs
 * @param value    Value
 * @param percent  Percent
 * @return Step
 */
function getLightnessStep(value, percent) {
    var base = percent > 0 ? 255 - value : value;
    return Math.round(base * percent);
}
/**
 * Returns a color that is `percent` brighter than the source `color`.
 *
 * @ignore Exclude from docs
 * @param color    Source color
 * @param percent  Brightness percent
 * @return New color
 */
function Colors_brighten(rgb, percent) {
    if (rgb) {
        var base = Math.min(Math.max(rgb.r, rgb.g, rgb.b), 230);
        //let base = Math.max(rgb.r, rgb.g, rgb.b);
        var step = getLightnessStep(base, percent);
        return {
            r: Math.max(0, Math.min(255, Math.round(rgb.r + step))),
            g: Math.max(0, Math.min(255, Math.round(rgb.g + step))),
            b: Math.max(0, Math.min(255, Math.round(rgb.b + step))),
            a: rgb.a
        };
    }
    else {
        // TODO is this correct ?
        return rgb;
    }
}
;
/**
 * Returns brightness step.
 *
 * @ignore Exclude from docs
 * @param value    Value
 * @param percent  Percent
 * @return Step
 */
function getBrightnessStep(value, percent) {
    var base = 255; //percent > 0 ? 255 - value : value;
    return Math.round(base * percent);
}
/**
 * Returns a new [[iRGB]] object based on `rgb` parameter with specific
 * saturation applied.
 *
 * `saturation` can be in the range of 0 (fully desaturated) to 1 (fully
 * saturated).
 *
 * @ignore Exclude from docs
 * @param color       Base color
 * @param saturation  Saturation (0-1)
 * @return New color
 */
function saturate(rgb, saturation) {
    if (rgb == null || saturation == 1) {
        return rgb;
    }
    var hsl = rgbToHsl(rgb);
    hsl.s = saturation;
    return hslToRgb(hsl);
}
/*
// not used
export function rgbToMatrix(rgb: iRGB): string {
    let r = $type.toText($math.round((rgb.r || 0) / 255, 10));
    let g = $type.toText($math.round((rgb.g || 0) / 255, 10));
    let b = $type.toText($math.round((rgb.b || 0) / 255, 10));
    let a = $type.toText(rgb.a || 1);
    return	      r + " 0 0 0 0" +
                    " 0 " + g + " 0 0 0" +
                    " 0 0 " + b + " 0 0" +
                    " 0 0 0 " + a + " 0";
}
*/
/**
 * The functions below are taken and adapted from Garry Tan's blog post:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * The further attributions go mjijackson.com, which now seems to be defunct.
 */
/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes h, s, and l are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * Function adapted from:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * @ignore Exclude from docs
 * @param h       The hue
 * @param s       The saturation
 * @param l       The lightness
 * @return The RGB representation
 */
function hslToRgb(color) {
    var r, g, b;
    var h = color.h;
    var s = color.s;
    var l = color.l;
    if (s == 0) {
        r = g = b = l; // achromatic
    }
    else {
        var hue2rgb = function hue2rgb(p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        };
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}
/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and l in the set [0, 1].
 *
 * Function adapted from:
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 *
 * @ignore Exclude from docs
 * @param r       The red color value
 * @param g       The green color value
 * @param b       The blue color value
 * @return The HSL representation
 */
function rgbToHsl(color) {
    var r = color.r / 255;
    var g = color.g / 255;
    var b = color.b / 255;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var s = 0;
    var l = (max + min) / 2;
    if (max === min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return {
        h: h,
        s: s,
        l: l
    };
}
/**
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes r, g, and b are contained in the set [0, 255] and
 * returns h, s, and v in the set [0, 1].
 *
 * @ignore Exclude from docs
 * @param   Number  r       The red color value
 * @param   Number  g       The green color value
 * @param   Number  b       The blue color value
 * @return  Array           The HSV representation
 */
function rgbToHsv(color) {
    var r = color.r / 255;
    var g = color.g / 255;
    var b = color.b / 255;
    var max = Math.max(r, g, b), min = Math.min(r, g, b);
    var h = 0;
    var s = 0;
    var v = max;
    var d = max - min;
    s = max == 0 ? 0 : d / max;
    if (max == min) {
        h = 0; // achromatic
    }
    else {
        switch (max) {
            case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                h = (b - r) / d + 2;
                break;
            case b:
                h = (r - g) / d + 4;
                break;
        }
        h /= 6;
    }
    return {
        h: h,
        s: s,
        v: v
    };
}
/**
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @ignore Exclude from docs
 * @param   Number  h       The hue
 * @param   Number  s       The saturation
 * @param   Number  v       The value
 * @return  Array           The RGB representation
 */
function hsvToRgb(color) {
    var r = 0;
    var g = 0;
    var b = 0;
    var h = color.h;
    var s = color.s;
    var v = color.v;
    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0:
            r = v;
            g = t;
            b = p;
            break;
        case 1:
            r = q;
            g = v;
            b = p;
            break;
        case 2:
            r = p;
            g = v;
            b = t;
            break;
        case 3:
            r = p;
            g = q;
            b = v;
            break;
        case 4:
            r = t;
            g = p;
            b = v;
            break;
        case 5:
            r = v;
            g = p;
            b = q;
            break;
    }
    return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
    };
}
/**
 * Returns `true` if color is "light". Useful indetermining which contrasting
 * color to use for elements over this color. E.g.: you would want to use
 * black text over light background, and vice versa.
 *
 * @ignore Exclude from docs
 * @param color  Source color
 * @return Light?
 */
function isLight(color) {
    return ((color.r * 299) + (color.g * 587) + (color.b * 114)) / 1000 >= 128;
}
//# sourceMappingURL=Colors.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Color.js
/**
 * This module contains Color object definition
 */



/**
 * Represents a color.
 *
 * `Color` accepts value only in [[iRGB]] object format. To create `Color`
 * object by parsing it from any supported string-based formats, use helper
 * [[color]] function:
 *
 * ```TypeScript
 * am4core.color("#ff0000");
 * am4core.color("#f00");
 * am4core.color("rgb(255, 0, 0)");
 * am4core.color("rgba(255, 0, 0, 0.5)");
 * am4core.color({ r: 255, g: 0, b: 0 });
 * am4core.color("red");
 * ```
 * ```JavaScript
 * am4core.color("#ff0000");
 * am4core.color("#f00");
 * am4core.color("rgb(255, 0, 0)");
 * am4core.color("rgba(255, 0, 0, 0.5)");
 * am4core.color({ r: 255, g: 0, b: 0 });
 * am4core.color("red");
 * ```
 *
 * @see {@link https://www.amcharts.com/docs/v4/concepts/colors/} for color-related info
 */
var Color_Color = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param color Source color
     */
    function Color(color) {
        this._value = color;
    }
    Object.defineProperty(Color.prototype, "rgb", {
        /**
         * Returns [[iRGB]] representation of the color.
         *
         * @return RGB object
         */
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "hex", {
        /**
         * Returns color hex value string, e.g. "#FF0000".
         *
         * @return Hex color code
         */
        get: function () {
            return this._value ? rgbToHex(this._value) : "none";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "rgba", {
        /**
         * Returns an `rgba()` representation of the color, e.g.:
         * `rgba(255, 0, 0, 0.5)`.
         *
         * @return rgba color string
         */
        get: function () {
            return this._value ? rgbToRGBA(this._value) : "none";
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "alpha", {
        /**
         * Returns current transparency.
         *
         * @return Alpha (0-1)
         */
        get: function () {
            if (this._value != null && this._value.a != null) {
                return this._value.a;
            }
            else {
                return 1;
            }
        },
        /**
         * Set alpha (transparency) of the color.
         *
         * @param value Alpha (0-1)
         */
        set: function (value) {
            if (this._value) {
                this._value.a = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "lightColor", {
        /**
         * Returns current light color setting.
         *
         * @return Color
         */
        get: function () {
            if (!this._lightColor) {
                this._lightColor = new Color({ r: 255, g: 255, b: 255 });
            }
            return this._lightColor;
        },
        /**
         * Sets "light" color. Used when determining contrasting color.
         *
         * @param color Color
         */
        set: function (color) {
            this._lightColor = color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Color.prototype, "darkColor", {
        /**
         * Returns current dark color setting.
         *
         * @return Color
         */
        get: function () {
            if (!this._darkColor) {
                this._darkColor = new Color({ r: 0, g: 0, b: 0 });
            }
            return this._darkColor;
        },
        /**
         * Sets "dark" color. Used when determining contrasting color.
         *
         * @param color Color
         */
        set: function (color) {
            this._darkColor = color;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Overrides `toString` method so that [[Color]] object can be used as
     * string.
     *
     * @ignore Exclude from docs
     * @return String represantion of color (usable in CSS)
     */
    Color.prototype.toString = function () {
        return this.alpha < 1 ? this.rgba : this.hex;
    };
    /**
     * Returns a new [[Color]] which is percent lighter (positive value),
     * or darker (negative value).
     *
     * Parameter is in the scale of -1 to 1.
     *
     * @param percent  Increase/decrease lightness by X
     * @return New Color
     */
    Color.prototype.lighten = function (percent) {
        return new Color(Colors_lighten(this.rgb, percent));
    };
    /**
     * Returns a new [[Color]] which is percent brighter (positive value),
     * or darker (negative value).
     *
     * Parameter is in the scale of -1 to 1.
     *
     * @param percent  Increase/decrease brightness by X
     * @return New Color
     */
    Color.prototype.brighten = function (percent) {
        return new Color(Colors_brighten(this.rgb, percent));
    };
    /**
     * Returns a new [[Color]] based on current color with specific saturation
     * applied.
     *
     * `saturation` can be in the range of 0 (fully desaturated) to 1 (fully
     * saturated).
     *
     * @param saturation  Saturation (0-1)
     * @return New (saturated) color
     */
    Color.prototype.saturate = function (saturation) {
        return new Color(saturate(this.rgb, saturation));
    };
    Object.defineProperty(Color.prototype, "alternative", {
        /**
         * Returns a either light or dark color that contrasts specifically with
         * this color.
         *
         * Uses properties `darkColor` (default black) and `lightColor` (default
         * white).
         *
         * Useful when determining which color label should be on a colored
         * background, so that it stands out.
         *
         * @return Contrasting color
         */
        get: function () {
            if (this.rgb != null) {
                return isLight(this.rgb) ? this.darkColor : this.lightColor;
            }
            else {
                throw new Error("Color does not exist");
            }
        },
        enumerable: true,
        configurable: true
    });
    return Color;
}());

/**
 * Resolves an input variable to a normal [[iRGB]] color and creates [[Color]]
 * object for it.
 *
 * @param value  Input value
 * @param alpha  Alpha (0-1)
 * @return Color object
 */
function Color_color(value, alpha) {
    if (!hasValue(value)) {
        return new Color_Color(undefined);
    }
    if (typeof value == "string") {
        var cacheId = "_color_" + value + "_" + (alpha || "1");
        var cached = registry.getCache(cacheId);
        if (cached) {
            return new Color_Color({
                r: cached.r,
                g: cached.g,
                b: cached.b,
                a: cached.a
            });
        }
        var rgb = Colors_rgb(value, alpha);
        registry.setCache(cacheId, rgb);
        return new Color_Color(rgb);
    }
    // Check if it's already a Color object
    if (value instanceof Color_Color) {
        if (hasValue(alpha)) {
            value.alpha = alpha;
        }
        return value;
    }
    // Not a string or Color instance, it's the iRGB object then
    return new Color_Color(value);
}
/**
 * Checks if supplied argument is instance of [[Color]].
 *
 * @param value  Input value
 * @return Is Color?
 */
function isColor(value) {
    return value instanceof Color_Color;
}
/**
 * Converts any value to [[Color]].
 *
 * @param value  Input value
 * @return Color
 */
function castColor(value) {
    return Color_color(value);
}
/**
 * Converts any value into a [[Color]].
 *
 * @param value  Source value
 * @return Color object
 */
function toColor(value) {
    if (hasValue(value) && !isColor(value)) {
        return castColor(value);
    }
    return value;
}
//# sourceMappingURL=Color.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/Base.js
/**
 * Base functionality
*/














//import * as $debug from "./utils/Debug";
/**
 * Provides base functionality for all derivative objects, like generating ids,
 * handling cache, etc.
 */
var Base_BaseObject = /** @class */ (function () {
    //protected _classes: { [index: string]: any } = {};
    /**
     * Constructor
     * * Sets class name
     */
    function BaseObject() {
        /**
         * Indicates if this object has already been deleted. Any
         * destruction/disposal code should take this into account when deciding
         * wheter to run potentially costly disposal operations if they already have
         * been run.
         */
        this._disposed = false;
        /**
         * List of IDisposer which will be disposed when the BaseObject is disposed.
         */
        this._disposers = [];
        this.className = "BaseObject";
        //this.debug();
    }
    BaseObject.prototype.debug = function () {
        //$debug.debug(this);
    };
    Object.defineProperty(BaseObject.prototype, "uid", {
        /**
         * Returns object's internal unique ID.
         *
         * @return Unique ID
         */
        get: function () {
            if (!this._uid) {
                this._uid = registry.getUniqueId();
                registry.map.setKey(this._uid, this);
            }
            return this._uid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseObject.prototype, "id", {
        /**
         * @return Id
         */
        get: function () {
            return this._id;
        },
        /**
         * Sets the user-defined id of the element.
         *
         * @param value Id
         */
        set: function (value) {
            //registry.map.setKey(value, this); // registry.map only stores by uid
            this._id = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseObject.prototype, "map", {
        /**
         * Returns a universal collection for mapping ids with objects.
         *
         * @ignore Exclude from docs
         * @return Map collection
         */
        get: function () {
            if (!this._map) {
                this._map = new Dictionary_Dictionary();
            }
            return this._map;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseObject.prototype, "delayedMap", {
        /**
         * Returns mapping for objects referenced by id in JSON config that are not yet
         * available at processing time.
         *
         * @ignore Exclude from docs
         * @return Map collection
         */
        get: function () {
            if (!this._delayedMap) {
                this._delayedMap = new Dictionary_Dictionary();
            }
            return this._delayedMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Logs an id and property of the target element that is not yet available
     * for later assignment.
     *
     * @ignore
     * @param  property  Property to set
     * @param  id        ID of the target element
     */
    BaseObject.prototype.addDelayedMap = function (property, id) {
        var map = this.delayedMap;
        if (!map.hasKey(id)) {
            map.setKey(id, []);
        }
        var list = map.getKey(id);
        list.push({
            property: property,
            target: this
        });
    };
    /**
     * Processes delayed JSON config items.
     *
     * @ignore
     */
    BaseObject.prototype.processDelayedMap = function () {
        var _this = this;
        this.delayedMap.each(function (id, list) {
            if (_this.map.hasKey(id)) {
                var target_1 = _this.map.getKey(id);
                each(list, function (item) {
                    item.target[item.property] = target_1;
                });
                _this.delayedMap.removeKey(id);
            }
        });
    };
    /**
     * Applies properties from all assigned themes.
     *
     * @ignore Exclude from docs
     */
    BaseObject.prototype.applyTheme = function () {
        var _this = this;
        // TODO is this needed ?
        if (registry) {
            var themes = this.getCurrentThemes();
            // TODO is this needed ?
            if (themes) {
                each(themes, function (theme, index) {
                    theme(_this);
                });
            }
        }
    };
    Object.defineProperty(BaseObject.prototype, "themes", {
        /**
         * @ignore Exclude from docs
         * @return An array of themes
         */
        get: function () {
            return this._themes;
        },
        /**
         * A list of themes to be used for this element.
         *
         * @ignore Exclude from docs
         * @param value An array of themes
         */
        set: function (value) {
            this._themes = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a list of themes that should be applied to this element. It could
     * either be a list of themes set explicitly on this element, or system-wide.
     *
     * @return List of themes
     */
    BaseObject.prototype.getCurrentThemes = function () {
        return this.themes || registry.themes;
    };
    /**
     * Returns if this object has been already been disposed.
     *
     * @return Is disposed?
     */
    BaseObject.prototype.isDisposed = function () {
        return this._disposed;
    };
    /**
     * Destroys this object and all related data.
     */
    BaseObject.prototype.dispose = function () {
        if (!this._disposed) {
            this._disposed = true;
            var a = this._disposers;
            this._disposers = null;
            while (a.length !== 0) {
                var disposer = a.shift();
                disposer.dispose();
            }
            // Clear cache
            this.clearCache();
            // remove from clones list
            if (this.clonedFrom) {
                this.clonedFrom.clones.removeValue(this);
            }
            var uid = this._uid;
            if (uid != null) {
                registry.map.removeKey(uid);
            }
        }
    };
    /**
     * Adds an IDisposer, which will be disposed when this object is disposed.
     *
     * @param target Object to dispose
     * @ignore Exclude from docs
     */
    BaseObject.prototype.addDisposer = function (target) {
        this._disposers.push(target);
    };
    /**
     * Disposes disposable object and removes it from `_disposers`.
     *
     * @param target Object to dispose
     * @ignore Exclude from docs
     */
    BaseObject.prototype.removeDispose = function (target) {
        //if(target){
        if (!this._disposed) {
            var index = indexOf(this._disposers, target);
            if (index > -1) {
                this._disposers.splice(index, 1);
            }
        }
        target.dispose();
        //}
    };
    /**
     * Makes a copy of this object and returns the clone. Try to avoid cloning complex objects like chart, create new instances if you need them.
     *
     * @param cloneId  An id to use for clone (if not set a unique id will be generated)
     * @returns Clone
     */
    BaseObject.prototype.clone = function (cloneId) {
        if (!cloneId) {
            cloneId = "clone-" + registry.getUniqueId();
        }
        var newObject = new this.constructor();
        newObject.cloneId = cloneId;
        newObject.copyFrom(this);
        // add to clones list
        // this.clones.push(newObject); // moved this to copyFrom
        return newObject;
    };
    Object.defineProperty(BaseObject.prototype, "clones", {
        /**
         * Returns a collection of object's clones.
         *
         * @ignore Exclude from docs
         * @return Clones
         */
        get: function () {
            if (!this._clones) {
                this._clones = new List_List();
            }
            return this._clones;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all properties and related data from different element.
     *
     * @param object Source element
     */
    BaseObject.prototype.copyFrom = function (object) {
        object.clones.push(this); // do not moveValue, as it is expensive! even if there will be several items in clones list, it's not that bad.
        this.clonedFrom = object;
    };
    Object.defineProperty(BaseObject.prototype, "className", {
        /**
         * @ignore Exclude from docs
         * @return Class name
         */
        get: function () {
            return this._className;
        },
        /**
         * Element's class name. (a class that was used to instantiate the element)
         *
         * @ignore Exclude from docs
         * @param value  Class name
         */
        set: function (value) {
            this._className = value;
            /*if (registry) {
                registry.registeredClasses[value] = typeof this;
            }*/
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Caches value in object's cache.
     *
     * @ignore Exclude from docs
     * @param key    Key
     * @param value  Value
     * @param ttl    TTL in seconds
     */
    BaseObject.prototype.setCache = function (key, value, ttl) {
        Cache_cache.set(this.uid, key, value, ttl);
    };
    /**
     * Retrieves cached value.
     *
     * If optional second padarameter is specified, it will return that value
     * if cache is not available or is expired.
     *
     * @ignore Exclude from docs
     * @param key    Key
     * @param value  Value to return if cache is not available
     * @return Value
     */
    BaseObject.prototype.getCache = function (key, value) {
        if (value === void 0) { value = undefined; }
        return Cache_cache.get(this.uid, key, value);
    };
    /**
     * Clears object's local cache.
     *
     * @ignore Exclude from docs
     */
    BaseObject.prototype.clearCache = function () {
        Cache_cache.clear(this.uid);
    };
    /**
     * Creates [[Disposer]] for `setTimeout` function call. This ensures that all
     * timeouts created by the object will be cleared when object itself is
     * disposed.
     *
     * @ignore Exclude from docs
     * @param fn     Callback function
     * @param delay  Timeout (ms)
     * @return Disposer for timeout
     */
    BaseObject.prototype.setTimeout = function (fn, delay) {
        var _this = this;
        var id = setTimeout(function () {
            _this.removeDispose(disposer);
            fn();
        }, delay);
        var disposer = new Disposer(function () {
            clearTimeout(id);
        });
        this._disposers.push(disposer);
        return disposer;
    };
    /**
     * Creates [[Disposer]] for `setInterval` function call. This ensures that all
     * timeouts created by the object will be cleared when object itself is
     * disposed.
     *
     * @ignore Exclude from docs
     * @param fn     Callback function
     * @param delay  Timeout (ms)
     * @return Disposer for timeout
     */
    BaseObject.prototype.setInterval = function (fn, delay) {
        var _this = this;
        var id = setInterval(function () {
            _this.removeDispose(disposer);
            fn();
        }, delay);
        var disposer = new Disposer(function () {
            clearTimeout(id);
        });
        this._disposers.push(disposer);
        return disposer;
    };
    Object.defineProperty(BaseObject.prototype, "config", {
        /**
         * ==========================================================================
         * JSON-BASED CONFIG PROCESSING
         * ==========================================================================
         * @hidden
         */
        /**
         * Use this property to set JSON-based config. When set, triggers processing
         * routine, which will go through all properties, and try to apply values,
         * create instances, etc.
         *
         * Use this with caution, as it is a time-consuming process. It's used for
         * initialchart setup only, not routine operations.
         *
         * @param json JSON config
         */
        set: function (config) {
            try {
                this.processConfig(config);
            }
            catch (e) {
                /*if (this instanceof Sprite) {
                    this.raiseCriticalError(e);
                }*/
                this.raiseCriticalError(e);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Processes the JSON config.
     *
     * @param json  JSON config
     * @ignore Exclude from docs
     */
    BaseObject.prototype.processConfig = function (config) {
        var _this = this;
        if (!config) {
            return;
        }
        // Get target
        var target = this;
        // Iterate through all of the items
        eachOrdered(config, function (configKey, value) {
            var configValue = value;
            // Is this a callback?
            if (configKey == "callback" && typeof value == "function") {
                value.call(target);
            }
            // Check if there's a property in target
            if (_this.hasProperty(configKey)) {
                var item_1;
                // Do we have instructions to create an object?
                // We create a new object if "type" key is set, but only if the
                // target object is of different type.
                if (isObject(configValue)
                    && hasValue(configValue["type"])
                    && (!isObject(target[configKey])
                        || !hasValue(target[configKey].className)
                        || configValue["forceCreate"]
                        || target[configKey].className != configValue["type"])
                    && !_this.asIs(configKey)) {
                    item_1 = _this.createClassInstance(configValue["type"]);
                    // Create new instance
                    if (item_1) {
                        target[configKey] = item_1;
                    }
                    else {
                        item_1 = target[configKey];
                    }
                }
                else {
                    // Get item from the object
                    item_1 = target[configKey];
                }
                /**
                 * It is...
                 * --------------------------------------------------------------------
                 */
                if (item_1 instanceof Adapter_Adapter) {
                    // ... an Adapter, try to add handlers to it
                    // ------------------------------------------------------------------
                    _this.processAdapters(item_1, configValue);
                }
                else if (item_1 instanceof EventDispatcher_EventDispatcher) {
                    // ... an EventDispatcher, try to add handlers to it
                    // ------------------------------------------------------------------
                    _this.processEvents(item_1, configValue);
                }
                else if (configKey == "locale" && isString(configValue)) {
                    // ... a locale specified as string, e.g. "fr_FR"
                    // ------------------------------------------------------------------
                    if (window["am4lang_" + configValue]) {
                        target[configKey] = window["am4lang_" + configValue];
                    }
                }
                else if (configKey == "parent" && isString(configValue)) {
                    // ... a parent referred via its it
                    // ------------------------------------------------------------------
                    var parent_1 = _this.map.getKey(configValue);
                    if (parent_1) {
                        target[configKey] = parent_1;
                    }
                    else {
                        _this.addDelayedMap("parent", configValue);
                    }
                }
                else if (_this.asIs(configKey)) {
                    // ... a special field, just set it to new value
                    // ------------------------------------------------------------------
                    // (no need to add each indvidual item)
                    target[configKey] = configValue;
                }
                else if (_this.asFunction(configKey) && isString(configValue)) {
                    // ... a field indicating function name to look for in registry
                    // ------------------------------------------------------------------
                    if (hasValue(registry.registeredClasses[configValue])) {
                        target[configKey] = registry.registeredClasses[configValue];
                    }
                    else {
                        throw Error("Invalid easing function: " + configValue);
                    }
                }
                else if (configValue instanceof BaseObject) {
                    // ... a BaseObject object, we just going to use it as it is
                    // ------------------------------------------------------------------
                    target[configKey] = configValue;
                }
                else if (item_1 instanceof BaseObject) {
                    // ... another child BaseObject
                    // ------------------------------------------------------------------
                    // Let's just pass in config part in and let itself deal with it
                    item_1.config = configValue;
                }
                else if (item_1 instanceof List_ListTemplate || item_1 instanceof SortedList_OrderedListTemplate || item_1 instanceof SortedList_SortedListTemplate) {
                    // ... a list with template
                    // ------------------------------------------------------------------
                    // Let's see what we can do with it
                    if (isArray(configValue)) {
                        // It's an array.
                        // Create a list item for entry, or try to apply properties to an
                        // existing entry if possible and it is present.
                        if (item_1 instanceof List_ListTemplate) {
                            _this.processListTemplate(configValue, item_1);
                        }
                        else {
                            _this.processOrderedTemplate(configValue, item_1);
                        }
                    }
                    else if (isObject(configValue)) {
                        // It's a single oject.
                        // Treat it as a template.
                        if (configValue instanceof BaseObject) {
                            // Item is already a BaseObject, no need to process it further
                            item_1.template = configValue;
                        }
                        else {
                            // Now let's find out if the whole object if a template, or we
                            // need to get it from `template` key
                            var templateValue = void 0;
                            if (hasValue(configValue.template)) {
                                templateValue = configValue.template;
                            }
                            else {
                                templateValue = configValue;
                            }
                            if (item_1.template instanceof BaseObject) {
                                // Template is a BaseObject so we will just let its config
                                // deal with the configuration
                                item_1.template.config = templateValue;
                            }
                            else {
                                Object_each(templateValue, function (entryKey, entryValue) {
                                    var listItem = item_1.template[entryKey];
                                    if (listItem instanceof Adapter_Adapter) {
                                        _this.processAdapters(listItem, entryValue);
                                    }
                                    else if (listItem instanceof EventDispatcher_EventDispatcher) {
                                        _this.processEvents(listItem, entryValue);
                                    }
                                    else if (listItem instanceof Dictionary_DictionaryTemplate) {
                                        _this.processDictionaryTemplate(listItem, entryValue);
                                    }
                                    else if (item_1.template[entryKey] instanceof BaseObject) {
                                        // Template is a BaseObject. Let it deal with its own config.
                                        item_1.template[entryKey].config = entryValue;
                                    }
                                    else if (isObject(entryValue) && hasValue(entryValue["type"])) {
                                        listItem = _this.createClassInstance(entryValue["type"]);
                                        if (listItem) {
                                            if (listItem instanceof BaseObject) {
                                                listItem.config = entryValue;
                                            }
                                            item_1.template[entryKey] = listItem;
                                        }
                                        else {
                                            item_1.template[entryKey] = entryValue;
                                        }
                                    }
                                    else if (listItem instanceof List_List) {
                                        // It's List, process it
                                        _this.processList(entryValue, listItem);
                                    }
                                    else {
                                        // Aything else. Just assing and be done with it.
                                        item_1.template[entryKey] = _this.maybeColorOrPercent(entryValue);
                                    }
                                });
                            }
                            // Check maybe there are `values` to insert
                            if (hasValue(configValue.values)) {
                                if (item_1 instanceof List_ListTemplate) {
                                    _this.processListTemplate(configValue.values, item_1);
                                }
                                else {
                                    _this.processOrderedTemplate(configValue.values, item_1);
                                }
                            }
                        }
                    }
                    else {
                        // Something else?
                        // Not sure what to do with it on a list - ignore
                    }
                }
                else if (item_1 instanceof List_List) {
                    // ... a list
                    // ------------------------------------------------------------------
                    if (configKey == "children") {
                        _this.processList(configValue, item_1, _this);
                    }
                    else {
                        _this.processList(configValue, item_1);
                    }
                }
                else if (item_1 instanceof Dictionary_DictionaryTemplate) {
                    // ... a dictionary with template
                    // ------------------------------------------------------------------
                    _this.processDictionaryTemplate(item_1, configValue);
                }
                else if (item_1 instanceof Dictionary_Dictionary) {
                    // ... a dictionary
                    // ------------------------------------------------------------------
                    _this.processDictionary(item_1, configValue);
                }
                else if (item_1 instanceof Color_Color || item_1 instanceof Percent) {
                    // ... it's a Color or Percent
                    // ------------------------------------------------------------------
                    target[configKey] = _this.maybeColorOrPercent(configValue);
                }
                else if (isObject(item_1) && isObject(configValue)) {
                    // ... a regular object
                    // ------------------------------------------------------------------
                    copyAllProperties(configValue, item_1);
                }
                else {
                    // ... something else - probably a simple property or object
                    // ------------------------------------------------------------------
                    // Maybe convert to `Percent` or `Color`?
                    configValue = _this.maybeColorOrPercent(configValue);
                    // Assign
                    target[configKey] = configValue;
                }
            }
            else if (!_this.isReserved(configKey)) {
                // Doesn't have property set. But we're going to assume JSON config
                // creator knows what he/she is doing and set it anyway.
                target[configKey] = configValue;
            }
        }, this.configOrder);
        // Any errors?
        if (this.processingErrors.length) {
            var errors = this.processingErrors.join("\n");
            this._processingErrors = [];
            throw Error(errors);
        }
    };
    /**
     * Tries to detect if value is color or percent and converts to proper object
     * if necessary.
     *
     * Returns the same source value if no color/percent detected
     *
     * @param value  Source value
     * @return Converted value
     */
    BaseObject.prototype.maybeColorOrPercent = function (value) {
        if (isString(value)) {
            if (value.match(/^[\-]?[0-9.]+\%$/)) {
                return Percent_percent(toNumber(value));
            }
            else if (value.match(/^\#[0-9abcdef]{3,}$/i)) {
                return Color_color(value);
            }
        }
        return value;
    };
    BaseObject.prototype.processAdapters = function (item, config) {
        var _this = this;
        if (isArray(config)) {
            each(config, function (entry, index) {
                item.add(entry.key, entry.callback, entry.priority || 0, _this);
            });
        }
        else if (isObject(config)) {
            Object_each(config, function (key, entry) {
                if (!item.has(key, entry)) {
                    item.add(key, entry);
                }
            });
        }
    };
    BaseObject.prototype.processEvents = function (item, config) {
        var _this = this;
        if (isObject(config)) {
            Object_each(config, function (key, entry) {
                if (!item.has(key, entry)) {
                    item.on(key, entry);
                }
            });
        }
        else if (isArray(config)) {
            each(config, function (entry, index) {
                item.on(entry.type, entry.callback, _this);
            });
        }
    };
    /**
     * Processes JSON config for a [[DictionaryTemplate]] item.
     *
     * @todo Description
     * @param item    Item
     * @param config  Config
     */
    BaseObject.prototype.processDictionaryTemplate = function (item, config) {
        // We can only process object
        // Not sure what to do with other types - ignore
        if (isObject(config)) {
            // Create an entry for each item, or override properties for
            // existing one.
            Object_each(config, function (entryKey, entryValue) {
                var listItem;
                // Get existing one, or create a new one
                if (entryKey == "template") {
                    listItem = item.template;
                }
                else if (item.hasKey(entryKey)) {
                    listItem = item.getKey(entryKey);
                }
                else {
                    listItem = item.create(entryKey);
                }
                // Set data
                if (listItem instanceof BaseObject) {
                    listItem.config = entryValue;
                }
                else if (isObject(listItem) && isObject(entryValue)) {
                    copyAllProperties(entryValue, listItem);
                }
                else {
                    listItem.setKey(entryKey, entryValue);
                }
            });
        }
    };
    /**
     * Processes JSON config for a [[Dictionary]] item.
     *
     * @todo Description
     * @param item    Item
     * @param config  Config
     */
    BaseObject.prototype.processDictionary = function (item, config) {
        // We can only process object
        // Not sure what to do with other types - ignore
        if (isObject(config)) {
            // Create an entry for each item, or override properties for
            // existing one.
            // @todo support for non-basic types
            Object_each(config, function (entryKey, entryValue) {
                item.setKey(entryKey, entryValue);
            });
        }
    };
    /**
     * Processes [[ListTemplate]].
     *
     * @param configValue  Config value
     * @param item         Item
     */
    BaseObject.prototype.processListTemplate = function (configValue, item) {
        var _this = this;
        each(configValue, function (entry, index) {
            var type = _this.getConfigEntryType(entry);
            var listItem;
            if (item.hasIndex(index) && !entry["forceCreate"]) {
                listItem = item.getIndex(index);
            }
            else if (entry instanceof BaseObject) {
                // Item is already a BaseObject, no need to process it further
                item.push(entry);
                return;
            }
            else if (type) {
                listItem = item.create(type);
            }
            else {
                listItem = item.create();
            }
            if (entry === listItem) {
                // It's already the same item, do nothing
            }
            else {
                if (isObject(entry)) {
                    // If the list item is BaseObject, we just need to let it
                    // deal if its own config
                    if (listItem instanceof BaseObject) {
                        listItem.config = entry;
                    }
                    else if (isObject(listItem) && isObject(entry)) {
                        copyAllProperties(entry, listItem);
                    }
                    else {
                        item.setIndex(item.indexOf(listItem), entry);
                    }
                }
            }
        });
        // Truncate the list if it contains less items than the config
        // array
        while (configValue.length > item.length) {
            item.pop();
        }
    };
    /**
     * Processes [[OrdererListTemplate]] or [[SortedListTemplate]].
     *
     * @param configValue  Config value
     * @param item         Item
     */
    BaseObject.prototype.processOrderedTemplate = function (configValue, item) {
        var _this = this;
        each(configValue, function (entry, index) {
            var type = _this.getConfigEntryType(entry);
            var listItem;
            if (type) {
                listItem = item.create(type);
            }
            else {
                listItem = item.create();
            }
            if (isObject(entry)) {
                // If the list item is BaseObject, we just need to let it
                // deal if its own config
                if (listItem instanceof BaseObject) {
                    listItem.config = entry;
                }
                else if (isObject(listItem) && isObject(entry)) {
                    copyAllProperties(entry, listItem);
                }
                else {
                    item.insert(entry);
                }
            }
        });
    };
    /**
     * Processes [[List]].
     *
     * @param configValue  Config value
     * @param item         Item
     */
    BaseObject.prototype.processList = function (configValue, item, parent) {
        var _this = this;
        // Convert to array if necessary
        if (!isArray(configValue)) {
            configValue = [configValue];
        }
        // It's an array
        // Create a list item for entry
        var itemCount = item.length;
        each(configValue, function (entry, index) {
            if (isObject(entry)) {
                // An object.
                //
                // Let's see if we can instantiate a class out of it, or we need
                // to push it into list as it is.
                //
                // If there are items already at the specified index in the list,
                // apply properties rather than create a new one.
                var listItem = void 0;
                if ((index < itemCount) && !entry["forceCreate"]) {
                    listItem = item.getIndex(index);
                }
                else if (entry instanceof BaseObject) {
                    // Item is already a BaseObject, no need to process it further
                    item.push(entry);
                    return;
                }
                else {
                    listItem = _this.createEntryInstance(entry);
                    if (parent) {
                        listItem.parent = parent;
                    }
                    else {
                        item.push(listItem);
                    }
                }
                // If the list item is BaseObject, we just need to let it
                // deal if its own config
                if (listItem instanceof BaseObject) {
                    listItem.config = entry;
                }
                else if (isObject(listItem) && isObject(entry)) {
                    copyAllProperties(entry, listItem);
                }
            }
            else {
                // Basic value.
                // Just push it into list, or override existing value
                if (item.hasIndex(index)) {
                    item.setIndex(index, entry);
                }
                else {
                    item.push(entry);
                }
            }
        });
        // Truncate the list if it contains less items than the config
        // array
        while (configValue.length > item.length) {
            item.pop();
        }
    };
    /**
     * This function is used to sort element's JSON config properties, so that
     * some properties that absolutely need to be processed last, can be put at
     * the end.
     *
     * @ignore Exclude from docs
     * @param a  Element 1
     * @param b  Element 2
     * @return Sorting number
     */
    BaseObject.prototype.configOrder = function (a, b) {
        if (a == b) {
            return 0;
        }
        // Language must come first, so it's all set up when the rest of the
        // elements are being instantiated
        else if (a == "language") {
            return -1;
        }
        else if (b == "language") {
            return 1;
        }
        else {
            return 0;
        }
    };
    /**
     * Checks if field should be just assigned as is, without any checking when
     * processing JSON config.
     *
     * Extending functions can override this function to do their own checks.
     *
     * @param field  Field name
     * @return Assign as is?
     */
    BaseObject.prototype.asIs = function (field) {
        return indexOf(["locale"], field) != -1;
    };
    /**
     * Checks if field needs to be converted to function, if it is specified
     * as string.
     *
     * @param field  Field name
     * @return Assign as function?
     */
    BaseObject.prototype.asFunction = function (field) {
        return false;
    };
    /**
     * Creates a relevant class instance if such class definition exists.
     *
     * @ignore Exclude from docs
     * @param className  Class name
     * @return Instance
     */
    BaseObject.prototype.createClassInstance = function (className) {
        if (hasValue(registry.registeredClasses[className])) {
            return new registry.registeredClasses[className]();
        }
        else {
            throw Error("Invalid type: \"" + className + "\".");
        }
    };
    /**
     * Creates a class instance for a config entry using it's type. (as set in
     * `type` property)
     *
     * @ignore Exclude from docs
     * @param config  Config part
     * @return Instance
     */
    BaseObject.prototype.createEntryInstance = function (config) {
        var res;
        if (hasValue(config["type"])) {
            res = this.createClassInstance(config["type"]);
        }
        if (!res) {
            return config;
        }
        return res;
    };
    /**
     * Determines config object type.
     *
     * @ignore Exclude from docs
     * @param config  Config part
     * @return Type
     */
    BaseObject.prototype.getConfigEntryType = function (config) {
        if (hasValue(config["type"])) {
            if (hasValue(registry.registeredClasses[config["type"]])) {
                return registry.registeredClasses[config["type"]];
            }
            else {
                throw Error("Invalid type: \"" + config["type"] + "\".");
            }
        }
        return;
    };
    /**
     * Checks if this element has a property.
     *
     * @ignore Exclude from docs
     * @param prop  Property name
     * @return Has property?
     */
    BaseObject.prototype.hasProperty = function (prop) {
        return prop in this ? true : false;
    };
    /**
     * Checkes whether JSON key is a reserved keyword.
     *
     * @param key  Key
     * @return Reserved
     */
    BaseObject.prototype.isReserved = function (key) {
        return ["type", "forceCreate"].indexOf(key) !== -1;
    };
    Object.defineProperty(BaseObject.prototype, "processingErrors", {
        /**
         * A list of errors that happened during JSON processing.
         *
         * @return Errors
         */
        get: function () {
            if (!this._processingErrors) {
                this._processingErrors = [];
            }
            return this._processingErrors;
        },
        enumerable: true,
        configurable: true
    });
    return BaseObject;
}());

;
/**
 * A version of [[BaseObject]] with events properties and methods.
 * Classes that use [[EventDispatcher]] should extend this instead of
 * [[BaseObject]] directly.
 */
var Base_BaseObjectEvents = /** @class */ (function (_super) {
    __extends(BaseObjectEvents, _super);
    /**
     * Constructor
     */
    function BaseObjectEvents() {
        var _this = _super.call(this) || this;
        _this.className = "BaseObjectEvents";
        return _this;
    }
    Object.defineProperty(BaseObjectEvents.prototype, "events", {
        /**
         * An [[EventDispatcher]] instance
         */
        get: function () {
            if (!this._eventDispatcher) {
                this._eventDispatcher = new EventDispatcher_EventDispatcher();
                this._disposers.push(this._eventDispatcher);
            }
            return this._eventDispatcher;
        },
        enumerable: true,
        configurable: true
    });
    //public set events(value:EventDispatcher<AMEvent<this, this["_events"]>>){
    //	this._eventDispatcher = value;
    //}
    /**
     * Dispatches an event using own event dispatcher. Will automatically
     * populate event data object with event type and target (this element).
     * It also checks if there are any handlers registered for this sepecific
     * event.
     *
     * @param eventType Event type (name)
     * @param data      Data to pass into event handler(s)
     */
    BaseObjectEvents.prototype.dispatch = function (eventType, data) {
        // @todo Implement proper type check
        if (this._eventDispatcher) {
            if (this.events.isEnabled(eventType)) {
                if (data) {
                    data.type = eventType;
                    data.target = data.target || this;
                    this.events.dispatch(eventType, {
                        type: eventType,
                        target: this
                    });
                }
                else {
                    this.events.dispatch(eventType, {
                        type: eventType,
                        target: this
                    });
                }
            }
        }
    };
    /**
     * Works like `dispatch`, except event is triggered immediately, without
     * waiting for the next frame cycle.
     *
     * @param eventType Event type (name)
     * @param data      Data to pass into event handler(s)
     */
    BaseObjectEvents.prototype.dispatchImmediately = function (eventType, data) {
        // @todo Implement proper type check
        if (this._eventDispatcher) {
            if (this.events.isEnabled(eventType)) {
                if (data) {
                    data.type = eventType;
                    data.target = data.target || this;
                    this.events.dispatchImmediately(eventType, data);
                }
                else {
                    this.events.dispatchImmediately(eventType, {
                        type: eventType,
                        target: this
                    });
                }
            }
        }
    };
    /**
     * Copies all parameters from another [[Sprite]].
     *
     * @param source Source object
     */
    BaseObjectEvents.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (source._eventDispatcher) {
            this.events.copyFrom(source._eventDispatcher);
        }
    };
    return BaseObjectEvents;
}(Base_BaseObject));

//# sourceMappingURL=Base.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Browser.js
// Also detects iOS
function isSafari() {
    return /apple/i.test(navigator.vendor);
}
function isInternetExplorer() {
    return /MSIE |Trident\//.test(navigator.userAgent);
}
//# sourceMappingURL=Browser.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Strings.js
/**
 * A collection of String-based constants.
 * @hidden
 * @ignore Exclude from docs
 */
/**
 * @ignore Exclude from docs
 */
var PX = "px";
/**
 * @ignore Exclude from docs
 */
var STRING = "string";
/**
 * @ignore Exclude from docs
 */
var NUMBER = "number";
/**
 * @ignore Exclude from docs
 */
var DATE = "date";
/**
 * @ignore Exclude from docs
 */
var DURATION = "duration";
/**
 * @ignore Exclude from docs
 */
var PLACEHOLDER = "__§§§__";
/**
 * @ignore Exclude from docs
 */
var PLACEHOLDER2 = "__§§§§__";
//# sourceMappingURL=Strings.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Utils.js
/**
 * A collection of universal utility functions.
 */








/**
 * ============================================================================
 * MISC FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Marks a value as being used (e.g. because the value has side effects).
 */
function used(value) { }
/**
 * Copies all properties of one object to the other, omitting undefined.
 *
 * @param fromObject  Source object
 * @param toObject    Target object
 * @return Updated target object
 * @todo Maybe consolidate with utils.copy?
 */
function Utils_copyProperties(source, target) {
    Object_each(source, function (key, value) {
        // only if value is set
        if (hasValue(value)) {
            target[key] = value;
        }
    });
    return target;
}
/**
 * Removes target from url
 */
function stripHash(url) {
    return /^[^#]*/.exec(url)[0];
}
function getBaseURI() {
    var url = "#";
    // Needed until https://bugs.webkit.org/show_bug.cgi?id=189499 is fixed
    if (isSafari()) {
        var baseURI = document.baseURI;
        if (baseURI) {
            baseURI = stripHash(baseURI);
            var loc = stripHash(location.href);
            if (baseURI !== loc) {
                url = loc + url;
            }
        }
    }
    return url;
}
/**
 * Copies all properties of one object to the other, omitting undefined, but only if property in target object doesn't have a value set.
 *
 * @param fromObject  Source object
 * @param toObject    Target object
 * @return Updated target object
 * @todo Maybe consolidate with utils.copy?
 */
function Utils_softCopyProperties(source, target) {
    Object_each(source, function (key, value) {
        // only if value is set
        if (hasValue(value) && !(hasValue(target[key]))) {
            target[key] = value;
        }
    });
    return target;
}
/**
 * Copies all properties of one object to the other.
 *
 * @param source     Source object
 * @param recipient  Target object
 * @return Updated target object
 */
function Utils_copy(source, target) {
    Object_each(source, function (key, value) {
        target[key] = value;
    });
    return target;
}
/**
 * Checks if value is not empty (undefined or zero-length string).
 *
 * @param value  Value to check
 * @return `true` if value is not "empty"
 */
function isNotEmpty(value) {
    return hasValue(value) && (value.toString() !== "");
}
/**
 * [relativeToValue description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param percent  [description]
 * @param full     [description]
 * @return [description]
 */
function relativeToValue(percent, full) {
    if (isNumber(percent)) {
        return percent;
    }
    else if (percent != null && isNumber(percent.value) && isNumber(full)) {
        return full * percent.value;
    }
    else {
        return 0;
    }
}
/**
 * [relativeRadiusToValue description]
 *
 * Differs from relativeToValue so that if a value is negative, it subtracts
 * it from full value.
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param percent             [description]
 * @param full                [description]
 * @param subtractIfNegative  [description]
 * @return [description]
 */
function relativeRadiusToValue(percent, full, subtractIfNegative) {
    var value;
    if (isNumber(percent)) {
        value = percent;
        if (value < 0) {
            if (subtractIfNegative) {
                value = full + value;
            }
            else {
                value = full - value;
            }
        }
    }
    else if (percent != null && isNumber(percent.value)) {
        value = full * percent.value;
    }
    return value;
}
/**
 * [valueToRelative description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param value  [description]
 * @param full   [description]
 * @return [description]
 */
function valueToRelative(value, full) {
    if (value instanceof Percent) {
        return value.value;
    }
    else {
        return value / full;
    }
}
/**
 * Returns pixel ratio of the current screen (used on retina displays).
 *
 * @return Pixel ratio
 */
function getPixelRatio() {
    var ratio = window.devicePixelRatio || 1;
    return ratio;
}
/**
 * ============================================================================
 * STRING FORMATTING FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Converts camelCased text to dashed version:
 * ("thisIsString" > "this-is-string")
 *
 * @param str  Input
 * @return Output
 */
function camelToDashed(str) {
    return str.replace(/\W+/g, '-').replace(/([a-z\d])([A-Z])/g, '$1-$2').toLowerCase();
}
/**
 * Converts tring to uppercase.
 *
 * @param str  String to convert
 * @return uppercased string
 * @todo Maybe make it better
 */
function capitalize(str) {
    var arr = str.split("");
    arr[0] = arr[0].toUpperCase();
    return arr.join("");
}
/**
 * Converts any value into its string representation.
 *
 * @param value  Value
 * @return String represantation of the value
 */
function stringify(value) {
    return JSON.stringify(value);
}
/**
 * Escapes string so it can safely be used in a Regex.
 *
 * @param value  Unsescaped string
 * @return Escaped string
 */
function escapeForRgex(value) {
    return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
/**
 * Splits the text into multiple lines, respecting maximum character count.
 * Prioretizes splitting on spaces and punctuation. Falls back on splitting
 * mid-word if there's no other option.
 *
 * @param text      Text
 * @param maxChars  Maximum number of characters per line
 * @return An array of split text
 */
function splitTextByCharCount(text, maxChars, fullWords, rtl) {
    // Maybe the text fits?
    if (text.length <= maxChars) {
        return [text];
    }
    // Init result
    var res = [];
    // Split by words or by charts
    if (fullWords) {
        // Split by words first
        // Split by spacing
        var currentIndex = -1;
        var tmpText = text.replace(/([,;:!?\\\/\.]+[\s]+|[\s])/g, PLACEHOLDER + "$1" + PLACEHOLDER);
        var words = tmpText.split(PLACEHOLDER);
        // Process each word
        for (var i = 0; i < words.length; i++) {
            // Get word and symbol count
            var word = words[i];
            var wordLength = word.length;
            // Ignore empty words
            if (wordLength === 0) {
                continue;
            }
            // Check word length
            //if ((wordLength > maxChars) && fullWords !== true) {
            if (wordLength > maxChars) {
                // A single word is longer than allowed symbol count
                // Break it up
                if (rtl) {
                    word = reverseString(word);
                }
                var parts = word.match(new RegExp(".{1," + maxChars + "}", "g"));
                // TODO is this correct ?
                if (parts) {
                    if (rtl) {
                        for (var x = 0; x < parts.length; x++) {
                            parts[x] = reverseString(parts[x]);
                        }
                        //parts.reverse();
                    }
                    res = res.concat(parts);
                }
            }
            else {
                // Init current line
                if (currentIndex === -1) {
                    res.push("");
                    currentIndex = 0;
                }
                // Check if we need to break into another line
                if (((res[currentIndex].length + wordLength + 1) > maxChars) && res[currentIndex] !== "") {
                    res.push("");
                    currentIndex++;
                }
                // Add word
                res[currentIndex] += word;
            }
            // Update index
            currentIndex = res.length - 1;
        }
    }
    else {
        // Splitting by anywhere (living la vida facil)
        var parts = text.match(new RegExp(".{1," + maxChars + "}", "g"));
        if (parts) {
            if (rtl) {
                for (var x = 0; x < parts.length; x++) {
                    parts[x] = reverseString(parts[x]);
                }
            }
            res = parts;
        }
    }
    // Do we have only one word that does not fit?
    // Since fullWords is set and we can't split the word, we end up with empty
    // set.
    if (res.length == 1 && fullWords && (res[0].length > maxChars)) {
        res = [];
    }
    return res;
}
/**
 * Truncates the text to certain character count.
 *
 * Will add ellipsis if the string is truncated. Optionally, can truncate on
 * full words only.
 *
 * For RTL support, pass in the fifth parameter as `true`.
 *
 * @param text       Input text
 * @param maxChars   Maximum character count of output
 * @param ellipsis   Ellipsis string, i.e. "..."
 * @param fullWords  If `true`, will not break mid-word, unless there's a single word and it does not with into `maxChars`
 * @param rtl        Is this an RTL text?
 * @return Truncated text
 */
function truncateWithEllipsis(text, maxChars, ellipsis, fullWords, rtl) {
    if (text.length <= maxChars) {
        return text;
    }
    // Calc max chars
    maxChars -= ellipsis.length;
    if (maxChars < 1) {
        maxChars = 1;
        //ellipsis = "";
    }
    // Get lines
    var lines = splitTextByCharCount(text, maxChars, fullWords, rtl);
    // Use first line
    return (lines[0] || "") + ellipsis;
}
/**
 * Removes whitespace from beginning and end of the string.
 *
 * @param str  Input
 * @return Output
 */
function trim(str) {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
;
/**
 * Removes whitespace from end of the string.
 *
 * @param str  Input
 * @return Output
 */
function rtrim(str) {
    return str.replace(/[\s\uFEFF\xA0]+$/g, "");
}
;
/**
 * Removes whitespace from beginning of the string.
 *
 * @param str  Input
 * @return Output
 */
function ltrim(str) {
    return str.replace(/^[\s\uFEFF\xA0]+/g, "");
}
;
/**
 * Reverses string.
 *
 * @param str  Input
 * @return Output
 */
function reverseString(str) {
    return str.split("").reverse().join("");
}
/**
 * Removes quotes from the string.
 *
 * @param str  Input
 * @return Output
 */
function unquote(str) {
    var res = str.trim();
    res = str.replace(/^'(.*)'$/, "$1");
    if (res == str) {
        res = str.replace(/^"(.*)"$/, "$1");
    }
    return res;
}
/**
 * Pads a string with additional characters to certain length.
 *
 * @param value  A numeric value
 * @param len    Result string length in characters
 * @param char   A character to use for padding
 * @return Padded value as string
 */
function padString(value, len, char) {
    if (len === void 0) { len = 0; }
    if (char === void 0) { char = "0"; }
    if (typeof value !== "string") {
        value = value.toString();
    }
    return len > value.length ? Array(len - value.length + 1).join(char) + value : value;
}
/**
 * Tries to determine format type.
 *
 * @ignore Exclude from docs
 * @param format  Format string
 * @return Format type ("string" | "number" | "date" | "duration")
 */
function getFormat(format) {
    // Undefined?
    if (typeof format === "undefined") {
        return STRING;
    }
    // Cleanup and lowercase format
    format = format.toLowerCase().replace(/^\[[^\]]*\]/, "");
    // Remove style tags
    format = format.replace(/\[[^\]]+\]/, "");
    // Trim
    format = format.trim();
    // Check for any explicit format hints (i.e. /Date)
    var hints = format.match(/\/(date|number|duration)$/);
    if (hints) {
        return hints[1];
    }
    // Check for explicit hints
    if (format === NUMBER) {
        return NUMBER;
    }
    if (format === DATE) {
        return DATE;
    }
    if (format === DURATION) {
        return DURATION;
    }
    // Detect number formatting symbols
    if (format.match(/[#0]/)) {
        return NUMBER;
    }
    // Detect date formatting symbols
    if (format.match(/[ymwdhnsqaxkzgtei]/)) {
        return DATE;
    }
    // Nothing? Let's display as string
    return STRING;
}
/**
 * Cleans up format:
 * * Strips out formatter hints
 *
 * @ignore Exclude from docs
 * @param format  Format
 * @return Cleaned format
 */
function cleanFormat(format) {
    return format.replace(/\/(date|number|duration)$/i, "");
}
/**
 * Strips all tags from the string.
 *
 * @param text  Source string
 * @return String without tags
 */
function stripTags(text) {
    return text ? text.replace(/<[^>]*>/g, "") : text;
}
/**
 * Removes new lines and tags from a string.
 *
 * @param text  String to conver
 * @return Converted string
 */
function plainText(text) {
    return text ? stripTags(text.replace(/[\n\r]+/g, ". ")) : text;
}
/**
 * ============================================================================
 * TYPE CONVERSION FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Converts numeric value into string. Deals with large or small numbers that
 * would otherwise use exponents.
 *
 * @param value  Numeric value
 * @return Numeric value as string
 */
function numberToString(value) {
    // TODO handle Infinity and -Infinity
    if (Type_isNaN(value)) {
        return "NaN";
    }
    if (value === Infinity) {
        return "Infinity";
    }
    if (value === -Infinity) {
        return "-Infinity";
    }
    // Negative 0
    if ((value === 0) && (1 / value === -Infinity)) {
        return "-0";
    }
    // Preserve negative and deal with absoute values
    var negative = value < 0;
    value = Math.abs(value);
    // TODO test this
    var parsed = getValue(/^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + value));
    var digits = parsed[1];
    var decimals = parsed[2] || "";
    var res;
    // Leave the nummber as it is if it does not use exponents
    if (parsed[3] == null) {
        res = (decimals === "" ? digits : digits + "." + decimals);
    }
    else {
        var exponent = +parsed[3];
        // Deal with decimals
        if (value < 1) {
            var zeros = exponent - 1;
            res = "0." + repeat("0", zeros) + digits + decimals;
            // Deal with integers
        }
        else {
            var zeros = exponent - decimals.length;
            if (zeros === 0) {
                res = digits + decimals;
            }
            else if (zeros < 0) {
                res = digits + decimals.slice(0, zeros) + "." + decimals.slice(zeros);
            }
            else {
                res = digits + decimals + repeat("0", zeros);
            }
        }
    }
    return negative ? "-" + res : res;
}
/**
 * Converts anything to Date object.
 *
 * @param value  A value of any type
 * @return Date object representing a value
 */
function anyToDate(value) {
    if (isDate(value)) {
        // TODO maybe don't create a new Date ?
        return new Date(value);
    }
    else if (isNumber(value)) {
        return new Date(value);
    }
    else {
        // Try converting to number (assuming timestamp)
        var num = Number(value);
        if (!isNumber(num)) {
            return new Date(value);
        }
        else {
            return new Date(num);
        }
    }
}
/**
 * Tries converting any value to a number.
 *
 * @param value  Source value
 * @return Number
 */
function anyToNumber(value) {
    if (isDate(value)) {
        return value.getTime();
    }
    else if (isNumber(value)) {
        return value;
    }
    else if (isString(value)) {
        // Try converting to number (assuming timestamp)
        var num = Number(value);
        if (!isNumber(num)) {
            // Failing
            return undefined;
        }
        else {
            return num;
        }
    }
}
/**
 * ============================================================================
 * DATE-RELATED FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Returns a year day.
 *
 * @param date  Date
 * @param utc   Assume UTC dates?
 * @return Year day
 * @todo Account for UTC
 */
function getYearDay(date, utc) {
    if (utc === void 0) { utc = false; }
    var start = new Date(date.getFullYear(), 0, 0);
    var diff = (date.getTime() - start.getTime()) + ((start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000);
    var oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
}
/**
 * Returns week number for a given date.
 *
 * @param date  Date
 * @param utc   Assume UTC dates?
 * @return Week number
 * @todo Account for UTC
 */
function getWeek(date, utc) {
    if (utc === void 0) { utc = false; }
    var day = getYearDay(date, utc) - 1;
    var week = Math.floor((day - (date.getDay() || 7) + 10) / 7);
    if (week === 0) {
        week = 53;
    }
    else if (week === 53) {
        week = 1;
    }
    return week;
}
/**
 * Returns a week number in the month.
 *
 * @param date  Source Date
 * @param utc   Assume UTC dates?
 * @return Week number in month
 */
function getMonthWeek(date, utc) {
    if (utc === void 0) { utc = false; }
    var firstWeek = getWeek(new Date(date.getFullYear(), date.getMonth(), 1), utc);
    var currentWeek = getWeek(date, utc);
    if (currentWeek == 1) {
        currentWeek = 53;
    }
    return currentWeek - firstWeek + 1;
}
/**
 * Returns a year day out of the given week number.
 *
 * @param week     Week
 * @param year     Year
 * @param weekday  Weekday
 * @param utc      Assume UTC dates
 * @return Day in a year
 */
function getDayFromWeek(week, year, weekday, utc) {
    if (weekday === void 0) { weekday = 1; }
    if (utc === void 0) { utc = false; }
    var date = new Date(year, 0, 4, 0, 0, 0, 0);
    if (utc) {
        date.setUTCFullYear(year);
    }
    var day = week * 7 + weekday - ((date.getDay() || 7) + 3);
    return day;
}
/**
 * Returns 12-hour representation out of the 24-hour hours.
 *
 * @param hours  24-hour number
 * @return 12-hour number
 */
function get12Hours(hours, base) {
    if (hours > 12) {
        hours -= 12;
    }
    else if (hours === 0) {
        hours = 12;
    }
    return hasValue(base) ? hours + (base - 1) : hours;
}
/**
 * Returns a string name of the tome zone.
 *
 * @param date     Date object
 * @param long     Should return long ("Pacific Standard Time") or short abbreviation ("PST")
 * @param savings  Include information if it's in daylight savings mode
 * @param utc      Assume UTC dates
 * @return Time zone name
 */
function getTimeZone(date, long, savings, utc) {
    if (long === void 0) { long = false; }
    if (savings === void 0) { savings = false; }
    if (utc === void 0) { utc = false; }
    if (utc) {
        return long ? "Coordinated Universal Time" : "UTC";
    }
    var wotz = date.toLocaleString("UTC");
    var wtz = date.toLocaleString("UTC", { timeZoneName: long ? "long" : "short" }).substr(wotz.length);
    //wtz = wtz.replace(/[+-]+[0-9]+$/, "");
    if (savings === false) {
        wtz = wtz.replace(/ (standard|daylight|summer|winter) /i, " ");
    }
    return wtz;
}
/**
 * ============================================================================
 * NUMBER-RELATED FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Returns a random number between `from` and `to`.
 *
 * @param from  From number
 * @param to    To number
 * @return Random number
 */
function Utils_random(from, to) {
    return Math.floor(Math.random() * to) + from;
}
/**
 * Fits the number into specific `min` and `max` bounds.
 *
 * @param value  Input value
 * @param min    Minimum value
 * @param max    Maximum value
 * @return Possibly adjusted value
 */
function fitNumber(value, min, max) {
    if (value > max) {
        return max;
    }
    else if (value < min) {
        return min;
    }
    return value;
}
/**
 * Fits the number into specific `min` and `max` bounds.
 *
 * If the value is does not fit withing specified range, it "wraps" around the
 * values.
 *
 * For example, if we have input value 10 with min set at 1 and max set at 8,
 * the value will not fit. The remainder that does not fit (2) will be added
 * to `min`, resulting in 3.
 *
 * The output of regular `fitNumber()` would return 8 instead.
 *
 * @param value  Input value
 * @param min    Minimum value
 * @param max    Maximum value
 * @return Possibly adjusted value
 */
function fitNumberRelative(value, min, max) {
    var gap = max - min;
    if (value > max) {
        value = min + (value - gap * Math.floor(value / gap));
    }
    else if (value < min) {
        value = min + (value - gap * Math.floor(value / gap));
    }
    return value;
}
/**
 * ============================================================================
 * SPRITE-RELATED FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Converts SVG element coordinates to coordinates within specific [[Sprite]].
 *
 * @param point   SVG coordinates
 * @param sprite  Sprite
 * @return Sprite coordinates
 */
function svgPointToSprite(point, sprite) {
    var x = point.x;
    var y = point.y;
    var sprites = [];
    if (sprite) {
        while (hasValue(sprite.parent)) {
            sprites.push(sprite);
            sprite = sprite.parent;
        }
        sprites.reverse();
        for (var i = 0; i < sprites.length; i++) {
            var sprite_1 = sprites[i];
            var angle = sprite_1.rotation;
            var relativeX = x - sprite_1.pixelX - sprite_1.ex;
            var relativeY = y - sprite_1.pixelY - sprite_1.ey;
            if (sprite_1.dx) {
                x -= sprite_1.dx;
            }
            if (sprite_1.dy) {
                y -= sprite_1.dy;
            }
            var scale = sprite_1.scale;
            // this handles nonscaling
            if (sprite_1.group) {
                scale = sprite_1.group.scale;
            }
            x = (Math_cos(-angle) * relativeX - Math_sin(-angle) * relativeY) / scale - sprite_1.pixelPaddingLeft;
            y = (Math_cos(-angle) * relativeY + Math_sin(-angle) * relativeX) / scale - sprite_1.pixelPaddingTop;
        }
    }
    return { x: x, y: y };
}
/**
 * Converts coordinates within [[Sprite]] to coordinates relative to the whole
 * SVG element.
 *
 * @param point   Sprite coordinates
 * @param sprite  Sprite
 * @return SVG coordinates
 */
function spritePointToSvg(point, sprite) {
    var x = point.x;
    var y = point.y;
    if (sprite) {
        while (hasValue(sprite.parent)) {
            var angle = sprite.rotation;
            x += sprite.pixelPaddingLeft + sprite.ex;
            y += sprite.pixelPaddingTop + sprite.ey;
            var scale = sprite.scale;
            // this handles nonscaling
            if (sprite.group) {
                scale = sprite.group.scale;
            }
            var relativeX = sprite.pixelX + ((x * Math_cos(angle) - y * Math_sin(angle))) * scale;
            var relativeY = sprite.pixelY + ((x * Math_sin(angle) + y * Math_cos(angle))) * scale;
            if (sprite.dx) {
                relativeX += sprite.dx;
            }
            if (sprite.dy) {
                relativeY += sprite.dy;
            }
            x = relativeX;
            y = relativeY;
            sprite = sprite.parent;
        }
    }
    return { x: x, y: y };
}
/**
 * Converts coordinates of one sprite to another.
 *
 * @param point   Sprite coordinates
 * @param sprite  Sprite
 * @param toSprite  Sprite
 * @return converted coordinates
 */
function spritePointToSprite(point, sprite, toSprite) {
    return svgPointToSprite(spritePointToSvg(point, sprite), toSprite);
}
/**
 * Converts a rectangle expressed in SVG element coordinates to coordinates
 * within specific [[Sprite]].
 *
 * @param rect    SVG rectangle
 * @param sprite  Sprite
 * @return Sprite rectangle
 */
function svgRectToSprite(rect, sprite) {
    var p1 = svgPointToSprite(rect, sprite);
    var p2 = svgPointToSprite({ x: rect.x + rect.width, y: rect.y + rect.height }, sprite);
    return { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };
}
/**
 * Converts a rectangle expressed in [[Sprite]] coordinates to SVG coordinates.
 *
 * @param rect    Sprite rectangle
 * @param sprite  Sprite
 * @return SVG rectangle
 */
function spriteRectToSvg(rect, sprite) {
    var p1 = spritePointToSvg(rect, sprite);
    var p2 = spritePointToSvg({ x: rect.x + rect.width, y: rect.y + rect.height }, sprite);
    return { x: p1.x, y: p1.y, width: p2.x - p1.x, height: p2.y - p1.y };
}
/**
 * Converts global document-wide coordinates to coordinates within SVG element.
 *
 * @param point         Global coordinates
 * @param svgContainer  SVG element
 * @return SVG coordinates
 */
function documentPointToSvg(point, svgContainer, cssScale) {
    try {
        var bbox = svgContainer.getBoundingClientRect();
        if (!isNumber(cssScale)) {
            cssScale = 1;
        }
        return {
            "x": (point.x - bbox.left) / cssScale,
            "y": (point.y - bbox.top) / cssScale
        };
    }
    catch (e) {
        return point;
    }
}
/**
 * Converts SVG coordinates to global document-wide coordinates.
 *
 * @param point         SVG coordinates
 * @param svgContainer  SVG element
 * @return Global coordinates
 */
function svgPointToDocument(point, svgContainer) {
    try {
        var bbox = svgContainer.getBoundingClientRect();
        return {
            "x": point.x + bbox.left,
            "y": point.y + bbox.top
        };
    }
    catch (e) {
        return point;
    }
}
/**
 * Converts document-wide global coordinates to coordinates within specific
 * [[Sprite]].
 *
 * @param point   Global coordinates
 * @param sprite  Sprite
 * @return Sprite coordinates
 */
function documentPointToSprite(point, sprite) {
    if (sprite && sprite.htmlContainer) {
        var svgPoint = documentPointToSvg(point, getValue(sprite.htmlContainer), sprite.svgContainer.cssScale);
        return svgPointToSprite(svgPoint, sprite);
    }
    else {
        return point;
    }
}
/**
 * Converts coordinates within [[Sprite]] to global document coordinates.
 *
 * @param point   Sprite coordinates
 * @param sprite  Sprite
 * @return Global coordinates
 */
function spritePointToDocument(point, sprite) {
    if (sprite && sprite.htmlContainer) {
        var svgPoint = spritePointToSvg(point, sprite);
        return svgPointToDocument(svgPoint, getValue(sprite.htmlContainer));
    }
    else {
        return point;
    }
}
/**
 * ============================================================================
 * DEPRECATED FUNCTIONS
 * @todo Review and remove
 * ============================================================================
 * @hidden
 */
/**
 * Returns element's width.
 *
 * @ignore Exclude from docs
 * @param element  Element
 * @return Width (px)
 * @deprecated Not used anywhere
 */
function Utils_width(element) {
    var cs = getComputedStyle(element);
    var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
    var borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);
    return element.clientWidth - paddingX - borderX;
}
/**
 * Returns element's height.
 *
 * @ignore Exclude from docs
 * @param element  Element
 * @return Height (px)
 * @deprecated Not used anywhere
 */
function Utils_height(element) {
    var cs = getComputedStyle(element);
    var paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);
    var borderY = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);
    return element.clientHeight - paddingY - borderY;
}
/**
 * Returns number of decimals
 *
 * @ignore Exclude from docs
 * @param number  Input number
 * @return Number of decimals
 */
function decimalPlaces(number) {
    var match = ('' + number).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
    if (!match) {
        return 0;
    }
    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? +match[2] : 0));
}
var urlRegexp = /^([a-zA-Z][a-zA-Z0-9\+\.\-]*:)?(?:(\/\/)([^\@]+\@)?([^\/\?\#\:]*)(\:[0-9]+)?)?([^\?\#]*)(\?[^\#]*)?(\#.*)?$/;
/**
 * Parses a URL
 *
 * @ignore Exclude from docs
 */
// TODO test this
function parseUrl(url) {
    var match = urlRegexp.exec(url);
    return {
        protocol: (match && match[1]) || "",
        separator: (match && match[2]) || "",
        authority: (match && match[3]) || "",
        domain: (match && match[4]) || "",
        port: (match && match[5]) || "",
        path: (match && match[6]) || "",
        query: (match && match[7]) || "",
        hash: (match && match[8]) || ""
    };
}
/**
 * Serializes a Url into a string
 *
 * @ignore Exclude from docs
 */
function serializeUrl(url) {
    return url.protocol + url.separator + url.authority + url.domain + url.port + url.path + url.query + url.hash;
}
/**
 * Checks whether a Url is relative or not
 *
 * @ignore Exclude from docs
 */
// TODO is this correct ?
function isRelativeUrl(url) {
    return url.protocol === "" &&
        url.separator === "" &&
        url.authority === "" &&
        url.domain === "" &&
        url.port === "";
}
/**
 * Joins together two URLs, resolving relative URLs correctly
 *
 * @ignore Exclude from docs
 */
// TODO test this
function joinUrl(left, right) {
    var parsedLeft = parseUrl(left);
    var parsedRight = parseUrl(right);
    if (isRelativeUrl(parsedLeft)) {
        throw new Error("Left URL is not absolute");
    }
    if (isRelativeUrl(parsedRight)) {
        // TODO is this correct ?
        if (parsedRight.path !== "") {
            if (parsedRight.path[0] === "/") {
                parsedLeft.path = parsedRight.path;
                // TODO is this correct ?
            }
            else {
                var leftPath = parsedLeft.path.split(/\//);
                var rightPath = parsedRight.path.split(/\//);
                // TODO is this correct ?
                if (leftPath.length === 0) {
                    if (rightPath.length !== 0) {
                        leftPath.push("");
                    }
                }
                else if (leftPath.length > 1) {
                    leftPath.pop();
                }
                pushAll(leftPath, rightPath);
                parsedLeft.path = leftPath.join("/");
                if (parsedLeft.path !== "" && parsedLeft.path[0] !== "/") {
                    throw new Error("URL path must start with /");
                }
            }
        }
        // TODO is this correct ?
        parsedLeft.query = parsedRight.query;
        parsedLeft.hash = parsedRight.hash;
        return serializeUrl(parsedLeft);
    }
    else {
        return serializeUrl(parsedRight);
    }
}
/**
 * Detects MSIE.
 *
 * @return Is IE?
 */
function isIE() {
    return !!window.MSInputMethodContext && !!document.documentMode;
}
//# sourceMappingURL=Utils.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Ease.js
/**
 * A collection of easing functions
 *
 * Parts of this collection are taken from D3.js library (https://d3js.org/)
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * The functions below are from D3.js library (https://d3js.org/)
 *
 * ----------------------------------------------------------------------------
 * Copyright 2017 Mike Bostock
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * ----------------------------------------------------------------------------
 * @hidden
 */
/**
 * ============================================================================
 * LINEAR FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Easing function: "linear".
 */
function linear(t) {
    return +t;
}
registry.registeredClasses["ease.linear"] = linear;
/**
 * Easing function: "quadIn".
 */
function quadIn(t) {
    return t * t;
}
registry.registeredClasses["ease.quadIn"] = quadIn;
/**
 * Easing function: "quadOut".
 */
function quadOut(t) {
    return t * (2 - t);
}
registry.registeredClasses["ease.quadOut"] = quadOut;
/**
 * Easing function: "quadInOut".
 */
function quadInOut(t) {
    t *= 2;
    return (t <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}
registry.registeredClasses["ease.quadInOut"] = quadInOut;
/**
 * Easing function: "polyIn".
 */
function polyIn(t, e) {
    return Math.pow(t, e);
}
registry.registeredClasses["ease.polyIn"] = polyIn;
/**
 * Easing function: "polyOut".
 */
function polyOut(t, e) {
    return 1 - Math.pow(1 - t, e);
}
registry.registeredClasses["ease.polyOut"] = polyOut;
/**
 * Easing function: "polyInOut".
 */
function polyInOut(t, e) {
    t *= 2;
    return (t <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
}
registry.registeredClasses["ease.polyInOut"] = polyInOut;
/**
 * Easing function: "polyIn3".
 */
function polyIn3(t) {
    return polyIn(t, 3);
}
registry.registeredClasses["ease.polyIn3"] = polyIn3;
/**
 * Easing function: "polyOut3".
 */
function polyOut3(t) {
    return polyOut(t, 3);
}
registry.registeredClasses["ease.polyOut3"] = polyOut3;
/**
 * Easing function: "polyInOut3".
 */
function polyInOut3(t) {
    return polyInOut(t, 3);
}
registry.registeredClasses["ease.polyInOut3"] = polyInOut3;
/**
 * ============================================================================
 * EXPONENTIAL FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Easing function: "expIn".
 */
function expIn(t) {
    return Math.pow(2, 10 * t - 10);
}
registry.registeredClasses["ease.expIn"] = expIn;
/**
 * Easing function: "expOut".
 */
function expOut(t) {
    return 1 - Math.pow(2, -10 * t);
}
registry.registeredClasses["ease.expOut"] = expOut;
/**
 * Easing function: "expInOut".
 */
function expInOut(t) {
    t *= 2;
    return (t <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}
registry.registeredClasses["ease.expInOut"] = expInOut;
/**
 * ============================================================================
 * SINE FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Easing function: "sinIn".
 */
function sinIn(t) {
    return 1 - Math.cos(t * HALFPI);
}
registry.registeredClasses["ease.sinIn"] = sinIn;
/**
 * Easing function: "sinOut".
 */
function sinOut(t) {
    return Math.sin(t * HALFPI);
}
registry.registeredClasses["ease.sinOut"] = sinOut;
/**
 * Easing function: "sinInOut".
 */
function sinInOut(t) {
    return (1 - Math.cos(PI * t)) / 2;
}
registry.registeredClasses["ease.sinInOut"] = sinInOut;
/**
 * ============================================================================
 * CUBIC FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Easing function: "cubicIn".
 */
function cubicIn(t) {
    return t * t * t;
}
registry.registeredClasses["ease.cubicIn"] = cubicIn;
/**
 * Easing function: "cubicOut".
 */
function cubicOut(t) {
    return --t * t * t + 1;
}
registry.registeredClasses["ease.cubicOut"] = cubicOut;
/**
 * Easing function: "cubicInOut".
 */
function cubicInOut(t) {
    t *= 2;
    return (t <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
registry.registeredClasses["ease.cubicInOut"] = cubicInOut;
/**
 * ============================================================================
 * CIRCLE FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Easing function: "circleIn".
 */
function circleIn(t) {
    return 1 - Math.sqrt(1 - t * t);
}
registry.registeredClasses["ease.circleIn"] = circleIn;
/**
 * Easing function: "circleOut".
 */
function circleOut(t) {
    return Math.sqrt(1 - --t * t);
}
registry.registeredClasses["ease.circleOut"] = circleOut;
/**
 * Easing function: "circleInOut".
 */
function circleInOut(t) {
    t *= 2;
    return (t <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}
registry.registeredClasses["ease.circleInOut"] = circleInOut;
/**
 * ============================================================================
 * BOUNCE FUNCTIONS
 * ============================================================================
 * @hidden
 */
var Ease_b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, Ease_b0 = 1 / Ease_b1 / Ease_b1;
/**
 * Easing function: "bounceIn".
 */
function bounceIn(t) {
    return 1 - bounceOut(1 - t);
}
registry.registeredClasses["ease.bounceIn"] = bounceIn;
/**
 * Easing function: "bounceOut".
 */
function bounceOut(t) {
    t = +t;
    return t < Ease_b1 ? Ease_b0 * t * t : t < b3 ? Ease_b0 * (t -= b2) * t + b4 : t < b6 ? Ease_b0 * (t -= b5) * t + b7 : Ease_b0 * (t -= b8) * t + b9;
}
registry.registeredClasses["ease.bounceOut"] = bounceOut;
/**
 * Easing function: "bounceInOut".
 */
function bounceInOut(t) {
    t *= 2;
    return (t <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}
registry.registeredClasses["ease.bounceInOut"] = bounceInOut;
/**
 * ============================================================================
 * ELASTIC FUNCTIONS
 * ============================================================================
 * @hidden
 */
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3 / tau;
var Ease_s = Math.asin(1 / amplitude) * period;
/**
 * Easing function: "elasticIn".
 *
 * @function elasticIn
 * @param a  Amplitude
 * @param p  period
 */
function elasticIn(t) {
    return amplitude * Math.pow(2, 10 * --t) * Math.sin((Ease_s - t) / period);
}
registry.registeredClasses["ease.elasticIn"] = elasticIn;
/**
 * Easing function: "elasticOut".
 *
 * @function elasticOut
 * @param a  Amplitude
 * @param p  period
 */
function elasticOut(t) {
    return 1 - amplitude * Math.pow(2, -10 * (t = +t)) * Math.sin((t + Ease_s) / period);
}
registry.registeredClasses["ease.elasticOut"] = elasticOut;
/**
 * Easing function: "elasticInOut".
 *
 * @function elasticInOut
 * @param a  Amplitude
 * @param p  period
 */
function elasticInOut(t) {
    t = t * 2 - 1;
    return (t < 0
        ? amplitude * Math.pow(2, 10 * t) * Math.sin((Ease_s - t) / period)
        : 2 - amplitude * Math.pow(2, -10 * t) * Math.sin((Ease_s + t) / period)) / 2;
}
registry.registeredClasses["ease.elasticInOut"] = elasticInOut;
//# sourceMappingURL=Ease.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/SpriteState.js
/**
 * Module contains functionality related to [[Sprite]] states.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */










/**
 * Defines a state for [[Sprite]].
 *
 * A "state" is a special object that has all the same properties as the
 * [[Sprite]] of the same type, and which can be used to quickly apply a set
 * of property values. (set state)
 *
 * When [[Sprite]] (or any object that extends Sprite) is created it creates a
 * "default" state. You can modify the "default" state so that when the Sprite
 * returns to default state certain properties are added.
 *
 * Default state can be accessed using Sprite's `defaultState` getter.
 *
 * ```TypeScript
 * sprite.defaultState.properties.fillOpacity = 0.5;
 * ```
 * ```JavaScript
 * sprite.defaultState.properties.fillOpacity = 0.5;
 * ```
 * ```JSON
 * {
 *   // ...
 *   "defaultState": {
 *     "properties": {
 *       "fillOpacity": 0.5
 *     }
 *   }
 * }
 * ```
 *
 * If Sprite is "hoverable", it automatically adds a "hover" state, which is
 * applied when it has a cursor over it.
 *
 * ```TypeScript
 * let hoverstate = sprite.states.create("hover");
 * hoverstate.properties.fillOpacity = 1;
 * ```
 * ```JavaScript
 * var hoverstate = sprite.states.create("hover");
 * hoverstate.properties.fillOpacity = 1;
 * ```
 * ```JSON
 * {
 *   // ...
 *   "states": {
 *     "hover": {
 *       "properties": {
 *         "fillOpacity": 0.5
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * The above will automatically apply "hover" state when the Sprite is hovered,
 * thus will set its `fillOpacity` property to 1, and will reset it to 0.5 when
 * it's no longer hovered.
 *
 * Every object that inherits from [[Sprite]] can and will add their own
 * properties to the available list.
 *
 * User can create their own states, and apply them as needed:
 *
 * ```TypeScript
 * let myCustomState = sprite.states.create("mystate");
 * myCustomState.properties.fillOpacity = 0.5;
 * myCustomState.properties.strokeOpacity = 0.8;
 * sprite.setState("mystate");
 * ```
 * ```JavaScript
 * var myCustomState = sprite.states.create("mystate");
 * myCustomState.properties.fillOpacity = 0.5;
 * myCustomState.properties.strokeOpacity = 0.8;
 * sprite.setState("mystate");
 * ```
 *
 * @see {@link https://www.amcharts.com/docs/v4/concepts/states/}
 * @important
 */
var SpriteState_SpriteState = /** @class */ (function (_super) {
    __extends(SpriteState, _super);
    /**
     * Constructor
     */
    function SpriteState() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Duration of the transition to this state. 0 means instantenous transition.
         * Any number means the [[Sprite]] will transit smoothly to this state,
         * animating all animatable properties.
         *
         * @default 0
         * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations
         */
        _this.transitionDuration = 0;
        /**
         * Easing function to use when transitioning to this state.
         *
         * @default cubicOut
         * @see {@link Ease}
         * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations
         */
        _this.transitionEasing = cubicOut;
        /**
         * Collection of properties and their values that should be applied to [[Sprite]]
         * when switching to this State.
         *
         * The property values set on a [[SpriteState]] will override the ones set
         * directly on a [[Sprite]].
         */
        _this.properties = {};
        /**
         * A collection of key/value pairs that can be used to bind specific Sprite
         * properties to [[DataItem]].
         *
         * For example: `fill` property can be bound to `myCustomColor` field in
         * DataItem. The Sprite will automatically get the value for `fill` from its
         * DataItem.
         *
         * SpriteState-specific binding will override binding set directly on
         * [[Sprite]]. I.e. you can make Sprite use different fill color on hover by
         * adding a `fill` binding to a different DataItem key for Sprite's "hover"
         * state object.
         *
         * @see {@link Sprite}
         */
        _this.propertyFields = {};
        //public propertyFields: Dictionary<keyof this["_properties"], string> = new Dictionary<keyof this["_properties"], string>();;
        /**
         * A list of [[Filter]] elements to be applied to the relative [[Sprite]]
         * when switching to this State.
         *
         * @param {List}
         */
        _this.filters = new List_List();
        /**
         * Identifies if this object is a "template" and should not be treated as
         * real object that is drawn or actually used in the chart.
         */
        _this.isTemplate = false;
        _this.className = "SpriteState";
        // Make filter list disposable
        _this._disposers.push(new List_ListDisposer(_this.filters));
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(SpriteState.prototype, "adapter", {
        /**
         * Holds Adapter.
         */
        get: function () {
            var _this = this;
            if (!this._adapterO) {
                this._adapterO = new Adapter_Adapter(this);
                // Decorate adapter with events so that we can apply its settings whenever
                // it is modified
                this._adapterO.events.on("inserted", function (ev) {
                    _this[ev.newValue.key] = _this[ev.newValue.key];
                }, undefined, false);
                this._adapterO.events.on("removed", function (ev) {
                    _this[ev.newValue.key] = _this[ev.newValue.key];
                }, undefined, false);
            }
            return this._adapterO;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns [[Sprite]] element's property value.
     *
     * Will check if there are any bindings with [[DataItem]] and if there are
     * any method callbacks set up for the specific property.
     *
     * @param propertyName  Property name
     * @return Property value
     */
    SpriteState.prototype.getPropertyValue = function (propertyName) {
        var propValue = this.properties[propertyName];
        var sprite = this.sprite;
        if (sprite) {
            var fieldName = this.propertyFields[propertyName];
            if (hasValue(fieldName)) {
                if (sprite.dataItem) {
                    propValue = sprite.dataItem.dataContext[fieldName];
                }
                if (propValue == undefined) {
                    propValue = "__unset";
                }
            }
            // Apply adapters
            // If the value itself is undefined, we're going to pass in Sprite's
            // value to adapters
            // @todo get rid of <any>
            if (!hasValue(propValue)) {
                var spriteValue = sprite.getPropertyValue(propertyName);
                if (this._adapterO) {
                    propValue = this._adapterO.apply(propertyName, spriteValue);
                }
                else {
                    propValue = spriteValue;
                }
                if (propValue == spriteValue) {
                    propValue = undefined;
                }
            }
            else {
                if (this._adapterO) {
                    propValue = this._adapterO.apply(propertyName, propValue);
                }
            }
            /*let method = this.propertyMethods.getKey(propertyName);
            if (method) {
                propValue = method(sprite, propertyName);
            }*/
        }
        return propValue;
    };
    /**
     * Copies all property and style values from another [[SpriteState]] object.
     *
     * @param source  Source [[SpriteState]]
     */
    SpriteState.prototype.copyFrom = function (source) {
        if (source && source != this) {
            this.transitionDuration = source.transitionDuration;
            this.transitionEasing = source.transitionEasing;
            Utils_copyProperties(source.properties, this.properties);
            Utils_copyProperties(source.propertyFields, this.propertyFields);
            this.filters.copyFrom(source.filters);
            if (source._adapterO) {
                this.adapter.copyFrom(source._adapterO);
            }
        }
    };
    Object.defineProperty(SpriteState.prototype, "allValues", {
        /**
         * Returns all values that should be applied by the SpriteState.
         *
         * It takes adapters into account.
         *
         * @ignore Exclude from docs
         * @return Properties
         * @todo Add adapter values
         * @todo proper type this["_properties"]
         */
        get: function () {
            var _this = this;
            // Init return value
            var res = {};
            // Apply adapters to all values
            Object_each(this.properties, function (prop, value) {
                res[prop] = _this.getPropertyValue(prop);
            });
            // Cycle through all adapters and add values for missing properties
            if (this._adapterO) {
                var keys = this._adapterO.keys();
                Object_each(keys, function (_x, prop) {
                    var value = _this.getPropertyValue(prop);
                    res[prop] = value;
                });
            }
            // Cycle through all property fileds and add values for missing properties
            var propertyFields = this.propertyFields;
            Object_each(propertyFields, function (prop) {
                var value = _this.getPropertyValue(prop);
                res[prop] = value;
            });
            return res;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the State to initial state - no values or Filters applied.
     */
    SpriteState.prototype.reset = function () {
        this.properties = {};
        this.filters.clear();
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    SpriteState.prototype.processConfig = function (config) {
        if (hasValue(config) && hasValue(config["properties"])) {
            Object_each(config["properties"], function (key, value) {
                if (isString(value)) {
                    if (value.match(/^[0-9.\-]+\%$/)) {
                        config["properties"][key] = Percent_percent(toNumber(value));
                    }
                    else if (value.match(/^\#[0-9abcdef]{3,}$/i)) {
                        config["properties"][key] = toColor(value);
                    }
                }
            });
        }
        _super.prototype.processConfig.call(this, config);
    };
    /**
     * Adds easing functions to "function" fields.
     *
     * @param field  Field name
     * @return Assign as function?
     */
    SpriteState.prototype.asFunction = function (field) {
        return field == "transitionEasing" || _super.prototype.asIs.call(this, field);
    };
    return SpriteState;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["SpriteState"] = SpriteState_SpriteState;
//# sourceMappingURL=SpriteState.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/SpriteEvents.js






/**
 * An [[EventDispatcher]] for [[Sprite]].
 *
 * @important
 */
var SpriteEvents_SpriteEventDispatcher = /** @class */ (function (_super) {
    __extends(SpriteEventDispatcher, _super);
    function SpriteEventDispatcher() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * [_interactionEvents description]
         *
         * @todo Description
         */
        _this._interactionEvents = new Dictionary_Dictionary();
        return _this;
    }
    /**
     * [_dispatchSpriteEvent description]
     *
     * @todo Description
     */
    SpriteEventDispatcher.prototype._dispatchSpriteEvent = function (ev) {
        if (this.target.disabled || this.target.isTemplate) {
            return;
        }
        // TODO remove this <any> later
        if (this.target.events.isEnabled(ev.type)) {
            var imev = merge(ev, {
                target: this.target
            });
            this.target.events.dispatchImmediately(imev.type, imev);
        }
    };
    /**
     * [_dispatchSpritePointEvent description]
     *
     * @todo Description
     */
    SpriteEventDispatcher.prototype._dispatchSpritePointEvent = function (ev) {
        if (this.target.disabled || this.target.isTemplate) {
            return;
        }
        // TODO remove this <any> later
        if (this.target.events.isEnabled(ev.type)) {
            var imev = merge(ev, {
                target: this.target,
                spritePoint: documentPointToSprite(ev.point, this.target),
                svgPoint: this.target.getSvgPoint(ev.point)
            });
            this.target.events.dispatchImmediately(imev.type, imev);
        }
    };
    /**
     * [_addInteractionObjectEvent description]
     *
     * @todo Description
     */
    SpriteEventDispatcher.prototype._addInteractionObjectEvent = function (type, callback, context, shouldClone) {
        var _this = this;
        var key = shouldClone + "-" + type;
        var counter = this._interactionEvents.insertKeyIfEmpty(key, function () {
            var disposer = _this.target.interactions.events.on(type, callback, context, shouldClone);
            return new Disposer_CounterDisposer(function () {
                _this._interactionEvents.removeKey(key);
                disposer.dispose();
            });
        });
        return counter.increment();
    };
    /**
     * [_on description]
     *
     * @todo Description
     */
    SpriteEventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {
        var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);
        var disposers = [info.disposer];
        /**
         * Catching Sprite-related events, converting them to [[SpriteEvent]] and
         * triggering them on sprite
         */
        switch (type) {
            case "hit":
            case "track":
            case "doublehit":
            case "wheel":
            case "wheelup":
            case "wheeldown":
            case "wheelleft":
            case "wheelright":
                disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpritePointEvent, this, shouldClone));
                break;
            case "rightclick":
            case "down":
            //case "hold":
            case "up":
            case "drag":
            case "dragged":
            case "dragstart":
            case "dragstop":
            case "over":
            case "out":
            case "swipe":
            case "swipeleft":
            case "swiperight":
            case "resize":
            //case "rotate":
            case "focus":
            case "blur":
            case "toggled":
                disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpriteEvent, this, shouldClone));
                break;
        }
        /**
         * Set functional properties based on events. For example if we add a
         * "drag" event handler, we want to make the Sprite draggable, even if we
         * don't explicitly set "draggable"
         */
        switch (type) {
            case "hit":
            case "doublehit":
            case "rightclick":
            case "down":
            case "up":
                this.target.clickable = true;
                break;
            case "toggled":
                this.target.togglable = true;
                break;
            case "drag":
            case "dragstart":
            case "dragstop":
                this.target.draggable = true;
                break;
            case "track":
                this.target.trackable = true;
                break;
            case "resize":
                this.target.resizable = true;
                break;
            case "swipe":
            case "swipeleft":
            case "swiperight":
                this.target.swipeable = true;
                break;
            case "wheel":
            case "wheelup":
            case "wheeldown":
            case "wheelleft":
            case "wheelright":
                this.target.wheelable = true;
                break;
            case "over":
                this.target.hoverable = true;
            case "out":
                this.target.hoverable = true;
                break;
            case "focus":
            case "blur":
                this.target.focusable = true;
                break;
        }
        info.disposer = new Disposer_MultiDisposer(disposers);
        return info;
    };
    return SpriteEventDispatcher;
}(EventDispatcher_TargetedEventDispatcher));

//# sourceMappingURL=SpriteEvents.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/defs/SVGDefaults.js
/**
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * Defines a class that holds default properties for new SVG elements
 */
var SVGDefaults_SVGDefaults = /** @class */ (function () {
    function SVGDefaults() {
    }
    SVGDefaults.opacity = 1;
    SVGDefaults.strokeOpacity = 1;
    SVGDefaults.strokeWidth = 1;
    SVGDefaults.fillOpacity = 1;
    SVGDefaults.fill = Color_color("#000000");
    SVGDefaults.stroke = Color_color("#000000");
    SVGDefaults.focusable = undefined;
    SVGDefaults.tabindex = 0;
    return SVGDefaults;
}());

//# sourceMappingURL=SVGDefaults.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/Options.js
/**
 * Global options.
 */
var Options_options = {
    verbose: true,
    commercialLicense: false,
    classNamePrefix: "amcharts-",
    autoSetClassName: false,
    minPolylineStep: 0.5,
    onlyShowOnViewport: false,
    queue: false,
    licenses: [],
    suppressErrors: false,
    animationsEnabled: true,
    nonce: ""
};
//# sourceMappingURL=Options.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Animation.js
/**
 * Animation module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */













/**
 * Calls a `callback` function for the `duration` of milliseconds.
 *
 * @todo Needed?
 * @deprecated Not used anywhere
 * @ignore Exclude from docs
 * @param duration  Duration (ms)
 * @param callback  Callback function
 * @return Disposer
 */
function animate(duration, callback) {
    var disposed = false;
    // TODO use performance.now() ?
    var startTime = Date.now();
    function loop(now) {
        if (!disposed) {
            var diff = now - startTime;
            if (diff >= duration) {
                callback(1);
            }
            else {
                nextFrame(loop);
                callback(diff / duration);
            }
        }
    }
    nextFrame(loop);
    return new Disposer(function () {
        disposed = true;
    });
}
/**
 * Returns numeric value accoring to progress between start and end values.
 *
 * @param progress  Progress (0-1)
 * @param from
 * @param to
 * @return Value according to progress
 */
function getProgressNumber(progress, from, to) {
    return from + ((to - from) * progress);
}
/**
 * Returns [[Percent]] value accoring to progress between start and end
 * values.
 *
 * @param progress  Progress (0-1)
 * @param from
 * @param to
 * @return Value according to progress
 */
function getProgressPercent(progress, from, to) {
    return new Percent(getProgressNumber(progress, from.percent, to.percent));
}
/**
 * Returns color value accoring to progress between start and end values.
 *
 * @param progress  Progress (0-1)
 * @param from
 * @param to
 * @return Color according to progress
 */
function getProgressColor(progress, from, to) {
    var color = new Color_Color(interpolate(from.rgb, to.rgb, progress));
    if (from.alpha != to.alpha) {
        color.alpha = from.alpha + (to.alpha - from.alpha) * progress;
    }
    return color;
}
/**
 * [getHybridProperty description]
 *
 * @todo Description
 * @param property [description]
 * @param type [description]
 * @return [description]
 */
function getHybridProperty(property, type) {
    return type + property.charAt(0).toUpperCase() + property.substr(1);
}
var Animation_AnimationDisposer = /** @class */ (function () {
    function AnimationDisposer(array) {
        this._disposer = new Disposer(function () {
            while (array.length !== 0) {
                array[0].dispose();
            }
        });
    }
    AnimationDisposer.prototype.isDisposed = function () {
        return this._disposer.isDisposed();
    };
    AnimationDisposer.prototype.dispose = function () {
        this._disposer.dispose();
    };
    return AnimationDisposer;
}());

/**
 * Animation can be used to transition certain properties on an object that
 * implements [[IAnimatable]] interface.
 *
 * @see {@link IAnimationEvents} for a list of available events
 */
var Animation_Animation = /** @class */ (function (_super) {
    __extends(Animation, _super);
    /**
     * Constructor
     *
     * @param object            An object animation should run on
     * @param animationOptions  One or several (array) of animation options
     * @param duration          Duration (ms)
     * @param easing            Easing function
     */
    function Animation(object, animationOptions, duration, easing) {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Duration of the animation in milliseconds.
         */
        _this.duration = 0;
        /**
         * Easing function to use.
         *
         * @see {@link Ease}
         */
        _this.easing = linear;
        /**
         * Contains progress of the current animation: 0 (start) to 1 (end).
         */
        _this.progress = 0;
        /**
         * Indicated how many times animation should loop.
         */
        _this._loop = 0;
        /**
         * Animation is paused.
         */
        _this._pause = false;
        /**
         * Holds reference to timeout for delayed play.
         */
        _this._delayTimeout = null;
        /**
         * Elapsed time in currently playing animation.
         */
        _this._time = 0;
        _this._isFinished = false;
        _this.className = "Animation";
        // Override duration if animations disabled system-wide
        if (Options_options.animationsEnabled === false) {
            duration = 0;
        }
        // Set parameters
        _this.object = object;
        _this.animationOptions = toArray(animationOptions);
        _this.duration = duration;
        if (easing) {
            _this.easing = easing;
        }
        // Run check if there are already animations playing on the same properties
        // and stop them - the last animation takes precedence
        //this.stopSameAnimations();
        /*if ($type.hasValue(callback)) {
            // TODO don't use .call
            this.events.on("animationended", callback, object);
        }*/
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    // TODO verify that this is correct
    Animation.prototype.debug = function () { };
    /**
     * Disposes this object, clears up after itself.
     */
    Animation.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.pause();
    };
    /**
     * Delays animation start by X milliseconds.
     *
     * @param delay  Delay (ms)
     * @return Animation
     */
    Animation.prototype.delay = function (delay) {
        var _this = this;
        //@todo Maybe not use `bind()`
        if (delay > 0) {
            this.pause();
            // This is so that it will get disposed if `this.object` is disposed
            // TODO hacky, figure out a better way
            move(this.object.animations, this);
            var id_1 = setTimeout(function () {
                _this._delayTimeout = null;
                _this.start();
            }, delay);
            this._delayTimeout = new Disposer(function () {
                clearTimeout(id_1);
            });
        }
        return this;
    };
    Animation.prototype._start = function () {
        this._isFinished = false;
        // Clear delay timeout if there was one
        if (this._delayTimeout) {
            this.removeDispose(this._delayTimeout);
            this._delayTimeout = null;
        }
        // Run check if there are already animations playing on the same properties
        // and stop them - the last animation takes precedence
        this.stopSameAnimations();
        // Reset counters
        this._pause = false;
        // Register animation
        move(system.animations, this);
        // Register this animation in object's `animations` list
        move(this.object.animations, this);
        system.requestFrame();
    };
    /**
     * Starts animation.
     *
     * @return Animation
     */
    Animation.prototype.start = function () {
        this._start();
        this._startTime = Date.now();
        this._time = 0;
        this.staticOptions = [];
        // Process initial property values
        for (var i = this.animationOptions.length - 1; i >= 0; i--) {
            var options_1 = this.animationOptions[i];
            if (!hasValue(options_1.from)) {
                if (options_1.childObject) {
                    options_1.from = options_1.childObject[options_1.property];
                }
                else {
                    options_1.from = this.object[options_1.property];
                    if (!hasValue(options_1.from)) {
                        options_1.from = SVGDefaults_SVGDefaults[options_1.property];
                    }
                }
                /*if (!$type.hasValue(options.from)) {
                    throw Error("Could not get initial transition value.");
                }*/
            }
            if (options_1.from == options_1.to) { // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue
                remove(this.animationOptions, options_1);
            }
            else if (!hasValue(options_1.from) || (!(options_1.from instanceof Percent) && (options_1.to instanceof Percent)) || ((options_1.from instanceof Percent) && !(options_1.to instanceof Percent))) {
                // Initial value is undefined, treat it as static
                this.staticOptions.push(options_1);
                remove(this.animationOptions, options_1);
            }
            else {
                // Use different update methods for different value types
                if (isNumber(options_1.to)) {
                    // Numeric value
                    options_1.updateMethod = getProgressNumber;
                    // Check if initial value is not Percent
                    if (options_1.from instanceof Percent) {
                        // It is. Let's convert it to pixel value
                        // @todo Check if we can do this in a less hacky way
                        var convertedFrom = this.object[getHybridProperty(options_1.property, "pixel")];
                        if (!isNaN(convertedFrom)) {
                            options_1.from = convertedFrom;
                        }
                        else {
                            this.staticOptions.push(options_1);
                            remove(this.animationOptions, options_1);
                        }
                    }
                    else if (isNaN(options_1.from)) {
                        // Static value
                        this.staticOptions.push(options_1);
                        remove(this.animationOptions, options_1);
                    }
                }
                else {
                    // Check if maybe we have a color or percent value
                    if (options_1.to instanceof Color_Color) {
                        // Yup - set resolved named color
                        //options.from = $colors.stringToColor(<string>options.from);
                        if (options_1.from) {
                            options_1.updateMethod = getProgressColor;
                        }
                        else {
                            // Static value
                            this.staticOptions.push(options_1);
                            remove(this.animationOptions, options_1);
                        }
                    }
                    else if (options_1.to instanceof Percent) {
                        // Percent
                        options_1.updateMethod = getProgressPercent;
                        // Check if the initial value is maybe in pixels
                        if (!isNaN(options_1.from)) {
                            // It is. Let's convert it
                            // @todo Check if we can do this in a less hacky way
                            var convertedFrom = this.object[getHybridProperty(options_1.property, "relative")];
                            if (!isNaN(convertedFrom)) {
                                options_1.from = Percent_percent(convertedFrom * 100);
                            }
                        }
                    }
                    else {
                        // Static value
                        this.staticOptions.push(options_1);
                        remove(this.animationOptions, options_1);
                    }
                }
            }
        }
        // Apply static options (just in case they were reset by previous
        // animation loop)
        this.applyStaticOptions();
        if (this.events.isEnabled("animationstarted")) {
            var event_1 = {
                type: "animationstarted",
                target: this,
                progress: this.progress
            };
            this.events.dispatchImmediately("animationstarted", event_1);
        }
        this.update();
        // If duration is 0, just end animation
        if (this.duration === 0) {
            this.end();
        }
        return this;
    };
    /**
     * Sets loop count for the animation. If parameter is not a valid number the
     * animation will keep on looping indefinitely.
     *
     * @param count  Number of times to loop animation
     * @return Animation
     */
    Animation.prototype.loop = function (count) {
        if (!isNumber(count)) {
            count = Infinity;
        }
        this._loop = count;
        return this;
    };
    /**
     * Pauses animation.
     *
     * @return Animation
     */
    Animation.prototype.pause = function () {
        this._pause = true;
        if (this._delayTimeout) {
            this.removeDispose(this._delayTimeout);
            this._delayTimeout = null;
        }
        remove(system.animations, this);
        remove(this.object.animations, this);
        return this;
    };
    /**
     * Resumes paused animation.
     *
     * @return Animation
     */
    Animation.prototype.resume = function () {
        this._start();
        this._startTime = Date.now() - this._time;
        return this;
    };
    /**
     * Jumps to animation end. If animation is set to loop, this will start
     * another round of animation from start.
     *
     * @return Animation
     */
    Animation.prototype.end = function () {
        // Pause and complete the progress
        if (this._loop == 0) {
            this.pause();
        }
        this.setProgress(1);
        // Apply static options
        this.applyStaticOptions();
        if (this.events.isEnabled("animationended")) {
            var event_2 = {
                type: "animationended",
                target: this,
                progress: this.progress
            };
            this.events.dispatchImmediately("animationended", event_2);
        }
        // Check if we should loop
        if (this._loop > 0) {
            this._loop--;
            this.start();
        }
        else {
            this.stop();
            this._isFinished = true;
        }
        return this;
    };
    /**
     * Stops animation immediately leaving properties in their current values.
     */
    Animation.prototype.kill = function () {
        this.pause();
        this._isFinished = true;
    };
    /**
     * Returns indicator if this animation is finished or not
     *
     * @return Is finished?
     */
    Animation.prototype.isFinished = function () {
        return this._isFinished;
    };
    /**
     * Applies static options that can't be animated.
     */
    Animation.prototype.applyStaticOptions = function () {
        var _this = this;
        each(this.staticOptions, function (options) {
            if (options.childObject) {
                options.childObject[options.property] = _this.progress == 1 ? options.to : options.from;
            }
            else {
                _this.object[options.property] = _this.progress == 1 ? options.to : options.from;
            }
        });
    };
    /**
     * Stops animation.
     *
     * When animation is stopped, the properties of the target object will remain
     * where they were at the moment when `stop()` was called.
     *
     * @param skipEvent  Do not trigger `animationstopped` event
     * @return Animation
     */
    Animation.prototype.stop = function (skipEvent) {
        this.pause();
        if (!skipEvent) {
            if (this.events.isEnabled("animationstopped")) {
                var event_3 = {
                    type: "animationstopped",
                    target: this,
                    progress: this.progress
                };
                this.events.dispatchImmediately("animationstopped", event_3);
            }
        }
        return this;
    };
    /**
     * Sets current progress and updates object's numeric and color values.
     *
     * @param progress Progress (0-1)
     */
    Animation.prototype.setProgress = function (progress) {
        var _this = this;
        this._time = this.duration * progress; // just in case we call this from outside
        each(this.animationOptions, function (options) {
            if (options.updateMethod && hasValue(options.from)) {
                var value = options.updateMethod(progress, options.from, options.to);
                if (options.childObject) {
                    options.childObject[options.property] = value;
                }
                else {
                    _this.object[options.property] = value;
                }
            }
        });
        this.progress = progress;
        if (this.events.isEnabled("animationprogress")) {
            var event_4 = {
                type: "animationprogress",
                target: this,
                progress: this.progress
            };
            this.events.dispatchImmediately("animationprogress", event_4);
        }
        system.requestFrame();
    };
    /**
     * Tracks and sets progress according to time or frames.
     *
     * @ignore Exclude from docs
     * @return Animation
     */
    Animation.prototype.update = function () {
        if (!this._pause) {
            var progress = void 0;
            this._time = fitToRange(Date.now() - this._startTime, 0, this.duration);
            var timeProgress = this._time / this.duration;
            progress = this.easing(timeProgress);
            if (this.duration == 0 || !isNumber(progress) || timeProgress >= 1) {
                progress = 1;
            }
            this.setProgress(progress);
            if (Math_round(this._time / this.duration, 6) == 1) {
                this.end();
            }
        }
        return this;
    };
    Object.defineProperty(Animation.prototype, "delayed", {
        /**
         * Returns `true` if this animation is delayed.
         *
         * @readonly
         * @return [description]
         */
        get: function () {
            return this._delayTimeout ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks other animations currently running on the same object and removes
     * overlapping options from those other animations that are contained in
     * this animation.
     *
     * This is needed to ensure that no two confurent animations step on each
     * other's toes by trying to animate the same property.
     */
    Animation.prototype.stopSameAnimations = function () {
        var _this = this;
        // stop animation of the same property
        // TODO make this more efficient
        // TODO don't copy the array
        each(copy(this.object.animations), function (animation) {
            if (animation !== _this && !animation.delayed) {
                var killed_1 = [];
                each(_this.animationOptions, function (newOptions) {
                    each(animation.animationOptions, function (oldOptions) {
                        if (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {
                            killed_1.push(oldOptions);
                            if (animation.animationOptions.length == 0) {
                                animation.kill();
                            }
                        }
                    });
                });
                each(killed_1, function (oldOptions) {
                    remove(animation.animationOptions, oldOptions);
                });
            }
        });
    };
    /**
     * Adds easing functions to "function" fields.
     *
     * @param field  Field name
     * @return Assign as function?
     */
    Animation.prototype.asFunction = function (field) {
        return field == "easing" || _super.prototype.asIs.call(this, field);
    };
    return Animation;
}(Base_BaseObjectEvents));

//# sourceMappingURL=Animation.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/DOM.js
/**
 * A collection of DOM-related functions.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * SVG namespace.
 *
 * @ignore Exclude from docs
 */
var SVGNS = "http://www.w3.org/2000/svg";
/**
 * XML namespace.
 *
 * @ignore Exclude from docs
 */
var XMLNS = "http://www.w3.org/2000/xmlns/";
/**
 * XLINK namespace.
 *
 * @ignore Exclude from docs
 */
var XLINK = "http://www.w3.org/1999/xlink";
/**
 * Function that adds a disposable event listener directly to a DOM element.
 *
 * @ignore Exclude from docs
 * @param dom       A DOM element to add event to
 * @param type      Event type
 * @param listener  Event listener
 * @returns Disposable event
 */
function addEventListener(dom, type, listener, options) {
    //@todo proper type check for options: EventListenerOptions | boolean (TS for some reason gives error on passive parameter)
    //console.log(type, dom);
    dom.addEventListener(type, listener, options || false);
    return new Disposer(function () {
        dom.removeEventListener(type, listener, options || false);
    });
}
/**
 * Finds and returns an element reference using following logic:
 * * If we pass in an element instance, we just return it back.
 * * If we pass in a string, the function looks for an element with such id.
 * * If no element with such id is found, we grab the first element with a tag name like this.
 *
 * @ignore Exclude from docs
 * @param el  Element definition (reference, or id, or tag name)
 * @return Element reference
 * @todo Review this function as it seems pretty fuzzy and hacky
 */
function getElement(el) {
    if (isString(el)) {
        var e = document.getElementById(el);
        if (e == null) {
            e = document.getElementsByClassName(el)[0];
        }
        if (e instanceof HTMLElement) {
            return e;
        }
    }
    else if (el instanceof HTMLElement) {
        return el;
    }
}
/**
 * Adds a class name to an HTML or SVG element.
 *
 * @ignore Exclude from docs
 * @param element    Element
 * @param className  Class name to add
 */
function addClass(element, className) {
    if (!element) {
        return;
    }
    if (element.classList) {
        element.classList.add(className);
    }
    else {
        var currentClassName = element.getAttribute("class");
        if (currentClassName) {
            element.setAttribute("class", currentClassName.split(" ").filter(function (item) {
                return item !== className;
            }).join(" ") + " " + className);
        }
        else {
            element.setAttribute("class", className);
        }
        //element.className = element.className.replace(new RegExp("^" + className + "| " + className), "") + " " + className;
    }
}
/**
 * Removes a class name from an HTML or SVG element.
 *
 * @ignore Exclude from docs
 * @param element    Element
 * @param className  Class name to add
 */
function removeClass(element, className) {
    if (!element) {
        return;
    }
    if (element.classList) {
        element.classList.remove(className);
    }
    else {
        var currentClassName = element.getAttribute("class");
        if (currentClassName) {
            element.setAttribute("class", currentClassName.split(" ").filter(function (item) {
                return item !== className;
            }).join(" "));
        }
        //element.className = element.className.replace(new RegExp("^" + className + "| " + className), "");
    }
}
/**
 * Sets style property on DOM element.
 *
 * @ignore Exclude from docs
 * @todo Still needed?
 */
function setStyle(element, property, value) {
    element.style[property] = value;
}
/**
 * Gets the computed style value for an element.
 *
 * @ignore Exclude from docs
 */
function DOM_getComputedStyle(element, property) {
    if (element.currentStyle) {
        return element.currentStyle[property];
    }
    return document.defaultView.getComputedStyle(element, null).getPropertyValue(property);
}
/**
 * Removes focus from any element by shifting focus to body.
 *
 * @ignore Exclude from docs
 */
function DOM_blur() {
    var input = document.createElement("input");
    input.style.position = "fixed";
    input.style.top = "0px";
    input.style.left = "-10000px";
    document.body.appendChild(input);
    input.focus();
    input.blur();
    document.body.removeChild(input);
}
/**
 * Tries to focus the element.
 *
 * @ignore Exlude from docs
 * @param element  Element to focus
 */
function DOM_focus(element) {
    if (element instanceof HTMLElement) {
        element.focus();
    }
    else {
        var input = document.createElement("input");
        var fo = document.createElementNS(SVGNS, "foreignObject");
        fo.appendChild(input);
        element.appendChild(fo);
        input.focus();
        input.disabled = true;
        fo.remove();
    }
    /*if ((<any>element).focus != undefined) {
        (<any>element).focus();
    }
    else if (element instanceof SVGSVGElement) {
        // Not implemented
        // @todo implement focus fallback
    }*/
}
/**
 * Returns markup for the element including the element tag itself.
 * SVG elements do not support `outerHTML` so this functions applies of
 * a workaround which creates a new temporary wrapper, clones element and uses
 * wrapper's `innerHTML`.
 *
 * @ignore Exclude from docs
 * @param element  Element to get full markup for
 * @return Markup
 * @deprecated Not in use anywhere
 */
function outerHTML(element) {
    if (element.outerHTML) {
        return element.outerHTML;
    }
    else {
        var twrap = document.createElement("div");
        var tnode = element.cloneNode(true);
        twrap.appendChild(tnode);
        var content = twrap.innerHTML;
        return content;
    }
}
/**
 * Checks if element is a valid DOM node.
 *
 * @ignore Exclude from docs
 * @param el  Element
 * @return `true` if element is a valid DOM node
 */
function isElement(el) {
    return el instanceof Object && el && el.nodeType === 1;
}
/**
 * Checks of element `a` contains element `b`.
 *
 * @param a  Aleged ascendant
 * @param b  Aleged descendant
 * @return Contains?
 */
function DOM_contains(a, b) {
    var cursor = b;
    while (true) {
        if (a === cursor) {
            return true;
        }
        else if (cursor.parentNode == null) {
            // TODO better ShadowRoot detection
            if (cursor.host == null) {
                return false;
            }
            else {
                cursor = cursor.host;
            }
        }
        else {
            cursor = cursor.parentNode;
        }
    }
}
/**
 * Returns the shadow root of the element or null
 *
 * @param a  Node
 * @return Root
 */
function getShadowRoot(a) {
    var cursor = a;
    while (true) {
        if (cursor.parentNode == null) {
            // TODO better ShadowRoot detection
            if (cursor.host != null) {
                return cursor;
            }
            else {
                return null;
            }
        }
        else {
            cursor = cursor.parentNode;
        }
    }
}
/**
 * Returns the root of the element (either the Document or the ShadowRoot)
 *
 * @param a  Node
 * @return Root
 */
function getRoot(a) {
    // TODO replace with Node.prototype.getRootNode
    var owner = a.ownerDocument;
    var cursor = a;
    while (true) {
        if (cursor.parentNode == null) {
            // If the cursor is the document, or it is a ShadowRoot
            // TODO better ShadowRoot detection
            if (cursor === owner || cursor.host != null) {
                return cursor;
            }
            else {
                return null;
            }
        }
        else {
            cursor = cursor.parentNode;
        }
    }
}
/**
 * Gets the true target of the Event.
 *
 * This is needed to make events work with the shadow DOM.
 *
 * @param event  Event
 * @return EventTarget
 */
function eventTarget(event) {
    if (typeof event.composedPath === "function") {
        return event.composedPath()[0];
    }
    else {
        return event.target;
    }
}
/**
 * Copies attributes from one element to another.
 *
 * @ignore Exclude from docs
 * @param source  Element to copy attributes from
 * @param target  Element to copy attributes to
 */
function copyAttributes(source, target) {
    each(source.attributes, function (attr) {
        // TODO what if it's null ?
        if (attr.value != null) {
            target.setAttribute(attr.name, attr.value);
        }
    });
}
/**
 * [fixPixelPerfect description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param el  Element
 */
function fixPixelPerfect(el) {
    readFrame(function () {
        // sometimes IE doesn't like this
        // TODO figure out a way to remove this
        try {
            var rect = el.getBoundingClientRect();
            var left_1 = rect.left - Math.round(rect.left);
            var top_1 = rect.top - Math.round(rect.top);
            if (left_1 !== 0) {
                writeFrame(function () {
                    el.style.left = left_1 + "px";
                });
            }
            if (top_1 !== 0) {
                writeFrame(function () {
                    el.style.top = top_1 + "px";
                });
            }
        }
        catch (e) { }
    });
}
/**
 * [rootStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 */
var rootStylesheet;
/**
 * [getStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @return [description]
 */
function getStylesheet(element) {
    if (element == null) {
        if (!hasValue(rootStylesheet)) {
            // TODO use createElementNS ?
            var e = document.createElement("style");
            e.type = "text/css";
            if (Options_options.nonce != "") {
                e.setAttribute("nonce", Options_options.nonce);
            }
            document.head.appendChild(e);
            rootStylesheet = e.sheet;
        }
        return rootStylesheet;
    }
    else {
        // TODO use createElementNS ?
        var e = document.createElement("style");
        e.type = "text/css";
        if (Options_options.nonce != "") {
            e.setAttribute("nonce", Options_options.nonce);
        }
        element.appendChild(e);
        return e.sheet;
    }
}
/**
 * [makeStylesheet description]
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param selector  [description]
 * @return [description]
 */
function appendStylesheet(root, selector) {
    var index = root.cssRules.length;
    root.insertRule(selector + "{}", index);
    return root.cssRules[index];
}
/**
 * Defines a class for a CSS rule.
 *
 * Can be used to dynamically add CSS to the document.
 */
var DOM_StyleRule = /** @class */ (function (_super) {
    __extends(StyleRule, _super);
    /**
     * Constructor.
     *
     * @param selector  CSS selector
     * @param styles    An object of style attribute - value pairs
     */
    function StyleRule(element, selector, styles) {
        var _this = this;
        var root = getStylesheet(element);
        // TODO test this
        _this = _super.call(this, function () {
            // TODO a bit hacky
            var index = indexOf(root.cssRules, _this._rule);
            if (index === -1) {
                throw new Error("Could not dispose StyleRule");
            }
            else {
                // TODO if it's empty remove it from the DOM ?
                root.deleteRule(index);
            }
        }) || this;
        _this._rule = appendStylesheet(root, selector);
        Object_each(styles, function (key, value) {
            _this.setStyle(key, value);
        });
        return _this;
    }
    Object.defineProperty(StyleRule.prototype, "selector", {
        /**
         * @return CSS selector
         */
        get: function () {
            return this._rule.selectorText;
        },
        /**
         * A CSS selector text.
         *
         * E.g.: `.myClass p`
         *
         * @param selector  CSS selector
         */
        set: function (selector) {
            this._rule.selectorText = selector;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the same style properties with browser-specific prefixes.
     *
     * @param name   Attribute name
     * @param value  Attribute value
     */
    StyleRule.prototype._setVendorPrefixName = function (name, value) {
        var style = this._rule.style;
        style.setProperty("-webkit-" + name, value, "");
        style.setProperty("-moz-" + name, value, "");
        style.setProperty("-ms-" + name, value, "");
        style.setProperty("-o-" + name, value, "");
        style.setProperty(name, value, "");
    };
    /**
     * Sets a value for specific style attribute.
     *
     * @param name   Attribute
     * @param value  Value
     */
    StyleRule.prototype.setStyle = function (name, value) {
        if (name === "transition") {
            this._setVendorPrefixName(name, value);
        }
        else {
            this._rule.style.setProperty(name, value, "");
        }
    };
    return StyleRule;
}(Disposer));

/**
 * An internal counter for unique style ids.
 *
 * @ignore Exclude from docs
 */
var styleId = 0;
/**
 * @ignore Exclude from docs
 * @todo Description
 */
var DOM_StyleClass = /** @class */ (function (_super) {
    __extends(StyleClass, _super);
    /**
     * Constructor.
     *
     * @param styles  An object of style attribute - value pairs
     * @param name    Class name
     */
    function StyleClass(element, styles, name) {
        var _this = this;
        var className = (!hasValue(name)
            // TODO generate the classname randomly
            ? "__style_" + (++styleId) + "__"
            : name);
        _this = _super.call(this, element, "." + className, styles) || this;
        _this._className = className;
        return _this;
    }
    Object.defineProperty(StyleClass.prototype, "className", {
        /**
         * @return Class name
         */
        get: function () {
            return this._className;
        },
        /**
         * Class name.
         *
         * @param name  Class name
         */
        set: function (name) {
            this._className = name;
            this.selector = "." + name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts the whole class to
     * @ignore Exclude from docs
     */
    StyleClass.prototype.toString = function () {
        return this._className;
    };
    return StyleClass;
}(DOM_StyleRule));

function ready(f) {
    if (document.readyState !== "loading") {
        f();
    }
    else {
        var listener_1 = function () {
            if (document.readyState !== "loading") {
                document.removeEventListener("readystatechange", listener_1);
                f();
            }
        };
        document.addEventListener("readystatechange", listener_1);
    }
}
/**
 * Returns a font fmaily name for the element (directly set or
 * computed/inherited).
 *
 * @ignore Exclude from docs
 * @param element  Element
 * @return Font family
 */
function findFont(element) {
    // Check if element has styles set
    var font = DOM_getComputedStyle(element, "font-family");
    if (!font) {
        // Completely transparent. Look for a parent
        var parent_1 = element.parentElement || element.parentNode;
        if (parent_1) {
            return findFont(parent_1);
        }
        else {
            return undefined;
        }
    }
    else {
        return font;
    }
}
/**
 * Returns a font fmaily name for the element (directly set or
 * computed/inherited).
 *
 * @ignore Exclude from docs
 * @param element  Element
 * @return Font family
 */
function findFontSize(element) {
    // Check if element has styles set
    var font = DOM_getComputedStyle(element, "font-size");
    if (!font) {
        // Completely transparent. Look for a parent
        var parent_2 = element.parentElement || element.parentNode;
        if (parent_2) {
            return findFontSize(parent_2);
        }
        else {
            return undefined;
        }
    }
    else {
        return font;
    }
}
/**
 * Checks whether element is not visible, whether directly or via its
 * ascendants.
 *
 * @param   element  Target element
 * @return           Hidden?
 */
function isHidden(element) {
    return (element.offsetParent === null);
}
/**
 * Checks wthether element is in the current viewport.
 *
 * @since 2.5.5
 * @param   el Element
 * @return     Within viewport?
 */
function isElementInViewport(el, viewportTarget) {
    // Get position data of the element
    var rect = el.getBoundingClientRect();
    // Convert to array
    var targets = isArray(viewportTarget) ? viewportTarget : viewportTarget ? [viewportTarget] : [];
    // Should we measure against specific viewport element?
    if (targets.length) {
        for (var i = 0; i < targets.length; i++) {
            var target = targets[i];
            // Check if viewport itself is visible
            if (!isElementInViewport(target)) {
                return false;
            }
            // Check if element is visible within the viewport
            var viewportRect = target.getBoundingClientRect();
            if (rect.top >= 0 &&
                rect.left >= 0 &&
                rect.top <= (viewportRect.top + viewportRect.height) &&
                rect.left <= (viewportRect.left + viewportRect.width)) {
                return true;
            }
        }
        return false;
    }
    return (rect.top >= 0 &&
        rect.left >= 0 &&
        rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.left <= (window.innerWidth || document.documentElement.clientWidth));
}
//# sourceMappingURL=DOM.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/AMElement.js
/**
 * [[AMElement]] represents any SVG element and related functionality.
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A base class for all SVG elements. Provides low-level DOM functionality.
 *
 * All visual elements extend this class.
 */
var AMElement_AMElement = /** @class */ (function () {
    /**
     * Constructor creates a new element or uses the one that was passed in.
     *
     * @param element Element reference node type
     */
    function AMElement(element) {
        /**
         * Indicates if the element was already disposed.
         */
        this._isDisposed = false;
        /**
         * Current X coordinate.
         */
        this._x = 0;
        /**
         * Current Y coordinate.
         */
        this._y = 0;
        /**
         *
         */
        this._rotationY = 0;
        /**
         *
         */
        this._rotationX = 0;
        /**
         * Current rotation.
         */
        this._rotation = 0;
        /**
         * Current scale.
         */
        this._scale = 1;
        if (typeof element === "string") {
            this.node = document.createElementNS(SVGNS, element);
        }
        else {
            this.node = element;
        }
    }
    /**
     * Removes element's node from DOM.
     */
    AMElement.prototype.removeNode = function () {
        if (this.node) {
            if (this.node.parentNode) {
                this.node.parentNode.removeChild(this.node);
            }
        }
    };
    Object.defineProperty(AMElement.prototype, "transformString", {
        /**
         * Returns `transform` attribute of the element.
         *
         * @ignore Exclude from docs
         * @return Transform attribute value
         */
        get: function () {
            if (this.node) {
                return this._transformString;
                /*
                const value = this.node.getAttribute("transform");
    
                if (value !== null) {
                    return value;
                }*/
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Appply position, rotation and scale properties via elemen's `transform`
     * property
     *
     * @ignore Exclude from docs
     */
    AMElement.prototype.transform = function () {
        var transfromString = "translate(" + this._x + "," + this._y + ")";
        if (this._scale != 1) {
            transfromString += ((transfromString ? " " : "") + "scale(" + this._scale + ")");
        }
        if (this._rotation != 0) {
            var rotateString = "rotate(" + this._rotation + ")";
            if (this._rotationX && this._rotationY) {
                rotateString = "rotate(" + this._rotation + " " + this._rotationX + " " + this._rotationY + ")";
            }
            transfromString += ((transfromString ? " " : "") + rotateString);
        }
        this._transformString = transfromString;
        this.node.setAttribute("transform", transfromString);
    };
    /**
     * Returns bounding box of the element.
     *
     * ATTENTION: Bounding box calculations are extremely costly so should be
     * used sparingly and cached whenever possible.
     *
     * @return Bounding rectangle
     */
    AMElement.prototype.getBBox = function () {
        var bbox = {
            width: 0,
            height: 0,
            x: 0,
            y: 0
        };
        // FF would fail if getBBox() is called without node added to parent
        if (this.node && this.node.parentNode) {
            try { // again for ff. TODO: check if this doesn't slow down
                var svgbbox = this.node.getBBox();
                bbox.x = svgbbox.x;
                bbox.y = svgbbox.y;
                bbox.width = svgbbox.width;
                bbox.height = svgbbox.height;
            }
            catch (err) { }
        }
        return bbox;
    };
    /**
     * Moves the element to new coordinates.
     *
     * @param x  Target X
     * @param y  Target Y
     */
    AMElement.prototype.moveTo = function (point) {
        if (point) {
            var x = point.x;
            var y = point.y;
            if (this._x != x || this._y != y) {
                this._x = x;
                this._y = y;
                this.transform();
            }
        }
    };
    Object.defineProperty(AMElement.prototype, "content", {
        /**
         * Returns element's contents as SVG markup.
         *
         * @return Contents
         */
        get: function () {
            // @todo Do not use `innerHTML` as this is not reliable and will not work on all browsers
            return this.node.innerHTML || "";
        },
        /**
         * Element's SVG contents.
         *
         * @param value Contents
         */
        set: function (value) {
            // @todo Do not use `innerHTML` as this is not reliable and will not work on all browsers
            this.node.innerHTML = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AMElement.prototype, "textContent", {
        /**
         * @return Text contents
         */
        get: function () {
            return this.node.textContent || "";
        },
        /**
         * Text contents of the SVG element.
         *
         * @param value Text contents
         */
        set: function (value) {
            this.node.textContent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AMElement.prototype, "x", {
        /**
         * @return X coordinate (px)
         */
        get: function () {
            return this._x;
        },
        /**
         * Element's X position in pixels.
         *
         * @param value  X coordinate (px)
         */
        set: function (value) {
            if (this._x != value) {
                this._x = value;
                this.transform();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AMElement.prototype, "y", {
        /**
         * @return Y coordinate (px)
         */
        get: function () {
            return this._y;
        },
        /**
         * Element's Y position in pixels.
         *
         * @param value Y coordinate (px)
         */
        set: function (value) {
            if (this._y != value) {
                this._y = value;
                this.transform();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AMElement.prototype, "rotation", {
        /**
         * @return Rotation
         */
        get: function () {
            return this._rotation;
        },
        /**
         * Element's rotation in degrees.
         *
         * @param value Rotation
         */
        set: function (angle) {
            if (this._rotation != angle) {
                this._rotation = angle;
                this.transform();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AMElement.prototype, "rotationX", {
        /**
         * @ignore
         */
        get: function () {
            return this._rotationX;
        },
        /**
         * @ignore
         */
        set: function (x) {
            if (this._rotationX != x) {
                this._rotationX = x;
                this.transform();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AMElement.prototype, "rotationY", {
        /**
         * @ignore
         */
        get: function () {
            return this._rotationY;
        },
        /**
         * @ignore
         */
        set: function (y) {
            if (this._rotationY != y) {
                this._rotationY = y;
                this.transform();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AMElement.prototype, "scale", {
        /**
         * @return Scale
         */
        get: function () {
            return this._scale;
        },
        /**
         * Element's scale where 1 is original size.
         *
         * Setting to 0.5 will reduce element's size by 50%, 2 will make element
         * twice as large, etc.
         *
         * @param value Scale
         */
        set: function (value) {
            if (this._scale != value) {
                this._scale = value;
                this.transform();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Removes an attribute from element.
     *
     * @param attribute  Attribute to remove
     */
    AMElement.prototype.removeAttr = function (attribute) {
        this.node.removeAttribute(attribute);
    };
    /**
     * Sets a set of attributes on a element.
     *
     * @param attributes  An object with attribute names (key) and values
     * @return The same element
     */
    AMElement.prototype.attr = function (attributes) {
        var _this = this;
        Object_each(attributes, function (attributeName, attributeValue) {
            if (!hasValue(attributeValue)) {
                _this.node.removeAttribute(attributeName);
            }
            else {
                // this is for performance testing
                //if(attributeValue == this.node.getAttribute(attributeName)){
                //	console.log(attributeName, attributeValue)
                //}
                _this.node.setAttribute(attributeName, attributeValue);
            }
        });
        return this;
    };
    /**
     * Returns a value of a node attribute.
     *
     * @param attribute  Attribute name
     * @return Attribute value
     */
    AMElement.prototype.getAttr = function (attribute) {
        return this.node.getAttribute(attribute);
    };
    /**
     * Sets a single attribute of the element's node using namesspace.
     *
     * @param ns         Namespace
     * @param attribute  Attribute
     * @param value      Value
     * @return The same element
     */
    AMElement.prototype.attrNS = function (ns, attribute, value) {
        this.node.setAttributeNS(ns, attribute, value);
        return this;
    };
    /**
     * Returns a namespaced attribute value from node.
     *
     * @param ns         Namespace
     * @param attribute  Attribute
     * @return Attribute value
     */
    AMElement.prototype.getAttrNS = function (ns, attribute) {
        return this.node.getAttributeNS(ns, attribute);
    };
    /**
     * Removes `style` attribute from node.
     *
     * @param attribute  Attribute to remove
     */
    AMElement.prototype.removeStyle = function (attribute) {
        // @todo Review because it's a bit messy and maybe not needed (pratically not used)
        this.node.style[attribute] = null;
        delete this.node.style[attribute];
    };
    /**
     * Returns style attribute value.
     *
     * @param attribute  Style attribute value
     * @return Attribute value
     */
    AMElement.prototype.getStyle = function (attribute) {
        // @todo Review because it's a bit messy and maybe not needed (pratically not used)
        return this.node.style[attribute];
    };
    /**
     * Adds style attributes to element's node.
     *
     * @param attributes  Object containing attribute: value pairs
     * @return The same element
     */
    AMElement.prototype.addStyle = function (attributes) {
        var _this = this;
        // @todo Review because it's a bit messy and maybe not needed (pratically not used)
        Object_each(attributes, function (attributeName, attributeValue) {
            if (!hasValue(attributeValue)) {
                _this.removeStyle(attributeName);
            }
            else {
                _this.node.style[attributeName] = attributeValue;
            }
        });
        return this;
    };
    /**
     * Adds a class to element.
     *
     * @param name  Class name
     */
    AMElement.prototype.addClass = function (name) {
        addClass(this.node, name);
    };
    /**
     * Removes a class from element.
     *
     * @param name Class name
     */
    AMElement.prototype.removeClass = function (name) {
        removeClass(this.node, name);
    };
    /**
     * Sets a class name on element.
     *
     * @param name  Class name
     */
    AMElement.prototype.setClass = function (name) {
        this.node.setAttribute("class", name);
    };
    /**
     * Removes all element's child nodes, basically leaving it empty.
     */
    AMElement.prototype.removeChildNodes = function () {
        // remove all children
        while (this.node.childNodes.length > 0) {
            this.node.removeChild(this.node.firstChild);
        }
    };
    /**
     * Was this element already been disposed?
     *
     * @return Disposed?
     */
    AMElement.prototype.isDisposed = function () {
        return this._isDisposed;
    };
    /**
     * Disposes element.
     */
    AMElement.prototype.dispose = function () {
        this.removeNode();
    };
    return AMElement;
}());

//# sourceMappingURL=AMElement.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/Group.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates an SVG `<g>` element.
 *
 * SVG groups are used for elements that need more elements just one.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Element/g} About `<g>` element
 */
var Group_Group = /** @class */ (function (_super) {
    __extends(Group, _super);
    /**
     * Constructor.
     *
     * @param elementName Element type (should be "g")
     */
    function Group(elementName) {
        return _super.call(this, elementName) || this;
    }
    /**
     * Adds an element to group.
     *
     * This will manipulate DOM. `element` will be physically moved into group.
     *
     * @param element  Element
     */
    Group.prototype.add = function (element) {
        if (element) {
            this.node.appendChild(element.node);
        }
    };
    /**
     * Adds an element to group.
     *
     * This will manipulate DOM. `element` will be physically moved into group.
     *
     * @param element  Element
     */
    Group.prototype.addToBack = function (element) {
        if (element) {
            var first = this.node.childNodes[0];
            if (first) {
                if (first != element.node) {
                    this.node.insertBefore(element.node, first);
                }
            }
            else {
                this.node.appendChild(element.node);
            }
        }
    };
    /**
     * Removes the `element` from group.
     *
     * Please note that this will not dispose the element itself, it will just
     * remove it from the group.
     *
     * @param element  Element
     */
    Group.prototype.removeElement = function (element) {
        // todo: not sure about the speed, need to investigate, maybe it's faster to check if node is a child
        if (element) {
            try {
                if (element.node && element.node.parentNode == this.node) {
                    this.node.removeChild(element.node);
                }
            }
            catch (err) {
            }
        }
    };
    /**
     * Checks if this group already has the child element added
     *
     * @param element
     * @return {boolean}
     */
    Group.prototype.hasChild = function (element) {
        for (var i = 0; i < this.node.childNodes.length; i++) {
            if (this.node.childNodes[i] == element.node) {
                return true;
            }
        }
        return false;
    };
    Object.defineProperty(Group.prototype, "content", {
        /**
         * @return SVG markup
         */
        get: function () {
            return this.node.innerHTML;
        },
        /**
         * Content of the group element.
         *
         * Can be used to add a lot of proprietary SVG markup into group.
         *
         * @param value  SVG markup
         */
        set: function (value) {
            this.node.innerHTML = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Removes all children from the group.
     */
    Group.prototype.removeChildren = function () {
        if (this.node.childNodes) {
            while (this.node.childNodes.length > 0) {
                var childNode = this.node.firstChild;
                if (childNode && childNode.parentNode) {
                    childNode.parentNode.removeChild(childNode);
                }
            }
        }
    };
    return Group;
}(AMElement_AMElement));

//# sourceMappingURL=Group.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/InterfaceColorSet.js
/**
 * This module contains a version of ColorSet that can (and should) be used for
 * coloring UI elements.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * This module contains a version of ColorSet that can (and should) be used for
 * coloring UI elements.
 *
 * The main difference from the basic [[ColorSet]] is that instead of sequenced
 * colors, it uses a concept of named colors.
 *
 * This way, every element in the UI can extract an exact color theme author
 * meant for the specific purpose, like strokes, backgrounds, etc.
 *
 * @see {@link https://www.amcharts.com/docs/v4/concepts/colors/} for color-related info
 */
var InterfaceColorSet_InterfaceColorSet = /** @class */ (function (_super) {
    __extends(InterfaceColorSet, _super);
    /**
     * Constructor
     */
    function InterfaceColorSet() {
        var _this = _super.call(this) || this;
        /**
         * Maps the list of purposes (like "stroke") to an index of color of the
         * color set.
         */
        _this._purposes = {
            stroke: Color_color("#e5e5e5"),
            fill: Color_color("#f3f3f3"),
            primaryButton: Color_color("#6794dc"),
            primaryButtonHover: Color_color("#6771dc"),
            primaryButtonDown: Color_color("#68dc75"),
            primaryButtonActive: Color_color("#68dc75"),
            primaryButtonText: Color_color("#FFFFFF"),
            primaryButtonStroke: Color_color("#FFFFFF"),
            secondaryButton: Color_color("#d9d9d9"),
            secondaryButtonHover: Color_color("#d9d9d9").brighten(-0.25),
            secondaryButtonDown: Color_color("#d9d9d9").brighten(-0.35),
            secondaryButtonActive: Color_color("#d9d9d9").brighten(0.35),
            secondaryButtonText: Color_color("#000000"),
            secondaryButtonStroke: Color_color("#FFFFFF"),
            grid: Color_color("#000000"),
            background: Color_color("#ffffff"),
            alternativeBackground: Color_color("#000000"),
            text: Color_color("#000000"),
            alternativeText: Color_color("#FFFFFF"),
            disabledBackground: Color_color("#999999"),
            positive: Color_color("#67dc75"),
            negative: Color_color("#dc6788")
        };
        _this.className = "InterfaceColorSet";
        _this.applyTheme();
        return _this;
    }
    InterfaceColorSet.prototype.debug = function () { };
    /**
     * Returns a color to be used for the specific purpose.
     *
     * ```TypeScript
     * let uicolors = new am4core.InterfaceColorSet();
     * console.log(uicolors.getFor("stroke"));
     * ```
     * ```JavaScript
     * var uicolors = new am4core.InterfaceColorSet();
     * console.log(uicolors.getFor("stroke"));
     * ```
     *
     * @param purpose  Color use purpuse
     * @return Color
     */
    InterfaceColorSet.prototype.getFor = function (purpose) {
        return this._purposes[purpose];
    };
    /**
     * Sets color to be used for the specific purpose.
     *
     * @param purpose  Color use purpose
     * @param color    Color
     */
    InterfaceColorSet.prototype.setFor = function (purpose, color) {
        this._purposes[purpose] = color;
    };
    return InterfaceColorSet;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["InterfaceColorSet"] = InterfaceColorSet_InterfaceColorSet;
//# sourceMappingURL=InterfaceColorSet.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/PopupCSS.js




var PopupCSS_rules = new Dictionary_Dictionary();
/**
 * Default CSS for Popup.
 *
 * @ignore Exclude from docs
 * @param prefix  Prefix for CSS classes
 * @return Disposer for the CSS definition
 */
/* harmony default export */ var PopupCSS = (function (element, prefix) {
    if (!prefix) {
        prefix = "ampopup";
    }
    var cs = new InterfaceColorSet_InterfaceColorSet();
    var fg = cs.getFor("text");
    var bg = cs.getFor("background");
    bg.alpha = 0.8;
    var abg = cs.getFor("alternativeBackground");
    abg.alpha = 0.05;
    var counter = PopupCSS_rules.insertKeyIfEmpty(prefix, function () {
        var disposer = new Disposer_MultiDisposer([
            new DOM_StyleRule(element, "." + prefix, {
                //"width": "100%",
                //"height": "100%",
                "overflow": "visible",
                "position": "absolute",
                "top": "0",
                "left": "0",
                "z-index": "2000"
            }),
            new DOM_StyleRule(element, "." + prefix + "-curtain", {
                "width": "100%",
                "height": "100%",
                "position": "absolute",
                "top": "0",
                "left": "0",
                "z-index": "2001",
                "background-color": bg.hex,
                "opacity": "0.5"
            }),
            new DOM_StyleRule(element, "." + prefix + "-header", {
                "display": "block",
                "width": "100%",
                "min-height": "1.8em",
                "background": abg.rgba
            }),
            new DOM_StyleRule(element, "." + prefix + "-title", {
                "font-weight": "bold",
                "font-size": "110%",
                "padding": "0.5em 1.2em 0.5em 1em"
            }),
            new DOM_StyleRule(element, "." + prefix + "-content", {
                /*"width": "100%",
                "height": "100%",*/
                // "padding": "2em 1em 1em 1em",
                "background": bg.hex,
                "background-color": bg.rgba,
                "color": fg.hex,
                "display": "inline-block",
                "position": "absolute",
                "top": "0",
                "left": "0",
                "max-width": "90%",
                "max-height": "90%",
                "overflow": "auto",
                "z-index": "2002"
            }),
            new DOM_StyleRule(element, "." + prefix + "-inside", {
                "padding": "1em"
            }),
            new DOM_StyleRule(element, "." + prefix + "-close", {
                "display": "block",
                "position": "absolute",
                "top": "0.3em",
                "right": "0.3em",
                "background-color": "rgb(100, 100, 100)",
                "background": "rgba(100, 100, 100, 0.1) url(data:image/svg+xml;charset=utf-8;base64,PHN2ZyBoZWlnaHQ9IjUxMiIgdmVyc2lvbj0iMSIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHdpZHRoPSI1MTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTQ0NS4yIDEwOS4ybC00Mi40LTQyLjRMMjU2IDIxMy42IDEwOS4yIDY2LjhsLTQyLjQgNDIuNEwyMTMuNiAyNTYgNjYuOCA0MDIuOGw0Mi40IDQyLjRMMjU2IDI5OC40bDE0Ni44IDE0Ni44IDQyLjQtNDIuNEwyOTguNCAyNTYiLz48L3N2Zz4=) no-repeat center",
                "background-size": "80%",
                "width": "1.2em",
                "height": "1.2em",
                "cursor": "pointer"
            }),
        ]);
        return new Disposer_CounterDisposer(function () {
            PopupCSS_rules.removeKey(prefix);
            disposer.dispose();
        });
    });
    return counter.increment();
});
//# sourceMappingURL=PopupCSS.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/interaction/InteractionObjectEvents.js



/**
 * Represents an Event Dispatcher for [[InteractionObject]].
 *
 * Besides regular [[EventDispatcher]] functionality it adds new events with
 * direct application to DOM nodes. Primarily used to handle keyboard events,
 * but can turn into something else moving forward.
 */
var InteractionObjectEvents_InteractionObjectEventDispatcher = /** @class */ (function (_super) {
    __extends(InteractionObjectEventDispatcher, _super);
    function InteractionObjectEventDispatcher() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Holds a list of Disposers for DOM events added.
         */
        _this._domEvents = {};
        return _this;
    }
    /**
     * Adds a DOM event and returns Disposer.
     *
     * @return Disposer
     */
    InteractionObjectEventDispatcher.prototype._addDOMEvent = function (type, key, listener, context) {
        var _this = this;
        if (!this._domEvents[type]) {
            var callback_1 = function (e) {
                listener.call(context, key, e);
            };
            this.target.element.addEventListener(type, callback_1, false);
            this._domEvents[type] = new Disposer_CounterDisposer(function () {
                delete _this._domEvents[type];
                _this.target.element.removeEventListener(type, callback_1, false);
            });
        }
        return this._domEvents[type].increment();
    };
    InteractionObjectEventDispatcher.prototype._dispatchKeyboardEvent = function (key, ev) {
        // TODO use this.dispatchImmediately ?
        if (this.target.events.isEnabled(key)) {
            this.target.events.dispatchImmediately(key, {
                type: key,
                target: this.target,
                event: ev
            });
        }
    };
    InteractionObjectEventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {
        var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);
        var disposers = [info.disposer];
        switch (type) {
            case "hit":
            case "doublehit":
            case "rightclick":
            case "down":
            case "up":
                this.target.clickable = true;
                break;
            case "drag":
            case "dragstart":
            case "dragstop":
                this.target.draggable = true;
                break;
            case "track":
                this.target.trackable = true;
                break;
            case "resize":
                this.target.resizable = true;
                break;
            case "swipe":
            case "swipeleft":
            case "swiperight":
                this.target.swipeable = true;
                break;
            case "wheel":
            case "wheelup":
            case "wheeldown":
            case "wheelleft":
            case "wheelright":
                this.target.wheelable = true;
                break;
            case "over":
            case "out":
                this.target.hoverable = true;
                break;
            case "focus":
            case "blur":
            case "focusin":
            case "focusout":
                this.target.focusable = true;
                break;
            case "keydown":
                disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));
                break;
            case "keyup":
                disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));
                break;
            case "keypress":
                disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));
                break;
            case "input":
                disposers.push(this._addDOMEvent(type, type, this._dispatchKeyboardEvent, this));
                break;
        }
        info.disposer = new Disposer_MultiDisposer(disposers);
        return info;
    };
    return InteractionObjectEventDispatcher;
}(EventDispatcher_TargetedEventDispatcher));

//# sourceMappingURL=InteractionObjectEvents.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/interaction/InteractionObject.js
/**
 * Interaction Object module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * Re-exports
 */

/**
 * Interaction object represents an object that is subject for any kind of
 * interaction with it with any input devices: mouse, touch or keyboard.
 *
 * Any DOM element can be wrapped into an Internaction object which in turn
 * enables attaching various interaction events to it, such as: hit, drag,
 * swipe, etc.
 *
 * To create an [[InteractionObject]] out of a [[Sprite]], use:
 * `interaction.getInteractionFromSprite(sprite: Sprite)`
 *
 * To create an [[InteractionObject]] out of a a regular element:
 * `interaction.getInteraction(element: HTMLElement)`
 */
var InteractionObject_InteractionObject = /** @class */ (function (_super) {
    __extends(InteractionObject, _super);
    /**
     * Constructor
     */
    function InteractionObject(element) {
        var _this = _super.call(this) || this;
        /**
         * @ignore
         * An [[EventDispatcher]] instance which holds events for this object
         */
        _this._eventDispatcher = new InteractionObjectEvents_InteractionObjectEventDispatcher(_this);
        /**
         * Collection of Disposers for various events. (so that those get disposed
         * when the whole InteractionObject is disposed)
         *
         * @ignore Exclude from docs
         */
        _this.eventDisposers = new Dictionary_Dictionary();
        /**
         * A [[Dictionary]] that holds temporarily replaced original style values for
         * HTML element, so that they can be restored when the functionality that
         * replaced them is done.
         *
         * @ignore Exclude from docs
         */
        _this.replacedStyles = new Dictionary_Dictionary();
        _this._clickable = false;
        _this._contextMenuDisabled = false;
        _this._hoverable = false;
        _this._trackable = false;
        _this._draggable = false;
        _this._swipeable = false;
        _this._resizable = false;
        _this._wheelable = false;
        _this._inert = false;
        /**
         * Is element currently hovered?
         */
        _this._isHover = false;
        /**
         * Was this element hovered via pointer or is it just "pretenting" to be
         * hovered.
         *
         * @ignore
         */
        _this.isRealHover = false;
        /**
         * Is the element hovered by touch pointer?
         */
        _this._isHoverByTouch = false;
        /**
         * Has element got any pointers currently pressing down on it?
         */
        _this._isDown = false;
        /**
         * Does element have focus?
         */
        _this._isFocused = false;
        /**
         * Is element currently protected from touch interactions?
         */
        _this._isTouchProtected = false;
        /**
         * Options used for inertia functionality.
         */
        _this._inertiaOptions = new Dictionary_Dictionary();
        /**
         * A collection of different inertia types, currently playing out.
         *
         * @ignore Exclude from docs
         */
        _this.inertias = new Dictionary_Dictionary();
        /**
         * Click/tap options.
         */
        _this._hitOptions = {};
        /**
         * Hover options.
         */
        _this._hoverOptions = {};
        /**
         * Swipe gesture options.
         */
        _this._swipeOptions = {};
        /**
         * Keyboard options.
         */
        _this._keyboardOptions = {};
        /**
         * Mouse options.
         */
        _this._mouseOptions = {};
        /**
         * Cursor options.
         */
        _this._cursorOptions = {
            "defaultStyle": [{
                    "property": "cursor",
                    "value": "default"
                }]
        };
        _this._disposers.push(_this._eventDispatcher);
        _this._element = element;
        _this.className = "InteractionObject";
        _this._disposers.push(new Dictionary_DictionaryDisposer(_this.inertias));
        _this._disposers.push(new Dictionary_DictionaryDisposer(_this.eventDisposers));
        _this.applyTheme();
        return _this;
    }
    ;
    Object.defineProperty(InteractionObject.prototype, "events", {
        /**
         * An [[EventDispatcher]] instance which holds events for this object
         */
        get: function () {
            return this._eventDispatcher;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "isHover", {
        /**
         * @return Hovered?
         */
        get: function () {
            return this._isHover;
        },
        /**
         * Indicates if this element is currently hovered.
         *
         * @param value Hovered?
         */
        set: function (value) {
            if (this.isHover != value) {
                this._isHover = value;
                if (value) {
                    getInteraction().overObjects.moveValue(this);
                }
                else {
                    this.isRealHover = false;
                    getInteraction().overObjects.removeValue(this);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "isHoverByTouch", {
        /**
         * @return Hovered?
         */
        get: function () {
            return this._isHoverByTouch;
        },
        /**
         * Indicates if this element is currently hovered.
         *
         * @param value Hovered?
         */
        set: function (value) {
            if (this.isHoverByTouch != value) {
                this._isHoverByTouch = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "overPointers", {
        /**
         * A list of pointers currently over the element.
         *
         * @see {@link Pointer}
         * @return List if pointers currently hovering the element
         */
        get: function () {
            if (!this._overPointers) {
                this._overPointers = new List_List();
            }
            return this._overPointers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "isDown", {
        /**
         * @return Has down pointers?
         */
        get: function () {
            return this._isDown;
        },
        /**
         * Indicates if this element has currently any pointers pressing on it.
         *
         * @param value Has down pointers?
         */
        set: function (value) {
            if (this.isDown != value) {
                this._isDown = value;
                if (value) {
                    getInteraction().downObjects.moveValue(this);
                }
                else {
                    getInteraction().downObjects.removeValue(this);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "downPointers", {
        /**
         * A list of pointers currently pressing down on this element.
         *
         * @see {@link Pointer}
         * @return List of down pointers
         */
        get: function () {
            if (!this._downPointers) {
                this._downPointers = new List_List();
            }
            return this._downPointers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "isFocused", {
        /**
         * @return Focused?
         */
        get: function () {
            return this._isFocused;
        },
        /**
         * Indicates if this element is currently focused.
         *
         * @param value Focused?
         */
        set: function (value) {
            if (this.isFocused != value) {
                this._isFocused = value;
                if (value) {
                    getInteraction().focusedObject = this;
                }
                else {
                    getInteraction().focusedObject = undefined;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "isTouchProtected", {
        /**
         * @ignore
         * @return Touch protected?
         */
        get: function () {
            return this._isTouchProtected;
        },
        /**
         * Indicates if this element is currently being protected from touch actions.
         *
         * @ignore
         * @param value Touch protected?
         */
        set: function (value) {
            if (this._isTouchProtected != value) {
                this._isTouchProtected = value;
                if (value) {
                    getInteraction().unprepElement(this);
                }
                else if (this.draggable || this.swipeable || this.trackable || this.resizable) {
                    getInteraction().prepElement(this);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "clickable", {
        /**
         * @return Clickable?
         */
        get: function () {
            return this._clickable;
        },
        /**
         * Is element clickable? Clickable elements will generate "hit" events when
         * clicked or tapped.
         *
         * @param value Clickable?
         */
        set: function (value) {
            if (this._clickable !== value) {
                this._clickable = value;
                getInteraction().processClickable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "contextMenuDisabled", {
        /**
         * @return Context menu disabled?
         */
        get: function () {
            return this._contextMenuDisabled;
        },
        /**
         * Should element prevent context menu to be displayed, e.g. when
         * right-clicked?
         *
         * @default false
         * @param value Context menu disabled?
         */
        set: function (value) {
            if (this._contextMenuDisabled !== value) {
                this._contextMenuDisabled = value;
                getInteraction().processContextMenu(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "hoverable", {
        /**
         * @return Hoverable?
         */
        get: function () {
            return this._hoverable;
        },
        /**
         * Indicates if element should generate hover events.
         *
         * @param value Hoverable?
         */
        set: function (value) {
            if (this._hoverable !== value) {
                this._hoverable = value;
                getInteraction().processHoverable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "trackable", {
        /**
         * @return Track pointer?
         */
        get: function () {
            return this._trackable;
        },
        /**
         * Indicates if pointer movement over element should be tracked.
         *
         * @param value Track pointer?
         */
        set: function (value) {
            if (this._trackable !== value) {
                this._trackable = value;
                getInteraction().processTrackable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "draggable", {
        /**
         * @return Draggable?
         */
        get: function () {
            return this._draggable;
        },
        /**
         * Indicates if element can be dragged. (moved)
         *
         * @param value Draggable?
         */
        set: function (value) {
            if (this._draggable !== value) {
                this._draggable = value;
                getInteraction().processDraggable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "swipeable", {
        /**
         * @return Track swipe?
         */
        get: function () {
            return this._swipeable;
        },
        /**
         * Indicates whether element should react to swipe gesture.
         *
         * @param value Track swipe?
         */
        set: function (value) {
            if (this._swipeable !== value) {
                this._swipeable = value;
                getInteraction().processSwipeable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "resizable", {
        /**
         * @return Resizeble?
         */
        get: function () {
            return this._resizable;
        },
        /**
         * Indicates if element can be resized.
         *
         * @param value Resizeable?
         */
        set: function (value) {
            if (this._resizable !== value) {
                this._resizable = value;
                getInteraction().processResizable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "wheelable", {
        /**
         * @return Track wheel?
         */
        get: function () {
            return this._wheelable;
        },
        /**
         * Indicates whether track moouse wheel rotation over element.
         *
         * @param value Track wheel?
         */
        set: function (value) {
            if (this._wheelable !== value) {
                this._wheelable = value;
                getInteraction().processWheelable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "inert", {
        /**
         * @return Inert?
         */
        get: function () {
            return this._inert;
        },
        /**
         * Indicates if element is inert, i.e. if it should carry movement momentum
         * after it is dragged and released.
         *
         * @param value Inert?
         */
        set: function (value) {
            if (this._inert !== value) {
                this._inert = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "focusable", {
        /**
         * @return Focusable?
         */
        get: function () {
            return this._focusable;
        },
        /**
         * Indicates if element can gain focus.
         *
         * @param value Focusable?
         */
        set: function (value) {
            if (this._focusable !== value) {
                this._focusable = value;
                if (this._focusable && this.tabindex == -1) {
                    this._tabindex = 1;
                }
                getInteraction().processFocusable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "tabindex", {
        /**
         * @return Tab index
         */
        get: function () {
            return getValueDefault(this._tabindex, -1);
        },
        /**
         * Element's tab index.
         *
         * @param value Tab index
         */
        set: function (value) {
            if (this._tabindex !== value) {
                this._tabindex = value;
                if (value > -1) {
                    this.focusable = true;
                }
                getInteraction().processFocusable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "element", {
        /**
         * @return Element
         */
        get: function () {
            return this._element;
        },
        /**
         * A DOM element associated with this element.
         *
         * @param element Element
         */
        set: function (element) {
            this._element = element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "originalPosition", {
        /**
         * @ignore Exclude from docs
         * @return Position.
         */
        get: function () {
            return this._originalPosition || { x: 0, y: 0 };
        },
        /**
         * Element's original position.
         *
         * @ignore Exclude from docs
         * @param value Position
         */
        set: function (value) {
            this._originalPosition = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "originalScale", {
        /**
         * @return Scale
         */
        get: function () {
            return getValueDefault(this._originalScale, 1);
        },
        /**
         * Element's original scale.
         *
         * @ignore Exclude from docs
         * @param value Scale
         */
        set: function (value) {
            if (this._originalScale !== value) {
                this._originalScale = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "originalAngle", {
        /**
         * @return Angle
         */
        get: function () {
            return getValueDefault(this._originalAngle, 0);
        },
        /**
         * Element's original angle.
         *
         * @ignore Exclude from docs
         * @param value Angle
         */
        set: function (value) {
            if (this._originalAngle !== value) {
                this._originalAngle = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "inertiaOptions", {
        /**
         * @return Options
         */
        get: function () {
            if (this.sprite && this.sprite._adapterO) {
                return this.sprite._adapterO.apply("inertiaOptions", this._inertiaOptions);
            }
            else {
                return this._inertiaOptions;
            }
        },
        /**
         * Inertia options.
         *
         * @param value  Options
         */
        set: function (value) {
            this._inertiaOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "hitOptions", {
        /**
         * @return Options
         */
        get: function () {
            if (this.sprite && this.sprite._adapterO) {
                return this.sprite._adapterO.apply("hitOptions", this._hitOptions);
            }
            else {
                return this._hitOptions;
            }
        },
        /**
         * Hit options.
         *
         * @param value  Options
         */
        set: function (value) {
            this._hitOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "hoverOptions", {
        /**
         * @return Options
         */
        get: function () {
            if (this.sprite && this.sprite._adapterO) {
                return this.sprite._adapterO.apply("hoverOptions", this._hoverOptions);
            }
            else {
                return this._hoverOptions;
            }
        },
        /**
         * Hover options.
         *
         * @param value  Options
         */
        set: function (value) {
            this._hoverOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "swipeOptions", {
        /**
         * @return Options
         */
        get: function () {
            if (this.sprite && this.sprite._adapterO) {
                return this.sprite._adapterO.apply("swipeOptions", this._swipeOptions);
            }
            else {
                return this._swipeOptions;
            }
        },
        /**
         * Swipe options.
         *
         * @param value  Options
         */
        set: function (value) {
            this._swipeOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "keyboardOptions", {
        /**
         * @return Options
         */
        get: function () {
            if (this.sprite && this.sprite._adapterO) {
                return this.sprite._adapterO.apply("keyboardOptions", this._keyboardOptions);
            }
            else {
                return this._keyboardOptions;
            }
        },
        /**
         * Keyboard options.
         *
         * @param value  Options
         */
        set: function (value) {
            this._keyboardOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "mouseOptions", {
        /**
         * @return Options
         */
        get: function () {
            if (this.sprite && this.sprite._adapterO) {
                return this.sprite._adapterO.apply("mouseOptions", this._mouseOptions);
            }
            else {
                return this._mouseOptions;
            }
        },
        /**
         * Mouse options.
         *
         * Enables controlling options related to the mouse, for example sensitivity
         * of its mouse wheel.
         *
         * E.g. the below will reduce chart's wheel-zoom speed to half its default
         * speed:
         *
         * ```TypeScript
         * chart.plotContainer.mouseOptions.sensitivity = 0.5;
         * ```
         * ```JavaScript
         * chart.plotContainer.mouseOptions.sensitivity = 0.5;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "plotContainer": {
         *     "mouseOptions": {
         *       "sensitivity": 0.5
         *     }
         *   }
         * }
         * ```
         *
         * @since 4.5.14
         * @param value  Options
         */
        set: function (value) {
            this._mouseOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InteractionObject.prototype, "cursorOptions", {
        /**
         * @return Options
         */
        get: function () {
            if (this.sprite && this.sprite._adapterO) {
                return this.sprite._adapterO.apply("cursorOptions", this._cursorOptions);
            }
            else {
                return this._cursorOptions;
            }
        },
        /**
         * Cursor options.
         *
         * @param value  Options
         */
        set: function (value) {
            this._cursorOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all properties and related assets from another object of the same
     * type.
     *
     * @param source Source object
     */
    InteractionObject.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.inertiaOptions = source.inertiaOptions;
        this.hitOptions = source.hitOptions;
        this.hoverOptions = source.hoverOptions;
        this.swipeOptions = source.swipeOptions;
        this.keyboardOptions = source.keyboardOptions;
        this.cursorOptions = source.cursorOptions;
        this.contextMenuDisabled = source.contextMenuDisabled;
        getInteraction().applyCursorOverStyle(this);
    };
    /**
     * @ignore Exclude from docs
     */
    InteractionObject.prototype.setEventDisposer = function (key, value, f) {
        var disposer = this.eventDisposers.getKey(key);
        if (value) {
            if (disposer == null) {
                this.eventDisposers.setKey(key, f());
            }
        }
        else {
            if (disposer != null) {
                disposer.dispose();
                this.eventDisposers.removeKey(key);
            }
        }
    };
    /**
     * Disposes object.
     */
    InteractionObject.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        // Remove from all interaction registries
        var interaction = getInteraction();
        interaction.overObjects.removeValue(this);
        interaction.downObjects.removeValue(this);
        interaction.trackedObjects.removeValue(this);
        interaction.transformedObjects.removeValue(this);
        // Unlock document wheel
        if (this.isHover && this.wheelable) {
            interaction.unlockWheel();
        }
        if (interaction.focusedObject === this) {
            interaction.focusedObject = undefined;
        }
    };
    return InteractionObject;
}(Base_BaseObjectEvents));

//# sourceMappingURL=InteractionObject.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/interaction/InteractionKeyboardObject.js
/**
 * Functionality related simulating of dragging of elements using keyboard.
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * [[InteractionKeyboardObject]] is used to simulate dragging of the `draggable`
 * element using keyboard arrows.
 *
 * @ignore Exclude from docs
 */
var InteractionKeyboardObject_InteractionKeyboardObject = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param io An InteractionObject
     */
    function InteractionKeyboardObject(io, ev) {
        /**
         * Indicates if this object has already been deleted. Any
         * destruction/disposal code should take this into account when deciding
         * wheter to run potentially costly disposal operations if they already have
         * been run.
         */
        this._disposed = false;
        /**
         * Indicates direction of current horizontal movement.
         *
         * 0 - not moving horizontally
         * 1 - moving right
         * -1 - moving left
         */
        this.directionX = 0;
        /**
         * Indicates direction of current vertical movement.
         *
         * 0 - not moving vertically
         * 1 - moving down
         * -1 - moving up
         */
        this.directionY = 0;
        this.interaction = io;
        this.keyboardEvent = ev;
        this._startedOn = new Date().getTime();
        getInteraction().processDragStart(io);
        system.animations.push(this);
        this.update();
    }
    /**
     * It's an update method which is called by the system if
     * [[InteractionObject]] is used as animation.
     *
     * This will update coordinates of the element based on the movement
     * directions.
     */
    InteractionKeyboardObject.prototype.update = function () {
        // Init and get settings
        var io = this.interaction;
        var speed = getInteraction().getKeyboardOption(io, "speed"), accelleration = getInteraction().getKeyboardOption(io, "accelleration"), accellerationDelay = getInteraction().getKeyboardOption(io, "accellerationDelay"), shift = {
            x: 0,
            y: 0
        };
        // If SHIFT key is pressed we slash speed by half and disable accelleration
        if (this.keyboardEvent.shiftKey) {
            speed *= 0.5;
            accelleration = 1;
        }
        // If CTRL is pressed we increase speed by x2
        else if (this.keyboardEvent.ctrlKey) {
            speed *= 2;
        }
        // Get elapsed time
        var ms = new Date().getTime() - this._startedOn;
        var accelleratedMs = ms - accellerationDelay;
        // Add accellerated movement
        if ((accelleration > 0) && (accelleratedMs > 0)) {
            var accellerationFactor = ms / accellerationDelay;
            ms = accellerationDelay;
            shift.x += this.directionX * (speed * accelleration * accellerationFactor * accelleratedMs);
            shift.y += this.directionY * (speed * accelleration * accellerationFactor * accelleratedMs);
        }
        // Calculate position
        shift.x += this.directionX * (speed * ms);
        shift.y += this.directionY * (speed * ms);
        // Simulate move on Interaction
        getInteraction().handleTransformMove(io, shift, { x: 0, y: 0 }, this.keyboardEvent, true, false);
    };
    /**
     * Returns if this object has been already been disposed.
     *
     * @return Is disposed?
     */
    InteractionKeyboardObject.prototype.isDisposed = function () {
        return this._disposed;
    };
    /**
     * Disposes this object. Removes from system animations.
     */
    InteractionKeyboardObject.prototype.dispose = function () {
        if (!this._disposed) {
            getInteraction().processDragStop(this.interaction);
            remove(system.animations, this);
        }
    };
    return InteractionKeyboardObject;
}());

//# sourceMappingURL=InteractionKeyboardObject.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/interaction/Inertia.js
/**
 * Functionality related to inertia
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * A point of inertia is to simulate gradually drecreasing motion even after
 * actual interaction by user, that caused it, has already ended.
 *
 * [[Inertia]] object will continue triggering the same [[Sprite]] handlers
 * as if the interaction was still happening, gradually reducing
 * shift/angle/scale values until full stop.
 *
 * Basically, from the target element's point of view, while inertia is
 * playing, it is still being interacted with by user, albeit with a
 * decreasing speed.
 */
var Inertia_Inertia = /** @class */ (function (_super) {
    __extends(Inertia, _super);
    /**
     * Constructor
     */
    function Inertia(interaction, type, point, startPoint) {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * List of animations currently playing.
         */
        _this.animations = [];
        _this.className = "Inertia";
        _this.interaction = interaction;
        _this.type = type;
        _this.point = point;
        _this.startPoint = startPoint;
        // Make animations disposable
        _this._disposers.push(new Animation_AnimationDisposer(_this.animations));
        return _this;
    }
    Object.defineProperty(Inertia.prototype, "x", {
        /**
         * Returns current X coordinate.
         *
         * @return X
         */
        get: function () {
            return this.point.x;
        },
        /**
         * Sets current X coordinate.
         *
         * Will trigger "drag" event for the target element.
         *
         * @param value X
         */
        set: function (value) {
            if (isNumber(value)) {
                this.point.x = value;
                this.handleMove();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Inertia.prototype, "y", {
        /**
         * Returns current Y coordinate.
         *
         * @return Y
         */
        get: function () {
            return this.point.y;
        },
        /**
         * Sets current Y coordinate.
         *
         * Will trigger "drag" event for the target element.
         *
         * @param value Y
         */
        set: function (value) {
            if (isNumber(value)) {
                this.point.y = value;
                this.handleMove();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Simulates dragging of element.
     */
    Inertia.prototype.handleMove = function () {
        // Prepare {InteractionEvent} object
        if (this.interaction.events.isEnabled("drag")) {
            var imev = {
                type: "drag",
                target: this.interaction,
                shift: {
                    x: this.x - this.startPoint.x,
                    y: this.y - this.startPoint.y
                },
                startPoint: this.startPoint,
                point: {
                    x: this.x,
                    y: this.y
                },
                touch: false
            };
            // Call handler
            this.interaction.events.dispatchImmediately("drag", imev);
        }
    };
    /**
     * Finishes up the inertia animation. (removes reference to this animation
     * object)
     */
    Inertia.prototype.done = function () {
        // Remove inertia animation from the object
        this.interaction.inertias.removeKey(this.type);
        // Move ended
        if (this.type === "move") {
            getInteraction().processDragStop(this.interaction);
        }
        // Destroy
        this.dispose();
    };
    return Inertia;
}(Base_BaseObject));

//# sourceMappingURL=Inertia.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Keyboard.js
/**
 * A collection of keyboard-related utilities accessible via `keyboard`
 * instance.
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * A class that represents collection of keyboard-related utilities.
 *
 * Do not instantiate this class directly, but rather use `keyboard` variable.
 */
var Keyboard_Keyboard = /** @class */ (function () {
    function Keyboard() {
    }
    /**
     * Returns a named key based on information contained in the event or
     * "other".
     *
     * @param ev  A keyboard event
     * @return Keyboard named key
     */
    Keyboard.prototype.getEventKey = function (ev) {
        // Get the key code
        var code = ev.keyCode || ev.which, key;
        // Map to internal key
        switch (code) {
            case 38:
                key = "up";
                break;
            case 40:
                key = "down";
                break;
            case 37:
                key = "left";
                break;
            case 39:
                key = "right";
                break;
            case 13:
                key = "enter";
                break;
            case 27:
                key = "esc";
                break;
            case 36:
                key = "home";
                break;
            case 35:
                key = "end";
                break;
            case 9:
                key = "tab";
                break;
            case 17:
                key = "ctrl";
                break;
            case 18:
                key = "alt";
                break;
            case 16:
                key = "shift";
                break;
            case 32:
                key = "space";
                break;
            case 36:
                key = "home";
                break;
            case 35:
                key = "end";
                break;
            case 33:
                key = "pgup";
                break;
            case 34:
                key = "pgdn";
                break;
            case 45:
                key = "ins";
                break;
            case 46:
                key = "del";
                break;
            case 107:
                key = "plus";
                break;
            case 109:
                key = "minus";
                break;
            default:
                key = "other";
                break;
        }
        return key;
    };
    /**
     * Checks if event key is one or more of the selected named keys.
     *
     * @param ev   Keyboard event
     * @param key  Named key or array of keys
     * @return Is event key one of the list?
     */
    Keyboard.prototype.isKey = function (ev, key) {
        var eventKey = this.getEventKey(ev);
        if (isString(key)) {
            key = [key];
        }
        return key.indexOf(eventKey) !== -1;
    };
    /**
     * Returns `true` if shift key was presset at the moment of the event.
     *
     * @param ev  Event object
     * @return Was shift pressed?
     */
    Keyboard.prototype.shiftKey = function (ev) {
        return ev.shiftKey;
    };
    /**
     * Returns `true` if ctrl key was presset at the moment of the event.
     *
     * @param ev  Event object
     * @return Was ctrl pressed?
     */
    Keyboard.prototype.ctrlKey = function (ev) {
        return ev.ctrlKey;
    };
    /**
     * Returns `true` if alt key was presset at the moment of the event
     * @param ev  Event object
     * @return Was alt pressed?
     */
    Keyboard.prototype.altKey = function (ev) {
        return ev.altKey;
    };
    /**
     * Returns `true` if meta key was presset at the moment of the event
     * @param ev  Event object
     * @return Was meta pressed?
     */
    Keyboard.prototype.metaKey = function (ev) {
        return ev.metaKey;
    };
    return Keyboard;
}());

/**
 * A single [[Keyboard]] instance to be reused across all elements so that
 * they don't need to instantiate their own.
 *
 * @ignore Exclude from docs
 */
var keyboard = new Keyboard_Keyboard();
//# sourceMappingURL=Keyboard.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Time.js

/**
 * Maps time period names to their numeric representations in milliseconds.
 *
 * @ignore Exclude from docs
 */
var timeUnitDurations = {
    millisecond: 1,
    second: 1000,
    minute: 60000,
    hour: 3600000,
    day: 86400000,
    week: 604800000,
    month: 2592000000,
    year: 31536000000
};
/**
 * Returns the next time unit that goes after source `unit`.
 *
 * E.g. "hour" is the next unit after "minute", etc.
 *
 * @ignore Exclude from docs
 * @param unit  Source time unit
 * @return Next time unit
 */
function getNextUnit(unit) {
    switch (unit) {
        case "year":
            return;
        case "month":
            return "year";
        case "week":
            return "month";
        case "day":
            return "month"; // not a mistake
        case "hour":
            return "day";
        case "minute":
            return "hour";
        case "second":
            return "minute";
        case "millisecond":
            return "second";
    }
}
/**
 * Returns number of milliseconds in the `count` of time `unit`.
 *
 * Available units: "millisecond", "second", "minute", "hour", "day", "week",
 * "month", and "year".
 *
 * @ignore Exclude from docs
 * @param unit   Time unit
 * @param count  Number of units
 * @return Milliseconds
 */
function getDuration(unit, count) {
    if (!hasValue(count)) {
        count = 1;
    }
    return timeUnitDurations[unit] * count;
}
/**
 * Returns current `Date` object.
 *
 * @return Current date
 */
function Time_now() {
    return new Date();
}
/**
 * Returns current timestamp.
 *
 * @return Current timestamp
 */
function getTime() {
    return Time_now().getTime();
}
/**
 * Returns a copy of the `Date` object.
 *
 * @ignore Exclude from docs
 * @param date  Source date
 * @return Copy
 */
function Time_copy(date) {
    return new Date(date.getTime()); // todo: check if this is ok. new Date(date) used to strip milliseconds on FF in v3
}
/**
 * Checks if the `unit` part of two `Date` objects do not match. Two dates
 * represent a "range" of time, rather the same time date.
 *
 * @ignore Exclude from docs
 * @param dateOne  Date 1
 * @param dateTwo  Date 2
 * @param unit     Time unit to check
 * @return Range?
 */
function checkChange(dateOne, dateTwo, unit, utc) {
    dateOne = new Date(dateOne.getTime());
    dateTwo = new Date(dateTwo.getTime());
    var timeZoneOffset1 = 0;
    var timeZoneOffset2 = 0;
    if (!utc && unit != "millisecond") {
        timeZoneOffset1 = dateOne.getTimezoneOffset();
        dateOne.setUTCMinutes(dateOne.getUTCMinutes() - timeZoneOffset1);
        timeZoneOffset2 = dateTwo.getTimezoneOffset();
        dateTwo.setUTCMinutes(dateTwo.getUTCMinutes() - timeZoneOffset2);
    }
    var changed = false;
    switch (unit) {
        case "year":
            if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
                changed = true;
            }
            break;
        case "month":
            if (dateOne.getUTCFullYear() != dateTwo.getUTCFullYear()) {
                changed = true;
            }
            else if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
                changed = true;
            }
            break;
        case "day":
            if (dateOne.getUTCMonth() != dateTwo.getUTCMonth()) {
                changed = true;
            }
            else if (dateOne.getUTCDate() != dateTwo.getUTCDate()) {
                changed = true;
            }
            break;
        case "hour":
            if (dateOne.getUTCHours() != dateTwo.getUTCHours()) {
                changed = true;
            }
            break;
        case "minute":
            if (dateOne.getUTCMinutes() != dateTwo.getUTCMinutes()) {
                changed = true;
            }
            break;
        case "second":
            if (dateOne.getUTCSeconds() != dateTwo.getUTCSeconds()) {
                changed = true;
            }
            break;
        case "millisecond":
            if (dateOne.getTime() != dateTwo.getTime()) {
                changed = true;
            }
            break;
    }
    if (changed) {
        return true;
    }
    var nextUnit = getNextUnit(unit);
    if (nextUnit) {
        dateOne.setUTCMinutes(dateOne.getUTCMinutes() + timeZoneOffset1);
        dateTwo.setUTCMinutes(dateTwo.getUTCMinutes() + timeZoneOffset2);
        return checkChange(dateOne, dateTwo, nextUnit, utc);
    }
    else {
        return false;
    }
}
/**
 * Adds `count` of time `unit` to the source date. Returns a modified `Date` object.
 *
 * @ignore Exclude from docs
 * @param date   Source date
 * @param unit   Time unit
 * @param count  Number of units to add
 * @return Modified date
 */
function Time_add(date, unit, count, utc) {
    var timeZoneOffset = 0;
    if (!utc && unit != "millisecond") {
        timeZoneOffset = date.getTimezoneOffset();
        date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
    }
    switch (unit) {
        case "day":
            var day = date.getUTCDate();
            date.setUTCDate(day + count);
            break;
        case "second":
            var seconds = date.getUTCSeconds();
            date.setUTCSeconds(seconds + count);
            break;
        case "millisecond":
            var milliseconds = date.getUTCMilliseconds();
            date.setUTCMilliseconds(milliseconds + count);
            break;
        case "hour":
            var hours = date.getUTCHours();
            date.setUTCHours(hours + count);
            break;
        case "minute":
            var minutes = date.getUTCMinutes();
            date.setUTCMinutes(minutes + count);
            break;
        case "year":
            var year = date.getUTCFullYear();
            date.setUTCFullYear(year + count);
            break;
        case "month":
            var month = date.getUTCMonth();
            date.setUTCMonth(month + count);
            break;
        case "week":
            var wday = date.getUTCDate();
            date.setUTCDate(wday + count * 7);
            break;
    }
    if (!utc && unit != "millisecond") {
        date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
        if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
            var newTimeZoneOffset = date.getTimezoneOffset();
            if (newTimeZoneOffset != timeZoneOffset) {
                var diff = newTimeZoneOffset - timeZoneOffset;
                date.setUTCMinutes(date.getUTCMinutes() + diff);
                // solves issues if newe time falls back to old time zone
                if (date.getTimezoneOffset() != newTimeZoneOffset) {
                    date.setUTCMinutes(date.getUTCMinutes() - diff);
                }
            }
        }
    }
    return date;
}
/**
 * "Rounds" the date to specific time unit.
 *
 * @ignore Exclude from docs
 * @param date             Source date
 * @param unit             Time unit
 * @param count            Number of units to round to
 * @param firstDateOfWeek  First day of week
 * @return New date
 */
function Time_round(date, unit, count, firstDateOfWeek, utc, firstDate) {
    if (!isNumber(count)) {
        count = 1;
    }
    var timeZoneOffset = 0;
    if (!utc && unit != "millisecond") {
        timeZoneOffset = date.getTimezoneOffset();
        date.setUTCMinutes(date.getUTCMinutes() - timeZoneOffset);
    }
    switch (unit) {
        case "day":
            var day = date.getUTCDate();
            if (count > 1) {
                //	day = Math.floor(day / count) * count;
                if (firstDate) {
                    firstDate = Time_round(firstDate, "day", 1);
                    var difference = date.getTime() - firstDate.getTime();
                    var unitCount = Math.floor(difference / getDuration("day") / count);
                    var duration = getDuration("day", unitCount * count);
                    date.setTime(firstDate.getTime() + duration - timeZoneOffset * getDuration("minute"));
                }
            }
            else {
                date.setUTCDate(day);
            }
            date.setUTCHours(0, 0, 0, 0);
            break;
        case "second":
            var seconds = date.getUTCSeconds();
            if (count > 1) {
                seconds = Math.floor(seconds / count) * count;
            }
            date.setUTCSeconds(seconds, 0);
            break;
        case "millisecond":
            if (count == 1) {
                return date; // much better for perf!
            }
            var milliseconds = date.getUTCMilliseconds();
            milliseconds = Math.floor(milliseconds / count) * count;
            date.setUTCMilliseconds(milliseconds);
            break;
        case "hour":
            var hours = date.getUTCHours();
            if (count > 1) {
                hours = Math.floor(hours / count) * count;
            }
            date.setUTCHours(hours, 0, 0, 0);
            break;
        case "minute":
            var minutes = date.getUTCMinutes();
            milliseconds = date.getUTCMilliseconds();
            if (count > 1) {
                minutes = Math.floor(minutes / count) * count;
            }
            date.setUTCMinutes(minutes, 0, 0);
            break;
        case "month":
            var month = date.getUTCMonth();
            if (count > 1) {
                month = Math.floor(month / count) * count;
            }
            date.setUTCMonth(month, 1);
            date.setUTCHours(0, 0, 0, 0);
            break;
        case "year":
            var year = date.getUTCFullYear();
            if (count > 1) {
                year = Math.floor(year / count) * count;
            }
            date.setUTCFullYear(year, 0, 1);
            date.setUTCHours(0, 0, 0, 0);
            //let nonUTCDateY = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
            //timeZoneOffset = nonUTCDateY.getTimezoneOffset();
            break;
        case "week":
            var wday = date.getUTCDate();
            var weekDay = date.getUTCDay();
            if (!isNumber(firstDateOfWeek)) {
                firstDateOfWeek = 1;
            }
            // todo: rounding when count is not 1
            if (weekDay >= firstDateOfWeek) {
                wday = wday - weekDay + firstDateOfWeek;
            }
            else {
                wday = wday - (7 + weekDay) + firstDateOfWeek;
            }
            date.setUTCDate(wday);
            date.setUTCHours(0, 0, 0, 0);
            break;
    }
    if (!utc && unit != "millisecond") {
        date.setUTCMinutes(date.getUTCMinutes() + timeZoneOffset);
        if (unit == "day" || unit == "week" || unit == "month" || unit == "year") {
            var newTimeZoneOffset = date.getTimezoneOffset();
            if (newTimeZoneOffset != timeZoneOffset) {
                var diff = newTimeZoneOffset - timeZoneOffset;
                date.setUTCMinutes(date.getUTCMinutes() + diff);
            }
        }
    }
    return date;
}
//# sourceMappingURL=Time.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/interaction/Interaction.js
/**
 * Interaction manages all aspects of user interaction - mouse move,
 * click, hover, drag events, touch gestures.
 *
 * [[InteractionObject]] elements that want to use certain events, must attach event
 * listeners to Interaction instance.
 *
 * Interaction itself will not modify [[InteractionObject]] elements, it will be up to
 * those elements to handle interaction information received via event triggers.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


















/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
* Interaction manages all aspects of user interaction - mouse move,
* click, hover, drag events, touch gestures.
*
* [[InteractionObject]] elements that want to use certain events, must attach event
* listeners to Interaction instance.
*
* Interaction itself will not modify [[InteractionObject]] elements, it will be up to
* those elements to handle interaction information received via event triggers.
*
* @see {@link IInteractionEvents} for a list of available events
*/
var Interaction_Interaction = /** @class */ (function (_super) {
    __extends(Interaction, _super);
    /**
     * Constructor. Sets up universal document-wide move events to handle stuff
     * outside particular chart container.
     */
    function Interaction() {
        var _this = 
        // Call super
        _super.call(this) || this;
        /**
         * An indicator of global events were already initialized.
         */
        _this._globalEventsAdded = false;
        /**
         * Holds which mouse event listeners to use.
         */
        _this._pointerEvents = {
            "pointerdown": "mousedown",
            "pointerup": "mouseup",
            "pointermove": "mousemove",
            "pointercancel": "mouseup",
            "pointerover": "mouseover",
            "pointerout": "mouseout",
            "wheel": "wheel"
        };
        /**
         * Indicates if Interaction should use only "pointer" type events, like
         * "pointermove", available in all modern browsers, ignoring "legacy"
         * events, like "touchmove".
         */
        _this._usePointerEventsOnly = false;
        /**
         * Use only touch events (for touch only devices such as tablets and phones)
         */
        _this._useTouchEventsOnly = false;
        /**
         * Add special hover events. Normally, touch device tap will also simulate
         * hover event. On some devices (ahem iOS) we want to prevent that so that
         * over/out events are not duplicated.
         */
        _this._addHoverEvents = true;
        /**
         * Indicates if passive mode options is supported by this browser.
         */
        _this._passiveSupported = false;
        /**
         * Holds list of delayed events
         */
        _this._delayedEvents = { out: [] };
        /**
         * List of objects that current have a pointer hovered over them.
         */
        _this.overObjects = new List_List();
        /**
         * List of objects that currently has a pressed pointer.
         */
        _this.downObjects = new List_List();
        /**
         * List of objects that need mouse position to be reported to them.
         */
        _this.trackedObjects = new List_List();
        /**
         * List of objects that are currently being dragged.
         */
        _this.transformedObjects = new List_List();
        /**
         * Holds all known pointers.
         */
        _this.pointers = new Dictionary_Dictionary();
        /**
         * Inertia options that need to be applied to after element drag, if it's
         * `inert = true`.
         *
         * This is just a default, which can and probably will be overridden by
         * actual elements.
         */
        _this.inertiaOptions = new Dictionary_Dictionary();
        /**
         * Default options for click events. These can be overridden in
         * [[InteractionObject]].
         */
        _this.hitOptions = {
            //"holdTime": 1000,
            "doubleHitTime": 300,
            //"delayFirstHit": false,
            "hitTolerance": 10,
            "noFocus": true
        };
        /**
         * Default options for hover events. These can be overridden in
         * [[InteractionObject]].
         */
        _this.hoverOptions = {
            "touchOutBehavior": "leave",
            "touchOutDelay": 1000
        };
        /**
         * Default options for detecting a swipe gesture. These can be overridden in
         * [[InteractionObject]].
         */
        _this.swipeOptions = {
            "time": 500,
            "verticalThreshold": 75,
            "horizontalThreshold": 30
        };
        /**
         * Default options for keyboard operations. These can be overridden in
         * [[InteractionObject]].
         */
        _this.keyboardOptions = {
            "speed": 0.1,
            "accelleration": 1.2,
            "accellerationDelay": 2000
        };
        /**
         * Default options for keyboard operations. These can be overridden in
         * [[InteractionObject]].
         *
         * @since 4.5.14
         */
        _this.mouseOptions = {
            "sensitivity": 1
        };
        // Set class name
        _this.className = "Interaction";
        // Create InteractionObject for <body>
        _this.body = _this.getInteraction(document.body);
        _this._disposers.push(_this.body);
        // Detect browser capabilities and determine what event listeners to use
        if (window.hasOwnProperty("PointerEvent")) {
            // IE10+/Edge without touch controls enabled
            _this._pointerEvents.pointerdown = "pointerdown";
            _this._pointerEvents.pointerup = "pointerup";
            _this._pointerEvents.pointermove = "pointermove";
            _this._pointerEvents.pointercancel = "pointercancel";
            _this._pointerEvents.pointerover = "pointerover";
            _this._pointerEvents.pointerout = "pointerout";
            //this._usePointerEventsOnly = true;
        }
        else if (window.hasOwnProperty("MSPointerEvent")) {
            // IE9
            _this._pointerEvents.pointerdown = "MSPointerDown";
            _this._pointerEvents.pointerup = "MSPointerUp";
            _this._pointerEvents.pointermove = "MSPointerMove";
            _this._pointerEvents.pointercancel = "MSPointerUp";
            _this._pointerEvents.pointerover = "MSPointerOver";
            _this._pointerEvents.pointerout = "MSPointerOut";
            //this._usePointerEventsOnly = true;
        }
        else if ((typeof matchMedia !== "undefined") && matchMedia('(pointer:fine)').matches) {
            // This is only for Safari as it does not support PointerEvent
            // Do nothing and let it use regular `mouse*` events
            // Hi Apple ;)
            // Additionally disable hover events for iOS devices
            if ('ontouchstart' in window) {
                _this._addHoverEvents = false;
                _this._useTouchEventsOnly = true;
            }
        }
        else if (window.navigator.userAgent.match(/MSIE /)) {
            // Oh looky, an MSIE that does not support PointerEvent. Hi granpa IE9!
            _this._usePointerEventsOnly = true;
        }
        else if (_this.fullFF()) {
            // Old FF, let's use regular events.
            // (Newer FFs would be detected by the PointerEvent availability check)
            _this._usePointerEventsOnly = true;
        }
        else {
            // Uses defaults for normal browsers
            // We also assume that this must be a touch device that does not have
            // any pointer events
            _this._useTouchEventsOnly = true;
        }
        // Detect if device has a mouse
        // This is turning out to be not reliable
        // @todo remove
        /*if (!window.navigator.msPointerEnabled && (typeof matchMedia !== "undefined") && !matchMedia('(pointer:fine)').matches && !this.fullFF()) {
            this._useTouchEventsOnly = true;
        }*/
        // Detect proper mouse wheel events
        if ("onwheel" in document.createElement("div")) {
            // Modern browsers
            _this._pointerEvents.wheel = "wheel";
        }
        else if (hasValue(document.onmousewheel)) {
            // Webkit and IE support at least "mousewheel"
            _this._pointerEvents.wheel = "mousewheel";
        }
        // Set up default inertia options
        _this.inertiaOptions.setKey("move", {
            "time": 100,
            "duration": 500,
            "factor": 1,
            "easing": polyOut3
        });
        _this.inertiaOptions.setKey("resize", {
            "time": 100,
            "duration": 500,
            "factor": 1,
            "easing": polyOut3
        });
        // Set the passive mode support
        _this._passiveSupported = Interaction.passiveSupported;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * This is a nasty detection for Firefox. The reason why we have is that
     * Firefox ESR version does not support matchMedia correctly.
     *
     * On iOS, Firefox uses different userAgent, so we don't have to detect iOS.
     *
     * @return Full Firefox?
     */
    Interaction.prototype.fullFF = function () {
        return (window.navigator.userAgent.match(/Firefox/)) && !(window.navigator.userAgent.match(/Android/));
    };
    Interaction.prototype.debug = function () { };
    /**
     * ==========================================================================
     * Processing
     * ==========================================================================
     * @hidden
     */
    /**
     * Sets up global events.
     *
     * We need this so that we can track drag movement beyond chart's container.
     *
     * @ignore Exclude from docs
     */
    Interaction.prototype.addGlobalEvents = function () {
        var _this = this;
        if (!this._globalEventsAdded) {
            if (!this._useTouchEventsOnly) {
                this._disposers.push(addEventListener(document, this._pointerEvents.pointerdown, function (ev) { _this.handleGlobalPointerDown(ev); }));
                this._disposers.push(addEventListener(document, this._pointerEvents.pointermove, function (ev) { _this.handleGlobalPointerMove(ev); }));
                this._disposers.push(addEventListener(document, this._pointerEvents.pointerup, function (ev) { _this.handleGlobalPointerUp(ev); }));
                this._disposers.push(addEventListener(document, this._pointerEvents.pointercancel, function (ev) { _this.handleGlobalPointerUp(ev, true); }));
                this._disposers.push(addEventListener(document, "mouseenter", function (ev) {
                    if (!hasValue(ev.relatedTarget) && (ev.buttons == 0 || ev.which == 0)) {
                        _this.handleDocumentLeave(ev);
                    }
                }));
            }
            // No need to duplicate events for hubrid systems that support both
            // pointer events and touch events. Touch events are need only for
            // some touch-only systems, like Mobile Safari.
            if (!this._usePointerEventsOnly) {
                this._disposers.push(addEventListener(document, "touchstart", function (ev) { _this.handleGlobalTouchStart(ev); }));
                this._disposers.push(addEventListener(document, "touchmove", function (ev) { _this.handleGlobalTouchMove(ev); }));
                this._disposers.push(addEventListener(document, "touchend", function (ev) { _this.handleGlobalTouchEnd(ev); }));
            }
            this._disposers.push(addEventListener(document, "keydown", function (ev) { _this.handleGlobalKeyDown(ev); }));
            this._disposers.push(addEventListener(document, "keyup", function (ev) { _this.handleGlobalKeyUp(ev); }));
            this._globalEventsAdded = true;
        }
    };
    /**
     * Sets if [[InteractionObject]] is clickable.
     *
     * @ignore Exclude from docs
     * @param io [[InteractionObject]] instance
     */
    Interaction.prototype.processClickable = function (io) {
        // Add or remove touch events
        this.processTouchable(io);
    };
    /**
     * Sets if [[InteractionObject]] will display context menu when right-clicked.
     *
     * @ignore Exclude from docs
     * @param io [[InteractionObject]] instance
     */
    Interaction.prototype.processContextMenu = function (io) {
        if (io.contextMenuDisabled) {
            if (!io.eventDisposers.hasKey("contextMenuDisabled")) {
                io.eventDisposers.setKey("contextMenuDisabled", addEventListener(io.element, "contextmenu", function (e) {
                    e.preventDefault();
                }));
            }
        }
        else {
            if (io.eventDisposers.hasKey("contextMenuDisabled")) {
                io.eventDisposers.getKey("contextMenuDisabled").dispose();
            }
        }
    };
    /**
     * Sets if [[InteractionObject]] is hoverable.
     *
     * @ignore Exclude from docs
     * @param io [[InteractionObject]] instance
     */
    Interaction.prototype.processHoverable = function (io) {
        var _this = this;
        if (io.hoverable || io.trackable) {
            // Add global events
            this.addGlobalEvents();
            // Add hover styles
            this.applyCursorOverStyle(io);
            // Add local events
            if (!io.eventDisposers.hasKey("hoverable") && this._addHoverEvents) {
                io.eventDisposers.setKey("hoverable", new Disposer_MultiDisposer([
                    addEventListener(io.element, this._pointerEvents.pointerout, function (e) { return _this.handlePointerOut(io, e); }),
                    addEventListener(io.element, this._pointerEvents.pointerover, function (e) { return _this.handlePointerOver(io, e); })
                ]));
            }
            if (io.trackable) {
                //sprite.addEventListener("touchmove", this.handleTouchMove, false, this);
            }
        }
        else {
            var disposer = io.eventDisposers.getKey("hoverable");
            if (disposer != null) {
                disposer.dispose();
                io.eventDisposers.removeKey("hoverable");
            }
        }
        // Add or remove touch events
        this.processTouchable(io);
    };
    /**
     * Sets up [[InteractionObject]] as movable. Movable can be any
     * transformation, e.g. drag, swipe, resize, track.
     *
     * @ignore Exclude from docs
     * @param io  Element
     */
    Interaction.prototype.processMovable = function (io) {
        // Add unified events
        if (io.draggable || io.swipeable || io.trackable || io.resizable) {
            // Prep the element
            if (!this.isGlobalElement(io) && !io.isTouchProtected) {
                this.prepElement(io);
            }
            // Add hover styles
            this.applyCursorOverStyle(io);
        }
        // Add or remove touch events
        this.processTouchable(io);
    };
    /**
     * Checks if [[InteractionObject]] is trackable and sets relative events.
     *
     * @ignore Exclude from docs
     * @param io  Element
     */
    Interaction.prototype.processTrackable = function (io) {
        this.processHoverable(io);
        this.processMovable(io);
        if (io.trackable) {
            this.trackedObjects.moveValue(io);
        }
        else {
            this.trackedObjects.removeValue(io);
        }
    };
    /**
     * Checks if [[InteractionObject]] is draggable.
     *
     * @ignore Exclude from docs
     * @param io  Element
     */
    Interaction.prototype.processDraggable = function (io) {
        this.processMovable(io);
    };
    /**
     * Checks if [[InteractionObject]] is swipeable and sets relative events.
     *
     * A swipe event is triggered when a horizontal drag of 75px or more (and
     * less than 30px vertically) occurs within 700 milliseconds. This can be
     * overridden in sprites [[swipeOptions]].
     *
     * @ignore Exclude from docs
     * @param io  Element
     */
    Interaction.prototype.processSwipeable = function (io) {
        this.processMovable(io);
    };
    /**
     * Checks if [[InteractionObject]] is resizable and attaches required events
     * to it.
     *
     * @ignore Exclude from docs
     * @param io  Element
     */
    Interaction.prototype.processResizable = function (io) {
        this.processMovable(io);
    };
    /**
     * Checks if [[InteractionObject]] is supposed to capture mouse wheel events
     * and prepares it to catch those events.
     *
     * @ignore Exclude from docs
     * @param io  Element
     */
    Interaction.prototype.processWheelable = function (io) {
        var _this = this;
        if (io.wheelable) {
            //io.hoverable = true;
            if (!io.eventDisposers.hasKey("wheelable")) {
                io.eventDisposers.setKey("wheelable", new Disposer_MultiDisposer([
                    addEventListener(io.element, this._pointerEvents.wheel, function (e) { return _this.handleMouseWheel(io, e); }, this._passiveSupported ? { passive: false } : false),
                    io.events.on("out", function (e) {
                        if (io.wheelable) {
                            _this.unlockWheel();
                        }
                    }),
                    io.events.on("over", function (e) {
                        if (io.wheelable) {
                            _this.lockWheel();
                        }
                    })
                ]));
            }
        }
        else {
            var disposer = io.eventDisposers.getKey("wheelable");
            if (disposer != null) {
                disposer.dispose();
                io.eventDisposers.removeKey("wheelable");
            }
        }
    };
    /**
     * Checks if [[InteractionObject]] is focusable. A focusable element is an
     * element that will be highlighted when users presses TAB key. If the
     * element is focusable, this function will attach relative focus/blur
     * events to it.
     *
     * @ignore Exclude from docs
     * @param io  Element
     */
    Interaction.prototype.processFocusable = function (io) {
        var _this = this;
        if (io.focusable === true && (io.tabindex > -1) && !this._useTouchEventsOnly) {
            if (!io.eventDisposers.hasKey("focusable")) {
                io.eventDisposers.setKey("focusable", new Disposer_MultiDisposer([
                    addEventListener(io.element, "focus", function (e) { return _this.handleFocus(io, e); }),
                    addEventListener(io.element, "blur", function (e) { return _this.handleBlur(io, e); }),
                    addEventListener(io.element, this._pointerEvents.pointerdown, function (e) { return _this.handleFocusBlur(io, e); }),
                    addEventListener(io.element, "touchstart", function (e) { return _this.handleFocusBlur(io, e); }, this._passiveSupported ? { passive: false } : false)
                ]));
            }
        }
        else {
            var disposer = io.eventDisposers.getKey("focusable");
            if (disposer != null) {
                disposer.dispose();
                io.eventDisposers.removeKey("focusable");
            }
        }
    };
    /**
     * Checks if [[InteractionObject]] is "touchable". It means any interaction
     * whatsoever: mouse click, touch screen tap, swipe, drag, resize, etc.
     *
     * @ignore Exclude from docs
     * @param io  Element
     */
    Interaction.prototype.processTouchable = function (io) {
        var _this = this;
        // Add unified events
        if (io.clickable || io.hoverable || io.trackable || io.draggable || io.swipeable || io.resizable) {
            // Add global events
            this.addGlobalEvents();
            // Add local events
            if (!io.eventDisposers.hasKey("touchable")) {
                if (!this._useTouchEventsOnly && !this._usePointerEventsOnly) {
                    io.eventDisposers.setKey("touchable", new Disposer_MultiDisposer([
                        addEventListener(io.element, this._pointerEvents.pointerdown, function (e) { return _this.handlePointerDown(io, e); }),
                        addEventListener(io.element, "touchstart", function (e) { return _this.handleTouchDown(io, e); }, this._passiveSupported ? { passive: false } : false)
                    ]));
                }
                else if (!this._useTouchEventsOnly) {
                    io.eventDisposers.setKey("touchable", addEventListener(io.element, this._pointerEvents.pointerdown, function (e) { return _this.handlePointerDown(io, e); }));
                }
                else if (!this._usePointerEventsOnly) {
                    io.eventDisposers.setKey("touchable", addEventListener(io.element, "touchstart", function (e) { return _this.handleTouchDown(io, e); }, this._passiveSupported ? { passive: false } : false));
                }
            }
        }
        else {
            var disposer = io.eventDisposers.getKey("touchable");
            if (disposer != null) {
                disposer.dispose();
                io.eventDisposers.removeKey("touchable");
            }
        }
    };
    /**
     * ==========================================================================
     * Non-pointer events
     * ==========================================================================
     * @hidden
     */
    /**
     * Dispatches "focus" event when element gains focus.
     *
     * @ignore Exclude from docs
     * @param io  Element
     * @param ev  Original event
     */
    Interaction.prototype.handleFocus = function (io, ev) {
        if (!io.focusable) {
            ev.preventDefault();
            return;
        }
        io.isFocused = true;
        if (io.events.isEnabled("focus") && !system.isPaused) {
            var imev = {
                type: "focus",
                target: io,
                event: ev
            };
            io.events.dispatchImmediately("focus", imev);
        }
    };
    /**
     * Used by regular click events to prevent focus if "noFocus" is set.
     *
     * This should not be called by "focus" handlers.
     *
     * @param io  Element
     * @param ev  Original event
     */
    Interaction.prototype.handleFocusBlur = function (io, ev) {
        if (io.focusable !== false && this.getHitOption(io, "noFocus")) {
            io.events.once("focus", function () {
                io.events.disableType("blur");
                DOM_blur();
                if (io.sprite) {
                    io.sprite.handleBlur();
                }
                io.events.enableType("blur");
            });
        }
    };
    /**
     * Dispatches "blur" event when element loses focus.
     *
     * @ignore Exclude from docs
     * @param io  Element
     * @param ev  Original event
     */
    Interaction.prototype.handleBlur = function (io, ev) {
        if (!io.focusable) {
            ev.preventDefault();
            return;
        }
        io.isFocused = false;
        if (io.events.isEnabled("blur") && !system.isPaused) {
            var imev = {
                type: "blur",
                target: io,
                event: ev
            };
            io.events.dispatchImmediately("blur", imev);
        }
    };
    /**
     * ==========================================================================
     * Global keyboard-related even handlers
     * ==========================================================================
     * @hidden
     */
    /**
     * Checks if there is an item that has currently focus and that they key is
     * one of the directional keys. If both of the conditions are true, it
     * creates an object to simulate movement of dragable element with keyboard.
     *
     * @ignore Exclude from docs
     * @param ev An original keyboard event
     */
    Interaction.prototype.handleGlobalKeyDown = function (ev) {
        if (this.focusedObject) {
            if (keyboard.isKey(ev, "esc")) {
                // ESC removes focus
                DOM_blur();
            }
            else if (this.focusedObject.draggable && keyboard.isKey(ev, ["up", "down", "left", "right"])) {
                // Prevent scrolling of the document
                ev.preventDefault();
                // Get focused object
                var io = this.focusedObject;
                // Get particular key
                var disposerKey = "interactionKeyboardObject";
                // If such disposer already exists we know the event is going on so we
                // just move on
                if (io.eventDisposers.hasKey(disposerKey)) {
                    return;
                }
                // Create a keyboard mover
                var ko = new InteractionKeyboardObject_InteractionKeyboardObject(io, ev);
                io.eventDisposers.setKey(disposerKey, ko);
                switch (keyboard.getEventKey(ev)) {
                    case "up":
                        ko.directionY = -1;
                        break;
                    case "down":
                        ko.directionY = 1;
                        break;
                    case "left":
                        ko.directionX = -1;
                        break;
                    case "right":
                        ko.directionX = 1;
                        break;
                }
            }
        }
    };
    /**
     * Dispatches related events when the keyboard key is realeasd.
     *
     * @ignore Exclude from docs
     * @param ev An original keyboard event
     */
    Interaction.prototype.handleGlobalKeyUp = function (ev) {
        var disposerKey = "interactionKeyboardObject";
        if (this.focusedObject) {
            var disposer = this.focusedObject.eventDisposers.getKey(disposerKey);
            if (disposer != null) {
                // Prevent scrolling of the document
                ev.preventDefault();
                // Dispose stuff
                disposer.dispose();
                this.focusedObject.eventDisposers.removeKey(disposerKey);
            }
        }
    };
    /**
     * ==========================================================================
     * Global pointer-related even handlers
     * ==========================================================================
     * @hidden
     */
    /**
     * Handler for a global "pointermove" event.
     *
     * @ignore Exclude from docs
     * @param ev Event object
     */
    Interaction.prototype.handleGlobalPointerMove = function (ev) {
        // Get pointer
        var pointer = this.getPointer(ev);
        // Update current point position
        pointer.point = this.getPointerPoint(ev);
        // Prepare and fire global event
        if (this.events.isEnabled("track") && !system.isPaused) {
            var imev = {
                type: "track",
                target: this,
                event: ev,
                pointer: pointer,
                touch: pointer.touch
            };
            this.events.dispatchImmediately("track", imev);
        }
        // Track
        this.addBreadCrumb(pointer, pointer.point);
        // Process further
        this.handleGlobalMove(pointer, ev);
    };
    /**
     * Handler for a global "pointerdown" event.
     *
     * @ignore Exclude from docs
     * @param ev Event object
     */
    Interaction.prototype.handleGlobalPointerDown = function (ev) {
        // Remove delayed hovers
        this.processDelayed();
        // Get pointer
        var pointer = this.getPointer(ev);
        // Prepare and fire global event
        if (this.events.isEnabled("down") && !system.isPaused) {
            var imev = {
                type: "down",
                target: this,
                event: ev,
                pointer: pointer,
                touch: pointer.touch
            };
            this.events.dispatchImmediately("down", imev);
        }
    };
    /**
     * Prevents touch action from firing.
     *
     * @ignore Exclude from docs
     * @param ev Event
     */
    Interaction.prototype.preventTouchAction = function (ev) {
        if (!ev.defaultPrevented) {
            ev.preventDefault();
        }
    };
    /**
     * Handler for a global "pointerup" event.
     *
     * @ignore Exclude from docs
     * @param ev Event object
     */
    Interaction.prototype.handleGlobalPointerUp = function (ev, cancelled) {
        if (cancelled === void 0) { cancelled = false; }
        // Get pointer
        var pointer = this.getPointer(ev);
        // Prepare and fire global event
        if (this.events.isEnabled("up") && !system.isPaused) {
            var imev = {
                type: "up",
                target: this,
                event: ev,
                pointer: pointer,
                touch: pointer.touch
            };
            this.events.dispatchImmediately("up", imev);
        }
        // Process further
        this.handleGlobalUp(pointer, ev, cancelled);
    };
    /**
 * ==========================================================================
 * Global touch-related even handlers
 * ==========================================================================
 */
    /**
     * Handler for a global "touchmove" event.
     *
     * @ignore Exclude from docs
     * @param ev Event object
     */
    Interaction.prototype.handleGlobalTouchMove = function (ev) {
        // Process each changed touch point
        for (var i = 0; i < ev.changedTouches.length; i++) {
            // Get pointer
            var pointer = this.getPointer(ev.changedTouches[i]);
            // Update current point position
            pointer.point = this.getPointerPoint(ev.changedTouches[i]);
            // Prepare and fire global event
            if (this.events.isEnabled("track") && !system.isPaused) {
                var imev = {
                    type: "track",
                    target: this,
                    event: ev,
                    pointer: pointer,
                    touch: pointer.touch
                };
                this.events.dispatchImmediately("track", imev);
            }
            // Track
            this.addBreadCrumb(pointer, pointer.point);
            // Process further
            this.handleGlobalMove(pointer, ev);
        }
    };
    /**
     * Handler for a global "touchstart" event.
     *
     * @ignore Exclude from docs
     * @param ev Event object
     */
    Interaction.prototype.handleGlobalTouchStart = function (ev) {
        // Remove delayed hovers
        this.processDelayed();
        // Process each changed touch point
        for (var i = 0; i < ev.changedTouches.length; i++) {
            // Get pointer
            var pointer = this.getPointer(ev.changedTouches[i]);
            // Prepare and fire global event
            if (!this._usePointerEventsOnly && this.events.isEnabled("down") && !system.isPaused) {
                var imev = {
                    type: "down",
                    target: this,
                    event: ev,
                    pointer: pointer,
                    touch: pointer.touch
                };
                this.events.dispatchImmediately("down", imev);
            }
        }
    };
    /**
     * Handler for a global "touchend" event.
     *
     * @ignore Exclude from docs
     * @param ev Event object
     */
    Interaction.prototype.handleGlobalTouchEnd = function (ev) {
        // Process each changed touch point
        for (var i = 0; i < ev.changedTouches.length; i++) {
            // Get pointer
            var pointer = this.getPointer(ev.changedTouches[i]);
            // Prepare and fire global event
            if (this.events.isEnabled("up") && !system.isPaused) {
                var imev = {
                    type: "up",
                    target: this,
                    event: ev,
                    pointer: pointer,
                    touch: pointer.touch
                };
                this.events.dispatchImmediately("up", imev);
            }
            // Handle element-related events
            this.handleGlobalUp(pointer, ev);
        }
    };
    /**
     * ==========================================================================
     * Element-specific pointer-related even handlers
     * ==========================================================================
     * @hidden
     */
    /**
     * Handles event when pointer is over [[InteractionObject]] and button is
     * pressed.
     *
     * @ignore Exclude from docs
     * @param io  Element
     * @param ev  Original event
     */
    Interaction.prototype.handlePointerDown = function (io, ev) {
        // Stop further propagation so we don't get multiple triggers on hybrid
        // devices (both mouse and touch capabilities)
        //ev.preventDefault();
        //ev.stopPropagation();
        //if (ev.defaultPrevented) {
        //}
        // Get pointer
        var pointer = this.getPointer(ev);
        // Ignore if it's anything but mouse's primary button
        if (!pointer.touch && ev.which != 1 && ev.which != 3) {
            return;
        }
        // Set mouse button
        pointer.button = ev.which;
        // Reset pointer
        this.resetPointer(pointer, ev);
        // Process down
        this.handleDown(io, pointer, ev);
    };
    /**
     * Handles event when [[InteractionObject]] is hovered by a mouse pointer.
     *
     * @ignore Exclude from docs
     * @param io  Element
     * @param ev  Original event
     */
    Interaction.prototype.handlePointerOver = function (io, ev) {
        // Get pointer
        var pointer = this.getPointer(ev);
        // Process down
        this.handleOver(io, pointer, ev);
    };
    /**
     * Handles event when [[InteractionObject]] loses hover from a mouse pointer.
     *
     * @ignore Exclude from docs
     * @param io  Element
     * @param ev  Original event
     */
    Interaction.prototype.handlePointerOut = function (io, ev) {
        // Get pointer
        var pointer = this.getPointer(ev);
        // Process down
        this.handleOut(io, pointer, ev);
    };
    /**
     * Handles event when mouse wheel is crolled over the [[InteractionObject]].
     *
     * @ignore Exclude from docs
     * @param io  Element
     * @param ev  Original event
     * @todo Investigate more-cross browser stuff https://developer.mozilla.org/en-US/docs/Web/Events/wheel
     */
    Interaction.prototype.handleMouseWheel = function (io, ev) {
        // Get pointer
        var pointer = this.getPointer(ev);
        // Update current point position
        pointer.point = this.getPointerPoint(ev);
        // Init delta values
        var deltaX = 0, deltaY = 0;
        // Set up modifier
        // This is needed because FireFox reports wheel deltas in "lines" instead
        // of pixels so we have to approximate pixel value
        var mod = 1;
        if (ev.deltaMode == 1) {
            mod = 50;
        }
        // Adjust configurable sensitivity
        mod *= this.getMouseOption(io, "sensitivity");
        // Calculate deltas
        if (ev instanceof WheelEvent) {
            deltaX = Math.round((-1 * ev.wheelDeltaX) || ev.deltaX) * mod;
            deltaY = Math.round((-1 * ev.wheelDeltaY) || ev.deltaY) * mod;
        }
        else {
            throw new Error("Invalid event type");
        }
        // Handle the event
        this.handleWheel(io, pointer, deltaX, deltaY, ev);
    };
    /**
     * ==========================================================================
     * Element-specific touch-related even handlers
     * ==========================================================================
     * @hidden
     */
    /**
      * Handles an event when an [[InteractionObject]] is touched on a touch
      * device.
      *
      * @ignore Exclude from docs
      * @param io  Element
      * @param ev  Original event
      */
    Interaction.prototype.handleTouchDown = function (io, ev) {
        // Stop further propagation so we don't get multiple triggers on hybrid
        // devices (both mouse and touch capabilities)
        //this.maybePreventDefault(io, ev);
        //return;
        // Process each changed touch point
        for (var i = 0; i < ev.changedTouches.length; i++) {
            // Get pointer
            var pointer = this.getPointer(ev.changedTouches[i]);
            this.maybePreventDefault(io, ev, pointer);
            // Reset pointer
            this.resetPointer(pointer, ev.changedTouches[i]);
            // Process down
            this.handleDown(io, pointer, ev);
        }
    };
    /**
     * ==========================================================================
     * Universal handlers
     * ==========================================================================
     * @hidden
     */
    /**
     * Handles click/tap. Checks for doublehit.
     *
     * @ignore Exclude from docs
     * @param io       Interaction object
     * @param pointer  Pointer
     * @param ev       Original event
     */
    Interaction.prototype.handleHit = function (io, pointer, ev) {
        // Check if this is a double-hit
        var now = getTime();
        if (io.lastHit && (io.lastHit >= (now - this.getHitOption(io, "doubleHitTime")))) {
            // Yup - it's a double-hit
            // Cancel the hit
            //clearTimeout(io.lastHitPointer.hitTimeout);
            // If it happened too fast it probably means that hybrid device just
            // generated two events for the same tap
            if ((now - io.lastHit) < 100) {
                // Ignore
                return;
            }
            // Clear last hit
            io.lastHit = undefined;
            io.lastHitPointer = undefined;
            // Dispatch event
            if (io.events.isEnabled("doublehit") && !system.isPaused) {
                var imev = {
                    type: "doublehit",
                    target: io,
                    point: pointer.point,
                    event: ev,
                    touch: pointer.touch
                };
                io.events.dispatchImmediately("doublehit", imev);
            }
        }
        else {
            // Log last hit
            io.lastHit = now;
            io.lastHitPointer = pointer;
            if (pointer.button === 3) {
                // Execute HIT now
                if (io.events.isEnabled("rightclick") && !system.isPaused) {
                    var imev = {
                        type: "rightclick",
                        target: io,
                        event: ev
                    };
                    io.events.dispatchImmediately("rightclick", imev);
                }
            }
            else {
                if (io.events.isEnabled("hit") && !system.isPaused) {
                    var imev = {
                        type: "hit",
                        target: io,
                        event: ev,
                        point: pointer.point,
                        touch: pointer.touch
                    };
                    io.events.dispatchImmediately("hit", imev);
                }
            }
        }
    };
    /**
     * Handles pointer hovering over [[InteractionObject]].
     *
     * @ignore Exclude from docs
     * @param io       Interaction object
     * @param pointer  Pointer
     * @param ev       Original event
     * @param soft     Invoked by helper function
     */
    Interaction.prototype.handleOver = function (io, pointer, ev, soft) {
        if (soft === void 0) { soft = false; }
        if (!io.hoverable) {
            return;
        }
        // Remove any delayed outs
        this.processDelayed();
        // Add pointer
        io.overPointers.moveValue(pointer);
        // Check if object is not yet hovered
        if (!io.isRealHover) {
            // Set element as hovered
            io.isHover = true;
            io.isRealHover = true;
            this.overObjects.moveValue(io);
            // Generate body track event. This is needed so that if element loads
            // under unmoved mouse cursor, we still need all the actions that are
            // required to happen to kick in.
            this.handleTrack(this.body, pointer, ev, true);
            // Event
            if (io.events.isEnabled("over") && !system.isPaused) {
                var imev = {
                    type: "over",
                    target: io,
                    event: ev,
                    pointer: pointer,
                    touch: pointer.touch
                };
                io.events.dispatchImmediately("over", imev);
            }
        }
    };
    /**
     * Handles when [[InteractionObject]] is no longer hovered.
     *
     * If `soft = true`, this means that method is being invoked by some other
     * code, not hard "out" function, like `handleUp` which implies we need to
     * run additional checks before unhovering the object.
     *
     * @ignore Exclude from docs
     * @param io       Interaction object
     * @param pointer  Pointer
     * @param ev       Original event
     * @param soft     Invoked by helper function
     * @param force    Force imediate out
     */
    Interaction.prototype.handleOut = function (io, pointer, ev, soft, force) {
        var _this = this;
        if (soft === void 0) { soft = false; }
        if (force === void 0) { force = false; }
        if (!io.hoverable) {
            return;
        }
        // Remove pointer
        io.overPointers.removeValue(pointer);
        // Check if element is still hovered
        if (io.isHover && (!io.hasDelayedOut || force)) {
            // Should we run additional checks?
            if (soft && io.overPointers.length) {
                // There are still pointers hovering - don't do anything else and
                // wait until either no over pointers are there or we get a hard out
                // event.
                return;
            }
            // Should we delay "out" if this is happening on a touch device?
            if (pointer.touch && !force && !this.old(pointer)) {
                // This is a touch pointer, and it hasn't moved, let's pretend
                // the object is still hovered, and act as per "behavior" setting
                var behavior = this.getHoverOption(io, "touchOutBehavior");
                if (behavior == "leave") {
                    // Set to "leave", so we do not execute any "out" event.
                    // It will be handled by any other interaction that happens
                    // afterwards.
                    this._delayedEvents.out.push({
                        type: "out",
                        io: io,
                        pointer: pointer,
                        event: ev,
                        keepUntil: getTime() + 500
                    });
                    io.hasDelayedOut = true;
                    return;
                }
                else if (behavior == "delay" && this.getHoverOption(io, "touchOutDelay")) {
                    this._delayedEvents.out.push({
                        type: "out",
                        io: io,
                        pointer: pointer,
                        event: ev,
                        keepUntil: getTime() + 500,
                        timeout: this.setTimeout(function () {
                            _this.handleOut(io, pointer, ev, true);
                        }, this.getHoverOption(io, "touchOutDelay"))
                    });
                    return;
                }
                else {
                    // Nothing for "remove" - that's how it works "out-of-the-box"
                }
            }
            // Set element as not hovered
            io.isHover = false;
            this.overObjects.removeValue(io);
            // Invoke event
            if (io.events.isEnabled("out") && !system.isPaused) {
                var imev = {
                    type: "out",
                    target: io,
                    event: ev,
                    pointer: pointer,
                    touch: pointer.touch
                };
                io.events.dispatchImmediately("out", imev);
            }
            // Reset object from lefover delayed outs, pointers
            io.overPointers.clear();
            io.hasDelayedOut = false;
            // @todo (clean delayed)
        }
    };
    /**
     * Processes dalyed events, such as "out" event that was initiated for
     * elements by touch.
     */
    Interaction.prototype.processDelayed = function () {
        var delayedEvent;
        while (true) {
            delayedEvent = this._delayedEvents.out.pop();
            if (!delayedEvent) {
                break;
            }
            if (delayedEvent.timeout) {
                delayedEvent.timeout.dispose();
            }
            this.handleOut(delayedEvent.io, delayedEvent.pointer, delayedEvent.event, false, true);
        }
    };
    /**
     * Performs tasks on pointer down.
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     * @param ev       Original event
     */
    Interaction.prototype.handleDown = function (io, pointer, ev) {
        // Need to prevent default event from happening on transformable objects
        this.maybePreventDefault(io, ev, pointer);
        // Stop inertia animations if they're currently being played out
        if (io.inert) {
            this.stopInertia(io);
        }
        // Trigger hover because some touch devices won't trigger over events
        // on their own
        this.handleOver(io, pointer, ev, true);
        // Add pointer to list
        io.downPointers.moveValue(pointer);
        // Apply styles if necessary
        this.applyCursorDownStyle(io, pointer);
        // Check if object is already down
        if (!io.isDown) {
            // Lose focus if needed
            if (io.focusable !== false && this.getHitOption(io, "noFocus") && this.focusedObject) {
                DOM_blur();
            }
            // Set object as hovered
            io.isDown = true;
            this.downObjects.moveValue(io);
            // Prep object for dragging and/or resizing
            if (io.draggable) {
                this.processDragStart(io, pointer, ev);
            }
            if (io.resizable) {
                this.processResizeStart(io, pointer, ev);
            }
        }
        // Dispatch "down" event
        if (io.events.isEnabled("down") && !system.isPaused) {
            var imev = {
                type: "down",
                target: io,
                event: ev,
                pointer: pointer,
                touch: pointer.touch
            };
            io.events.dispatchImmediately("down", imev);
        }
    };
    /**
     * Performs tasks on pointer up.
     *
     * @ignore Exclude from docs
     * @param pointer  Pointer
     * @param ev       Original event
     */
    Interaction.prototype.handleGlobalUp = function (pointer, ev, cancelled) {
        var _this = this;
        if (cancelled === void 0) { cancelled = false; }
        var sorted = this.downObjects.values.slice();
        sorted.sort(function (x, y) {
            if (x && y) {
                var pos = x.element.compareDocumentPosition(y.element);
                if (pos & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                    return 1;
                }
                else if (pos & Node.DOCUMENT_POSITION_CONTAINS) {
                    return -1;
                }
                else {
                    return 0;
                }
            }
            else {
                return 0;
            }
        });
        // Process all down objects
        each(sorted, function (io) {
            // Check if this particular pointer is pressing down
            // on object
            if (io && io.downPointers.contains(pointer)) {
                _this.handleUp(io, pointer, ev, cancelled);
            }
        });
    };
    /**
     * Simulates all pointers being up once mouse leaves document area.
     *
     * @ignore Exclude from docs
     * @param ev       Original event
     */
    Interaction.prototype.handleDocumentLeave = function (ev) {
        var _this = this;
        // Process all down objects
        Iterator_each(this.downObjects.backwards().iterator(), function (io) {
            io.downPointers.each(function (pointer) {
                _this.handleUp(io, pointer, ev);
            });
        });
    };
    /**
     * Handles when [[InteractionObject]] is no longer hovered.
     *
     * @ignore Exclude from docs
     * @param io       Interaction object
     * @param pointer  Pointer
     * @param ev       Original event
     */
    Interaction.prototype.handleUp = function (io, pointer, ev, cancelled) {
        if (cancelled === void 0) { cancelled = false; }
        // Restore cursor style
        this.restoreCursorDownStyle(io, pointer);
        // Remove pointer from the list
        io.downPointers.removeValue(pointer);
        // Trigger out because some touch devices won't trigger out events
        // on their own
        if (pointer.touch || this._useTouchEventsOnly) {
            this.handleOut(io, pointer, ev, true);
        }
        // Check if object still down
        if (io.isDown) {
            // Check if there are no other pointers hovering this element
            if (io.downPointers.length == 0) {
                // Set element as no longer down
                io.isDown = false;
                this.downObjects.removeValue(io);
            }
            // Dispatch "up" event
            if (io.events.isEnabled("up") && !system.isPaused) {
                var imev = {
                    type: "up",
                    target: io,
                    event: ev,
                    pointer: pointer,
                    touch: pointer.touch
                };
                io.events.dispatchImmediately("up", imev);
            }
            // Check if this was not a cancelled event.
            // If event was canelled (which might happen if gesture resulted in
            // navigation or page scroll) there's no point in triggering hit and
            // other actions.
            if (!cancelled) {
                // Handle swiping-related stuff
                if (io.swipeable && this.swiped(io, pointer)) {
                    // Swiped - nothing else should happen
                    this.handleSwipe(io, pointer, ev);
                }
                else {
                    // Check if it maybe a click
                    if (io.clickable && !this.moved(pointer, this.getHitOption(io, "hitTolerance"))) {
                        this.handleHit(io, pointer, ev);
                    }
                    // Handle inertia
                    if (io.inert && this.moved(pointer, this.getHitOption(io, "hitTolerance"))) {
                        this.handleInertia(io, pointer);
                    }
                    else if (io.draggable) {
                        this.processDragStop(io, pointer, ev);
                    }
                    if (io.resizable) {
                        this.processResizeStop(io, pointer, ev);
                    }
                }
            }
        }
    };
    /**
     * Checks if event needs to be prevented on draggable and such items, so that
     * touch gestures like navigation and scroll do not kick in.
     *
     * @param io  Object
     * @param ev  Event
     */
    Interaction.prototype.maybePreventDefault = function (io, ev, pointer) {
        if (hasValue(ev)
            && (io.draggable || io.swipeable || io.trackable || io.resizable)
            && !this.isGlobalElement(io)
            && ev.cancelable !== false
            && (!io.isTouchProtected || !pointer || !pointer.touch)) {
            ev.preventDefault();
        }
    };
    /**
     * Handles pointer move.
     *
     * @ignore Exclude from docs
     * @param pointer  Pointer
     * @param ev       Original event
     */
    Interaction.prototype.handleGlobalMove = function (pointer, ev) {
        var _this = this;
        // Process hovered elements
        // We check if the element became unhovered without reporting the mouseout
        // event. (it happens in some cases)
        if (!pointer.touch) {
            var target_1 = eventTarget(pointer.lastEvent);
            Iterator_each(this.overObjects.backwards().iterator(), function (io) {
                // Is this pointer relevant to element?
                if (io && io.overPointers.contains(pointer) && io.hoverable) {
                    // Check if the element is still hovered
                    var reset = false;
                    if (io.element && pointer.lastEvent) {
                        if (!DOM_contains(io.element, target_1)) {
                            reset = true;
                        }
                    }
                    else {
                        reset = true;
                    }
                    if (reset) {
                        _this.handleOut(io, pointer, ev, true);
                    }
                }
            });
        }
        // Process down elements
        Iterator_each(this.transformedObjects.backwards().iterator(), function (io) {
            // Is this pointer relevant to element?
            if (io.downPointers.contains(pointer) &&
                // Swipe still happening?
                !(io.swipeable && _this.swiping(io, pointer)) &&
                (io.draggable || io.resizable)) {
                _this.handleTransform(io, ev);
            }
        });
        // Process tracked elements
        Iterator_each(this.trackedObjects.backwards().iterator(), function (io) {
            // Is this pointer relevant to element?
            if (!io.overPointers.contains(pointer)) {
                _this.handleTrack(io, pointer, ev);
            }
        });
    };
    /**
     * Handles reporting of pointer movement.
     *
     * @ignore Exclude from docs
     * @param io        Element
     * @param pointer    Pointer
     * @param ev         Original event
     * @param skipCheck  Sould we skip check if cursor actually moved
     */
    Interaction.prototype.handleTrack = function (io, pointer, ev, skipCheck) {
        if (skipCheck === void 0) { skipCheck = false; }
        // Do nothing if the cursor did not actually move
        if (!skipCheck && !this.moved(pointer, 0)) {
            return;
        }
        // Initiate TRACK event
        if (io.events.isEnabled("track") && !system.isPaused) {
            var imev = {
                type: "track",
                target: io,
                event: ev,
                point: pointer.point,
                pointer: pointer,
                touch: pointer.touch
            };
            io.events.dispatchImmediately("track", imev);
        }
    };
    /**
     * Handles swipe action.
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     * @param ev       Original event
     */
    Interaction.prototype.handleSwipe = function (io, pointer, ev) {
        // We pass in InteractionEvent with shift in mouse coordinates
        // between when the drag started and ended
        if (io.events.isEnabled("swipe") && !system.isPaused) {
            var imev = {
                type: "swipe",
                target: io,
                event: ev,
                touch: pointer.touch
            };
            io.events.dispatchImmediately("swipe", imev);
        }
        if (pointer.startPoint.x < pointer.point.x) {
            if (io.events.isEnabled("swiperight") && !system.isPaused) {
                var imev = {
                    type: "swiperight",
                    target: io,
                    event: ev,
                    touch: pointer.touch
                };
                io.events.dispatchImmediately("swiperight", imev);
            }
        }
        else {
            if (io.events.isEnabled("swipeleft") && !system.isPaused) {
                var imev = {
                    type: "swipeleft",
                    target: io,
                    event: ev,
                    touch: pointer.touch
                };
                io.events.dispatchImmediately("swipeleft", imev);
            }
        }
    };
    /**
     * Handles event triggering for wheel rotation.
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     * @param deltaX   Horizontal shift
     * @param deltaY   Vertical shift
     * @param ev       Original event
     */
    Interaction.prototype.handleWheel = function (io, pointer, deltaX, deltaY, ev) {
        var shift = {
            x: deltaX,
            y: deltaY
        };
        // Trigger generic WHEEL event
        if (io.events.isEnabled("wheel") && !system.isPaused) {
            io.events.dispatchImmediately("wheel", {
                type: "wheel",
                target: io,
                event: ev,
                point: pointer.point,
                shift: shift
            });
        }
        // Trigger direction-specific events
        // Horizontal
        if (deltaX < 0) {
            if (io.events.isEnabled("wheelleft") && !system.isPaused) {
                io.events.dispatchImmediately("wheelleft", {
                    type: "wheelleft",
                    target: io,
                    event: ev,
                    point: pointer.point,
                    shift: shift
                });
            }
        }
        else if (deltaX > 0) {
            if (io.events.isEnabled("swiperight") && !system.isPaused) {
                io.events.dispatchImmediately("wheelright", {
                    type: "wheelright",
                    target: io,
                    event: ev,
                    point: pointer.point,
                    shift: shift
                });
            }
            // Vertical
        }
        else if (deltaY < 0) {
            if (io.events.isEnabled("wheelup") && !system.isPaused) {
                io.events.dispatchImmediately("wheelup", {
                    type: "wheelup",
                    target: io,
                    event: ev,
                    point: pointer.point,
                    shift: shift
                });
            }
        }
        else if (deltaY > 0) {
            if (io.events.isEnabled("wheeldown") && !system.isPaused) {
                io.events.dispatchImmediately("wheeldown", {
                    type: "wheeldown",
                    target: io,
                    event: ev,
                    point: pointer.point,
                    shift: shift
                });
            }
        }
    };
    /**
     * Initiates inertia checking sub-routines for different movement types:
     * drag, resize.
     *
     * @ignore Exclude from docs
     * @param sprite
     * @param pointer
     */
    Interaction.prototype.handleInertia = function (io, pointer) {
        if (io.draggable && io.downPointers.length === 0) {
            this.handleMoveInertia(io, pointer);
        }
        if (io.resizable && io.downPointers.length > 1) {
            this.handleResizeInertia(io, pointer);
        }
    };
    /**
     * Continues moving the element to simulate the effect of inertia. Happens
     * when `inert` and `draggable` object is dragged and then released.
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     */
    Interaction.prototype.handleMoveInertia = function (io, pointer) {
        var interaction = io;
        var type = "move";
        var point = {
            "x": pointer.point.x,
            "y": pointer.point.y
        };
        var startPoint = {
            "x": pointer.startPoint.x,
            "y": pointer.startPoint.y
        };
        // Init inertia object
        var inertia = new Inertia_Inertia(interaction, type, point, startPoint);
        // Get inertia data
        var ref = this.getTrailPoint(pointer, getTime() - this.getInertiaOption(io, "move", "time"));
        if (typeof ref === "undefined") {
            this.processDragStop(io, pointer, pointer.lastUpEvent);
            return;
        }
        // Init animation options
        var factor = this.getInertiaOption(io, "move", "factor");
        var animationOptions = [{
                "to": pointer.point.x + (pointer.point.x - ref.point.x) * factor,
                "property": "x"
            }, {
                "to": pointer.point.y + (pointer.point.y - ref.point.y) * factor,
                "property": "y"
            }];
        // Start animation
        var animation = new Animation_Animation(inertia, animationOptions, this.getInertiaOption(io, "move", "duration"), this.getInertiaOption(io, "move", "easing")).start();
        this._disposers.push(animation.events.on("animationended", function (ev) {
            inertia.done();
        }));
        // Add inertia object
        io.inertias.setKey("move", inertia);
    };
    /**
     * Continues resizing of a `resizable` element after it is resized and
     * released.
     *
     * **NOTE:** this is is just a placeholder function. No actual fucntionality
     * is implemented, yet.
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     */
    Interaction.prototype.handleResizeInertia = function (io, pointer) {
        // Some day, folks. Some day...
    };
    /**
     * Recalculates element's position and size based on position of
     * all its related pointers.
     *
     * @ignore Exclude from docs
     * @param io  Element
     * @param ev  Original event
     */
    Interaction.prototype.handleTransform = function (io, ev) {
        // Get primary pointer and its respective points
        var pointer1 = io.downPointers.getIndex(0);
        var point1 = null;
        var startPoint1 = null;
        if (pointer1) {
            point1 = pointer1.point;
            startPoint1 = pointer1.startPoint;
        }
        // Init secondary pointer
        var pointer2;
        var point2;
        var startPoint2;
        // Use center of the sprite to simulate "second" point of touch
        point2 = {
            "x": io.originalPosition.x,
            "y": io.originalPosition.y
        };
        startPoint2 = point2;
        // Determine if it's a sinngle pointer or multi
        var singlePoint = true;
        for (var i = 1; i < io.downPointers.length; i++) {
            // Get pointer
            var nextPointer = io.downPointers.getIndex(i);
            // Doublecheck if it's not the same pointer by comparing original position
            if (startPoint1.x != nextPointer.startPoint.x && startPoint1.y != nextPointer.startPoint.y) {
                // Several pointers down
                singlePoint = false;
                // Get second pointer
                pointer2 = nextPointer;
                point2 = pointer2.point;
                startPoint2 = pointer2.startPoint;
                // Stop looking
                break;
            }
        }
        // Primary touch point moved?
        var pointer1Moved = pointer1 && this.moved(pointer1, 0);
        // Report DRAG_START if necessary
        if (io.draggable && pointer1 && pointer1.dragStartEvents && pointer1.dragStartEvents.length && pointer1Moved) {
            if (io.events.isEnabled("dragstart") && !system.isPaused) {
                io.events.dispatchImmediately("dragstart", pointer1.dragStartEvents.shift());
            }
            //delete pointer1.dragStartEvents;
        }
        // Determine what we do in order of superiority
        if (singlePoint && io.draggable) {
            // We have only one pointer and the Sprite is draggable
            // There's nothing else to be done - just move it
            this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);
        }
        else {
            // Check if second touch point moved
            var pointer2Moved = pointer2 && this.moved(pointer2, 0);
            if (io.draggable && io.resizable) {
                //this.handleTransformAll(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved);
                this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved && pointer2Moved, pointer1.touch);
                this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);
            }
            else {
                if (io.draggable) {
                    this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);
                }
                if (io.resizable && (!singlePoint || ev.ctrlKey)) {
                    this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);
                }
            }
        }
    };
    /**
     * Handles movement of the dragged element.
     *
     * @ignore Exclude from docs
     * @param io            Element
     * @param point         Current point of the pointer
     * @param startPoint    Starting point of the pointer
     * @param ev            Original event
     * @param pointerMoved  Did pointer move?
     */
    Interaction.prototype.handleTransformMove = function (io, point, startPoint, ev, pointerMoved, touch) {
        if (pointerMoved) {
            if (io.events.isEnabled("drag") && !system.isPaused && (!io.isTouchProtected || !touch)) {
                var imev = {
                    type: "drag",
                    target: io,
                    event: ev,
                    shift: {
                        "x": point.x - startPoint.x,
                        "y": point.y - startPoint.y
                    },
                    startPoint: startPoint,
                    point: point,
                    touch: touch
                };
                io.events.dispatchImmediately("drag", imev);
            }
        }
    };
    /**
     * Handles resizing of the element.
     *
     * @ignore Exclude from docs
     * @param io            Element
     * @param point1        Current position of reference point #1
     * @param startPoint1   Original position of reference point #1
     * @param point2        Current position of reference point #2
     * @param startPoint2   Original position of reference point #2
     * @param ev            Original event
     * @param pointerMoved  Did pointer move?
     */
    Interaction.prototype.handleTransformResize = function (io, point1, startPoint1, point2, startPoint2, ev, pointerMoved, touch) {
        if (io.events.isEnabled("resize") && !system.isPaused && (!io.isTouchProtected || !touch)) {
            var imev = {
                type: "resize",
                target: io,
                event: ev,
                scale: getScale(point1, startPoint1, point2, startPoint2),
                startPoint1: startPoint1,
                point1: point1,
                startPoint2: startPoint2,
                point2: point2,
                touch: touch
            };
            io.events.dispatchImmediately("resize", imev);
        }
    };
    /**
     * Handles all the preparations of the element when it starts to be dragged.
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     * @param ev       Original event
     */
    Interaction.prototype.processDragStart = function (io, pointer, ev) {
        // Add to draggedObjects
        this.transformedObjects.moveValue(io);
        // Report "dragstart"
        var imev = {
            type: "dragstart",
            target: io,
            event: ev,
            touch: pointer ? pointer.touch : false
        };
        // Log object that we are starting to drag, so we can check against and
        // avoid hovers on other objects that might be in the path of movement.
        if (pointer) {
            pointer.dragTarget = io;
            //pointer.startPoint = pointer.point;
        }
        /**
         * If pointer is set we will not fire the event until the pointer has
         * actually moved. If it's not set we don't have to wait for anything, so we
         * just fire off the event right away.
         */
        if (pointer && pointer.dragStartEvents) {
            pointer.dragStartEvents.push(imev);
        }
        else {
            if (!system.isPaused) {
                io.dispatchImmediately("dragstart", imev);
            }
        }
    };
    /**
     * Finishes up element drag operation.
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     * @param ev       Original event
     */
    Interaction.prototype.processDragStop = function (io, pointer, ev) {
        // Pointer set?
        if (!pointer) {
            pointer = this.getDragPointer(io);
        }
        // Unset drag object
        if (pointer) {
            pointer.dragTarget = undefined;
        }
        // Removed from transformedObjects
        this.transformedObjects.removeValue(io);
        // Unlock document
        //this.unlockDocument();
        // Report dragstop
        if (!pointer || this.moved(pointer, 0)) {
            if (io.events.isEnabled("dragstop") && !system.isPaused) {
                var imev = {
                    type: "dragstop",
                    target: io,
                    touch: pointer ? pointer.touch : false
                };
                io.events.dispatchImmediately("dragstop", imev);
            }
        }
    };
    /**
     * Handles all the preparations of the element when it starts to be resized.
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     * @param ev       Original event
     */
    Interaction.prototype.processResizeStart = function (io, pointer, ev) {
        // Add to draggedObjects
        this.transformedObjects.moveValue(io);
    };
    /**
     * Finishes up element drag operation.
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     * @param ev       Original event
     */
    Interaction.prototype.processResizeStop = function (io, pointer, ev) {
        // Removed from transformedObjects
        this.transformedObjects.removeValue(io);
    };
    /**
     * ==========================================================================
     * Controls for InteractionObjects initiating directly
     * ==========================================================================
     * @hidden
     */
    /**
     * Manually triggers drag start on the element. Could be useful in cases
     * where tracking or dragging one element can also influence dragging another
     * element.
     *
     * Passing in `pointer` reference is advisable. If not passed in it will try
     * to determine which pointer to attach to. However, it's better to specify
     * it explicitly.
     *
     * @param io       Element
     * @param pointer  Pointer
     */
    Interaction.prototype.dragStart = function (io, pointer) {
        if (!pointer) {
            pointer = this.getDragPointer(io);
        }
        if (pointer) {
            this.handleDown(io, pointer, pointer.lastDownEvent);
        }
    };
    /**
     * Manually ends drag on the element.
     *
     * @param io       Element
     * @param pointer  Pointer
     */
    Interaction.prototype.dragStop = function (io, pointer, cancelled) {
        if (!pointer) {
            pointer = this.getDragPointer(io);
        }
        if (pointer && !cancelled) {
            this.handleGlobalUp(pointer, pointer.lastUpEvent, cancelled);
        }
    };
    /**
     * This method uses a fuzzy logic to find the pointer to be used for dragging.
     * Beware that this is not a rock-solid solution. If there are a few objects
     * being dragged at the same time, you may get unexepected results.
     *
     * @param io  InteractionObject to get pointers from
     * @return Pointer currently being used for dragging
     */
    Interaction.prototype.getDragPointer = function (io) {
        if (io) {
            // InteractionObject is supplied
            // Use it's first down pointer
            return io.downPointers.getIndex(0);
        }
        else if (this.transformedObjects.length) {
            // Use first dragged object
            return this.getDragPointer(this.transformedObjects.getIndex(0));
        }
        else {
            return undefined;
        }
    };
    /**
     * ==========================================================================
     * Utils
     * ==========================================================================
     * @hidden
     */
    /**
     * Returns pointer id for the given event object.
     *
     * @param ev  Event
     * @return Pointer ID
     */
    Interaction.prototype.getPointerId = function (ev) {
        var id = "";
        if (hasValue(ev.identifier)) {
            id = "" + ev.identifier;
        }
        else if (hasValue(ev.pointerId)) {
            id = "" + ev.pointerId;
        }
        else {
            id = "m";
        }
        return id.replace("-", "");
    };
    /**
     * Returns a cursor position of the event.
     *
     * @param ev  Original event
     * @return Event point
     */
    Interaction.prototype.getPointerPoint = function (ev) {
        return {
            "x": ev.clientX,
            "y": ev.clientY
        };
    };
    /**
     * Returns [[Pointer]] object that is associated with the Event.
     *
     * If no such [[Pointer]] object exists, it is created.
     *
     * @param ev  Event
     * @return Pointer
     */
    Interaction.prototype.getPointer = function (ev) {
        // Get pointer id
        var id = this.getPointerId(ev);
        // Get current coordinates
        var point = this.getPointerPoint(ev);
        // Look for the pointer in the Dictionary if it maybe already exists
        var pointer;
        if (this.pointers.hasKey(id)) {
            // We already have such pointer
            pointer = this.pointers.getKey(id);
            // We need this, because Edge reuses pointer ids across touch and mouse
            pointer.touch = this.isPointerTouch(ev);
            // Reset pointer
            //pointer.point = point;
        }
        else {
            // Init pointer
            pointer = {
                "id": id,
                //"touch": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != "pointer"),
                //"touch": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != "mouse"),
                "touch": this.isPointerTouch(ev),
                "startPoint": point,
                "startTime": getTime(),
                "point": point,
                "track": [],
                "swipeCanceled": false,
                "dragStartEvents": []
            };
            // Add first breadcrumb
            this.addBreadCrumb(pointer, point);
            // Add for re-use later
            this.pointers.setKey(id, pointer);
        }
        // Log last event
        pointer.lastEvent = ev;
        this.lastPointer = pointer;
        return pointer;
    };
    /**
     * Determines if pointer event originated from a touch pointer or mouse.
     *
     * @param ev  Original event
     * @return Touch pointer?
     */
    Interaction.prototype.isPointerTouch = function (ev) {
        if (typeof Touch !== "undefined" && ev instanceof Touch) {
            return true;
        }
        else if (typeof PointerEvent !== "undefined" && ev instanceof PointerEvent && hasValue(ev.pointerType)) {
            switch (ev.pointerType) {
                case "touch":
                case "pen":
                case 2:
                    return true;
                case "mouse":
                case 4:
                    return false;
                default:
                    return !(ev instanceof MouseEvent);
            }
        }
        else if (hasValue(ev.type)) {
            if (ev.type.match(/^mouse/)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Resets the poiner to original state, i.e. cleans movement information,
     * starting point, etc.
     *
     * @param pointer Pointer
     */
    Interaction.prototype.resetPointer = function (pointer, ev) {
        // Get current coordinates
        var point = this.getPointerPoint(ev);
        ;
        pointer.startTime = getTime();
        pointer.startPoint = { x: point.x, y: point.y };
        pointer.point = { x: point.x, y: point.y };
        pointer.track = [];
        pointer.swipeCanceled = false;
        //clearTimeout(pointer.swipeTimeout);
        //clearTimeout(pointer.holdTimeout);
    };
    /**
     * Adds a "breadcrumb" point to the [[Pointer]] to log its movement path.
     *
     * @param pointer  Pointer
     * @param point    Point coordinates
     */
    Interaction.prototype.addBreadCrumb = function (pointer, point) {
        pointer.track.push({
            "timestamp": getTime(),
            "point": point
        });
    };
    /**
     * Prepares the document for various touch-related operations.
     *
     * @ignore Exclude from docs
     */
    Interaction.prototype.lockDocument = function () {
        this.prepElement(this.body);
    };
    /**
     * Restores document functionality.
     *
     * @ignore Exclude from docs
     */
    Interaction.prototype.unlockDocument = function () {
        if (this.transformedObjects.length == 0) {
            this.restoreAllStyles(this.body);
        }
    };
    /**
     * Lock element (disable all touch)
     *
     * @ignore Exclude from docs
     */
    Interaction.prototype.lockElement = function (io) {
        this.prepElement(io);
    };
    /**
     * Restores element's functionality.
     *
     * @ignore Exclude from docs
     */
    Interaction.prototype.unlockElement = function (io) {
        this.restoreAllStyles(io);
    };
    /**
     * Locks document's wheel scroll.
     *
     * @ignore Exclude from docs
     */
    Interaction.prototype.lockWheel = function () {
        window.addEventListener(this._pointerEvents.wheel, this.wheelLockEvent, this._passiveSupported ? { passive: false } : false);
    };
    /**
     * Unlocks document's wheel scroll.
     *
     * @ignore Exclude from docs
     */
    Interaction.prototype.unlockWheel = function () {
        window.removeEventListener(this._pointerEvents.wheel, this.wheelLockEvent);
    };
    /**
     * Checks if top element at pointer's position belongs to the SVG.
     *
     * @ignore Exlude from docs
     * @param pointer  Pointer
     * @param svg      The <svg> element
     * @param id       A unique identifier of the object that is checking for locality
     * @return Belongs to SVG
     */
    Interaction.prototype.isLocalElement = function (pointer, svg, id) {
        var cached = this.getCache("local_pointer_" + pointer.id);
        if (hasValue(cached)) {
            return cached;
        }
        var doc = (getRoot(svg) || document);
        if (doc.elementFromPoint) {
            var target = doc.elementFromPoint(pointer.point.x, pointer.point.y);
            var local = target && DOM_contains(svg, target);
            this.setCache("local_pointer_" + pointer.id + "_" + id, local, 100);
            return local;
        }
        return false;
    };
    /**
     * A function that cancels mouse wheel scroll.
     *
     * @ignore Exclude from docs
     * @param ev  Event object
     * @return Returns `false` to cancel
     */
    Interaction.prototype.wheelLockEvent = function (ev) {
        ev.preventDefault();
        return false;
    };
    /**
     * Applies a set of styles to an element. Stores the original styles so they
     * can be restored later.
     *
     * @ignore
     * @param io      Element
     */
    Interaction.prototype.prepElement = function (io) {
        var el = io.element;
        if (el) {
            // Define possible props
            var props = [
                "touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",
                "userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",
                "touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",
                "touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",
                "contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",
                "userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"
            ];
            for (var i = 0; i < props.length; i++) {
                if (props[i] in el.style) {
                    this.setTemporaryStyle(io, props[i], "none");
                }
            }
            // Remove iOS-specific selection;
            this.setTemporaryStyle(io, "tapHighlightColor", "rgba(0, 0, 0, 0)");
            //this.setTemporaryStyle(io, "webkitOverflowScrolling", "none");
        }
    };
    /**
     * Restores replaced styles
     *
     * @ignore
     * @param  io  Element
     */
    Interaction.prototype.unprepElement = function (io) {
        var el = io.element;
        if (el) {
            // Define possible props
            var props = [
                "touchAction", "webkitTouchAction", "MozTouchAction", "MSTouchAction", "msTouchAction", "oTouchAction",
                "userSelect", "webkitUserSelect", "MozUserSelect", "MSUserSelect", "msUserSelect", "oUserSelect",
                "touchSelect", "webkitTouchSelect", "MozTouchSelect", "MSTouchSelect", "msTouchSelect", "oTouchSelect",
                "touchCallout", "webkitTouchCallout", "MozTouchCallout", "MSTouchCallout", "msTouchCallout", "oTouchCallout",
                "contentZooming", "webkitContentZooming", "MozContentZooming", "MSContentZooming", "msContentZooming", "oContentZooming",
                "userDrag", "webkitUserDrag", "MozUserDrag", "MSUserDrag", "msUserDrag", "oUserDrag"
            ];
            for (var i = 0; i < props.length; i++) {
                if (props[i] in el.style) {
                    this.restoreStyle(io, props[i]);
                }
            }
            // Remove iOS-specific selection;
            this.restoreStyle(io, "tapHighlightColor");
            //this.restoreStyle(io, "webkitOverflowScrolling");
        }
    };
    /**
     * Returns an option associated with hit events.
     *
     * @ignore Exclude from docs
     * @param io      Element
     * @param option  Option key
     * @return Option value
     */
    Interaction.prototype.getHitOption = function (io, option) {
        var res = io.hitOptions[option];
        if (typeof res === "undefined") {
            res = this.hitOptions[option];
        }
        return res;
    };
    /**
     * Returns an option associated with hover events.
     *
     * @ignore Exclude from docs
     * @param io      Element
     * @param option  Option key
     * @return Option value
     */
    Interaction.prototype.getHoverOption = function (io, option) {
        var res = io.hoverOptions[option];
        if (typeof res === "undefined") {
            res = this.hoverOptions[option];
        }
        return res;
    };
    /**
     * Returns an option associated with swipe events.
     *
     * @ignore Exclude from docs
     * @param io      Element
     * @param option  Option key
     * @return Option value
     */
    Interaction.prototype.getSwipeOption = function (io, option) {
        var res = io.swipeOptions[option];
        if (typeof res === "undefined") {
            res = this.swipeOptions[option];
        }
        return res;
    };
    /**
     * Returns an option for keyboard.
     *
     * @ignore Exclude from docs
     * @param io      Element
     * @param option  Option key
     * @return Option value
     */
    Interaction.prototype.getKeyboardOption = function (io, option) {
        var res = io.keyboardOptions[option];
        if (typeof res === "undefined") {
            res = this.keyboardOptions[option];
        }
        return res;
    };
    /**
     * Returns an option for mouse.
     *
     * @ignore Exclude from docs
     * @param io      Element
     * @param option  Option key
     * @return Option value
     */
    Interaction.prototype.getMouseOption = function (io, option) {
        var res = io.mouseOptions[option];
        if (typeof res === "undefined") {
            res = this.mouseOptions[option];
        }
        return res;
    };
    /**
     * Returns an option associated with inertia.
     *
     * @ignore Exclude from docs
     * @param io      Element
     * @param type    Inertia type
     * @param option  Option key
     * @return Option value
     */
    Interaction.prototype.getInertiaOption = function (io, type, option) {
        var options = io.inertiaOptions.getKey(type);
        var res;
        if (options && hasValue(options[option])) {
            res = options[option];
        }
        else {
            res = this.inertiaOptions.getKey(type)[option];
        }
        return res;
    };
    /**
     * Stops currently going on inertia. Useful if inertia is currently being
     * animated and the object is being interacted with.
     *
     * @param io Element
     */
    Interaction.prototype.stopInertia = function (io) {
        var x;
        var inertias = ["move", "resize"];
        for (var i = 0; i < inertias.length; i++) {
            x = inertias[i];
            if (io.inertias.hasKey(x)) {
                var inertia = io.inertias.getKey(x);
                if (inertia) {
                    inertia.dispose();
                    //io.inertiaAnimations.removeKey(x);
                    //this.processDragStop(io);
                    continue;
                }
            }
        }
    };
    /**
     * Check if swiping is currently being performed on an object.
     *
     * @param io       Element
     * @param pointer  Pointer to check
     * @return `true` if swiping
     */
    Interaction.prototype.swiping = function (io, pointer) {
        var now = getTime();
        if (pointer.swipeCanceled || !io.swipeable) {
            return false;
        }
        else if ((Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, "verticalThreshold")) &&
            (pointer.startTime > (now - this.getSwipeOption(io, "time")))) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Returns `true` if a successfull swipe action was performed on an element.
     *
     * @param io       Element
     * @param pointer  Pointer
     * @return Swiped?
     */
    Interaction.prototype.swiped = function (io, pointer) {
        var now = getTime();
        if (pointer.swipeCanceled) {
            return false;
        }
        else if ((Math.abs(pointer.startPoint.x - pointer.point.x) > this.getSwipeOption(io, "horizontalThreshold")) &&
            (Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, "verticalThreshold")) &&
            (pointer.startTime > (now - this.getSwipeOption(io, "time")))) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Applies style to mouse cursor based on its stage in relation to
     * [[InteractionObject]].
     *
     * @ignore Exclude from docs
     * @param Element
     */
    Interaction.prototype.applyCursorOverStyle = function (io) {
        // Get sprite's cursor ooptions
        var options = io.cursorOptions;
        if (!hasValue(options.overStyle)) {
            return;
        }
        // Apply cursor down styles
        for (var i = 0; i < options.overStyle.length; i++) {
            setStyle(io.element, options.overStyle[i].property, options.overStyle[i].value);
        }
    };
    /**
     * Applies style to mouse cursor based on its stage in relation to
     * [[InteractionObject]].
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     */
    Interaction.prototype.applyCursorDownStyle = function (io, pointer) {
        // Not applicable for touch pointers since they don't display a cursor
        if (pointer.touch) {
            return;
        }
        var downStyle = io.cursorOptions.downStyle;
        // Is down?
        if (io.downPointers.contains(pointer) && hasValue(downStyle)) {
            // Apply cursor down styles
            for (var i = 0; i < downStyle.length; i++) {
                this.setTemporaryStyle(this.body, downStyle[i].property, downStyle[i].value);
                this.setTemporaryStyle(io, downStyle[i].property, downStyle[i].value);
            }
        }
    };
    /**
     * Restores original cursor style for the element.
     *
     * @ignore Exclude from docs
     * @param io       Element
     * @param pointer  Pointer
     */
    Interaction.prototype.restoreCursorDownStyle = function (io, pointer) {
        // Not applicable for touch pointers since they don't display a cursor
        if (pointer.touch) {
            return;
        }
        var downStyle = io.cursorOptions.downStyle;
        // Is down?
        if (io.downPointers.contains(pointer) && hasValue(downStyle)) {
            // Apply cursor down styles
            for (var i = 0; i < downStyle.length; i++) {
                this.restoreStyle(this.body, downStyle[i].property);
                this.restoreStyle(io, downStyle[i].property);
            }
        }
    };
    /**
     * Sets style on the body of the document.
     *
     * @ignore Exclude from docs
     * @param style  Style definitions
     */
    Interaction.prototype.setGlobalStyle = function (style) {
        var body = getInteraction().body;
        var styles = (isArray(style) ? style : [style]);
        for (var i = 0; i < styles.length; i++) {
            this.setTemporaryStyle(body, styles[i].property, styles[i].value);
        }
    };
    /**
     * Restores style on the body of the document.
     *
     * @ignore Exclude from docs
     * @param style  Style definitions
     */
    Interaction.prototype.restoreGlobalStyle = function (style) {
        var body = getInteraction().body;
        var styles = (isArray(style) ? style : [style]);
        for (var i = 0; i < styles.length; i++) {
            this.restoreStyle(body, styles[i].property);
        }
    };
    /**
     * Checks if element is a non-cahrt element.
     *
     * @param io  InteractionObject
     * @return Global element?
     */
    Interaction.prototype.isGlobalElement = function (io) {
        return document.body === io.element;
    };
    /**
     * Checks if pointer has moved since it was created.
     *
     * @param pointer    Pointer
     * @param tolerance  Tolerance in pixels
     * @param minTime    Minimum time required for the pointer to be down to be considered moved
     * @return `true` if the pointer has moved
     */
    Interaction.prototype.moved = function (pointer, tolerance, minTime) {
        /*// If there was more time, we don't care if cursor actually moved
        let duration = $time.getTime() - pointer.startTime;
        if ($type.hasValue(minTime) && (minTime > duration)) {
            return false;
        }*/
        if (minTime === void 0) { minTime = 300; }
        // That was quick measure shift
        var shift = this.getShift(pointer);
        return (Math.abs(shift.x) > tolerance) || (Math.abs(shift.y) > tolerance);
    };
    /**
     * Returns if pointer is "old", meaning it has been pressing for more than
     * X milliseconds.
     *
     * @ignore
     * @param pointer  Pointer
     * @param minTime  Minimum time to consider pointer old
     * @return {boolean}
     */
    Interaction.prototype.old = function (pointer, minTime) {
        if (minTime === void 0) { minTime = 300; }
        return getTime() - pointer.startTime > minTime;
    };
    /**
     * Returns total a shift in pointers coordinates between its original
     * position and now.
     *
     * @param pointer  Pointer
     * @return Shift in coordinates (x/y)
     */
    Interaction.prototype.getShift = function (pointer) {
        return {
            "x": pointer.startPoint.x - pointer.point.x,
            "y": pointer.startPoint.y - pointer.point.y
        };
    };
    /**
     * Returns a point from [[Pointer]]'s move history at a certain timetamp.
     *
     * @param pointer    Pointer
     * @param timestamp  Timestamp
     * @return Point
     */
    Interaction.prototype.getTrailPoint = function (pointer, timestamp) {
        var res;
        for (var i = 0; i < pointer.track.length; i++) {
            if (pointer.track[i].timestamp >= timestamp) {
                res = pointer.track[i];
                break;
            }
        }
        return res;
    };
    /**
     * Checks if same pointer already exists in the list.
     *
     * @param list     List to check agains
     * @param pointer  Pointer
     * @return Exists?
     */
    Interaction.prototype.pointerExists = function (list, pointer) {
        var exists = false;
        list.each(function (item) {
            if (item == pointer) {
                return;
            }
            exists = item.point.x == pointer.point.x && item.point.y == pointer.point.y;
        });
        return exists;
    };
    /**
     * Returns an [[InteractionObject]] representation of a DOM element.
     *
     * You can use this on any HTML or SVG element, to add interactive features
     * to it.
     *
     * @param element  Element
     * @return InteractionObject
     */
    Interaction.prototype.getInteraction = function (element) {
        return new InteractionObject_InteractionObject(element);
    };
    /**
     * Sets a style property on an element. Stores original value to be restored
     * later with [[restoreStyle]].
     *
     * @see {@link restoreStyle}
     * @param io        Element
     * @param property  Property
     * @param value     Value
     */
    Interaction.prototype.setTemporaryStyle = function (io, property, value) {
        // Get element
        //let el = io.element.tagName == "g" ? <SVGSVGElement>io.element.parentNode : io.element;
        var el = io.element;
        // Save original property if it is set and hasn't been saved before already
        if (hasValue(el.style[property]) && !io.replacedStyles.hasKey(property)) {
            io.replacedStyles.setKey(property, el.style[property]);
        }
        // Replace with the new one
        setStyle(el, property, value);
    };
    /**
     * Restores specific style on an element.
     *
     * @param io        Element
     * @param property  Style property
     */
    Interaction.prototype.restoreStyle = function (io, property) {
        // Reset style
        if (io.replacedStyles.hasKey(property)) {
            io.element.style[property] = io.replacedStyles.getKey(property);
            io.replacedStyles.removeKey(property);
        }
        else {
            delete io.element.style[property];
        }
    };
    /**
     * Restore temporarily reset styles on an element.
     *
     * @param io Element
     */
    Interaction.prototype.restoreAllStyles = function (io) {
        Iterator_each(io.replacedStyles.iterator(), function (a) {
            var key = a[0];
            var value = a[1];
            io.element.style[key] = value;
            io.replacedStyles.removeKey(key);
        });
    };
    /**
     * Disposes this object and cleans up after itself.
     */
    Interaction.prototype.dispose = function () {
        if (!this.isDisposed()) {
            _super.prototype.dispose.call(this);
            this.restoreAllStyles(this.body);
            this.unlockWheel();
        }
    };
    // @ts-ignore Used for debugging
    Interaction.prototype.log = function (text, ev, io) {
        var show = true;
        if (show) {
            // Touchlist?
            if (ev.changedTouches) {
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    this.logTouch(text, ev.type, ev.changedTouches[i]);
                }
                return;
            }
            // Get type
            var type = "";
            if (ev.pointerType) {
                switch (ev.pointerType) {
                    case 2:
                        type = "touch";
                        break;
                    case 4:
                        type = "mouse";
                        break;
                    default:
                        type = ev.pointerType;
                        break;
                }
            }
            else if (typeof TouchEvent != "undefined" && ev instanceof TouchEvent) {
                type = "touch";
            }
            else if (ev.type.match(/^mouse/)) {
                type = "mouse";
            }
            else {
                type = "???";
            }
            // Get ID
            var id = "";
            if (hasValue(ev.identifier)) {
                id = ev.identifier;
            }
            else if (hasValue(ev.pointerId)) {
                id = ev.pointerId;
            }
            else {
                id = "???";
            }
            if (io) {
                console.log(text + " (" + io.uid + ")  " + ev.type + "  " + type + "  " + id);
            }
            else {
                console.log(text + "  " + ev.type + "  " + type + "  " + id);
            }
        }
    };
    /**
     * Checks whether there are currently any objects being transformed (dragged
     * or resized).
     *
     * If `except` is set, that object will be ignored.
     *
     * @since 4.9.3
     * @param   except  Ignore this object(s)
     * @return          Objects are being transformed
     */
    Interaction.prototype.areTransformed = function (except) {
        var count = this.transformedObjects.length;
        if (except) {
            var ex = isArray(except) ? except : [except];
            for (var i = 0; i < ex.length; i++) {
                if (this.transformedObjects.contains(ex[i])) {
                    count--;
                }
            }
        }
        return count > 0;
    };
    /**
     * Log.
     */
    Interaction.prototype.logTouch = function (text, type, ev) {
        console.log(text + "  " + type + "  " + "touch" + "  " + ev.identifier);
    };
    Object.defineProperty(Interaction, "passiveSupported", {
        /**
         * Indicates if passive mode options is supported by this browser.
         */
        get: function () {
            var _this = this;
            if (this._passiveSupported == null) {
                // Check for passive mode support
                try {
                    var options = Object.defineProperty({}, "passive", {
                        get: function () {
                            _this._passiveSupported = true;
                        }
                    });
                    window.addEventListener("test", options, options);
                    window.removeEventListener("test", options, options);
                }
                catch (err) {
                    this._passiveSupported = false;
                }
            }
            return this._passiveSupported;
        },
        enumerable: true,
        configurable: true
    });
    return Interaction;
}(Base_BaseObjectEvents));

var Interaction_interaction = null;
/**
 * Returns a single unified global instance of [[Interaction]].
 *
 * All code should use this function, rather than create their own instances
 * of [[Interaction]].
 */
function getInteraction() {
    if (Interaction_interaction == null) {
        Interaction_interaction = new Interaction_Interaction();
    }
    return Interaction_interaction;
}
//# sourceMappingURL=Interaction.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Popup.js
/**
 * Popup class is used to display information over chart area.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









/**
 * Shows an HTML popup which covers window or a chart area.
 *
 * @see {@link https://www.amcharts.com/docs/v4/concepts/popups-and-modals/} For examples and docs on Popups and Modals.
 * @todo Positioning over whole window
 */
var Popup_Popup = /** @class */ (function (_super) {
    __extends(Popup, _super);
    /**
     * Constructor
     */
    function Popup() {
        var _this = _super.call(this) || this;
        /**
         * Adapter.
         */
        _this.adapter = new Adapter_Adapter(_this);
        /**
         * Holds references to various HTML elements, Popup consists of.
         */
        _this._elements = {};
        /**
         * Holdes Interaction objects for various Popup's elements.
         */
        _this._IOs = {};
        /**
         * Contents of popup window.
         */
        _this._content = "";
        /**
         * Title of the popup window.
         */
        _this._title = "";
        /**
         * Prefix to apply to class names for popup elements.
         */
        _this._classPrefix = "ampopup";
        /**
         * If set to `true` [[Popup]] will use default styles.
         */
        _this._defaultStyles = true;
        /**
         * If set to `true` [[Popup]] will dim out all chart content behind it by
         * showing a semi-transparent fill. (curtain)
         */
        _this._showCurtain = false;
        /**
         * Indicates whether popup can be dragged.
         */
        _this._draggable = true;
        /**
         * Horizontal position of the content window.
         */
        _this._align = "center";
        /**
         * Resize popup as images are being loaded.
         */
        _this._dynamicResize = true;
        /**
         * Vertical position of the content window.
         */
        _this._verticalAlign = "middle";
        /**
         * Shift in position of the element. (used for dragging)
         */
        _this._shift = {
            x: 0,
            y: 0
        };
        /**
         * Temporary shift in position of the element. (used for dragging)
         */
        _this._tempShift = {
            x: 0,
            y: 0
        };
        /**
         * A title for screen readers. It is very highly recommended to set that title
         * so that people using screen reader tools can get an immediate summary of
         * the information in the popup.
         */
        _this._readerTitle = "";
        /**
         * Is popup closable?
         */
        _this._closable = true;
        /**
         * Was CSS already loaded?
         */
        _this._cssLoaded = false;
        /**
         * If set to other than "none" will try to re-adjust the position of the
         * popop to fit within chart container or browser window.
         *
         * @ignore Feature not yet implemented
         * @todo Implement
         */
        _this._fitTo = "window";
        /**
         * Identifies if this object is a "template" and should not be treated as
         * real object that is drawn or actually used in the chart.
         *
         * @ignore Exclude from docs
         */
        _this.isTemplate = false;
        /**
         * Indicates if the element was already sized and should not be measured for
         * size again, saving some precious resources.
         */
        _this._sized = false;
        _this.className = "Popup";
        return _this;
    }
    /**
     * Shows popup window.
     */
    Popup.prototype.open = function () {
        if (this.container) {
            if (this._elements.wrapper) {
                this.container.appendChild(this._elements.wrapper);
            }
            if (this._elements.curtain) {
                this.container.appendChild(this._elements.curtain);
                this.showCurtain = this.showCurtain;
            }
            this.positionElement();
            this.dispatchImmediately("opened");
        }
    };
    /**
     * Hides popup window.
     */
    Popup.prototype.close = function () {
        if (this._elements.wrapper) {
            if (this._elements.wrapper.parentElement) {
                this._elements.wrapper.parentElement.removeChild(this._elements.wrapper);
            }
        }
        if (this._elements.curtain) {
            if (this._elements.curtain.parentElement) {
                this._elements.curtain.parentElement.removeChild(this._elements.curtain);
            }
        }
        this.dispatchImmediately("closed");
        this.releasePointers();
    };
    /**
     * Destroy (dispose) popup.
     */
    Popup.prototype.dispose = function () {
        this.close();
        _super.prototype.dispose.call(this);
    };
    /**
     * Positions content element in the center of popup based on its actual size.
     *
     * @ignore Exclude from docs
     */
    Popup.prototype.positionElement = function (forceResize) {
        var _this = this;
        if (forceResize === void 0) { forceResize = true; }
        if (!this._elements.wrapper) {
            return;
        }
        setTimeout(function () {
            if (!_this._elements.wrapper) {
                return;
            }
            if (forceResize || !_this._sized) {
                _this._elements.wrapper.style.opacity = "0.01";
                _this._elements.wrapper.style.left = "0";
                _this._elements.wrapper.style.top = "0";
                _this._elements.wrapper.style.margin = "0 0 0 0";
                _this._elements.wrapper.style.width = "";
                _this._elements.wrapper.style.height = "";
                var bbox = _this._elements.wrapper.getBoundingClientRect();
                _this._elements.wrapper.style.width = bbox.width + "px";
                _this._elements.wrapper.style.height = bbox.height + "px";
                _this._sized = true;
            }
            // Check for any images that are not yet loaded
            if (_this.dynamicResize) {
                var images = _this._elements.wrapper.getElementsByTagName("img");
                for (var i = 0; i < images.length; i++) {
                    var image = images[i];
                    if (!image.complete) {
                        // Resize popup once again when image is loaded
                        image.addEventListener("load", function () {
                            _this.positionElement(true);
                        });
                        // Do this for one image only as it will be checked again next time
                        // anyway
                        break;
                    }
                }
            }
            setTimeout(function () {
                if (!_this._elements.wrapper) {
                    return;
                }
                var bbox;
                if ((forceResize || !_this._sized) && _this._bbox) {
                    bbox = _this._bbox;
                }
                else {
                    bbox = _this._elements.wrapper.getBoundingClientRect();
                    _this._elements.wrapper.style.opacity = "";
                }
                // Set horizontal positioning
                switch (_this.align) {
                    case "left":
                        _this._elements.wrapper.style.left = "0";
                        _this._elements.wrapper.style.right = "auto";
                        _this._elements.wrapper.style.marginLeft = _this.toStyle(_this._shift.x + _this._tempShift.x);
                        break;
                    case "center":
                        _this._elements.wrapper.style.left = "50%";
                        _this._elements.wrapper.style.right = "auto";
                        _this._elements.wrapper.style.marginLeft = _this.toStyle(Math.round(-bbox.width / 2) + (_this._shift.x + _this._tempShift.x));
                        break;
                    case "right":
                        _this._elements.wrapper.style.left = "auto";
                        _this._elements.wrapper.style.right = "0";
                        _this._elements.wrapper.style.marginLeft = _this.toStyle(_this._shift.x + _this._tempShift.x);
                        break;
                    default:
                        _this._elements.wrapper.style.left = _this.toStyle(_this.left) || "auto";
                        _this._elements.wrapper.style.right = _this.toStyle(_this.right) || "auto";
                        _this._elements.wrapper.style.marginLeft = _this.toStyle(_this._shift.x + _this._tempShift.x);
                        break;
                }
                // Set vertical positioning
                switch (_this.verticalAlign) {
                    case "top":
                        _this._elements.wrapper.style.top = "0";
                        _this._elements.wrapper.style.bottom = "auto";
                        _this._elements.wrapper.style.marginTop = _this.toStyle(_this._shift.y + _this._tempShift.y);
                        break;
                    case "middle":
                        _this._elements.wrapper.style.top = "50%";
                        _this._elements.wrapper.style.bottom = "auto";
                        _this._elements.wrapper.style.marginTop = _this.toStyle(Math.round(-bbox.height / 2) + (_this._shift.y + _this._tempShift.y));
                        break;
                    case "bottom":
                        _this._elements.wrapper.style.top = "auto";
                        _this._elements.wrapper.style.bottom = "0";
                        _this._elements.wrapper.style.marginTop = _this.toStyle(_this._shift.y + _this._tempShift.y);
                        break;
                    default:
                        _this._elements.wrapper.style.top = _this.toStyle(_this.top) || "auto";
                        _this._elements.wrapper.style.bottom = _this.toStyle(_this.bottom) || "auto";
                        _this._elements.wrapper.style.marginTop = _this.toStyle(_this._shift.y + _this._tempShift.y);
                        break;
                }
            }, 1);
        }, 1);
    };
    Popup.prototype.setupDragging = function () {
        var _this = this;
        if (this.draggable) {
            if (!this._IOs.header.events.has("drag")) {
                this._IOs.header.events.on("drag", function (ev) {
                    _this._tempShift.x = ev.shift.x;
                    _this._tempShift.y = ev.shift.y;
                    _this.positionElement(false);
                });
            }
            if (!this._IOs.header.events.has("dragstop")) {
                this._IOs.header.events.on("dragstop", function (ev) {
                    _this._shift.x += _this._tempShift.x;
                    _this._shift.y += _this._tempShift.y;
                    _this._tempShift.x = 0;
                    _this._tempShift.y = 0;
                    _this.positionElement(false);
                });
            }
        }
        else {
            if (this._IOs.header) {
                getInteraction().unprepElement(this._IOs.header);
                if (this._IOs.header.events.has("drag")) {
                    this._IOs.header.events.off("drag");
                }
                if (this._IOs.header.events.has("dragstop")) {
                    this._IOs.header.events.off("dragstop");
                }
            }
        }
    };
    Popup.prototype.toStyle = function (value) {
        if (!hasValue(value)) {
            return null;
        }
        else if (isNumber(value)) {
            return "" + value + "px";
        }
        else {
            return value.toString();
        }
    };
    Object.defineProperty(Popup.prototype, "classPrefix", {
        /**
         * A prefix that is applied to class names of various popup elements.
         *
         * @return Class name prefix
         */
        get: function () {
            return this.adapter.apply("classPrefix", this._classPrefix);
        },
        /**
         * @param value Class name prefix
         */
        set: function (value) {
            this._classPrefix = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "classPrefixRaw", {
        /**
         * Returns raw prefix (without adapters applied).
         *
         * @ignore Exclude from docs
         * @return Class name prefix
         */
        get: function () {
            return this._classPrefix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "content", {
        /**
         * @return Popup content
         */
        get: function () {
            return this.adapter.apply("content", this._content);
        },
        /**
         * Popup content.
         *
         * Popup content can be any valid HTML, including CSS.
         *
         * @param value Popup content
         */
        set: function (value) {
            if (this._content != value) {
                this._content = value;
                if (!this._elements.content) {
                    this.createContentElement();
                }
                this._elements.content.innerHTML = value;
                this.positionElement();
            }
        },
        enumerable: true,
        configurable: true
    });
    Popup.prototype.getClassNames = function () {
        return this.adapter.apply("classNames", {
            wrapperClass: this.classPrefix + "",
            headerClass: this.classPrefix + "-header",
            titleClass: this.classPrefix + "-title",
            contentClass: this.classPrefix + "-content",
            insideClass: this.classPrefix + "-inside",
            curtainClass: this.classPrefix + "-curtain",
            closeClass: this.classPrefix + "-close"
        });
    };
    /**
     * Creates content element.
     */
    Popup.prototype.createContentElement = function () {
        // Check if it's created already
        if (this._elements.wrapper) {
            return;
        }
        // Get class names for popup elements
        var classNames = this.getClassNames();
        // Create content element
        var wrapper = document.createElement("div");
        wrapper.className = classNames.contentClass;
        wrapper.style.opacity = "0.01";
        // Create close button
        var close = document.createElement("a");
        close.className = classNames.closeClass;
        // header title
        var header = document.createElement("div");
        header.className = classNames.headerClass;
        // Content title
        var title = document.createElement("div");
        title.innerHTML = this.title;
        title.className = classNames.titleClass;
        if (!this.title) {
            title.style.display = "none";
        }
        // Content div
        var content = document.createElement("div");
        content.className = classNames.insideClass;
        content.innerHTML = this.content;
        // Set up events for content
        this._IOs.wrapper = getInteraction().getInteraction(wrapper);
        this._IOs.header = getInteraction().getInteraction(header);
        this._disposers.push(this._IOs.wrapper);
        // Set hover/out events
        this._IOs.wrapper.events.on("over", this.disablePointers, this);
        this._IOs.wrapper.events.on("out", this.releasePointers, this);
        // Create an InteractionObject for close
        this._IOs.close = getInteraction().getInteraction(close);
        this._disposers.push(this._IOs.close);
        // Hide close for now
        close.style.visibility = "hidden";
        // Add accessible stuff
        wrapper.setAttribute("role", "dialog");
        // Add to wrapper
        header.appendChild(close);
        header.appendChild(title);
        wrapper.appendChild(header);
        wrapper.appendChild(content);
        this.container.appendChild(wrapper);
        // Save for later access
        this._elements.wrapper = wrapper;
        this._elements.header = header;
        this._elements.content = content;
        this._elements.title = title;
        this._elements.close = close;
        // Load CSS
        if (this.defaultStyles) {
            this.loadDefaultCSS();
        }
        // Create curtain as well
        this.createCurtainElement();
        // Apply events
        this.applyEvents();
        this.applyReaderSettings();
        // Draggable?
        this.setupDragging();
    };
    Object.defineProperty(Popup.prototype, "title", {
        /**
         * @return Popup title
         */
        get: function () {
            return this.adapter.apply("title", this._title);
        },
        /**
         * Popup title.
         *
         * Popup title can be any valid HTML, including CSS.
         *
         * @param value  Popup title
         */
        set: function (value) {
            if (this._title != value) {
                this._title = value;
                if (!this._elements.content) {
                    this.createContentElement();
                }
                this._elements.title.innerHTML = value;
                this.positionElement();
                this.applyReaderSettings();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "readerTitle", {
        /**
         * @return Popup content
         */
        get: function () {
            return this.adapter.apply("readerTitle", this._readerTitle != "" ? this._readerTitle : this.title);
        },
        /**
         * A title for screen readers. It is very highly recommended to set that title
         * so that people using screen reader tools can get an immediate summary of
         * the information in the popup.
         *
         * @param value  Reader title
         */
        set: function (value) {
            if (this._readerTitle != value) {
                this._readerTitle = value;
                this.applyReaderSettings();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "closable", {
        /**
         * @return Closable?
         */
        get: function () {
            return this.adapter.apply("closable", this._closable);
        },
        /**
         * Is popup closable?
         *
         * If it is, it can be closed in a number of ways, e.g. by hitting ESC key,
         * clicking curtain, or clicking the close button.
         *
         * If it is not closable, the only way to close it is via `close()` call.
         *
         * @param value Closable?
         */
        set: function (value) {
            if (value !== this._closable) {
                this._closable = value;
                this.applyEvents();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "fitTo", {
        /**
         * @ignore
         * @todo Implement
         * @return Fit option
         */
        get: function () {
            return this.adapter.apply("fitTo", this._fitTo);
        },
        /**
         * If set to other than "none" will try to re-adjust the position of the
         * popop to fit within chart container or browser window.
         *
         * @ignore
         * @todo Implement
         * @default "window"
         * @param value  Fit option
         */
        set: function (value) {
            if (value != this._fitTo) {
                this._fitTo = value;
                this.positionElement();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "defaultStyles", {
        /**
         * @return Use default CSS?
         */
        get: function () {
            return this.adapter.apply("defaultStyles", this._defaultStyles);
        },
        /**
         * Should popup use default CSS?
         *
         * If default CSS is disabled, an external CSS should handle the look of the
         * popup, since it will look quite out of place otherwise.
         *
         * @default true
         * @param Use default CSS?
         */
        set: function (value) {
            if (this._defaultStyles != value) {
                this._defaultStyles = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "showCurtain", {
        /**
         * @return Show curtain?
         */
        get: function () {
            return this.adapter.apply("showCurtain", this._showCurtain);
        },
        /**
         * Should popup use dim out all content behind it?
         *
         * @default false
         * @param Show curtain?
         */
        set: function (value) {
            if (this._showCurtain != value) {
                this._showCurtain = value;
                if (this._elements.curtain) {
                    this._elements.curtain.style.display = value ? "block" : "none";
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates curtain element.
     */
    Popup.prototype.createCurtainElement = function () {
        // Get class names for popup elements
        var classNames = this.getClassNames();
        // Create the curtain
        var curtain = document.createElement("div");
        curtain.className = classNames.curtainClass;
        // Append curtain to wrapper
        this.container.appendChild(curtain);
        // Create an InteractionObject for curtain because we might need to
        // set interactions on it
        this._IOs.curtain = getInteraction().getInteraction(curtain);
        // Add Curtain IO to disposers
        this._disposers.push(this._IOs.curtain);
        // Set events to disable underlying interactivity
        this._IOs.curtain.events.on("over", this.disablePointers, this);
        this._IOs.curtain.events.on("out", this.releasePointers, this);
        // Hide it?
        curtain.style.display = this.showCurtain ? "block" : "none";
        // Save for later
        this._elements.curtain = curtain;
    };
    Object.defineProperty(Popup.prototype, "draggable", {
        /**
         * @return Show curtain?
         */
        get: function () {
            return this.adapter.apply("draggable", this._draggable);
        },
        /**
         * Can the popup be dragged with a pointer?
         *
         * @default false
         * @param Show curtain?
         */
        set: function (value) {
            if (this._draggable != value) {
                this._draggable = value;
                this.setupDragging();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "dynamicResize", {
        /**
         * @return Resize dynamically?
         */
        get: function () {
            return this.adapter.apply("dynamicResize", this._dynamicResize);
        },
        /**
         * Resize popup as images are being loaded.
         *
         * @default true
         * @since 4.9.17
         * @param Resize dynamically?
         */
        set: function (value) {
            if (this._dynamicResize != value) {
                this._dynamicResize = value;
                this.positionElement(true);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "align", {
        /**
         * @return Horizontal position
         */
        get: function () {
            return this.adapter.apply("align", this._align);
        },
        /**
         * Horizontal positioning of the content window.
         *
         * Available options: "left", "center" (default), "right", and "none".
         *
         * @default "center"
         * @param Horizontal position
         */
        set: function (value) {
            if (this._align != value) {
                this._align = value;
                this.positionElement();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "verticalAlign", {
        /**
         * @return Vertical position
         */
        get: function () {
            return this.adapter.apply("verticalAlign", this._verticalAlign);
        },
        /**
         * Vertical positioning of the content window.
         *
         * Available options: "top", "middle" (default), "bottom", and "none".
         *
         * @default "middle"
         * @param Vertical position
         */
        set: function (value) {
            if (this._verticalAlign != value) {
                this._verticalAlign = value;
                this.positionElement();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "left", {
        /**
         * @return Left
         */
        get: function () {
            return this.adapter.apply("left", this._left);
        },
        /**
         * "left" coordinate of a non-aligned (`align = "none"`) popup.
         *
         * Can be either absolute pixel value, or relative (`Percent`).
         *
         * Setting this property will automatically set `align` to "none".
         *
         * NOTE: The position is relative to the chart container.
         *
         * @param Left
         */
        set: function (value) {
            if (this.left != value) {
                this._left = value;
                this._align = "none";
                this.positionElement();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "right", {
        /**
         * @return Right
         */
        get: function () {
            return this.adapter.apply("right", this._right);
        },
        /**
         * "right" coordinate of a non-aligned (`align = "none"`) popup.
         *
         * Can be either absolute pixel value, or relative (`Percent`).
         *
         * Setting this property will automatically set `align` to "none".
         *
         * NOTE: The position is relative to the chart container.
         *
         * @param Right
         */
        set: function (value) {
            if (this.right != value) {
                this._right = value;
                this._align = "none";
                this.positionElement();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "top", {
        /**
         * @return Top
         */
        get: function () {
            return this.adapter.apply("top", this._top);
        },
        /**
         * "top" coordinate of a non-aligned (`verticalAlign = "none"`) popup.
         *
         * Can be either absolute pixel value, or relative (`Percent`).
         *
         * Setting this property will automatically set `verticalAlign` to "none".
         *
         * NOTE: The position is relative to the chart container.
         *
         * @param Top
         */
        set: function (value) {
            if (this.top != value) {
                this._top = value;
                this._verticalAlign = "none";
                this.positionElement();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "bottom", {
        /**
         * @return Bottom
         */
        get: function () {
            return this.adapter.apply("bottom", this._bottom);
        },
        /**
         * "bottom" coordinate of a non-aligned (`verticalAlign = "none"`) popup.
         *
         * Can be either absolute pixel value, or relative (`Percent`).
         *
         * Setting this property will automatically set `verticalAlign` to "none".
         *
         * NOTE: The position is relative to the chart container.
         *
         * @param Bottom
         */
        set: function (value) {
            if (this.bottom != value) {
                this._bottom = value;
                this._verticalAlign = "none";
                this.positionElement();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Popup.prototype, "elements", {
        /**
         * Returns an object with references to various elements of the Popup.
         *
         * * `wrapper`
         * * `title`
         * * `content`
         * * `close`
         * * `curtain`
         */
        get: function () {
            return this._elements;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Loads popup CSS.
     *
     * @ignore Exclude from docs
     */
    Popup.prototype.loadDefaultCSS = function () {
        if (!this._cssLoaded) {
            this._disposers.push(PopupCSS(getShadowRoot(this.container), this.classPrefix));
            Object_each(this._elements, function (key, el) {
                el.style.display = "";
            });
            this._cssLoaded = true;
        }
    };
    /**
     * If popup is closable, this method adds various events to popup elements.
     */
    Popup.prototype.applyEvents = function () {
        var _this = this;
        if (this._IOs.close) {
            if (this.closable) {
                this._IOs.close.element.style.visibility = "visible";
                var disposers = [
                    getInteraction().body.events.on("keyup", function (ev) {
                        if (keyboard.isKey(ev.event, "esc") && _this.closable) {
                            _this.close();
                        }
                    }),
                    this._IOs.close.events.on("hit", function (ev) {
                        _this.close();
                    })
                ];
                disposers.push(this._IOs.curtain.events.on("hit", function (ev) {
                    if (_this.showCurtain && _this.closable) {
                        _this.close();
                    }
                }));
                this._disposers.push(new Disposer_MultiDisposer(disposers));
            }
            else {
                this._IOs.close.element.style.visibility = "hidden";
            }
        }
    };
    /**
     * Disables interactivity on parent chart.
     */
    Popup.prototype.disablePointers = function () {
        if (this.sprite) {
            this._spriteInteractionsEnabled = this.sprite.interactionsEnabled;
            this.sprite.interactionsEnabled = false;
        }
    };
    /**
     * Releases temporarily disabled pointers on parent chart.
     */
    Popup.prototype.releasePointers = function () {
        if (hasValue(this._spriteInteractionsEnabled)) {
            this.sprite.interactionsEnabled = this._spriteInteractionsEnabled;
            this._spriteInteractionsEnabled = undefined;
        }
    };
    /**
     * Sets screen reader related settings.
     */
    Popup.prototype.applyReaderSettings = function () {
        this.elements.wrapper.setAttribute("aria-label", this.readerTitle);
    };
    /**
     * Copies all properties and related data from different element.
     *
     * @param object Source element
     */
    Popup.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.container = source.container;
        this.sprite = source.sprite;
        this.classPrefix = source.classPrefixRaw;
        this.content = source.content;
        this.title = source.title;
        this.readerTitle = source.readerTitle;
        this.defaultStyles = source.defaultStyles;
        this.showCurtain = source.showCurtain;
        this.align = source.align;
        this.verticalAlign = source.verticalAlign;
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.adapter.copyFrom(source.adapter);
    };
    return Popup;
}(Base_BaseObjectEvents));

//# sourceMappingURL=Popup.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Modal.js
/**
 * Modal class is used to display information over chart area.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * Shows an HTML modal which covers window or a chart area.
 *
 * @see {@link https://www.amcharts.com/docs/v4/concepts/popups-and-modals/} For examples and docs on Popups and Modals.
 */
var Modal_Modal = /** @class */ (function (_super) {
    __extends(Modal, _super);
    /**
     * Constructor
     */
    function Modal() {
        var _this = _super.call(this) || this;
        /**
         * Adapter.
         */
        _this.adapter = new Adapter_Adapter(_this);
        _this.className = "Modal";
        _this.showCurtain = true;
        _this.draggable = false;
        return _this;
    }
    return Modal;
}(Popup_Popup));

//# sourceMappingURL=Modal.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/ResizeSensor.js

var ResizeSensor_Native = /** @class */ (function () {
    function Native() {
        var _this = this;
        this._targets = [];
        this._observer = new ResizeObserver(function (entries) {
            each(entries, function (entry) {
                each(_this._targets, function (x) {
                    if (x.target === entry.target) {
                        x.callback();
                    }
                });
            });
        });
    }
    Native.prototype.addTarget = function (target, callback) {
        this._observer.observe(target, { box: "content-box" });
        this._targets.push({ target: target, callback: callback });
    };
    Native.prototype.removeTarget = function (target) {
        this._observer.unobserve(target);
        keepIf(this._targets, function (x) {
            return x.target !== target;
        });
    };
    return Native;
}());
var ResizeSensor_Raf = /** @class */ (function () {
    function Raf() {
        this._targets = [];
    }
    Raf.prototype.addTarget = function (target, callback) {
        var _this = this;
        if (this._targets.length === 0) {
            var lastTime_1 = null;
            var loop_1 = function () {
                var currentTime = Date.now();
                if (lastTime_1 === null || currentTime > (lastTime_1 + Raf.delay)) {
                    lastTime_1 = currentTime;
                    each(_this._targets, function (x) {
                        var newSize = x.target.getBoundingClientRect();
                        if (newSize.width !== x.size.width || newSize.height !== x.size.height) {
                            x.size = newSize;
                            x.callback();
                        }
                    });
                }
                _this._timer = requestAnimationFrame(loop_1);
            };
            this._timer = requestAnimationFrame(loop_1);
        }
        var size = target.getBoundingClientRect();
        this._targets.push({ target: target, callback: callback, size: size });
    };
    Raf.prototype.removeTarget = function (target) {
        keepIf(this._targets, function (x) {
            return x.target !== target;
        });
        if (this._targets.length === 0) {
            cancelAnimationFrame(this._timer);
        }
    };
    Raf.delay = 200;
    return Raf;
}());
var observer = null;
function makeSensor() {
    if (observer === null) {
        if (typeof ResizeObserver !== "undefined") {
            observer = new ResizeSensor_Native();
        }
        else {
            observer = new ResizeSensor_Raf();
        }
    }
    return observer;
}
var ResizeSensor = /** @class */ (function () {
    function ResizeSensor(element, callback) {
        this._disposed = false;
        this._sensor = makeSensor();
        this._element = element;
        this._sensor.addTarget(element, callback);
    }
    ResizeSensor.prototype.isDisposed = function () {
        return this._disposed;
    };
    ResizeSensor.prototype.dispose = function () {
        if (!this._disposed) {
            this._disposed = true;
            this._sensor.removeTarget(this._element);
        }
    };
    /**
     * Deprecated: do not use.
     *
     * @ignore Exclude from docs
     */
    ResizeSensor.prototype.reset = function () {
        console.warn("resizeSensor.reset() is no longer needed and can be removed");
    };
    return ResizeSensor;
}());

//# sourceMappingURL=ResizeSensor.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/SVGContainer.js
/**
 * This functionality is related to the HTML wrapper that houses `<svg>` tag.
 */








/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A array of all SVG Containers (one SVG container per chart instance).
 *
 * @ignore Exclude from docs
 */
var svgContainers = [];
/**
 * A class used to create an HTML wrapper for the SVG contents.
 */
var SVGContainer_SVGContainer = /** @class */ (function () {
    /**
     * Constructor
     *
     * * Creates an HTML wrapper for SVG
     */
    function SVGContainer(htmlElement, ghost) {
        var _this = this;
        /**
         * Indicates if this object has already been deleted. Any
         * destruction/disposal code should take this into account when deciding
         * wheter to run potentially costly disposal operations if they already have
         * been run.
         */
        this._disposed = false;
        /**
         * If this component is in a separate HTML container, `autoResize` means the
         * module will constantly measure container's size and adopt contents to it.
         */
        this.autoResize = true;
        /**
         * Holds list of references to [[Sprite]] objects that should not be exported
         * when exporting chart to an image.
         *
         * @ignore
         */
        this.nonExportableSprites = [];
        /**
         * List of objects that need to be disposed when this one is disposed.
         */
        this._disposers = [];
        this.cssScale = 1;
        // Log parent HTML element
        this.htmlElement = htmlElement;
        if (!ghost) {
            var callback = function () {
                if (_this.autoResize) {
                    _this.measure();
                }
            };
            this.resizeSensor = new ResizeSensor(htmlElement, callback);
            this._disposers.push(this.resizeSensor);
        }
        // Adds to containers array
        svgContainers.push(this);
        /**
         * Create child div for the container - it will have svg node
         * It might seem that this container is not necessay, however having it solves
         * a problems with mouse position detection and some other.
         */
        var svgContainer = document.createElement("div");
        var style = svgContainer.style;
        style.width = "100%";
        style.height = "100%";
        style.position = "relative";
        htmlElement.appendChild(svgContainer);
        this.SVGContainer = svgContainer;
    }
    /**
     * Measures size of parent HTML element.
     *
     * @ignore Exclude from docs
     */
    SVGContainer.prototype.measure = function () {
        var width = Utils_width(this.htmlElement);
        var height = Utils_height(this.htmlElement);
        var container = this.container;
        if (container) {
            if (this.width != width || this.height != height) {
                this.width = width;
                this.height = height;
                if (width > 0) {
                    container.maxWidth = width;
                }
                if (height > 0) {
                    container.maxHeight = height;
                }
                fixPixelPerfect(this.SVGContainer);
            }
            if (!container.maxWidth) {
                container.maxWidth = 0;
            }
            if (!container.maxHeight) {
                container.maxHeight = 0;
            }
            this.cssScale = 1;
            this.checkTransform(this.htmlElement);
        }
    };
    Object.defineProperty(SVGContainer.prototype, "container", {
        /**
         * @return Container
         */
        get: function () {
            return this._container;
        },
        /**
         * A [[Container]] element which is placed into container.
         *
         * @param container  Container
         */
        set: function (container) {
            this._container = container;
            this.measure();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns if this object has been already been disposed.
     *
     * @return Is disposed?
     */
    SVGContainer.prototype.isDisposed = function () {
        return this._disposed;
    };
    /**
     * Removes this container from SVG container list in system, which
     * effectively disables size change monitoring for it.
     */
    SVGContainer.prototype.dispose = function () {
        if (!this._disposed) {
            remove(svgContainers, this);
        }
        each(this._disposers, function (item) {
            item.dispose();
        });
    };
    Object.defineProperty(SVGContainer.prototype, "hideOverflow", {
        /**
         * Indicates if chart container should have its style set
         * to `overflow: hidden`.
         *
         * Normally, we don't want that, so that certain elements, such as tooltips,
         * would be able to go outside chart area.
         *
         * There is one issue though. Some browsers ignore SVG masks and would
         * display scrollbars if chart elements, that go outside chart area extend
         * outside window.
         *
         * This is especially true for [[MapChart]], which can have its elements
         * extend very widely when zoomed in. Even if those parts are not visible
         * because of SVG masks, some browsers might still display window scrollbars.
         *
         * This is why we set this setting to `true` in [[MapChart]].
         *
         * Other charts use default of `false`.
         */
        set: function (value) {
            if (value) {
                this.SVGContainer.style.overflow = "hidden";
            }
            else {
                this.SVGContainer.style.overflow = "";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SVGContainer.prototype, "modal", {
        /**
         * ==========================================================================
         * MODAL/POPUP RELATED STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * Returns a [[Modal]] instance, associated with this chart.
         * (elements top parent)
         *
         * Accessing modal does not make it appear. To make a modal appear, use
         * `showModal()` method.
         *
         * @see {@link Modal} for more information about using Modal windows
         * @return Modal instance
         */
        get: function () {
            if (!hasValue(this._modal)) {
                // Create new modal
                this._modal = new Modal_Modal();
                this._modal.container = this.SVGContainer;
                // Add to disposers
                this._disposers.push(this._modal);
            }
            return this._modal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens a modal window with specific content (`text` parameter) and,
     * optionally, `title`.
     *
     * The `text` parameter can contain HTML content.
     *
     * @see {@link Modal} for more information about using Modal windows
     * @param text   Modal contents
     * @param title  Title for the modal window
     */
    SVGContainer.prototype.openModal = function (text, title) {
        // Hide previous modal
        this.closeModal();
        // Create modal
        var modal = this.modal;
        modal.content = text;
        modal.readerTitle = title || "";
        modal.title = title || "";
        modal.open();
        return modal;
    };
    /**
     * Hides modal window if there is one currently open.
     */
    SVGContainer.prototype.closeModal = function () {
        if (this._modal) {
            this.modal.close();
        }
    };
    Object.defineProperty(SVGContainer.prototype, "popups", {
        /**
         * A list of popups for this chart.
         *
         * @return Popups
         */
        get: function () {
            if (!hasValue(this._popups)) {
                // Create popup template
                var popupTemplate = new Popup_Popup();
                popupTemplate.container = this.SVGContainer;
                // Create the list
                this._popups = new List_ListTemplate(popupTemplate);
                // Add to disposers
                this._disposers.push(new List_ListDisposer(this._popups));
                this._disposers.push(this._popups.template);
            }
            return this._popups;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates, opens, and returns a new [[Popup]] window.
     *
     * `text` can be any valid HTML.
     *
     * `title` is currently not supported.
     *
     * @param text   Popup contents
     * @param title  Popup title
     * @return Popup instance
     */
    SVGContainer.prototype.openPopup = function (text, title) {
        var popup = this.popups.create();
        popup.content = text;
        if (hasValue(title)) {
            popup.title = title;
        }
        popup.open();
        return popup;
    };
    /**
     * Closes all currently open popup windows
     */
    SVGContainer.prototype.closeAllPopups = function () {
        this.popups.each(function (popup) {
            popup.close();
        });
    };
    Object.defineProperty(SVGContainer.prototype, "readerAlertElement", {
        /**
         * ==========================================================================
         * ACCESSIBILITY STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * A `<div>` element used as as placeholder to trigger screen alerts.
         *
         * @sunce 4.9.2
         * @return Element
         */
        get: function () {
            if (!hasValue(this._readerAlertElement)) {
                // Create element
                var div = document.createElement("div");
                div.setAttribute("role", "alert");
                div.style.zIndex = "-100000";
                div.style.opacity = "0";
                this.SVGContainer.appendChild(div);
                this._readerAlertElement = div;
            }
            return this._readerAlertElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Triggers screen reader read out a message.
     *
     * @since 4.9.2
     * @param  text  Alert text
     */
    SVGContainer.prototype.readerAlert = function (text) {
        this.readerAlertElement.innerHTML = text;
    };
    /**
     * ==========================================================================
     * OTHER STUFF
     * ==========================================================================
     * @hidden
     */
    SVGContainer.prototype.checkTransform = function (div) {
        if (window.getComputedStyle) {
            if (div && div.style) {
                var style = window.getComputedStyle(div, null);
                if (style) {
                    var matrix = style.getPropertyValue("-webkit-transform") ||
                        style.getPropertyValue("-moz-transform") ||
                        style.getPropertyValue("-ms-transform") ||
                        style.getPropertyValue("-o-transform") ||
                        style.getPropertyValue("transform");
                    if (matrix && matrix !== "none") {
                        var values = matrix.split('(')[1].split(')')[0].split(',');
                        var a = Number(values[0]);
                        var b = Number(values[1]);
                        var scale = Math.sqrt(a * a + b * b);
                        if (!isNaN(scale)) {
                            this.cssScale *= scale;
                        }
                    }
                }
            }
            if (div.parentNode && div.parentNode instanceof HTMLElement) {
                this.checkTransform(div.parentNode);
            }
        }
    };
    return SVGContainer;
}());

//# sourceMappingURL=SVGContainer.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/Paper.js
/**
 * Paper class just like the white sheet of pressed fiber it draws its name
 * inspiration from is used as a starting point to start a drawing.
 *
 * Before we can start adding elements (drawing) we need to take out a new sheet
 * of paper, or in this instance create a blank SVG element.
 *
 * This class creates such element, as well as implements methods needed to
 * start adding elements to it.
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Paper class which when instantiated will create an SVG element as well as
 * some of the sub-elements like `<desc>`, `<defs>`.
 *
 * Use its methods like `addGroup` and `append` to add elements to the paper.
 */
var Paper_Paper = /** @class */ (function () {
    /**
     * Creates main `<svg>` container and related elements.
     *
     * @param container A reference to HTML element to create `<svg>` in
     */
    function Paper(container, id) {
        // Store container reference
        this.container = container;
        this.id = id;
        // Create SVG element
        var svg = document.createElementNS(SVGNS, "svg");
        svg.setAttribute("version", "1.1");
        svg.setAttributeNS(XMLNS, "xmlns", SVGNS);
        svg.setAttributeNS(XMLNS, "xmlns:xlink", XLINK);
        svg.setAttribute("role", "group");
        this.container.appendChild(svg);
        // Add description
        //let desc: SVGElement = <SVGElement>document.createElementNS($dom.SVGNS, "desc");
        //desc.appendChild(document.createTextNode("JavaScript chart by amCharts"));
        //svg.appendChild(desc);
        // Add defs
        this.defs = document.createElementNS(SVGNS, "defs");
        svg.appendChild(this.defs);
        // Set width and height to fit container
        svg.style.width = "100%";
        svg.style.height = "100%";
        svg.style.overflow = "visible";
        // Store variable
        this.svg = svg;
    }
    /**
     * Creates and returns a new element. Does not attach it to Paper yet.
     *
     * @param elementName  Element name
     * @return New element
     */
    Paper.prototype.add = function (elementName) {
        return new AMElement_AMElement(elementName);
    };
    /**
     * Creates and returns a new Group element. Does not attach it to Paper.
     *
     * @param groupName  Element name
     * @return New Group
     */
    Paper.prototype.addGroup = function (groupName) {
        return new Group_Group(groupName);
    };
    /**
     * Appends an element to Paper.
     *
     * @param element Element to append
     */
    Paper.prototype.append = function (element) {
        if (element) {
            this.svg.appendChild(element.node);
        }
    };
    /**
     * Appends an element to `<defs>` block of the Paper.
     *
     * @param element  Element
     */
    Paper.prototype.appendDef = function (element) {
        if (element) {
            this.defs.appendChild(element.node);
        }
    };
    /**
     * Creates and returns new `<foreignObject>` element. Does not append it to
     * Paper.
     *
     * @return A foreignObject element
     */
    Paper.prototype.foreignObject = function () {
        var element = new AMElement_AMElement("foreignObject");
        //this.append(element);
        return element;
    };
    /**
     * Checks if browser supports `<foreignObject>` elements.
     *
     * @return Supports `foreignObject`?
     */
    Paper.prototype.supportsForeignObject = function () {
        return document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Extensibility", "1.1");
    };
    return Paper;
}());

var ghostPaper = null;
/**
 * A [[Paper]] instance to create elements, that are not yet ready to be
 * placed in visible DOM.
 *
 * @ignore Exclude from docs
 */
function getGhostPaper() {
    if (ghostPaper === null) {
        // ghost is used to draw elements while real paper is not yet created or Sprite doesn't know parent yet
        var ghostDiv = document.createElement("div");
        ghostDiv.hidden = true;
        document.body.appendChild(ghostDiv);
        var ghostSvgContainer = new SVGContainer_SVGContainer(ghostDiv, true);
        ghostPaper = new Paper_Paper(ghostSvgContainer.SVGContainer, "ghost");
    }
    return ghostPaper;
}
//# sourceMappingURL=Paper.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/Pattern.js
/**
 * Pattern module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Base class to define patterns.
 */
var Pattern_Pattern = /** @class */ (function (_super) {
    __extends(Pattern, _super);
    //public propertyValues = new Dictionary<PatternProperties, any>();
    /**
     * Constructor
     */
    function Pattern() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * List of elements the pattern consists of.
         */
        _this._elements = new List_List();
        /**
         * A storage for Filter property/value pairs.
         *
         * @ignore Exclude from docs
         * @see {@link PatternProperties}
         */
        _this.properties = {};
        _this.className = "Pattern";
        // Set defaults
        _this.width = 10;
        _this.height = 10;
        _this.x = 0;
        _this.y = 0;
        _this.patternUnits = "userSpaceOnUse";
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.backgroundFill = interfaceColors.getFor("background");
        _this.backgroundOpacity = 0;
        _this.fillOpacity = 1;
        _this.fill = interfaceColors.getFor("alternativeBackground");
        _this.stroke = interfaceColors.getFor("alternativeBackground");
        _this.strokeOpacity = 1;
        _this.strokeWidth = 1;
        _this.shapeRendering = "crispEdges";
        _this.rotation = 0;
        // Create main group to store pattern elements inelements
        _this.element = _this.paper.addGroup("pattern");
        _this.id = "pattern-" + registry.getUniqueId();
        _this.element.attr({ "id": _this.id });
        _this._disposers.push(_this.element);
        // Make elements disposable
        _this._disposers.push(new List_ListDisposer(_this._elements));
        // Request again to trigger getter/setter code
        _this.patternUnits = _this.patternUnits;
        _this.width = _this.width;
        _this.height = _this.height;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the pattern.
     */
    Pattern.prototype.draw = function () {
        var _this = this;
        var patternElement = this.element;
        if (patternElement) {
            patternElement.removeChildNodes();
            var background = this.paper.add("rect");
            background.attr({ "width": this.width, "height": this.height, "shape-rendering": "crispEdges", "fill": this.backgroundFill.hex, "fill-opacity": this.backgroundOpacity, "stroke": this.backgroundFill.hex, "stroke-opacity": this.backgroundOpacity });
            patternElement.add(background);
            patternElement.attr({ "x": this.x, "y": this.y, "width": this.width, "height": this.height, "stroke": this.stroke.hex, "fill": this.fill.hex, "fill-opacity": this.fillOpacity, "stroke-opacity": this.strokeOpacity, "stroke-width": this.strokeWidth, "shape-rendering": this.shapeRendering, "patternUnits": this.patternUnits, "stroke-dasharray": this.strokeDasharray });
            Iterator_each(this._elements.iterator(), function (element) {
                element.rotation = _this.rotation;
                element.rotationX = _this.properties["rotationX"];
                element.rotationY = _this.properties["rotationY"];
                _this.element.add(element);
            });
        }
    };
    /**
     * Animate pattern properties.
     *
     * @see {@link Animation}
     * @param animationOptions  Animation options
     * @param duration          Duration (ms)
     * @param easing            Easing function
     * @return Animation instance
     */
    Pattern.prototype.animate = function (animationOptions, duration, easing) {
        return new Animation_Animation(this, animationOptions, duration, easing).start();
    };
    /**
     * Adds an element to the pattern.
     *
     * @param element  Element
     */
    Pattern.prototype.addElement = function (element) {
        this._elements.push(element);
        this._disposers.push(element);
    };
    /**
     * Remove an element from the pattern.
     *
     * @param element  Element
     */
    Pattern.prototype.removeElement = function (element) {
        this._elements.removeValue(element);
        this.removeDispose(element);
    };
    Object.defineProperty(Pattern.prototype, "elements", {
        /**
         * Returns the list of SVG elements comprising the pattern.
         *
         * @return Pattern elements
         */
        get: function () {
            return this._elements;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "fillOpacity", {
        /**
         * @return Opacity (0-1)
         */
        get: function () {
            return this.properties["fillOpacity"];
        },
        /**
         * Pattern fill opacity. (0-1)
         *
         * @param value  Opacity (0-1)
         */
        set: function (value) {
            this.properties["fillOpacity"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "fill", {
        /**
         * @return Fill color
         */
        get: function () {
            return this.properties["fill"];
        },
        /**
         * Fill color of the pattern.
         *
         * @param value  Fill color
         */
        set: function (value) {
            this.properties["fill"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "backgroundFill", {
        /**
         * @return Background color
         */
        get: function () {
            return this.properties["backgroundFill"];
        },
        /**
         * Pattern background fill color.
         *
         * @param value  Background color
         */
        set: function (value) {
            this.properties["backgroundFill"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "backgroundOpacity", {
        /**
         * @return Background opacity (0-1)
         */
        get: function () {
            return this.properties["backgroundOpacity"];
        },
        /**
         * Pattern backgorund opacity. (0-1)
         *
         * @param value  Background opacity (0-1)
         */
        set: function (value) {
            this.properties["backgroundOpacity"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "stroke", {
        /**
         * @return Color
         */
        get: function () {
            return this.properties["stroke"];
        },
        /**
         * Pattern stroke (border) color.
         *
         * @param value  Color
         */
        set: function (value) {
            this.properties["stroke"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "strokeOpacity", {
        /**
         * @return Opacity (0-1)
         */
        get: function () {
            return this.properties["strokeOpacity"];
        },
        /**
         * Pattern stroke opacity. (0-1)
         *
         * @param value  Opacity (0-1)
         */
        set: function (value) {
            this.properties["strokeOpacity"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "strokeWidth", {
        /**
         * @return Stroke thickness (px)
         */
        get: function () {
            return this.properties["strokeWidth"];
        },
        /**
         * Pattern stroke thickness in pixels.
         *
         * @param value  Stroke thickness (px)
         */
        set: function (value) {
            this.properties["strokeWidth"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "shapeRendering", {
        get: function () {
            return this.properties["shapeRendering"];
        },
        /**
         * Shape rendering
         * @param value [description]
         */
        set: function (value) {
            this.properties["shapeRendering"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "rotation", {
        /**
         * @return Rotation
         */
        get: function () {
            return this.properties["rotation"];
        },
        /**
         * Pattern rotation in degrees.
         *
         * @param value  Rotation
         */
        set: function (value) {
            this.properties["rotation"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "patternUnits", {
        /**
         * @return Units
         */
        get: function () {
            return this.properties["patternUnits"];
        },
        /**
         * Pattern measuring units.
         *
         * Available options: "userSpaceOnUse" | "objectBoundingBox".
         *
         * @param value  Units
         */
        set: function (value) {
            this.properties["patternUnits"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "width", {
        /**
         * @return Width (px)
         */
        get: function () {
            return this.properties["width"];
        },
        /**
         * Pattern width in pixels.
         *
         * @param value  Width (px)
         */
        set: function (value) {
            this.properties["width"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "height", {
        /**
         * @return Height (px)
         */
        get: function () {
            return this.properties["height"];
        },
        /**
         * Pattern height in pixels.
         *
         * @param value Height (px)
         */
        set: function (value) {
            this.properties["height"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "x", {
        /**
         * @return X (px)
         */
        get: function () {
            return this.properties["x"];
        },
        /**
         * X position. (pixels)
         *
         * @param value X (px)
         */
        set: function (value) {
            this.properties["x"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "y", {
        /**
         * @return Y (px)
         */
        get: function () {
            return this.properties["y"];
        },
        /**
         * Y position (px).
         *
         * @param value Y (px)
         */
        set: function (value) {
            this.properties["y"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "paper", {
        /**
         * @ignore Exclude from docs
         * @return Paper
         */
        get: function () {
            if (this._paper) {
                return this._paper;
            }
            return getGhostPaper();
        },
        /**
         * [[Paper]] instance to draw pattern in.
         *
         * @ignore Exclude from docs
         * @param paper  Paper
         */
        set: function (paper) {
            if (this._paper != paper) {
                this._paper = paper;
                this.draw();
                paper.appendDef(this.element);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies properties from another Pattern instance.
     *
     * @param source  Source pattern
     */
    Pattern.prototype.copyFrom = function (source) {
        var _this = this;
        _super.prototype.copyFrom.call(this, source);
        Object_each(source.properties, function (key, value) {
            _this[key] = value;
        });
    };
    Object.defineProperty(Pattern.prototype, "animations", {
        /**
         * A list of animations currently running on the patter.
         *
         * @ignore Exclude from docs
         * @return Animation list
         */
        get: function () {
            if (!this._animations) {
                this._animations = [];
                this._disposers.push(new Animation_AnimationDisposer(this._animations));
            }
            return this._animations;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Pattern.prototype, "strokeDasharray", {
        /**
         * @return `stroke-dasharray`
         */
        get: function () {
            return this.properties["strokeDashArray"];
        },
        /**
         * A `stroke-dasharray` for the stroke (outline).
         *
         * "Dasharray" allows setting rules to make lines dashed, dotted, etc.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more info on `stroke-dasharray`
         * @param value  `stroke-dasharray`
         */
        set: function (value) {
            this.properties["strokeDashArray"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    Pattern.prototype.processConfig = function (config) {
        if (config) {
            // Set up series
            if (hasValue(config.elements) && isArray(config.elements)) {
                for (var i = 0, len = config.elements.length; i < len; i++) {
                    var element = config.elements[i];
                    if (hasValue(element["type"])) {
                        var sprite = this.createEntryInstance(element);
                        if (sprite instanceof Base_BaseObject) {
                            sprite.config = element;
                        }
                        this.addElement(hasValue(element["typeProperty"])
                            ? sprite[element["typeProperty"]]
                            : sprite.element);
                    }
                }
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    return Pattern;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Pattern"] = Pattern_Pattern;
//# sourceMappingURL=Pattern.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/LinearGradient.js
/**
 * Contains code and logic for generating linear gradients.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Linear gradient class.
 */
var LinearGradient_LinearGradient = /** @class */ (function (_super) {
    __extends(LinearGradient, _super);
    /**
     * Constructor.
     */
    function LinearGradient() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * List of colors switch definitions in a gradient.
         */
        _this._stops = new List_List();
        /**
         * Gradient direction.
         */
        _this._rotation = 0;
        _this.className = "LinearGradient";
        _this._stops.events.on("setIndex", _this.validate, _this);
        _this._stops.events.on("inserted", _this.validate, _this);
        // Create element
        _this.element = _this.paper.addGroup("linearGradient");
        _this.id = "gradient-" + registry.getUniqueId();
        _this.element.attr({ "id": _this.id });
        _this._disposers.push(_this.element);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws gradient.
     *
     * @ignore Exclude from docs
     */
    LinearGradient.prototype.validate = function () {
        var _this = this;
        var rotation = (this._rotation + 90) * RADIANS;
        var x1 = Math.round(50 + Math.sin(rotation + Math.PI) * 50) + '%';
        var y1 = Math.round(50 + Math.cos(rotation) * 50) + '%';
        var x2 = Math.round(50 + Math.sin(rotation) * 50) + '%';
        var y2 = Math.round(50 + Math.cos(rotation + Math.PI) * 50) + '%';
        var gradientElement = this.element;
        gradientElement.removeChildNodes();
        gradientElement.attr({ "x1": x1, "x2": x2, "y1": y1, "y2": y2 });
        Iterator_each(indexed(this._stops.iterator()), function (a) {
            var i = a[0];
            var stop = a[1];
            var offset = stop.offset;
            if (!isNumber(offset)) {
                offset = i / (_this._stops.length - 1);
            }
            var gradientStop = _this.paper.add("stop");
            if (hasValue(stop.color)) {
                gradientStop.attr({ "stop-color": stop.color.toString() });
            }
            if (isNumber(stop.opacity)) {
                gradientStop.attr({ "stop-opacity": stop.opacity });
            }
            if (isNumber(offset)) {
                gradientStop.attr({ "offset": offset });
            }
            gradientElement.add(gradientStop);
        });
    };
    /**
     * Clears the gradient.
     *
     * @ignore Exclude from docs
     */
    LinearGradient.prototype.clear = function () {
        this._stops.clear();
    };
    /**
     * Adds a color step to the gradient.
     *
     * @param color    Color (hex code or named color)
     * @param opacity  Opacity (value from 0 to 1; 0 completely transaprent, 1 fully opaque)
     * @param offset   Position of color in the gradient (value 0 to 1; 0 meaning start of the gradient and 1 end)
     */
    LinearGradient.prototype.addColor = function (color, opacity, offset) {
        this._stops.push({ color: color, opacity: opacity, offset: offset });
    };
    Object.defineProperty(LinearGradient.prototype, "stops", {
        /**
         * A list of color stops in the gradient.
         *
         * @return Stops
         */
        get: function () {
            return this._stops;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGradient.prototype, "paper", {
        /**
         * @ignore Exclude from docs
         * @return Paper
         */
        get: function () {
            if (this._paper) {
                return this._paper;
            }
            return getGhostPaper();
        },
        /**
         * [[Paper]] instace to use for the gradient.
         *
         * @ignore Exclude from docs
         * @param paper  Paper
         */
        set: function (paper) {
            if (this._paper != paper) {
                this._paper = paper;
                this.validate();
                paper.appendDef(this.element);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LinearGradient.prototype, "rotation", {
        /**
         * @return Rotation
         */
        get: function () {
            return this._rotation;
        },
        /**
         * Rotation (direction) of the gradient in degrees.
         *
         * @param value  Rotation
         */
        set: function (value) {
            //this.element.attr({ "gradientTransform": "rotate(" + value + " 10 100)" });
            this._rotation = value;
            this.validate();
        },
        enumerable: true,
        configurable: true
    });
    LinearGradient.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.stops.copyFrom(source.stops);
        this._rotation = source.rotation;
    };
    Object.defineProperty(LinearGradient.prototype, "gradientUnits", {
        /**
         * Which units are used when drawing gradient filter.
         *
         * Use `"userSpaceOnUse"` when applying gradient on a perfectly straight line.
         *
         * @since 4.9.17
         * @default objectBoundingBox
         * @param value Filter units
         */
        set: function (value) {
            this.element.attr({ gradientUnits: value });
        },
        enumerable: true,
        configurable: true
    });
    return LinearGradient;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["LinearGradient"] = LinearGradient_LinearGradient;
//# sourceMappingURL=LinearGradient.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/RadialGradient.js
/**
 * Contains code and logic for generating radial gradients.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Radial gradient class.
 */
var RadialGradient_RadialGradient = /** @class */ (function (_super) {
    __extends(RadialGradient, _super);
    /**
     * Constructor
     */
    function RadialGradient() {
        var _this = _super.call(this) || this;
        /**
         * List of colors switch definitions in a gradient.
         */
        _this._stops = new List_List();
        _this.element = _this.paper.addGroup("radialGradient");
        _this.id = "gradient-" + registry.getUniqueId();
        _this.element.attr({ "id": _this.id });
        _this._disposers.push(_this.element);
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws gradient.
     */
    RadialGradient.prototype.draw = function () {
        var _this = this;
        var gradientElement = this.element;
        if (isNumber(this.cx)) {
            var value = this.cx;
            if (value instanceof Percent) {
                value = value.percent + "%";
            }
            gradientElement.attr({ "cx": value });
        }
        if (isNumber(this.cy)) {
            var value = this.cy;
            if (value instanceof Percent) {
                value = value.percent + "%";
            }
            gradientElement.attr({ "cy": value });
        }
        if (this.fx) {
            var value = this.fx;
            if (value instanceof Percent) {
                value = value.percent + "%";
            }
            gradientElement.attr({ "fx": value });
        }
        if (this.fy) {
            var value = this.fy;
            if (value instanceof Percent) {
                value = value.percent + "%";
            }
            gradientElement.attr({ "fy": value });
        }
        gradientElement.removeChildNodes();
        Iterator_each(indexed(this._stops.iterator()), function (a) {
            var i = a[0];
            var stop = a[1];
            var offset = stop.offset;
            if (!isNumber(offset)) {
                offset = i / (_this._stops.length - 1);
            }
            var gradientStop = _this.paper.add("stop");
            if (hasValue(stop.color)) {
                gradientStop.attr({ "stop-color": stop.color.toString() });
            }
            if (isNumber(stop.opacity)) {
                gradientStop.attr({ "stop-opacity": stop.opacity });
            }
            if (isNumber(offset)) {
                gradientStop.attr({ "offset": offset });
            }
            gradientElement.add(gradientStop);
        });
    };
    /**
     * Adds a color step to the gradient.
     *
     * @param color    Color (hex code or named color)
     * @param opacity  Opacity (value from 0 to 1; 0 completely transaprent, 1 fully opaque)
     * @param offset   Position of color in the gradient (value 0 to 1; 0 meaning start of the gradient and 1 end)
     */
    RadialGradient.prototype.addColor = function (color, opacity, offset) {
        this._stops.push({ color: color, opacity: opacity, offset: offset });
        this.draw();
    };
    Object.defineProperty(RadialGradient.prototype, "paper", {
        /**
         * @ignore Exclude from docs
         * @return Paper
         */
        get: function () {
            if (this._paper) {
                return this._paper;
            }
            return getGhostPaper();
        },
        /**
         * A [[Paper]] instace to use for the gradient.
         *
         * @ignore Exclude from docs
         * @param paper  Paper
         */
        set: function (paper) {
            if (this._paper != paper) {
                this._paper = paper;
                this.draw();
                paper.appendDef(this.element);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadialGradient.prototype, "cx", {
        get: function () {
            return this._cx;
        },
        /**
         * Center x coordinate of the gradient, can be set as number or Percent
         *
         * @param point  Center point
         */
        set: function (value) {
            this._cx = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadialGradient.prototype, "cy", {
        get: function () {
            return this._cy;
        },
        /**
         * Center y coordinate of the gradient, can be set as number or Percent
         *
         * @param point  Center point
         */
        set: function (value) {
            this._cy = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadialGradient.prototype, "fx", {
        get: function () {
            return this._fx;
        },
        /**
         * y coordinate of the focal point of a gradient, can be set in pixels or as Percent
         *
         * @param point  Center point
         */
        set: function (value) {
            this._fx = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadialGradient.prototype, "fy", {
        get: function () {
            return this._fy;
        },
        /**
         * y coordinate of the focal point of a gradient, can be set in pixels or as Percent
         *
         * @param point  Center point
         */
        set: function (value) {
            this._fy = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    RadialGradient.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.stops.copyFrom(source.stops);
        this.cx = source.cx;
        this.cy = source.cy;
        this.fx = source.fx;
        this.fy = source.fy;
    };
    Object.defineProperty(RadialGradient.prototype, "stops", {
        /**
         * A list of color stops in the gradient.
         *
         * @return Stops
         */
        get: function () {
            return this._stops;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clears the gradient.
     *
     * @ignore Exclude from docs
     */
    RadialGradient.prototype.clear = function () {
        this._stops.clear();
    };
    return RadialGradient;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["RadialGradient"] = RadialGradient_RadialGradient;
//# sourceMappingURL=RadialGradient.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/interaction/Mouse.js
/**
 * Mouse-related functionality
 */
/**
 * Defines static methods that hold style list for various mouse cursor styles,
 * maintaining browser compatibility.
 */
var MouseCursorStyle = /** @class */ (function () {
    function MouseCursorStyle() {
    }
    /**
     * Styles for "grab" mouse cursor.
     */
    MouseCursorStyle.grab = [{
            "property": "cursor",
            "value": "move"
        }, {
            "property": "cursor",
            "value": "grab"
        }, {
            "property": "cursor",
            "value": "-webkit-grab"
        }];
    /**
     * Styles for "grabbing" mouse cursor.
     */
    MouseCursorStyle.grabbing = [{
            "property": "cursor",
            "value": "move"
        }, {
            "property": "cursor",
            "value": "grabbing"
        }, {
            "property": "cursor",
            "value": "-webkit-grabbing"
        }];
    /**
     * Styles for "pointer" mouse cursor. (usually used for links)
     */
    MouseCursorStyle.pointer = [{
            "property": "cursor",
            "value": "pointer"
        }];
    /**
     * Styles for default mouse cursor. (browser determines style)
     */
    MouseCursorStyle.default = [{
            "property": "cursor",
            "value": "default"
        }];
    /**
     * Styles for horizontal bi-directional resize mouse cursor.
     */
    MouseCursorStyle.horizontalResize = [{
            "property": "cursor",
            "value": "ew-resize"
        }];
    /**
     * Styles for vertical bi-directional mouse cursor.
     */
    MouseCursorStyle.verticalResize = [{
            "property": "cursor",
            "value": "ns-resize"
        }];
    /**
     * Styles for "no-allowed" cursor.
     * @since 4.7.15
     */
    MouseCursorStyle.notAllowed = [{
            "property": "cursor",
            "value": "not-allowed"
        }];
    /**
     * Styles for "text" cursor.
     * @since 4.9.12
     */
    MouseCursorStyle.text = [{
            "property": "cursor",
            "value": "text"
        }];
    return MouseCursorStyle;
}());

//# sourceMappingURL=Mouse.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/lang/en.js
/**
 * amCharts 4 locale
 *
 * Locale: en
 * Language: International English
 * Author: Martynas Majeris
 *
 * Follow instructions in [on this page](https://www.amcharts.com/docs/v4/tutorials/creating-translations/) to make corrections or add new translations.
 *
 * ---
 * Edit but leave the header section above this line. You can remove any
 * subsequent comment sections.
 * ---
 *
 * Use this file as a template to create translations. Leave the key part in
 * English intact. Fill the value with a translation.
 *
 * Empty string means no translation, so default "International English"
 * will be used.
 *
 * If you need the translation to literally be an empty string, use `null`
 * instead.
 *
 * IMPORTANT:
 * When translating make good effort to keep the translation length
 * at least the same chartcount as the English, especially for short prompts.
 *
 * Having significantly longer prompts may distort the actual charts.
 *
 * NOTE:
 * Some prompts - like months or weekdays - come in two versions: full and
 * shortened.
 *
 * If there's no official shortened version of these in your language, and it
 * would not be possible to invent such short versions that don't seem weird
 * to native speakers of that language, fill those with the same as full
 * version.
 *
 * PLACEHOLDERS:
 * Some prompts have placeholders like "%1". Those will be replaced by actual
 * values during translation and should be retained in the translated prompts.
 *
 * Placeholder positions may be changed to better suit structure of the
 * sentence.
 *
 * For example "From %1 to %2", when actually used will replace "%1" with an
 * actual value representing range start, and "%2" will be replaced by end
 * value.
 *
 * E.g. in a Scrollbar for Value axis "From %1 to %2" will become
 * "From 100 to 200". You may translate "From" and "to", as well as re-arrange
 * the order of the prompt itself, but make sure the "%1" and "%2" remain, in
 * places where they will make sense.
 *
 * Save the file as language_LOCALE, i.e. `en_GB.ts`, `fr_FR.ts`, etc.
 */
/* harmony default export */ var en = ({
    // Number formatting options.
    // 
    // Please check with the local standards which separator is accepted to be
    // used for separating decimals, and which for thousands.
    "_decimalSeparator": ".",
    "_thousandSeparator": ",",
    // Suffixes for numbers
    // When formatting numbers, big or small numers might be reformatted to
    // shorter version, by applying a suffix.
    // 
    // For example, 1000000 might become "1m".
    // Or 1024 might become "1KB" if we're formatting byte numbers.
    // 
    // This section defines such suffixes for all such cases.
    "_big_number_suffix_3": "k",
    "_big_number_suffix_6": "M",
    "_big_number_suffix_9": "G",
    "_big_number_suffix_12": "T",
    "_big_number_suffix_15": "P",
    "_big_number_suffix_18": "E",
    "_big_number_suffix_21": "Z",
    "_big_number_suffix_24": "Y",
    "_small_number_suffix_3": "m",
    "_small_number_suffix_6": "μ",
    "_small_number_suffix_9": "n",
    "_small_number_suffix_12": "p",
    "_small_number_suffix_15": "f",
    "_small_number_suffix_18": "a",
    "_small_number_suffix_21": "z",
    "_small_number_suffix_24": "y",
    "_byte_suffix_B": "B",
    "_byte_suffix_KB": "KB",
    "_byte_suffix_MB": "MB",
    "_byte_suffix_GB": "GB",
    "_byte_suffix_TB": "TB",
    "_byte_suffix_PB": "PB",
    // Default date formats for various periods.
    // 
    // This should reflect official or de facto formatting universally accepted
    // in the country translation is being made for
    // Available format codes here:
    // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Format_codes
    // 
    // This will be used when formatting date/time for particular granularity,
    // e.g. "_date_hour" will be shown whenever we need to show time as hours.
    // 
    // "date" is used as in default date format when showing standalone dates.
    "_date": "yyyy-MM-dd",
    "_date_millisecond": "mm:ss SSS",
    "_date_second": "HH:mm:ss",
    "_date_minute": "HH:mm",
    "_date_hour": "HH:mm",
    "_date_day": "MMM dd",
    "_date_week": "ww",
    "_date_month": "MMM",
    "_date_year": "yyyy",
    // Default duration formats for various base units.
    // 
    // This will be used by DurationFormatter to format numeric values into
    // duration.
    // 
    // Notice how each duration unit comes in several versions. This is to ensure
    // that each base unit is shown correctly.
    // 
    // For example, if we have baseUnit set to "second", meaning our duration is
    // in seconds.
    // 
    // If we pass in `50` to formatter, it will know that we have just 50 seconds
    // (less than a minute) so it will use format in `"_duration_second"` ("ss"),
    // and the formatted result will be in like `"50"`.
    // 
    // If we pass in `70`, which is more than a minute, the formatter will switch
    // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted
    // text.
    // 
    // Available codes here:
    // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes
    "_duration_millisecond": "SSS",
    "_duration_millisecond_second": "ss.SSS",
    "_duration_millisecond_minute": "mm:ss SSS",
    "_duration_millisecond_hour": "hh:mm:ss SSS",
    "_duration_millisecond_day": "d'd' mm:ss SSS",
    "_duration_millisecond_week": "d'd' mm:ss SSS",
    "_duration_millisecond_month": "M'm' dd'd' mm:ss SSS",
    "_duration_millisecond_year": "y'y' MM'm' dd'd' mm:ss SSS",
    "_duration_second": "ss",
    "_duration_second_minute": "mm:ss",
    "_duration_second_hour": "hh:mm:ss",
    "_duration_second_day": "d'd' hh:mm:ss",
    "_duration_second_week": "d'd' hh:mm:ss",
    "_duration_second_month": "M'm' dd'd' hh:mm:ss",
    "_duration_second_year": "y'y' MM'm' dd'd' hh:mm:ss",
    "_duration_minute": "mm",
    "_duration_minute_hour": "hh:mm",
    "_duration_minute_day": "d'd' hh:mm",
    "_duration_minute_week": "d'd' hh:mm",
    "_duration_minute_month": "M'm' dd'd' hh:mm",
    "_duration_minute_year": "y'y' MM'm' dd'd' hh:mm",
    "_duration_hour": "hh'h'",
    "_duration_hour_day": "d'd' hh'h'",
    "_duration_hour_week": "d'd' hh'h'",
    "_duration_hour_month": "M'm' dd'd' hh'h'",
    "_duration_hour_year": "y'y' MM'm' dd'd' hh'h'",
    "_duration_day": "d'd'",
    "_duration_day_week": "d'd'",
    "_duration_day_month": "M'm' dd'd'",
    "_duration_day_year": "y'y' MM'm' dd'd'",
    "_duration_week": "w'w'",
    "_duration_week_month": "w'w'",
    "_duration_week_year": "w'w'",
    "_duration_month": "M'm'",
    "_duration_month_year": "y'y' MM'm'",
    "_duration_year": "y'y'",
    // Era translations
    "_era_ad": "AD",
    "_era_bc": "BC",
    // Day part, used in 12-hour formats, e.g. 5 P.M.
    // Please note that these come in 3 variants:
    // * one letter (e.g. "A")
    // * two letters (e.g. "AM")
    // * two letters with dots (e.g. "A.M.")
    // 
    // All three need to to be translated even if they are all the same. Some
    // users might use one, some the other.
    "A": "",
    "P": "",
    "AM": "",
    "PM": "",
    "A.M.": "",
    "P.M.": "",
    // Date-related stuff.
    // 
    // When translating months, if there's a difference, use the form which is
    // best for a full date, e.g. as you would use it in "2018 January 1".
    // 
    // Note that May is listed twice. This is because in English May is the same
    // in both long and short forms, while in other languages it may not be the
    // case. Translate "May" to full word, while "May(short)" to shortened
    // version.
    // 
    // Should month names and weekdays be capitalized or not?
    // 
    // Rule of thumb is this: if the names should always be capitalized,
    // regardless of name position within date ("January", "21st January 2018",
    // etc.) use capitalized names. Otherwise enter all lowercase.
    // 
    // The date formatter will automatically capitalize names if they are the
    // first (or only) word in resulting date.
    "January": "",
    "February": "",
    "March": "",
    "April": "",
    "May": "",
    "June": "",
    "July": "",
    "August": "",
    "September": "",
    "October": "",
    "November": "",
    "December": "",
    "Jan": "",
    "Feb": "",
    "Mar": "",
    "Apr": "",
    "May(short)": "May",
    "Jun": "",
    "Jul": "",
    "Aug": "",
    "Sep": "",
    "Oct": "",
    "Nov": "",
    "Dec": "",
    // Weekdays.
    "Sunday": "",
    "Monday": "",
    "Tuesday": "",
    "Wednesday": "",
    "Thursday": "",
    "Friday": "",
    "Saturday": "",
    "Sun": "",
    "Mon": "",
    "Tue": "",
    "Wed": "",
    "Thu": "",
    "Fri": "",
    "Sat": "",
    // Date ordinal function.
    // 
    // This is used when adding number ordinal when formatting days in dates.
    // 
    // E.g. "January 1st", "February 2nd".
    // 
    // The function accepts day number, and returns a string to be added to the
    // day, like in default English translation, if we pass in 2, we will receive
    // "nd" back.
    "_dateOrd": function (day) {
        var res = "th";
        if ((day < 11) || (day > 13)) {
            switch (day % 10) {
                case 1:
                    res = "st";
                    break;
                case 2:
                    res = "nd";
                    break;
                case 3:
                    res = "rd";
                    break;
            }
        }
        return res;
    },
    // Various chart controls.
    // Shown as a tooltip on zoom out button.
    "Zoom Out": "",
    // Timeline buttons
    "Play": "",
    "Stop": "",
    // Chart's Legend screen reader title.
    "Legend": "",
    // Legend's item screen reader indicator.
    "Click, tap or press ENTER to toggle": "",
    // Shown when the chart is busy loading something.
    "Loading": "",
    // Shown as the first button in the breadcrumb navigation, e.g.:
    // Home > First level > ...
    "Home": "",
    // Chart types.
    // Those are used as default screen reader titles for the main chart element
    // unless developer has set some more descriptive title.
    "Chart": "",
    "Serial chart": "",
    "X/Y chart": "",
    "Pie chart": "",
    "Gauge chart": "",
    "Radar chart": "",
    "Sankey diagram": "",
    "Flow diagram": "",
    "Chord diagram": "",
    "TreeMap chart": "",
    "Force directed tree": "",
    "Sliced chart": "",
    // Series types.
    // Used to name series by type for screen readers if they do not have their
    // name set.
    "Series": "",
    "Candlestick Series": "",
    "OHLC Series": "",
    "Column Series": "",
    "Line Series": "",
    "Pie Slice Series": "",
    "Funnel Series": "",
    "Pyramid Series": "",
    "X/Y Series": "",
    // Map-related stuff.
    "Map": "",
    "Press ENTER to zoom in": "",
    "Press ENTER to zoom out": "",
    "Use arrow keys to zoom in and out": "",
    "Use plus and minus keys on your keyboard to zoom in and out": "",
    // Export-related stuff.
    // These prompts are used in Export menu labels.
    // 
    // "Export" is the top-level menu item.
    // 
    // "Image", "Data", "Print" as second-level indicating type of export
    // operation.
    // 
    // Leave actual format untranslated, unless you absolutely know that they
    // would convey more meaning in some other way.
    "Export": "",
    "Image": "",
    "Data": "",
    "Print": "",
    "Click, tap or press ENTER to open": "",
    "Click, tap or press ENTER to print.": "",
    "Click, tap or press ENTER to export as %1.": "",
    'To save the image, right-click this link and choose "Save picture as..."': "",
    'To save the image, right-click thumbnail on the left and choose "Save picture as..."': "",
    "(Press ESC to close this message)": "",
    "Image Export Complete": "",
    "Export operation took longer than expected. Something might have gone wrong.": "",
    "Saved from": "",
    "PNG": "",
    "JPG": "",
    "GIF": "",
    "SVG": "",
    "PDF": "",
    "JSON": "",
    "CSV": "",
    "XLSX": "",
    // Scrollbar-related stuff.
    // 
    // Scrollbar is a control which can zoom and pan the axes on the chart.
    // 
    // Each scrollbar has two grips: left or right (for horizontal scrollbar) or
    // upper and lower (for vertical one).
    // 
    // Prompts change in relation to whether Scrollbar is vertical or horizontal.
    // 
    // The final section is used to indicate the current range of selection.
    "Use TAB to select grip buttons or left and right arrows to change selection": "",
    "Use left and right arrows to move selection": "",
    "Use left and right arrows to move left selection": "",
    "Use left and right arrows to move right selection": "",
    "Use TAB select grip buttons or up and down arrows to change selection": "",
    "Use up and down arrows to move selection": "",
    "Use up and down arrows to move lower selection": "",
    "Use up and down arrows to move upper selection": "",
    "From %1 to %2": "",
    "From %1": "",
    "To %1": "",
    // Data loader-related.
    "No parser available for file: %1": "",
    "Error parsing file: %1": "",
    "Unable to load file: %1": "",
    "Invalid date": "",
    // Common actions
    "Close": "",
    "Minimize": ""
});
//# sourceMappingURL=en.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Language.js
/**
 * Language module contains everything related to language-specific operations:
 * * Translating prompts
 * * Translating functions
 * * Date format localizations
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






;
;
/**
 * Handles all language-related tasks, like loading and storing translations,
 * translating prompts, lists of prompts and even functions.
 *
 * Almost every object in amCharts4 universe will have a `language` property,
 * which can be accessed for prompt translation.
 *
 * @see {@link ILanguageAdapters} for a list of available Adapters
 * @todo Make prompt keys case-insensitive
 * @important
 */
var Language_Language = /** @class */ (function (_super) {
    __extends(Language, _super);
    /**
     * Constructor
     */
    function Language() {
        var _this = _super.call(this) || this;
        /**
         * Adapter.
         */
        _this.adapter = new Adapter_Adapter(_this);
        /**
         * Current locale.
         */
        _this._locale = en;
        /**
         * Default locale. A locale to fall back to if none is specified, or
         * if there's no translation for the prompt for the current language.
         */
        _this._defaultLocale = en;
        _this.className = "Language";
        // Set default language if necessary
        if (hasValue(Options_options.defaultLocale)) {
            _this.locale = Options_options.defaultLocale;
        }
        _this.applyTheme();
        return _this;
    }
    /**
     * Returns locale that is currently used.
     *
     * @param locale  Force locale. Will use current language if not set.
     * @return Locale
     */
    Language.prototype.getLocale = function (locale) {
        if (locale == null) {
            locale = this._locale;
        }
        return this.adapter.apply("locale", {
            locale: locale
        }).locale;
    };
    /**
     * Returns the translation of the string.
     *
     * If the translation is empty, it will return untranslated prompt.
     *
     * Third parameter and up are strings that can be used to replace "%X"
     * placeholders in prompt.
     *
     * E.g.:
     *
     * ```TypeScript
     * // Results in "This is a first translation test"
     * chart.language.translate("This is a %1 translation %2", null, "first", "test");
     * ```
     * ```JavaScriptScript
     * // Results in "This is a first translation test"
     * chart.language.translate("This is a %1 translation %2", null, "first", "test");
     * ```
     *
     * @param  prompt   A string to translate
     * @param  locale   Force translation into specific locale, e.g. fr_FR
     * @param  rest     Parameters to replace in string
     * @return          Translation
     */
    Language.prototype.translate = function (prompt, locale) {
        var rest = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            rest[_i - 2] = arguments[_i];
        }
        // Get langauge
        locale = this.getLocale(locale);
        // Init translation
        var translation = prompt;
        // Get translations for the locale
        var translations = this.getTranslations(locale);
        var value = translations[prompt];
        // Try to look for the translation
        if (value === null) {
            value = "";
        }
        else if (hasValue(value)) {
            // It might be an empty string
            if (value) {
                translation = value;
            }
        }
        else if (locale !== this._defaultLocale) {
            // Try to look in default language
            return this.translate.apply(this, __spread([prompt, this._defaultLocale], rest));
        }
        // Replace %1, %2, etc params
        if (rest.length) {
            for (var len = rest.length, i = 0; i < len; ++i) {
                translation = translation.split("%" + (i + 1)).join(rest[i]);
            }
        }
        // Return the translation
        return this.adapter.apply("translate", {
            translation: translation,
            locale: locale
        }).translation;
    };
    /**
     * Non-type-checked translation.
     *
     * Can be used by plugins and other code that may have their own non-standard
     * translation prompts.
     *
     * @since 4.5.5
     * @param  prompt   A string to translate
     * @param  locale   Force translation into specific locale, e.g. fr_FR
     * @param  rest     Parameters to replace in string
     * @return          Translation
     */
    Language.prototype.translateAny = function (prompt, locale) {
        var rest = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            rest[_i - 2] = arguments[_i];
        }
        return this.translate(prompt, locale);
    };
    /**
     * Translates prompt.
     *
     * If translation is empty, it will return empty string, which is a different
     * behavior than that of regular `translate`.
     *
     * @param prompt   A string to translate
     * @param locale   Force translation into specific locale, e.g. fr_FR
     * @param ...rest  Parameters to replace in string
     * @return Translation
     */
    Language.prototype.translateEmpty = function (prompt, locale) {
        var rest = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            rest[_i - 2] = arguments[_i];
        }
        var translation = this.translate.apply(this, __spread([prompt, locale], rest));
        return translation == prompt ? "" : translation;
    };
    /**
     * Translates a function.
     *
     * This method will return a function reference, but will not run it. It's
     * up to the caller script to run the function.
     *
     * @param prompt  A function id to translate
     * @param locale  Force translation into specific locale. e.g. fr_FR
     * @return A language-specific version of the function
     * @todo Apply adapter
     */
    Language.prototype.translateFunc = function (prompt, locale) {
        // Get langauge
        locale = this.getLocale(locale);
        // Get translations for the locale
        var translations = this.getTranslations(locale);
        var value = translations[prompt];
        // Try to look for the translation
        if (value != null) {
            return value;
        }
        // Try to look in default language
        if (locale !== this._defaultLocale) {
            return this.translateFunc(prompt, this._defaultLocale);
        }
        // Fail - return empty function
        return function () {
            return "";
        };
    };
    /**
     * Translates a list of prompts in one go.
     *
     * @param list    An array of strings to translate
     * @param locale  Force translation into specific locale. e.g. fr_FR
     * @return An array of translated strings in the same order as source list
     */
    Language.prototype.translateAll = function (list, locale) {
        var _this = this;
        // Translate all items in the list
        if (!this.isDefault()) {
            return map(list, function (x) { return _this.translate(x, locale); });
        }
        else {
            return list;
        }
    };
    /**
     * Returns `true` if the currently selected locale is a default locale.
     *
     * @return `true` if locale is default; `false` if it is not.
     */
    Language.prototype.isDefault = function () {
        return this._defaultLocale === this._locale;
    };
    Object.defineProperty(Language.prototype, "locale", {
        /**
         * @return Locale definition
         */
        get: function () {
            return this._locale;
        },
        /**
         * Current locale.
         *
         * @param value  Locale definition (translations)
         */
        set: function (value) {
            if (this._locale != value) {
                this._locale = value;
                if (this.events.isEnabled("localechanged")) {
                    var event_1 = {
                        type: "localechanged",
                        locale: value,
                        target: this
                    };
                    this.events.dispatchImmediately("localechanged", event_1);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns translations for a given locale.
     *
     * @ignore
     * @deprecated
     * @param locale  Locale
     * @return Translations
     */
    Language.prototype.getTranslations = function (locale) {
        return this.adapter.apply("translations", {
            translations: locale,
            locale: locale
        }).translations;
    };
    return Language;
}(Base_BaseObjectEvents));

//# sourceMappingURL=Language.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/formatters/TextFormatter.js
/**
 * Handles formatting of pseudo-markup in text.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * Handles formatting of pseudo-markdown in text.
 *
 * @todo Encode < > in output
 * @todo Add more adapters
 * @important
 */
var TextFormatter_TextFormatter = /** @class */ (function (_super) {
    __extends(TextFormatter, _super);
    /**
     * Constructor
     */
    function TextFormatter() {
        var _this = _super.call(this) || this;
        /**
         * Adapter.
         */
        _this.adapter = new Adapter_Adapter(_this);
        _this.className = "TextFormatter";
        _this.applyTheme();
        return _this;
    }
    TextFormatter.prototype.debug = function () { };
    /**
     * Formats the text according to specifications passed in.
     *
     * @param text    Text to format
     * @param output  Output format (svg, html)
     * @return Formatted text
     */
    TextFormatter.prototype.format = function (text, output) {
        // Apply default
        if (!hasValue(output)) {
            output = "svg";
        }
        // Init return value
        var formatted = "";
        // Replace double (escaped) square spaces with remporary codes
        text = this.escape(text);
        // Divvy up the string by style tags
        var styles = text.match(/\[([^\]]*?)\]/gm);
        if (!styles) {
            // Nothing to do here - no formatting elements
            return this.wrap(text, "", output);
        }
        // Get pure text - no style tags
        var texts = text.split(/\[[^\[\]]*\]/);
        // Go through each of the texts and wrap it in style tags
        for (var i = 0, len = texts.length; i < len; i++) {
            // Get text bit
            var t = texts[i];
            // Check if string is empty
            if (t === "") {
                continue;
            }
            // Run through an adapter
            t = this.adapter.apply("chunk", t);
            // Get related style
            var s = "";
            if (i > 0) {
                s = styles[i - 1].replace('[', '').replace(']', '');
            }
            // Wrap text in tag
            formatted += this.wrap(t, s, output);
        }
        // Replace placeholders back
        formatted = this.unescape(formatted);
        // Return result
        return this.cleanUp(formatted);
    };
    /**
     * Replaces brackets with temporary placeholders.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Escaped text
     */
    TextFormatter.prototype.escape = function (text) {
        return text.
            replace(/\[\[/g, registry.getPlaceholder("1")).
            replace(/([^\/]{1})\]\]/g, "$1" + registry.getPlaceholder("2")).
            replace(/\]\]/g, registry.getPlaceholder("2")).
            replace(/\{\{/g, registry.getPlaceholder("3")).
            replace(/\}\}/g, registry.getPlaceholder("4")).
            replace(/\'\'/g, registry.getPlaceholder("5"));
    };
    /**
     * Replaces placeholders back to brackets.
     *
     * @ignore Exclude from docs
     * @param text  Escaped text
     * @return Unescaped text
     */
    TextFormatter.prototype.unescape = function (text) {
        return text.
            replace(new RegExp(registry.getPlaceholder("1"), "g"), "[[").
            replace(new RegExp(registry.getPlaceholder("2"), "g"), "]]").
            replace(new RegExp(registry.getPlaceholder("3"), "g"), "{{").
            replace(new RegExp(registry.getPlaceholder("4"), "g"), "}}").
            replace(new RegExp(registry.getPlaceholder("5"), "g"), "'");
    };
    /**
     * Cleans up the text text for leftover double square brackets.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Cleaned up text
     */
    TextFormatter.prototype.cleanUp = function (text) {
        return text.
            replace(/\[\[/g, "[").
            replace(/\]\]/g, "]").
            replace(/\{\{/g, "{").
            replace(/\}\}/g, "}").
            replace(/\'\'/g, "'");
    };
    /**
     * Wraps text into corresponding tags.
     *
     * @ignore Exclude from docs
     * @param text   Text to wrap
     * @param style  Styles
     * @param output  Format to output in (svg, html)
     * @return Formatted string
     */
    TextFormatter.prototype.wrap = function (text, style, output) {
        if (style === "" || style === "/") {
            //return text;
            style = "";
        }
        switch (output) {
            case "html":
                return this.wrapHtml(text, this.translateStyleShortcuts(style));
            default:
                return this.wrapSvg(text, this.translateStyleShortcuts(style));
        }
    };
    /**
     * Wraps text in styled SVG tag.
     *
     * @ignore Exclude from docs
     * @param text   Text to wrap
     * @param style  Style property
     * @return Formatted tag
     */
    TextFormatter.prototype.wrapSvg = function (text, style) {
        if (style === "") {
            return "<tspan>" + text + "</tspan>";
        }
        else {
            return "<tspan style='" + style + "'>" + text + "</tspan>";
        }
    };
    /**
     * Returns an SVG `<tspan>` element.
     *
     * @ignore Exclude from docs
     * @param text   Text
     * @param style  Style
     * @return Element
     */
    TextFormatter.prototype.getSvgElement = function (text, style) {
        var element = new AMElement_AMElement("tspan");
        element.textContent = text;
        if (style) {
            element.node.setAttribute("style", style);
        }
        return element;
    };
    /**
     * Wraps text in HTML <span> tag.
     *
     * @ignore Exclude from docs
     * @param text   Text to wrap
     * @param style  Style property
     * @return Formatted tag
     * @todo Translate SVG styles into HTML ones
     */
    TextFormatter.prototype.wrapHtml = function (text, style) {
        if (style === "") {
            return "<span>" + text + "</span>";
        }
        else {
            return "<span style='" + this.styleSvgToHtml(style) + "'>" + text + "</span>";
        }
    };
    /**
     * Returns an HTML `<span>` element.
     *
     * @ignore Exclude from docs
     * @param text   Text/HTML
     * @param style  Style definition
     * @return HTML element
     */
    TextFormatter.prototype.getHtmlElement = function (text, style) {
        var element = document.createElement("span");
        element.innerHTML = text;
        if (style) {
            element.setAttribute("style", style);
        }
        return element;
    };
    /**
     * Trabslates SVG CSS into HTML CSS.
     *
     * @ignore Exclude from docs
     * @param style  SVG CSS
     * @return HTML CSS
     * @todo Implement actual translation
     */
    TextFormatter.prototype.styleSvgToHtml = function (style) {
        style = style.replace(/fill:/, "color:");
        return style;
    };
    /**
     * Translates style shortcuts into full styles, i.e.:
     * "bold" => "font-weight: bold"
     * "#f00" => "fill: #f00"
     *
     * @ignore Exclude from docs
     * @param style  Untranslated style
     * @return Translated style
     * @todo Implement actual translation
     */
    TextFormatter.prototype.translateStyleShortcuts = function (style) {
        if (style == "" || style == "[ ]") {
            return "";
        }
        var cached = registry.getCache("translateStyleShortcuts_" + style);
        if (cached) {
            return cached;
        }
        // Pre-process quoted text
        var q = style.match(/('[^']*')|("[^"]*")/gi);
        if (q) {
            for (var i = 0; i < q.length; i++) {
                style = style.replace(q[i], q[i].replace(/['"]*/g, "").replace(/[ ]+/g, "+"));
            }
        }
        // Get style parts
        var b = style.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w]+)|(\/)/gi);
        // Empty?
        if (!b) {
            return style;
        }
        // Check each part
        for (var i = 0; i < b.length; i++) {
            if (b[i].match(/^bold$/i)) {
                // Bold
                b[i] = "font-weight:" + b[i];
            }
            else if (b[i] == "/") {
                // Just closing tag
                // Do nothing
                b[i] = "";
            }
            else if (!b[i].match(/:/)) {
                // Color
                b[i] = "fill:" + b[i];
            }
            else {
                b[i] = b[i].replace(/\+/g, " ");
            }
        }
        var res = b.join(';');
        registry.setCache("translateStyleShortcuts_" + style, res);
        return res;
    };
    /**
     * Splits string into chunks. (style blocks, quoted blocks, regular blocks)
     *
     * If the second parameter `quotedBlocks` is set to `true` this method will
     * also single out text blocks enclosed within single quotes that no
     * formatting should be applied to, and they should be displayed as is.
     *
     * Default for the above is `false`, so that you can use single quote in text
     * without escaping it.
     *
     * If enabled, single quotes can be escaped by doubling it - adding two
     * single quotes, which will be replaced by a one single quote in the final
     * output.
     *
     * @ignore Exclude from docs
     * @param text          Text to chunk
     * @param quotedBlocks  Use quoted blocks
     * @param noFormatting  Formatting blocks will be treated as regular text
     * @return Array of string chunks
     */
    TextFormatter.prototype.chunk = function (text, quotedBlocks, noFormatting) {
        if (quotedBlocks === void 0) { quotedBlocks = false; }
        if (noFormatting === void 0) { noFormatting = false; }
        // Init result
        var res = [];
        // Replace double (escaped) square spaces and quotes with temporary codes
        text = this.escape(text);
        // Deal with style blocks
        var chunks = quotedBlocks ? text.split("'") : [text];
        for (var i = 0; i < chunks.length; i++) {
            var chunk = chunks[i];
            // Empty?
            if (chunk === "") {
                continue;
            }
            if ((i % 2) === 0) {
                // Text outside quotes
                // Parse for style blocks which are "text" chunks, the rest chunks are
                // "value"
                chunk = chunk.replace(/\]\[/g, "]" + PLACEHOLDER + "[");
                chunk = chunk.replace(/\[\]/g, "[ ]");
                var chunks2 = chunk.split(/[\[\]]+/);
                for (var i2 = 0; i2 < chunks2.length; i2++) {
                    var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
                    // Placeholder?
                    if (chunk2 === PLACEHOLDER) {
                        continue;
                    }
                    // Empty?
                    if (chunk2 === "") {
                        continue;
                    }
                    // Block or value
                    if ((i2 % 2) === 0) {
                        res.push({
                            "type": "value",
                            "text": this.adapter.apply("chunk", chunk2)
                        });
                    }
                    else {
                        res.push({
                            "type": noFormatting ? "value" : "format",
                            "text": "[" + chunk2 + "]"
                        });
                    }
                }
            }
            else {
                // A text within doublequotes
                // All chunks are "text"
                var chunks2 = chunk.split(/[\[\]]+/);
                for (var i2 = 0; i2 < chunks2.length; i2++) {
                    var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));
                    // Empty?
                    if (chunk2 === "") {
                        continue;
                    }
                    // Block or text
                    if ((i2 % 2) === 0) {
                        res.push({
                            "type": "text",
                            "text": chunk2
                        });
                    }
                    else if (this.isImage(chunk2)) {
                        res.push({
                            "type": "image",
                            "text": "[" + chunk2 + "]"
                        });
                    }
                    else {
                        res.push({
                            "type": "format",
                            "text": "[" + chunk2 + "]"
                        });
                    }
                }
            }
        }
        return res;
    };
    /**
     * Checks if supplied format contains image information and should be
     * formatted as such.
     * I.e.: `[img: myImage.png]`
     *
     * @ignore Exclude from docs
     * @param text  Format
     * @return `true` if it is an image
     */
    TextFormatter.prototype.isImage = function (text) {
        return text.match(/img[ ]?:/) ? true : false;
    };
    return TextFormatter;
}(Base_BaseObject));

var formatter;
/**
 * Returns the global instance of [[TextFormatter]].
 *
 * All classes and instances should reuse this universal text formatter,
 * rather than create their own instance of it.
 */
function getTextFormatter() {
    if (formatter == null) {
        formatter = new TextFormatter_TextFormatter();
    }
    return formatter;
}
/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["TextFormatter"] = TextFormatter_TextFormatter;
//# sourceMappingURL=TextFormatter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/formatters/NumberFormatter.js
/**
 * Number formatting-related functionality.
 */










/**
 * NumberFormatter class. Formats numbers according to specified formats.
 *
 * @todo Apply translations to suffixes/prefixes
 */
var NumberFormatter_NumberFormatter = /** @class */ (function (_super) {
    __extends(NumberFormatter, _super);
    /**
     * Constructor
     */
    function NumberFormatter() {
        var _this = _super.call(this) || this;
        /**
         * A base value for negative numbers. Will treat all numbers below this value
         * as negative numbers.
         */
        _this._negativeBase = 0;
        /**
         * Holds number format.
         *
         * @default #,###.#####
         */
        _this._numberFormat = "#,###.#####";
        /**
         * Output format to produce. If the format calls for applying color to the
         * formatted value, this setting will determine what markup to use: SVG or
         * HTML.
         *
         * Available options: svg, html.
         *
         * @default "svg"
         */
        _this._outputFormat = "svg";
        /**
         * Any number smaller than this will be considered "small" number, which will
         * trigger special formatting if "a" format modifier is used.
         */
        _this._smallNumberThreshold = 1.00;
        _this.className = "NumberFormatter";
        _this.applyTheme();
        return _this;
    }
    NumberFormatter.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this.language) {
            this.language.dispose();
        }
    };
    Object.defineProperty(NumberFormatter.prototype, "language", {
        /**
         * @return Language
         */
        get: function () {
            if (!this._language) {
                if (this.sprite) {
                    this._language = this.sprite.language;
                }
                else {
                    this._language = new Language_Language;
                }
            }
            return this._language;
        },
        /**
         * A reference to [[Language]] instance.
         *
         * Formatter will use language to translate various items, like number
         * suffixes, etc.
         *
         * @param value  Language
         */
        set: function (value) {
            this._language = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Formats the number according to specific format.
     *
     * @param value   Value to format
     * @param format  Format to apply
     * @return Formatted number
     */
    NumberFormatter.prototype.format = function (value, format, precision) {
        // no format passed in or "Number"
        if (typeof format === "undefined" || (isString(format) && format.toLowerCase() === "number")) {
            format = this._numberFormat;
        }
        // Init return value
        var formatted;
        // Cast to number just in case
        // TODO: maybe use better casting
        var source = Number(value);
        // Is it a built-in format or Intl.NumberFormatOptions
        if (format instanceof Object) {
            try {
                if (this.intlLocales) {
                    return new Intl.NumberFormat(this.intlLocales, format).format(source);
                }
                else {
                    return new Intl.NumberFormat(undefined, format).format(source);
                }
            }
            catch (e) {
                return "Invalid";
            }
        }
        else {
            // Clean format
            format = cleanFormat(format);
            // Get format info (it will also deal with parser caching)
            var info = this.parseFormat(format, this.language);
            // format and replace the number
            var details = void 0;
            if (source > this._negativeBase) {
                details = info.positive;
            }
            else if (source < this._negativeBase) {
                details = info.negative;
            }
            else {
                details = info.zero;
            }
            // Adjust precision
            if (hasValue(precision) && !details.mod) {
                details = Object_clone(details);
                details.decimals.active = source == 0 ? 0 : precision;
            }
            // Format
            formatted = details.template.split(PLACEHOLDER).join(this.applyFormat(source, details));
        }
        return formatted;
    };
    /**
     * Parses supplied format into structured object which can be used to format
     * the number.
     *
     * @param format Format string, i.e. "#,###.00"
     * @param language Language
     */
    NumberFormatter.prototype.parseFormat = function (format, language) {
        var _this = this;
        // Check cache
        var cached = this.getCache(format);
        if (hasValue(cached)) {
            return cached;
        }
        // init format parse info holder
        var info = {
            "positive": {
                "thousands": {
                    "active": -1,
                    "passive": -1,
                    "interval": -1,
                    "separator": language.translateEmpty("_thousandSeparator")
                },
                "decimals": {
                    "active": -1,
                    "passive": -1,
                    "separator": language.translateEmpty("_decimalSeparator")
                },
                "template": "",
                "source": "",
                "parsed": false
            },
            "negative": {
                "thousands": {
                    "active": -1,
                    "passive": -1,
                    "interval": -1,
                    "separator": language.translateEmpty("_thousandSeparator")
                },
                "decimals": {
                    "active": -1,
                    "passive": -1,
                    "separator": language.translateEmpty("_decimalSeparator")
                },
                "template": "",
                "source": "",
                "parsed": false
            },
            "zero": {
                "thousands": {
                    "active": -1,
                    "passive": -1,
                    "interval": -1,
                    "separator": language.translateEmpty("_thousandSeparator")
                },
                "decimals": {
                    "active": -1,
                    "passive": -1,
                    "separator": language.translateEmpty("_decimalSeparator")
                },
                "template": "",
                "source": "",
                "parsed": false
            }
        };
        // Escape double vertical bars (that mean display one vertical bar)
        format = format.replace("||", PLACEHOLDER2);
        // Split it up and deal with different formats
        var parts = format.split("|");
        info.positive.source = parts[0];
        if (typeof parts[2] === "undefined") {
            info.zero = info.positive;
        }
        else {
            info.zero.source = parts[2];
        }
        if (typeof parts[1] === "undefined") {
            info.negative = info.positive;
        }
        else {
            info.negative.source = parts[1];
        }
        // Parse each
        Object_each(info, function (part, item) {
            // Already parsed
            if (item.parsed) {
                return;
            }
            // Check cached
            if (typeof _this.getCache(item.source) !== "undefined") {
                info[part] = _this.getCache(item.source);
                return;
            }
            // Begin parsing
            var partFormat = item.source;
            // Just "Number"?
            if (partFormat.toLowerCase() === "number") {
                partFormat = isString(_this._numberFormat) ? _this._numberFormat : "#,###.#####";
            }
            // Let TextFormatter split into chunks
            var chunks = getTextFormatter().chunk(partFormat, true);
            for (var i = 0; i < chunks.length; i++) {
                var chunk = chunks[i];
                // replace back double vertical bar
                chunk.text = chunk.text.replace(PLACEHOLDER2, "|");
                if (chunk.type === "value") {
                    // Parse format
                    // Look for codes
                    var matches = chunk.text.match(/[#0.,]+[ ]?[abesABES%!]?[abesABES‰!]?/);
                    if (matches) {
                        if (matches === null || matches[0] === "") {
                            // no codes here - assume string
                            // nothing to do here
                            item.template += chunk.text;
                        }
                        else {
                            // look for the format modifiers at the end
                            var mods = matches[0].match(/[abesABES%‰!]{2}|[abesABES%‰]{1}$/);
                            if (mods) {
                                item.mod = mods[0].toLowerCase();
                                item.modSpacing = matches[0].match(/[ ]{1}[abesABES%‰!]{1}$/) ? true : false;
                            }
                            // break the format up
                            var a = matches[0].split(".");
                            // Deal with thousands
                            if (a[0] === "") {
                                // No directives for thousands
                                // Leave default settings (no formatting)
                            }
                            else {
                                // Counts
                                item.thousands.active = (a[0].match(/0/g) || []).length;
                                item.thousands.passive = (a[0].match(/\#/g) || []).length + item.thousands.active;
                                // Separator interval
                                var b = a[0].split(",");
                                if (b.length === 1) {
                                    // No thousands separators
                                    // Do nothing
                                }
                                else {
                                    // Use length fo the last chunk as thousands length
                                    item.thousands.interval = getValue(b.pop()).length;
                                    if (item.thousands.interval === 0) {
                                        item.thousands.interval = -1;
                                    }
                                }
                            }
                            // Deal with decimals
                            if (typeof (a[1]) === "undefined") {
                                // No directives for decimals
                                // Leave at defaults (no formatting)
                            }
                            else {
                                // Counts
                                item.decimals.active = (a[1].match(/0/g) || []).length;
                                item.decimals.passive = (a[1].match(/\#/g) || []).length + item.decimals.active;
                            }
                            // Add special code to template
                            item.template += chunk.text.split(matches[0]).join(PLACEHOLDER);
                        }
                    }
                }
                else {
                    // Quoted string - take it as it is
                    item.template += chunk.text;
                }
            }
            // Apply style formatting
            //item.template = getTextFormatter().format(item.template, this.outputFormat);
            // Save cache
            _this.setCache(item.source, item);
            // Mark this as parsed
            item.parsed = true;
        });
        // Save cache (the whole thing)
        this.setCache(format, info);
        return info;
    };
    /**
     * Applies parsed format to a numeric value.
     *
     * @param value    Value
     * @param details  Parsed format as returned by parseFormat()
     * @return Formatted number
     */
    NumberFormatter.prototype.applyFormat = function (value, details) {
        // Use absolute values
        var negative = value < 0;
        value = Math.abs(value);
        // Recalculate according to modifier
        var prefix = "", suffix = "";
        var mods = details.mod ? details.mod.split("") : [];
        if (mods.indexOf("b") !== -1) {
            var a_1 = this.applyPrefix(value, this.bytePrefixes, mods.indexOf("!") !== -1);
            value = a_1[0];
            prefix = a_1[1];
            suffix = a_1[2];
            if (details.modSpacing) {
                suffix = " " + suffix;
            }
        }
        else if (mods.indexOf("a") !== -1) {
            var a_2 = this.applyPrefix(value, value < this.smallNumberThreshold ? this.smallNumberPrefixes : this.bigNumberPrefixes, mods.indexOf("!") !== -1);
            value = a_2[0];
            prefix = a_2[1];
            suffix = a_2[2];
            if (details.modSpacing) {
                suffix = " " + suffix;
            }
        }
        else if (mods.indexOf("%") !== -1) {
            var ol = Math_min(value.toString().length + 2, 21);
            value *= 100;
            value = parseFloat(value.toPrecision(ol));
            suffix = "%";
        }
        else if (mods.indexOf("‰") !== -1) {
            var ol = Math_min(value.toString().length + 3, 21);
            value *= 1000;
            value = parseFloat(value.toPrecision(ol));
            suffix = "‰";
        }
        // Round to passive
        if (mods.indexOf("e") !== -1) {
            // convert the value to exponential
            var exp = void 0;
            if (details.decimals.passive >= 0) {
                exp = value.toExponential(details.decimals.passive).split("e");
            }
            else {
                exp = value.toExponential().split("e");
            }
            value = Number(exp[0]);
            suffix = "e" + exp[1];
            if (details.modSpacing) {
                suffix = " " + suffix;
            }
        }
        else if (details.decimals.passive === 0) {
            value = Math.round(value);
        }
        else if (details.decimals.passive > 0) {
            var d = Math.pow(10, details.decimals.passive);
            value = Math.round(value * d) / d;
        }
        // Init return value
        var res = "";
        // Calc integer and decimal parts
        var a = numberToString(value).split(".");
        // Format integers
        var ints = a[0];
        // Pad integers to active length
        if (ints.length < details.thousands.active) {
            ints = Array(details.thousands.active - ints.length + 1).join("0") + ints;
        }
        // Insert thousands separators
        if (details.thousands.interval > 0) {
            var ip = [];
            var intsr = ints.split("").reverse().join("");
            for (var i = 0, len = ints.length; i <= len; i += details.thousands.interval) {
                var c = intsr.substr(i, details.thousands.interval).split("").reverse().join("");
                if (c !== "") {
                    ip.unshift(c);
                }
            }
            ints = ip.join(details.thousands.separator);
        }
        // Add integers
        res += ints;
        // Add decimals
        if (a.length === 1) {
            a.push("");
        }
        var decs = a[1];
        // Fill zeros?
        if (decs.length < details.decimals.active) {
            decs += Array(details.decimals.active - decs.length + 1).join("0");
        }
        if (decs !== "") {
            res += details.decimals.separator + decs;
        }
        // Can't have empty return value
        if (res === "") {
            res = "0";
        }
        // Add minus sign back
        if (value !== 0 && negative && (mods.indexOf("s") === -1)) {
            res = "-" + res;
        }
        // Add suffixes/prefixes
        if (prefix) {
            res = prefix + res;
        }
        if (suffix) {
            res += suffix;
        }
        return res;
    };
    /**
     * Chooses appropriate prefix and suffix based on the passed in rules.
     *
     * @param  value     Value
     * @param  prefixes  Prefix array
     * @param  force     Force application of a first prefix (@sice 4.5.4)
     * @return Result
     */
    NumberFormatter.prototype.applyPrefix = function (value, prefixes, force) {
        if (force === void 0) { force = false; }
        var newvalue = value;
        var prefix = "";
        var suffix = "";
        var applied = false;
        var k = 1;
        for (var i = 0, len = prefixes.length; i < len; i++) {
            if (prefixes[i].number <= value) {
                if (prefixes[i].number === 0) {
                    newvalue = 0;
                }
                else {
                    newvalue = value / prefixes[i].number;
                    k = prefixes[i].number;
                }
                prefix = prefixes[i].prefix;
                suffix = prefixes[i].suffix;
                applied = true;
            }
        }
        if (!applied && force && prefixes.length && value != 0) {
            // Prefix was not applied. Use the first prefix.
            newvalue = value / prefixes[0].number;
            prefix = prefixes[0].prefix;
            suffix = prefixes[0].suffix;
            applied = true;
        }
        if (applied) {
            newvalue = parseFloat(newvalue.toPrecision(Math_min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, "").length, 21)));
        }
        return [newvalue, prefix, suffix];
    };
    /**
     * Invalidates the parent [[Sprite]] object.
     */
    NumberFormatter.prototype.invalidateSprite = function () {
        if (this.sprite) {
            this.sprite.invalidate();
        }
    };
    Object.defineProperty(NumberFormatter.prototype, "numberFormat", {
        /**
         * @return A format to use for number formatting
         */
        get: function () {
            return this._numberFormat;
        },
        /**
         * Number format.
         *
         * @default "#,###.#####"
         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting
         * @param format  A format to use for number formatting
         */
        set: function (format) {
            this._numberFormat = format;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberFormatter.prototype, "intlLocales", {
        /**
         * @return Date format
         */
        get: function () {
            return this._intlLocales;
        },
        /**
         * Locales if you are using date formats in `Intl.NumberFormatOptions` syntax.
         *
         * @see (@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) about using Intl for number formatting
         * @param value Locales
         */
        set: function (value) {
            this._intlLocales = value;
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberFormatter.prototype, "negativeBase", {
        /**
         * @return A format to use for number formatting
         */
        get: function () {
            return this._negativeBase;
        },
        /**
         * Negative base for negative numbers.
         *
         * @default 0
         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting
         * @param format  A format to use for number formatting
         */
        set: function (value) {
            this._negativeBase = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberFormatter.prototype, "bigNumberPrefixes", {
        /**
         * @return Prefixes for big numbers
         */
        get: function () {
            if (!hasValue(this._bigNumberPrefixes)) {
                this._bigNumberPrefixes = [
                    { "number": 1e+3, "suffix": this.language.translate("_big_number_suffix_3") },
                    { "number": 1e+6, "suffix": this.language.translate("_big_number_suffix_6") },
                    { "number": 1e+9, "suffix": this.language.translate("_big_number_suffix_9") },
                    { "number": 1e+12, "suffix": this.language.translate("_big_number_suffix_12") },
                    { "number": 1e+15, "suffix": this.language.translate("_big_number_suffix_15") },
                    { "number": 1e+18, "suffix": this.language.translate("_big_number_suffix_18") },
                    { "number": 1e+21, "suffix": this.language.translate("_big_number_suffix_21") },
                    { "number": 1e+24, "suffix": this.language.translate("_big_number_suffix_24") }
                ];
            }
            return this._bigNumberPrefixes;
        },
        /**
         * Prefixes for big numbers.
         *
         * It's an array of objects of number/prefix pairs.
         *
         * ```JSON
         * [
         *   { "number": 1e+3, "suffix": "K" },
         *   { "number": 1e+6, "suffix": "M" },
         *   { "number": 1e+9, "suffix": "G" },
         *   { "number": 1e+12, "suffix": "T" },
         *   { "number": 1e+15, "suffix": "P" },
         *   { "number": 1e+18, "suffix": "E" },
         *   { "number": 1e+21, "suffix": "Z" },
         *   { "number": 1e+24, "suffix": "Y" }
         * ]
         * ```
         *
         * If the number is bigger than the `number` ir will be converted to the
         * appropriate bigger number with prefix.
         *
         * E.g. as per above `1500` will be converted to `1.5K`.
         *
         * Please note that for this transformation to be enabled, you need to
         * enable it specific modifier in your format setting.
         *
         * The modifier for big/small number modification is "a":
         *
         * ```Text
         * {myfield.formatNumber("#,###.00a")}
         * ```
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting
         * @param prefixes  Prefixes for big numbers
         */
        set: function (prefixes) {
            this._bigNumberPrefixes = prefixes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberFormatter.prototype, "smallNumberPrefixes", {
        /**
         * @return Prefixes for small numbers
         */
        get: function () {
            if (!hasValue(this._smallNumberPrefixes)) {
                this._smallNumberPrefixes = [
                    { "number": 1e-24, "suffix": this.language.translate("_small_number_suffix_24") },
                    { "number": 1e-21, "suffix": this.language.translate("_small_number_suffix_21") },
                    { "number": 1e-18, "suffix": this.language.translate("_small_number_suffix_18") },
                    { "number": 1e-15, "suffix": this.language.translate("_small_number_suffix_15") },
                    { "number": 1e-12, "suffix": this.language.translate("_small_number_suffix_12") },
                    { "number": 1e-9, "suffix": this.language.translate("_small_number_suffix_9") },
                    { "number": 1e-6, "suffix": this.language.translate("_small_number_suffix_6") },
                    { "number": 1e-3, "suffix": this.language.translate("_small_number_suffix_3") }
                ];
            }
            return this._smallNumberPrefixes;
        },
        /**
         * Prefixes for big numbers.
         *
         * It's an array of objects of number/prefix pairs.
         *
         * ```JSON
         * [
         *   { "number": 1e-24, "suffix": "y" },
         *   { "number": 1e-21, "suffix": "z" },
         *   { "number": 1e-18, "suffix": "a" },
         *   { "number": 1e-15, "suffix": "f" },
         *   { "number": 1e-12, "suffix": "p" },
         *   { "number": 1e-9, "suffix": "n" },
         *   { "number": 1e-6, "suffix": "μ" },
         *   { "number": 1e-3, "suffix": "m" }
         * ]
         * ```
         *
         * If the number is smaller than the `number` ir will be converted to the
         * appropriate smaller number with prefix.
         *
         * E.g. as per above `0.0015` will be converted to `1.5m`.
         *
         * Please note that for this transformation to be enabled, you need to
         * enable it specific modifier in your format setting.
         *
         * The modifier for big/small number modification is "a":
         *
         * ```Text
         * {myfield.formatNumber("#,###.00a")}
         * ```
         *
         * IMPORTANT: The order of the suffixes is important. The list must start
         * from the smallest number and work towards bigger ones.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting
         * @param prefixes  Prefixes for small numbers
         */
        set: function (prefixes) {
            this._smallNumberPrefixes = prefixes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberFormatter.prototype, "smallNumberThreshold", {
        /**
         * @return Small number threshold
         */
        get: function () {
            return this._smallNumberThreshold;
        },
        /**
         * Any number smaller than this will be considered "small" number, which will
         * trigger special formatting if "a" format modifier is used.
         *
         * @since 4.6.8
         * @param  value  Small number threshold
         */
        set: function (value) {
            this._smallNumberThreshold = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberFormatter.prototype, "bytePrefixes", {
        /**
         * @return Prefixes for byte-size formatting
         */
        get: function () {
            if (!hasValue(this._bytePrefixes)) {
                this._bytePrefixes = [
                    { "number": 1, suffix: this.language.translate("_byte_suffix_B") },
                    { "number": 1024, suffix: this.language.translate("_byte_suffix_KB") },
                    { "number": 1048576, suffix: this.language.translate("_byte_suffix_MB") },
                    { "number": 1073741824, suffix: this.language.translate("_byte_suffix_GB") },
                    { "number": 1099511627776, suffix: this.language.translate("_byte_suffix_TB") },
                    { "number": 1125899906842624, suffix: this.language.translate("_byte_suffix_PB") }
                ];
            }
            return this._bytePrefixes;
        },
        /**
         * Basically the same as `bigNumberPrefixes`, except base for calculation
         * is not thousand but byte (1024).
         *
         * The modifier is "b".
         *
         *  ```Text
         * {myfield.formatNumber("#,###.00b")}
         * ```
         *
         * The above `2048` will change to `2K`.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting
         * @param prefixes  Prefixes for byte-size formatting
         */
        set: function (prefixes) {
            this._bytePrefixes = prefixes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberFormatter.prototype, "outputFormat", {
        /**
         * @ignore Exclude from docs
         * @return Output format
         */
        get: function () {
            return this._outputFormat;
        },
        /**
         * Ooutput format: "svg" or "html".
         *
         * @ignore Exclude from docs
         * @param value  Output format
         */
        set: function (outputFormat) {
            this._outputFormat = outputFormat.toLowerCase();
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Replaces brackets with temporary placeholders.
     *
     * @ignore Exclude from docs
     * @param text  Input text
     * @return Escaped text
     */
    NumberFormatter.prototype.escape = function (text) {
        return text.replace("||", PLACEHOLDER2);
    };
    /**
     * Replaces placeholders back to brackets.
     *
     * @ignore Exclude from docs
     * @param text  Escaped text
     * @return Unescaped text
     */
    NumberFormatter.prototype.unescape = function (text) {
        return text.replace(PLACEHOLDER2, "|");
    };
    return NumberFormatter;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["NumberFormatter"] = NumberFormatter_NumberFormatter;
//# sourceMappingURL=NumberFormatter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/formatters/DateFormatter.js
/**
 * Handles date and time formatting
 */








/**
 * Handles date and time formatting.
 *
 * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/} Tutorial on date/time formatting
 * @todo Better type casting of passed in date?
 * @todo Quarter support?
 * @todo When parsing named months make the search case-insensitive
 * @todo Escape a.m./p.m. properly when used in RegEx
 */
var DateFormatter_DateFormatter = /** @class */ (function (_super) {
    __extends(DateFormatter, _super);
    /**
     * Constructor
     */
    function DateFormatter() {
        var _this = _super.call(this) || this;
        /**
         * Date format.
         */
        _this._dateFormat = "yyyy-MM-dd";
        /**
         * Input date format.
         */
        _this._inputDateFormat = "yyyy-MM-dd";
        /**
         * Assume UTC time zone.
         */
        _this._utc = false;
        /**
         * First day of week.
         *
         * 0 - Sunday
         * 1 - Monday
         *
         * Etc.
         */
        _this._firstDayOfWeek = 1;
        /**
         * A list of month names.
         */
        _this.months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        /**
         * A list of short month names.
         */
        _this.monthsShort = ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        /**
         * A list of weekday names.
         */
        _this.weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        /**
         * A list of short weekday names.
         */
        _this.weekdaysShort = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        /**
         * Output format to produce. If the format calls for applying color to the
         * formatted value, this setting will determine what markup to use: SVG or
         * HTML.
         *
         * Available options: svg, html.
         *
         * @default "svg"
         */
        _this._outputFormat = "svg";
        /**
         * Should the first letter of the formatted date be capitalized?
         *
         * @default true
         */
        _this.capitalize = true;
        _this.className = "DateFormatter";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(DateFormatter.prototype, "language", {
        /**
         * @return Language
         */
        get: function () {
            return this._language;
        },
        /**
         * A reference to [[Language]] object.
         *
         * @param  value  Language
         */
        set: function (value) {
            this._language = value;
            this.dateFormat = this._language.translate("_date");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Formats the date value according to specified format.
     *
     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/} Tutorial on date/time formatting
     * @param source  Date value
     * @param format  Format
     * @return Formatted date string
     */
    DateFormatter.prototype.format = function (source, format) {
        // No language?
        if (!this.language) {
            if (this.sprite) {
                this.language = this.sprite.language;
            }
            else {
                this.language = new Language_Language();
            }
        }
        // No format passed in or it's empty
        if (typeof format === "undefined" || format === "") {
            format = this._dateFormat;
        }
        // Init return value
        var formatted;
        // Do casting if required
        // This will take care of timestamps as well as Date objects
        var date;
        if (isString(source)) {
            // If it's a string, let's try parsing it using our own functionality
            date = this.parse(source);
        }
        else {
            date = anyToDate(source);
        }
        // Is it a built-in format or Intl.DateTimeFormat
        if (format instanceof Object) {
            try {
                if (this.intlLocales) {
                    return new Intl.DateTimeFormat(this.intlLocales, format).format(date);
                }
                else {
                    return new Intl.DateTimeFormat(undefined, format).format(date);
                }
            }
            catch (e) {
                return "Invalid";
            }
        }
        else {
            // Clean format
            format = cleanFormat(format);
            // get format info (it will also deal with parser caching)
            var info = this.parseFormat(format);
            // Should we apply custom time zone?
            if (hasValue(this.timezoneOffset)) {
                date.setMinutes(date.getMinutes() + date.getTimezoneOffset() - this.timezoneOffset);
            }
            // Check if it's a valid date
            if (!isNumber(date.getTime())) {
                return this.language.translate("Invalid date");
            }
            // Apply format
            formatted = this.applyFormat(date, info, this.language);
            // Capitalize
            if (this.capitalize) {
                formatted = formatted.replace(/^.{1}/, formatted.substr(0, 1).toUpperCase());
            }
        }
        // We're done
        return formatted;
    };
    /**
     * Parses format into structured infromation.
     *
     * @param format Format template
     */
    DateFormatter.prototype.parseFormat = function (format) {
        // Check cache
        var cached = this.getCache(format);
        if (hasValue(cached)) {
            return cached;
        }
        // Init format parse info holder
        var info = {
            "template": "",
            "parts": []
        };
        // Let TextFormatter split into chunks
        var chunks = getTextFormatter().chunk(format, true);
        for (var i = 0; i < chunks.length; i++) {
            var chunk = chunks[i];
            if (chunk.type === "value") {
                // Just "Date"?
                if (chunk.text.match(/^date$/i) && isString(this._dateFormat)) {
                    chunk.text = this._dateFormat;
                }
                // Find all possible parts
                var matches = chunk.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);
                // Found?
                if (matches) {
                    // Populate template
                    for (var x = 0; x < matches.length; x++) {
                        info.parts.push(matches[x]);
                        chunk.text = chunk.text.replace(matches[x], PLACEHOLDER);
                    }
                }
            }
            // Apply to template
            info.template += chunk.text;
        }
        // Apply style formatting
        //info.template = getTextFormatter().format(info.template, this.outputFormat);
        // Save cache
        this.setCache(format, info);
        return info;
    };
    /**
     * Applies format to Date.
     *
     * @param date      Date object
     * @param info      Parsed format information
     * @param language  Language
     * @return Formatted date string
     */
    DateFormatter.prototype.applyFormat = function (date, info, language) {
        // Init return value
        var res = info.template;
        // Get values
        var fullYear, month, weekday, day, hours, minutes, seconds, milliseconds, offset = date.getTimezoneOffset(), timestamp = date.getTime();
        if (this.utc) {
            fullYear = date.getUTCFullYear();
            month = date.getUTCMonth();
            weekday = date.getUTCDay();
            day = date.getUTCDate();
            hours = date.getUTCHours();
            minutes = date.getUTCMinutes();
            seconds = date.getUTCSeconds();
            milliseconds = date.getUTCMilliseconds();
        }
        else {
            fullYear = date.getFullYear();
            month = date.getMonth();
            weekday = date.getDay();
            day = date.getDate();
            hours = date.getHours();
            minutes = date.getMinutes();
            seconds = date.getSeconds();
            milliseconds = date.getMilliseconds();
        }
        // Go through each part and format/replace it in template
        for (var i = 0, len = info.parts.length; i < len; i++) {
            var value = "";
            switch (info.parts[i]) {
                case "G":
                    value = language.translate(fullYear < 0
                        ? "_era_bc"
                        : "_era_ad");
                    break;
                case "yyyy":
                    value = Math.abs(fullYear).toString();
                    if (fullYear < 0) {
                        value += language.translate("_era_bc");
                    }
                    break;
                case "yyy":
                case "yy":
                case "y":
                    value = Math.abs(fullYear).toString().substr(-info.parts[i].length);
                    if (fullYear < 0) {
                        value += language.translate("_era_bc");
                    }
                    break;
                case "YYYY":
                case "YYY":
                case "YY":
                case "Y":
                    var week = getWeek(date);
                    var year = fullYear;
                    if (week == 1 && (weekday > 1)) {
                        year--;
                    }
                    if (info.parts[i] == "YYYY") {
                        value = Math.abs(year).toString();
                    }
                    else {
                        value = Math.abs(year).toString().substr(-info.parts[i].length);
                    }
                    if (year < 0) {
                        value += language.translate("_era_bc");
                    }
                    break;
                case "u":
                    // @todo
                    break;
                case "MMMMM":
                    value = language.translate(this.months[month]).substr(0, 1);
                    break;
                case "MMMM":
                    value = language.translate(this.months[month]);
                    break;
                case "MMM":
                    value = language.translate(this.monthsShort[month]);
                    break;
                case "MM":
                    value = padString(month + 1, 2, "0");
                    break;
                case "M":
                    value = (month + 1).toString();
                    break;
                case "ww":
                    value = padString(getWeek(date, this.utc), 2, "0");
                    break;
                case "w":
                    value = getWeek(date, this.utc).toString();
                    break;
                case "W":
                    value = getMonthWeek(date, this.utc).toString();
                    break;
                case "dd":
                    value = padString(day, 2, "0");
                    break;
                case "d":
                    value = day.toString();
                    break;
                case "DD":
                case "DDD":
                    value = padString(getYearDay(date, this.utc).toString(), info.parts[i].length, "0");
                    break;
                case "D":
                    value = getYearDay(date, this.utc).toString();
                    break;
                case "F":
                    // @todo
                    break;
                case "g":
                    // @todo
                    break;
                case "t":
                    value = language.translateFunc("_dateOrd").call(this, day);
                    break;
                case "E":
                    value = (weekday || 7).toString();
                    break;
                case "EE":
                    value = padString((weekday || 7).toString(), 2, "0");
                    break;
                case "EEE":
                case "eee":
                    value = language.translate(this.weekdaysShort[weekday]);
                    break;
                case "EEEE":
                case "eeee":
                    value = language.translate(this.weekdays[weekday]);
                    break;
                case "EEEEE":
                case "eeeee":
                    value = language.translate(this.weekdays[weekday]).substr(0, 1);
                    break;
                case "e":
                case "ee":
                    value = (weekday - this.firstDayOfWeek + 1).toString();
                    if (info.parts[i] == "ee") {
                        value = padString(value, 2, "0");
                    }
                    break;
                case "a":
                    if (hours >= 12) {
                        value = language.translate("PM");
                    }
                    else {
                        value = language.translate("AM");
                    }
                    break;
                case "aa":
                    if (hours >= 12) {
                        value = language.translate("P.M.");
                    }
                    else {
                        value = language.translate("A.M.");
                    }
                    break;
                case "aaa":
                    if (hours >= 12) {
                        value = language.translate("P");
                    }
                    else {
                        value = language.translate("A");
                    }
                    break;
                case "h":
                    value = get12Hours(hours).toString();
                    break;
                case "hh":
                    value = padString(get12Hours(hours), 2, "0");
                    break;
                case "H":
                    value = hours.toString();
                    break;
                case "HH":
                    value = padString(hours, 2, "0");
                    break;
                case "K":
                    value = get12Hours(hours, 0).toString();
                    break;
                case "KK":
                    value = padString(get12Hours(hours, 0), 2, "0");
                    break;
                case "k":
                    value = (hours + 1).toString();
                    break;
                case "kk":
                    value = padString(hours + 1, 2, "0");
                    break;
                case "m":
                    value = minutes.toString();
                    break;
                case "mm":
                    value = padString(minutes, 2, "0");
                    break;
                case "s":
                    value = seconds.toString();
                    break;
                case "ss":
                    value = padString(seconds, 2, "0");
                    break;
                case "S":
                case "SS":
                case "SSS":
                    value = Math.round((milliseconds / 1000) * Math.pow(10, info.parts[i].length)).toString();
                    break;
                case "x":
                    value = timestamp.toString();
                    break;
                case "n":
                case "nn":
                case "nnn":
                    value = padString(milliseconds, info.parts[i].length, "0");
                    break;
                case "z":
                    value = getTimeZone(date, false, false, this.utc);
                    break;
                case "zz":
                    value = getTimeZone(date, true, false, this.utc);
                    break;
                case "zzz":
                    value = getTimeZone(date, false, true, this.utc);
                    break;
                case "zzzz":
                    value = getTimeZone(date, true, true, this.utc);
                    break;
                case "Z":
                case "ZZ":
                    var tz = Math.abs(offset) / 60;
                    var tzh = Math.floor(tz);
                    var tzm = tz * 60 - tzh * 60;
                    if (this.utc) {
                        tzh = 0;
                        tzm = 0;
                    }
                    if (info.parts[i] == "Z") {
                        value = "GMT";
                        value += offset > 0 ? "-" : "+";
                        value += padString(tzh, 2) + ":" + padString(tzm, 2);
                    }
                    else {
                        value = offset > 0 ? "-" : "+";
                        value += padString(tzh, 2) + padString(tzm, 2);
                    }
                    break;
                case "i":
                    value = date.toISOString();
                    break;
                case "I":
                    value = date.toUTCString();
                    break;
            }
            res = res.replace(PLACEHOLDER, value);
        }
        return res;
    };
    /**
     * Parses any input value into Date object.
     *
     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date/time parsing
     * @param source  Source value
     * @param format  Source format
     * @return Date object
     */
    DateFormatter.prototype.parse = function (source, format) {
        // Format set?
        if (!hasValue(format)) {
            format = this.inputDateFormat;
        }
        // Is it already a Date
        if (source instanceof Date) {
            return source;
        }
        // Is it a numeric timestamp
        if (typeof source === "number") {
            return new Date(source);
        }
        // No? Let's check if it's string, and try converting to it if nec
        if (typeof source !== "string") {
            source = source.toString();
        }
        // no language?
        if (!this.language) {
            if (this.sprite) {
                this.language = this.sprite.language;
            }
            else {
                this.language = new Language_Language;
            }
        }
        // Init return value
        var res;
        // Init RegEx for parsing
        var reg = "";
        // Clean format
        format = cleanFormat(format);
        // Clip format to length of the source string
        format = format.substr(0, source.length);
        // Parse format
        var info = this.parseFormat(format);
        // Init parsed items holder
        var parsedIndexes = {
            "year": -1,
            "year3": -1,
            "year2": -1,
            "year1": -1,
            "month": -1,
            "monthShort": -1,
            "monthLong": -1,
            "weekdayShort": -1,
            "weekdayLong": -1,
            "day": -1,
            "yearDay": -1,
            "week": -1,
            "hourBase0": -1,
            "hour12Base0": -1,
            "hourBase1": -1,
            "hour12Base1": -1,
            "minute": -1,
            "second": -1,
            "millisecond": -1,
            "millisecondDigits": -1,
            "am": -1,
            "zone": -1,
            "timestamp": -1,
            "iso": -1
        };
        // Init values
        var resValues = {
            "year": 1970,
            "month": 0,
            "day": 1,
            "hour": 0,
            "minute": 0,
            "second": 0,
            "millisecond": 0,
            "timestamp": null,
            "offset": 0,
            "utc": this.utc
        };
        // Index adjuster
        var indexAdjust = 0, index = 0;
        // Iterate through all of the parts
        for (var i = 0; i < info.parts.length; i++) {
            // Set current match index
            index = i + indexAdjust + 1;
            switch (info.parts[i]) {
                case "yyyy":
                case "YYYY":
                    reg += "([0-9]{4})";
                    parsedIndexes.year = index;
                    break;
                case "yyy":
                case "YYY":
                    reg += "([0-9]{3})";
                    parsedIndexes.year3 = index;
                    break;
                case "yy":
                case "YY":
                    reg += "([0-9]{2})";
                    parsedIndexes.year2 = index;
                    break;
                case "y":
                case "Y":
                    reg += "([0-9]{1})";
                    parsedIndexes.year1 = index;
                    break;
                case "MMMM":
                    reg += "(" + this.getStringList(this.months).join("|") + ")";
                    parsedIndexes.monthLong = index;
                    break;
                case "MMM":
                    reg += "(" + this.getStringList(this.monthsShort).join("|") + ")";
                    parsedIndexes.monthShort = index;
                    break;
                case "MM":
                case "M":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.month = index;
                    break;
                case "ww":
                case "w":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.week = index;
                    break;
                case "dd":
                case "d":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.day = index;
                    break;
                case "DDD":
                case "DD":
                case "D":
                    reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                    parsedIndexes.yearDay = index;
                    break;
                case "dddd":
                    reg += "(" + this.getStringList(this.weekdays).join("|") + ")";
                    parsedIndexes.weekdayLong = index;
                    break;
                case "ddd":
                    reg += "(" + this.getStringList(this.weekdaysShort).join("|") + ")";
                    parsedIndexes.weekdayShort = index;
                    break;
                case "aaa":
                case "aa":
                case "a":
                    // TODO: fix (escape regex)
                    reg += "(" + this.getStringList(["AM", "PM", "A\.M\.", "P\.M\.", "A", "P"]).join("|") + ")";
                    parsedIndexes.am = index;
                    break;
                case "hh":
                case "h":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hour12Base1 = index;
                    break;
                case "HH":
                case "H":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hourBase0 = index;
                    break;
                case "KK":
                case "K":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hour12Base0 = index;
                    break;
                case "kk":
                case "k":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.hourBase1 = index;
                    break;
                case "mm":
                case "m":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.minute = index;
                    break;
                case "ss":
                case "s":
                    reg += "([0-9]{2}|[0-9]{1})";
                    parsedIndexes.second = index;
                    break;
                case "SSS":
                case "SS":
                case "S":
                    reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                    parsedIndexes.millisecond = index;
                    parsedIndexes.millisecondDigits = info.parts[i].length;
                    break;
                case "nnn":
                case "nn":
                case "n":
                    reg += "([0-9]{3}|[0-9]{2}|[0-9]{1})";
                    parsedIndexes.millisecond = index;
                    break;
                case "x":
                    reg += "([0-9]{1,})";
                    parsedIndexes.timestamp = index;
                    break;
                case "Z":
                    reg += "GMT([-+]+[0-9]{2}:[0-9]{2})";
                    parsedIndexes.zone = index;
                    break;
                case "ZZ":
                    reg += "([\\-+]+[0-9]{2}[0-9]{2})";
                    parsedIndexes.zone = index;
                    break;
                case "i":
                    reg += "([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})\.([0-9]{3})[0-9]*([Zz]?)";
                    parsedIndexes.iso = index;
                    indexAdjust += 7;
                    break;
                case "G":
                case "YYYY":
                case "YYY":
                case "YY":
                case "Y":
                case "MMMMM":
                case "W":
                case "EEEEE":
                case "EEEE":
                case "EEE":
                case "EE":
                case "E":
                case "eeeee":
                case "eeee":
                case "eee":
                case "ee":
                case "e":
                case "zzzz":
                case "zzz":
                case "zz":
                case "z":
                case "t":
                    // Ignore
                    indexAdjust--;
                    break;
            }
            reg += "[^0-9]*";
        }
        // Try matching
        var regex = new RegExp(reg);
        var matches = source.match(regex);
        if (matches) {
            // Populate the date object
            // Full year
            if (parsedIndexes.year > -1) {
                resValues.year = parseInt(matches[parsedIndexes.year]);
            }
            // 3-digit year
            if (parsedIndexes.year3 > -1) {
                var val = parseInt(matches[parsedIndexes.year3]);
                val += 1000;
                resValues.year = val;
            }
            // 2-digit year
            if (parsedIndexes.year2 > -1) {
                var val = parseInt(matches[parsedIndexes.year2]);
                if (val > 50) {
                    val += 1000;
                }
                else {
                    val += 2000;
                }
                resValues.year = val;
            }
            // 1-digit year
            if (parsedIndexes.year1 > -1) {
                var val = parseInt(matches[parsedIndexes.year1]);
                val = Math.floor((new Date().getFullYear()) / 10) * 10 + val;
                resValues.year = val;
            }
            // Full month
            if (parsedIndexes.monthLong > -1) {
                resValues.month = this.resolveMonth(matches[parsedIndexes.monthLong]);
            }
            // Short month
            if (parsedIndexes.monthShort > -1) {
                resValues.month = this.resolveShortMonth(matches[parsedIndexes.monthShort]);
            }
            // Numeric month
            if (parsedIndexes.month > -1) {
                resValues.month = parseInt(matches[parsedIndexes.month]) - 1;
            }
            // Weekday
            // @todo
            // Week
            if ((parsedIndexes.week > -1) && (parsedIndexes.day === -1)) {
                // We parse weeks ONLY if day is not explicitly set
                // TODO: this needs work
                // (but maybe later - I can hardly imagine anyone passing their dates in weeks)
                resValues.month = 0;
                resValues.day = getDayFromWeek(parseInt(matches[parsedIndexes.week]), resValues.year, 1, this.utc);
            }
            // Day
            if (parsedIndexes.day > -1) {
                resValues.day = parseInt(matches[parsedIndexes.day]);
            }
            // Year day
            if (parsedIndexes.yearDay > -1) {
                resValues.month = 0;
                resValues.day = parseInt(matches[parsedIndexes.yearDay]);
            }
            // 24 Hour (0-23)
            if (parsedIndexes.hourBase0 > -1) {
                resValues.hour = parseInt(matches[parsedIndexes.hourBase0]);
            }
            // 24 Hour (1-24)
            if (parsedIndexes.hourBase1 > -1) {
                resValues.hour = parseInt(matches[parsedIndexes.hourBase1]) - 1;
            }
            // 12 Hour (0-11)
            if (parsedIndexes.hour12Base0 > -1) {
                var val = parseInt(matches[parsedIndexes.hour12Base0]);
                if (val == 11) {
                    val = 0;
                }
                if ((parsedIndexes.am > -1) && !this.isAm(matches[parsedIndexes.am])) {
                    val += 12;
                }
                resValues.hour = val;
            }
            // 12 Hour (1-12)
            if (parsedIndexes.hour12Base1 > -1) {
                var val = parseInt(matches[parsedIndexes.hour12Base1]);
                if (val == 12) {
                    val = 0;
                }
                if ((parsedIndexes.am > -1) && !this.isAm(matches[parsedIndexes.am])) {
                    val += 12;
                }
                resValues.hour = val;
            }
            // Minute
            if (parsedIndexes.minute > -1) {
                resValues.minute = parseInt(matches[parsedIndexes.minute]);
            }
            // Second
            if (parsedIndexes.second > -1) {
                resValues.second = parseInt(matches[parsedIndexes.second]);
            }
            // Millisecond
            if (parsedIndexes.millisecond > -1) {
                var val = parseInt(matches[parsedIndexes.millisecond]);
                if (parsedIndexes.millisecondDigits == 2) {
                    val *= 10;
                }
                else if (parsedIndexes.millisecondDigits == 1) {
                    val *= 100;
                }
                resValues.millisecond = val;
            }
            // Timestamp
            if (parsedIndexes.timestamp > -1) {
                resValues.timestamp = parseInt(matches[parsedIndexes.timestamp]);
            }
            // Adjust time zone
            if (parsedIndexes.zone > -1) {
                var zone = matches[parsedIndexes.zone].replace(/:/, "");
                var match = getValue(zone.match(/([+\-]?)([0-9]{2})([0-9]{2})/));
                var dir = match[1];
                var hour = match[2];
                var minute = match[3];
                var offset = parseInt(hour) * 60 + parseInt(minute);
                // Adjust offset
                // Making it negative does not seem to make sense, but it's right
                // because of how JavaScript calculates GTM offsets
                if (dir == "+") {
                    offset *= -1;
                }
                // Check the difference in offset
                var originalOffset = new Date().getTimezoneOffset();
                var diff = offset - originalOffset;
                resValues.offset = diff;
            }
            // ISO
            if (parsedIndexes.iso > -1) {
                if (matches[parsedIndexes.iso + 7] == "Z" || matches[parsedIndexes.iso + 7] == "z") {
                    resValues.utc = true;
                }
                resValues.year = toNumber(matches[parsedIndexes.iso + 0]);
                resValues.month = toNumber(matches[parsedIndexes.iso + 1]) - 1;
                resValues.day = toNumber(matches[parsedIndexes.iso + 2]);
                resValues.hour = toNumber(matches[parsedIndexes.iso + 3]);
                resValues.minute = toNumber(matches[parsedIndexes.iso + 4]);
                resValues.second = toNumber(matches[parsedIndexes.iso + 5]);
                resValues.millisecond = toNumber(matches[parsedIndexes.iso + 6]);
            }
            // Create Date object
            if (resValues.utc) {
                res = new Date(Date.UTC(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond));
            }
            else {
                res = new Date(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond);
            }
        }
        else {
            // Didn't match anything
            // Let's try dropping it into Date constructor and hope for the best
            res = new Date(source);
        }
        return res;
    };
    /**
     * Resolves month name (i.e. "December") into a month number (11).
     *
     * @param value  Month name
     * @return Month number
     */
    DateFormatter.prototype.resolveMonth = function (value) {
        // Let's try English first
        var month = this.months.indexOf(value);
        if (month > -1) {
            return month;
        }
        // Try the translation
        if (this.language && !this.language.isDefault()) {
            month = this.language.translateAll(this.months).indexOf(value);
            if (month > -1) {
                return month;
            }
        }
        return 0;
    };
    /**
     * Resolves short month name (i.e. "Dec") into a month number.
     *
     * @param value  Short month name
     * @return Month number
     */
    DateFormatter.prototype.resolveShortMonth = function (value) {
        // Let's try English first
        var month = this.monthsShort.indexOf(value);
        if (month > -1) {
            return month;
        }
        // Maybe long month (workaround for May)
        month = this.months.indexOf(value);
        if (month > -1) {
            return month;
        }
        // Try the translation
        if (this.language && !this.language.isDefault()) {
            month = this.language.translateAll(this.monthsShort).indexOf(value);
            if (month > -1) {
                return month;
            }
        }
        return 0;
    };
    /**
     * Checks if passed in string represents AM/PM notation in many of its
     * versions.
     *
     * @param value  Source string
     * @return Is it AM/PM?
     */
    DateFormatter.prototype.isAm = function (value) {
        var list = this.getStringList(["AM", "A.M.", "A"]);
        return list.indexOf(value.toUpperCase()) > -1;
    };
    /**
     * Invalidates related [[Sprite]] causing it to redraw.
     */
    DateFormatter.prototype.invalidateSprite = function () {
        if (this.sprite) {
            this.sprite.invalidate();
        }
    };
    /**
     * Translates list of strings.
     *
     * @param list  Source strings
     * @return Translated strings
     */
    DateFormatter.prototype.getStringList = function (list) {
        var res = [];
        for (var i = 0; i < list.length; i++) {
            // translate?
            if (this.language) {
                res.push(escapeForRgex(this.language.translate(list[i])));
            }
            else {
                res.push(escapeForRgex(list[i]));
            }
        }
        return res;
    };
    Object.defineProperty(DateFormatter.prototype, "dateFormat", {
        /**
         * @return Date format
         */
        get: function () {
            return this._dateFormat;
        },
        /**
         * Date format to use.
         *
         * If format is not supplied in-line in the string, this setting will be
         * used.
         *
         * @default "yyyy-MM-dd"
         * @param value Date format
         */
        set: function (value) {
            this._dateFormat = value;
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateFormatter.prototype, "inputDateFormat", {
        /**
         * @return Date format
         */
        get: function () {
            return this._inputDateFormat;
        },
        /**
         * Date format to use when parsing dates.
         *
         * @default "yyyy-MM-dd"
         * @param value Date format
         */
        set: function (value) {
            this._inputDateFormat = value;
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateFormatter.prototype, "intlLocales", {
        /**
         * @return Date format
         */
        get: function () {
            return this._intlLocales;
        },
        /**
         * Locales if you are using date formats in `Intl.DateTimeFormatOptions` syntax.
         *
         * @param value Locales
         */
        set: function (value) {
            this._intlLocales = value;
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateFormatter.prototype, "utc", {
        /**
         * @return Use UTC?
         */
        get: function () {
            return this._utc;
        },
        /**
         * Should formatter use UTC functions?
         *
         * If UTC is used, all date/time values will be independent on client's
         * time zone.
         *
         * @param value Use UTC?
         */
        set: function (value) {
            this._utc = value;
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateFormatter.prototype, "timezoneOffset", {
        /**
         * @return Offset (minutes)
         */
        get: function () {
            return this._timezoneOffset;
        },
        /**
         * If set, will format date/time in specific time zone.
         *
         * The value is a number of minutes from target time zone to UTC.
         *
         * E.g. `300` will recalculate Dates in "GMT-5" time zone.
         *
         * @param  value  Offset (minutes)
         */
        set: function (value) {
            if (this._timezoneOffset != value) {
                this._timezoneOffset = value;
                this.invalidateSprite();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateFormatter.prototype, "firstDayOfWeek", {
        /**
         * @return First day of week
         */
        get: function () {
            return this._firstDayOfWeek;
        },
        /**
         * First day of the week:
         *
         * * 0 - Sunday
         * * 1 - Monday
         * * 2 - Tuesday
         *
         * Etc.
         *
         * @param value First day of week
         */
        set: function (value) {
            this._firstDayOfWeek = value;
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateFormatter.prototype, "outputFormat", {
        /**
         * @ignore Exclude from docs
         * @return Format
         */
        get: function () {
            return this._outputFormat;
        },
        /**
         * Output format for the formatted date.
         *
         * @ignore Exclude from docs
         * @param value  Format
         */
        set: function (value) {
            this._outputFormat = value.toLowerCase();
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    return DateFormatter;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["DateFormatter"] = DateFormatter_DateFormatter;
//# sourceMappingURL=DateFormatter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/formatters/DurationFormatter.js
/**
 * Duration formatting functionality.
 */










/**
 * DurationFormatter class. Formats numbers as durations.
 *
 * `1000` as `16:40`
 *
 * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/} Tutorial on duration formatting
 */
var DurationFormatter_DurationFormatter = /** @class */ (function (_super) {
    __extends(DurationFormatter, _super);
    /**
     * Constructor
     */
    function DurationFormatter() {
        var _this = _super.call(this) || this;
        /**
         * A base value for negative numbers. Will treat all numbers below this value
         * as negative numbers.
         */
        _this._negativeBase = 0;
        /**
         * A base unit to consider values are in.
         *
         * @default "s"
         */
        _this._baseUnit = "second";
        /**
         * Output format to produce. If the format calls for applying color to the
         * formatted value, this setting will determine what markup to use: SVG or
         * HTML.
         *
         * Available options: svg, html.
         *
         * @default "svg"
         */
        _this._outputFormat = "svg";
        /**
         * How many milliseconds each unit represents.
         */
        _this._unitValues = {
            "millisecond": 1,
            "second": 1000,
            "minute": 60000,
            "hour": 3600000,
            "day": 86400000,
            "week": 604800000,
            "month": 2592000000,
            "year": 31536000000,
        };
        /**
         * Collection of aliases for units.
         */
        _this._unitAliases = {
            "Y": "y",
            "D": "d",
            "H": "h",
            "K": "h",
            "k": "h",
            "n": "S"
        };
        _this.className = "DurationFormatter";
        _this.applyTheme();
        return _this;
    }
    /**
     * Formats the number according as duration.
     *
     * For example `1000` (base unit seconds) would be converted to `16:40` as in
     * 16 minutes and 40 seconds.
     *
     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/} Tutorial on duration formatting
     * @param value   Value to format
     * @param format  Format to apply
     * @param base    Override base unit
     * @return Formatted number
     */
    DurationFormatter.prototype.format = function (value, format, base) {
        // no language?
        if (!this.language) {
            if (this.sprite) {
                this.language = this.sprite.language;
            }
            else {
                this.language = new Language_Language;
            }
        }
        // no base unit?
        var baseUnit = base || this._baseUnit;
        // no format passed in or empty
        if (typeof format === "undefined" || format === "") {
            if (hasValue(this.durationFormat)) {
                format = this.durationFormat;
            }
            else {
                format = this.getFormat(toNumber(value), null, baseUnit);
            }
        }
        // Clean format
        format = cleanFormat(format);
        // get format info (it will also deal with parser caching)
        var info = this.parseFormat(format, baseUnit);
        // cast to number just in case
        // TODO: maybe use better casting
        var source = Number(value);
        // format and replace the number
        var details;
        if (source > this._negativeBase) {
            details = info.positive;
        }
        else if (source < this._negativeBase) {
            details = info.negative;
        }
        else {
            details = info.zero;
        }
        // Format
        var formatted = this.applyFormat(source, details);
        // Apply color?
        if (details.color !== "") {
            if (this._outputFormat === "svg") {
                formatted = "<tspan fill='" + details.color + "'>" + formatted + "</tspan>";
            }
            else if (this._outputFormat === "html") {
                formatted = "<span style='color: " + details.color + ";'>" + formatted + "</span>";
            }
        }
        return formatted;
    };
    /**
     * Parses supplied format into structured object which can be used to format
     * the number.
     *
     * @param format  Format string, i.e. "#,###.00"
     * @param base    Override base unit
     * @return Parsed information
     */
    DurationFormatter.prototype.parseFormat = function (format, base) {
        var _this = this;
        // Check cache
        var cached = this.getCache(format);
        if (hasValue(cached)) {
            return cached;
        }
        // no base unit?
        var baseUnit = base || this._baseUnit;
        // Initialize duration parsing info
        var info = {
            "positive": {
                "color": "",
                "template": "",
                "parts": [],
                "source": "",
                "baseUnit": baseUnit,
                "parsed": false,
                "absolute": false
            },
            "negative": {
                "color": "",
                "template": "",
                "parts": [],
                "source": "",
                "baseUnit": baseUnit,
                "parsed": false,
                "absolute": false
            },
            "zero": {
                "color": "",
                "template": "",
                "parts": [],
                "source": "",
                "baseUnit": baseUnit,
                "parsed": false,
                "absolute": false
            }
        };
        // Escape double vertical bars (that mean display one vertical bar)
        format = format.replace("||", PLACEHOLDER2);
        // Split it up and deal with different formats
        var parts = format.split("|");
        info.positive.source = parts[0];
        if (typeof parts[2] === "undefined") {
            info.zero = info.positive;
        }
        else {
            info.zero.source = parts[2];
        }
        if (typeof parts[1] === "undefined") {
            info.negative = info.positive;
        }
        else {
            info.negative.source = parts[1];
        }
        // Parse each
        Object_each(info, function (part, item) {
            // Already parsed
            if (item.parsed) {
                return;
            }
            // Check cached
            if (typeof _this.getCache(item.source) !== "undefined") {
                info[part] = _this.getCache(item.source);
                return;
            }
            // Begin parsing
            var partFormat = item.source;
            // Check for [] directives
            var dirs = [];
            dirs = item.source.match(/^\[([^\]]*)\]/);
            if (dirs && dirs.length && dirs[0] !== "") {
                partFormat = item.source.substr(dirs[0].length);
                item.color = dirs[1];
            }
            // Let TextFormatter split into chunks
            var chunks = getTextFormatter().chunk(partFormat, true);
            for (var i = 0; i < chunks.length; i++) {
                var chunk = chunks[i];
                // replace back double vertical bar
                chunk.text = chunk.text.replace(PLACEHOLDER2, "|");
                if (chunk.type === "value") {
                    // Just "Duration"?
                    // if (chunk.text.toLowerCase() === "duration") {
                    // 	chunk.text = durationFormat;
                    // }
                    // Check for "a" (absolute) modifier
                    if (chunk.text.match(/[yYMdDwhHKkmsSn]+a/)) {
                        item.absolute = true;
                        chunk.text = chunk.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1");
                    }
                    // Find all possible parts
                    var matches = chunk.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);
                    if (matches) {
                        // Populate template
                        for (var x = 0; x < matches.length; x++) {
                            // Is it an alias?
                            if (!hasValue(matches[x])) {
                                matches[x] = _this._unitAliases[matches[x]];
                            }
                            item.parts.push(matches[x]);
                            chunk.text = chunk.text.replace(matches[x], PLACEHOLDER);
                        }
                    }
                }
                // Apply to template
                item.template += chunk.text;
            }
            // Apply style formatting
            //item.template = getTextFormatter().format(item.template, this.outputFormat);
            // Save cache
            _this.setCache(item.source, item);
            // Mark this as parsed
            item.parsed = true;
        });
        // Save cache (the whole thing)
        this.setCache(format, info);
        return info;
    };
    /**
     * Applies parsed format to a numeric value.
     *
     * @param value    Value
     * @param details  Parsed format as returned by {parseFormat}
     * @return Formatted duration
     */
    DurationFormatter.prototype.applyFormat = function (value, details) {
        // Use absolute values
        var negative = !details.absolute && (value < this._negativeBase);
        value = Math.abs(value);
        // Recalculate to milliseconds
        var tstamp = this.toTimeStamp(value, details.baseUnit);
        // Init return value
        var res = details.template;
        // Iterate through duration parts
        for (var i = 0, len = details.parts.length; i < len; i++) {
            // Gather the part
            var part = details.parts[i];
            var unit = this.toTimeUnit(part.substr(0, 1));
            var digits = part.length;
            // Calculate current unit value
            var ints = Math.floor(tstamp / this._unitValues[unit]);
            res = res.replace(PLACEHOLDER, padString(ints, digits, "0"));
            // Reduce timestamp
            tstamp -= ints * this._unitValues[unit];
        }
        // Reapply negative sign
        if (negative) {
            res = "-" + res;
        }
        return res;
    };
    /**
     * Converts numeric value to timestamp in milliseconds.
     *
     * @param value     A source value
     * @param baseUnit  Base unit the source value is in: "q", "s", "i", "h", "d", "w", "m", "y"
     * @return Value representation as a timestamp in milliseconds
     */
    DurationFormatter.prototype.toTimeStamp = function (value, baseUnit) {
        return value * this._unitValues[baseUnit];
    };
    DurationFormatter.prototype.toTimeUnit = function (code) {
        switch (code) {
            case "S":
                return "millisecond";
            case "s":
                return "second";
            case "m":
                return "minute";
            case "h":
                return "hour";
            case "d":
                return "day";
            case "w":
                return "week";
            case "M":
                return "month";
            case "y":
                return "year";
        }
        ;
    };
    /**
     * Invalidates the parent [[Sprite]] object.
     */
    DurationFormatter.prototype.invalidateSprite = function () {
        if (this.sprite) {
            this.sprite.invalidate();
        }
    };
    Object.defineProperty(DurationFormatter.prototype, "baseUnit", {
        /**
         * @return Base unit
         */
        get: function () {
            return this._baseUnit;
        },
        /**
         * Base unit the values are in.
         *
         * A base unit will be used to recalculate the numeric value to millisecond
         * timestamps.
         *
         * Available options:
         *
         * * "millisecond"
         * * "second"
         * * "minute"
         * * "hour"
         * * "day"
         * * "week"
         * * "month"
         * * "year"
         *
         * @default "s"
         * @param baseUnit  A base unit
         */
        set: function (baseUnit) {
            this._baseUnit = baseUnit;
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DurationFormatter.prototype, "outputFormat", {
        /**
         * Getter for output format.
         *
         * @ignore Exclude from docs
         * @return Output format
         */
        get: function () {
            return this._outputFormat;
        },
        /**
         * Setter for output format: "svg" or "html.
         *
         * @ignore Exclude from docs
         * @param value  Output format
         */
        set: function (outputFormat) {
            this._outputFormat = outputFormat.toLowerCase();
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns appropriate default format for the value.
     *
     * If `maxValue` is sepcified, it will use that value to determine the time
     * unit for the format.
     *
     * For example if your `baseUnit` is `"second"` and you pass in `10`, you
     * will get `"10"`.
     *
     * However, you might want it to be formatted in the context of bigger scale,
     * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all
     * values, including small ones will use format with minutes, e.g.:
     * `00:10`, `00:50`, `12: 30`, etc.
     *
     * @param value     Value to format
     * @param maxValue  Maximum value to be used to determine format
     * @param baseUnit  Base unit of the value
     * @return Format
     */
    DurationFormatter.prototype.getFormat = function (value, maxValue, baseUnit) {
        // Is format override set?
        if (hasValue(this.durationFormat)) {
            return this.durationFormat;
        }
        // Get base unit
        if (!baseUnit) {
            baseUnit = this.baseUnit;
        }
        if (hasValue(maxValue) && value != maxValue) {
            value = Math.abs(value);
            maxValue = Math.abs(maxValue);
            var maxUnit = this.getValueUnit(Math_max(value, maxValue), baseUnit);
            //let diffUnit = this.getValueUnit(Math.abs(maxValue - value), baseUnit);
            //console.log(maxUnit, diffUnit);
            return this.durationFormats[baseUnit][maxUnit];
        }
        else {
            var unit = this.getValueUnit(value, baseUnit);
            return this.durationFormats[baseUnit][unit];
        }
    };
    /**
     * Returns value's closest denominator time unit, e.g 100 seconds is
     * `"minute"`, while 59 seconds would still be `second`.
     *
     * @param value     Source duration value
     * @param baseUnit  Base unit
     * @return Denominator
     */
    DurationFormatter.prototype.getValueUnit = function (value, baseUnit) {
        // Get base unit
        if (!baseUnit) {
            baseUnit = this.baseUnit;
        }
        // Convert to milliseconds
        var currentUnit;
        var ms = this.getMilliseconds(value, baseUnit);
        Object_eachContinue(this._unitValues, function (key, val) {
            if (key == baseUnit || currentUnit) {
                var num = ms / val;
                if (num <= 1) {
                    if (!currentUnit) {
                        currentUnit = key;
                    }
                    return false;
                }
                currentUnit = key;
            }
            return true;
        });
        return currentUnit;
    };
    /**
     * Converts value to milliseconds according to `baseUnit`.
     *
     * @param value     Source duration value
     * @param baseUnit  Base unit
     * @return Value in milliseconds
     */
    DurationFormatter.prototype.getMilliseconds = function (value, baseUnit) {
        // Get base unit
        if (!baseUnit) {
            baseUnit = this.baseUnit;
        }
        return value * this._unitValues[baseUnit];
    };
    Object.defineProperty(DurationFormatter.prototype, "durationFormat", {
        /**
         * @return Format
         */
        get: function () {
            return this._durationFormat;
        },
        /**
         * If set, this format will be used instead of the one determined dynamically
         * based on the basedUnit and range of values.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/} Available fomatting codes
         * @param value  Format
         */
        set: function (value) {
            if (this._durationFormat != value) {
                this._durationFormat = value;
                this.invalidateSprite();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DurationFormatter.prototype, "durationFormats", {
        /**
         * @return Formats
         */
        get: function () {
            if (!this._durationFormats) {
                this._durationFormats = {
                    "millisecond": {
                        "millisecond": this.language.translate("_duration_millisecond"),
                        "second": this.language.translate("_duration_millisecond_second"),
                        "minute": this.language.translate("_duration_millisecond_minute"),
                        "hour": this.language.translate("_duration_millisecond_hour"),
                        "day": this.language.translate("_duration_millisecond_day"),
                        "week": this.language.translate("_duration_millisecond_week"),
                        "month": this.language.translate("_duration_millisecond_month"),
                        "year": this.language.translate("_duration_millisecond_year")
                    },
                    "second": {
                        "second": this.language.translate("_duration_second"),
                        "minute": this.language.translate("_duration_second_minute"),
                        "hour": this.language.translate("_duration_second_hour"),
                        "day": this.language.translate("_duration_second_day"),
                        "week": this.language.translate("_duration_second_week"),
                        "month": this.language.translate("_duration_second_month"),
                        "year": this.language.translate("_duration_second_year")
                    },
                    "minute": {
                        "minute": this.language.translate("_duration_minute"),
                        "hour": this.language.translate("_duration_minute_hour"),
                        "day": this.language.translate("_duration_minute_day"),
                        "week": this.language.translate("_duration_minute_week"),
                        "month": this.language.translate("_duration_minute_month"),
                        "year": this.language.translate("_duration_minute_year")
                    },
                    "hour": {
                        "hour": this.language.translate("_duration_hour"),
                        "day": this.language.translate("_duration_hour_day"),
                        "week": this.language.translate("_duration_hour_week"),
                        "month": this.language.translate("_duration_hour_month"),
                        "year": this.language.translate("_duration_hour_year")
                    },
                    "day": {
                        "day": this.language.translate("_duration_day"),
                        "week": this.language.translate("_duration_day_week"),
                        "month": this.language.translate("_duration_day_month"),
                        "year": this.language.translate("_duration_day_year")
                    },
                    "week": {
                        "week": this.language.translate("_duration_week"),
                        "month": this.language.translate("_duration_week_month"),
                        "year": this.language.translate("_duration_week_year")
                    },
                    "month": {
                        "month": this.language.translate("_duration_month"),
                        "year": this.language.translate("_duration_month_year")
                    },
                    "year": {
                        "year": this.language.translate("_duration_year")
                    }
                };
            }
            return this._durationFormats;
        },
        /**
         * Duration formats for various combination of base units.
         *
         * @param value  Formats
         */
        set: function (value) {
            this._durationFormats = value;
            this.invalidateSprite();
        },
        enumerable: true,
        configurable: true
    });
    return DurationFormatter;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["DurationFormatter"] = DurationFormatter_DurationFormatter;
//# sourceMappingURL=DurationFormatter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/export/ExportCSS.js




var ExportCSS_rules = new Dictionary_Dictionary();
/**
 * A dynamically-loadable CSS module for Export menu.
 *
 * @ignore Exclude from docs
 * @param prefix  Prefix to addtach to class names
 * @return A MultiDisposer with style rules
 */
/* harmony default export */ var ExportCSS = (function (element, prefix) {
    var newPrefix = (prefix ? prefix : "amexport");
    var colorSet = new InterfaceColorSet_InterfaceColorSet();
    var counter = ExportCSS_rules.insertKeyIfEmpty(newPrefix, function () {
        var disposer = new Disposer_MultiDisposer([
            /*new StyleRule(`.${newPrefix}-menu`, {
                "opacity": "0.3",
                "transition": "all 100ms ease-in-out",
            }),

            new StyleRule(`div:hover .${newPrefix}-menu, .${newPrefix}-menu.active`, {
                "opacity": "0.9",
            }),*/
            new DOM_StyleRule(element, "." + newPrefix + "-menu *", {
                "box-sizing": "border-box"
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-menu-level-0", {
                "position": "absolute",
                "top": "5px",
                "right": "5px",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-menu-level-0." + newPrefix + "-left", {
                "right": "auto",
                "left": "5px",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-menu-level-0." + newPrefix + "-right", {
                "right": "5px",
                "left": "auto",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-menu-level-0." + newPrefix + "-top", {
                "top": "5px",
                "bottom": "auto",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-menu-level-0." + newPrefix + "-bottom", {
                "top": "auto",
                "bottom": "5px",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-item." + newPrefix + "-item-level-0", {
                "opacity": "0.3",
                "width": "30px",
                "min-height": "30px",
                "transition": "all 100ms ease-in-out",
            }),
            new DOM_StyleRule(element, "div:hover ." + newPrefix + "-item." + newPrefix + "-item-level-0, ." + newPrefix + "-item." + newPrefix + "-item-level-0.active", {
                "opacity": "0.9",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-item." + newPrefix + "-item-level-0 > a", {
                "padding": "0",
                "text-align": "center",
                "overflow": "hidden"
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-item." + newPrefix + "-item-level-0:before", {
                "display": "block"
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-item", {
                "position": "relative",
                "display": "block",
                "opacity": "0",
                "z-index": "1",
                "border-radius": "3px",
                "background-color": colorSet.getFor("secondaryButton").hex,
                "padding": "0",
                "margin": "1px 1px 0 0",
                "color": colorSet.getFor("secondaryButton").alternative.hex,
                "transition": "all 100ms ease-in-out, opacity 0.5s ease 0.5s",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-left ." + newPrefix + "-item", {
                "margin": "1px 0 0 1px",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-item:hover, ." + newPrefix + "-item.active", {
                "background": colorSet.getFor("secondaryButtonHover").hex,
                "color": colorSet.getFor("secondaryButtonText").hex,
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-item > ." + newPrefix + "-menu", {
                "position": "absolute",
                "top": "-1px",
                "right": "0",
                "margin-right": "100%",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-left ." + newPrefix + "-item > ." + newPrefix + "-menu", {
                "left": "0",
                "right": "auto",
                "margin-left": "100%",
                "margin-right": "auto",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-right ." + newPrefix + "-item > ." + newPrefix + "-menu", {
                "left": "auto",
                "right": "0",
                "margin-left": "auto",
                "margin-right": "100%",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-top ." + newPrefix + "-item > ." + newPrefix + "-menu", {
                "top": "-1px",
                "bottom": "auto",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-bottom ." + newPrefix + "-item > ." + newPrefix + "-menu", {
                "top": "auto",
                "bottom": "0",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-item > ." + newPrefix + "-menu", {
                "display": "none",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-item:hover > ." + newPrefix + "-menu, ." + newPrefix + "-item.active > ." + newPrefix + "-menu", {
                "display": "block",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-item:hover > ." + newPrefix + "-menu > ." + newPrefix + "-item, ." + newPrefix + "-item.active > ." + newPrefix + "-menu > ." + newPrefix + "-item", {
                "opacity": "1",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-menu", {
                "display": "block",
                "list-style": "none",
                "margin": "0",
                "padding": "0",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-label", {
                "display": "block",
                "cursor": "default",
                "padding": "0.5em 1em",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-icon", {
                "display": "block",
                "cursor": "default",
                "padding": "0.2em 0.4em",
                "width": "1.2em",
                "height": "1.2em",
                "min-width": "32px",
                "min-height": "32px",
                "margin": "auto auto",
                "border-radius": "3px",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-item-level-0 > ." + newPrefix + "-icon", {
                "padding": "0.1em 0.2em",
            }),
            new DOM_StyleRule(element, "." + newPrefix + "-clickable", {
                "cursor": "pointer",
            }),
        ]);
        return new Disposer_CounterDisposer(function () {
            ExportCSS_rules.removeKey(newPrefix);
            disposer.dispose();
        });
    });
    return counter.increment();
});
//# sourceMappingURL=ExportCSS.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Validatable.js
/**
 * This module defines a [[Validatable]] class which can be used by all
 * non-[[Sprite]] classes to use system beats to revalidate themselves.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * This module defines a [[Validatable]] class which can be used by all
 * non-[[Sprite]] classes to use system update cycle to revalidate themselves.
 *
 * @ignore Exclude from docs
 */
var Validatable_Validatable = /** @class */ (function (_super) {
    __extends(Validatable, _super);
    function Validatable() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Is invalid and should be revalidated?
         */
        _this._validateDisposer = null;
        return _this;
    }
    /**
     * Invalidates the element, so that it can re-validate/redraw itself in the
     * next cycle.
     *
     * @ignore Exclude from docs
     */
    Validatable.prototype.invalidate = function () {
        if (this._validateDisposer === null) {
            this._validateDisposer = registry.events.on("exitframe", this.validate, this);
        }
    };
    /**
     * Validates itself.
     *
     * Most probably the extending class will have an overriding `validate()`
     * method which will do actual work, as well as call this method using
     * `super.validate()`.
     *
     * @ignore Exclude from docs
     */
    Validatable.prototype.validate = function () {
        if (this._validateDisposer !== null) {
            this._validateDisposer.dispose();
            this._validateDisposer = null;
        }
    };
    Validatable.prototype.dispose = function () {
        if (this._validateDisposer !== null) {
            this._validateDisposer.dispose();
            this._validateDisposer = null;
        }
        _super.prototype.dispose.call(this);
    };
    return Validatable;
}(Base_BaseObjectEvents));

//# sourceMappingURL=Validatable.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/export/ExportMenu.js
/**
 * ExportMenu provides functionality for building Export menu
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */












/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a menu for Export operations.
 *
 * To add an export menu to a chart, set this to a new instance of
 * [[ExportMenu]].
 *
 * ```TypeScript
 * chart.exporting.menu = new am4core.ExportMenu();
 * ```
 * ```JavaScript
 * chart.exporting.menu = new am4core.ExportMenu();
 * ```
 * ```JSON
 * {
 *   // ...
 *   "exporting": {
 *     "menu": {}
 *   }
 * }
 * ```
 * @important
 */
var ExportMenu_ExportMenu = /** @class */ (function (_super) {
    __extends(ExportMenu, _super);
    /**
     * Constructor
     */
    function ExportMenu() {
        var _this = _super.call(this) || this;
        /**
         * An [[Adapter]].
         */
        _this.adapter = new Adapter_Adapter(_this);
        /**
         * How many milliseconds to hold menu/sub-menu open after it loses focus or
         * hover, before auto-closing it.
         *
         * @default 1000
         */
        _this.closeDelay = 1000;
        /**
         * Close the menu automatically when some export operation is triggered.
         *
         * @default true
         * @since 4.2.2
         */
        _this.closeOnClick = true;
        /**
         * An instance of [[Language]].
         */
        _this._language = new Disposer_MutableValueDisposer();
        /**
         * What HTML tags to use to build menu.
         */
        _this._menuTag = "ul";
        /**
         * Which tag to use to enclose individual menu items.
         */
        _this._itemTag = "li";
        /**
         * Tag to wrap menu item labels in.
         */
        _this._labelTag = "a";
        /**
         * Tag to use for icons
         */
        _this._iconTag = "img";
        /**
         * Prefix for class names applied to menu elements.
         */
        _this._classPrefix = "amexport";
        /**
         * If set to `true` [[ExportMenu]] will load it's own external CSS when
         * instantiated.
         */
        _this._defaultStyles = true;
        /**
         * Horizontal positioning.
         */
        _this._align = "right";
        /**
         * Vertical positioning.
         */
        _this._verticalAlign = "top";
        /**
         * A tabindex to apply to Export Menu.
         */
        _this._tabindex = 0;
        /**
         * Whether next menu close event should be ignored.
         */
        _this._ignoreNextClose = false;
        /**
         * Default menu items.
         */
        _this._items = [
            {
                "label": "...",
                "menu": [
                    {
                        "label": "Image",
                        "menu": [
                            { "type": "png", "label": "PNG" },
                            { "type": "jpg", "label": "JPG" },
                            { "type": "svg", "label": "SVG" },
                            { "type": "pdf", "label": "PDF" }
                        ]
                    }, {
                        "label": "Data",
                        "menu": [
                            { "type": "json", "label": "JSON" },
                            { "type": "csv", "label": "CSV" },
                            { "type": "xlsx", "label": "XLSX" },
                            { "type": "html", "label": "HTML" },
                            { "type": "pdfdata", "label": "PDF" }
                        ]
                    }, {
                        "label": "Print", "type": "print"
                    }
                ]
            }
        ];
        _this.className = "ExportMenu";
        _this._disposers.push(_this._language);
        _this.invalidate();
        _this.applyTheme();
        return _this;
    }
    /**
     * (Re)draws the Export menu.
     *
     * @ignore Exclude from docs
     */
    ExportMenu.prototype.validate = function () {
        this.draw();
        _super.prototype.validate.call(this);
    };
    /**
     * Draws the menu based on current items.
     *
     * Normally, there's no need to call this explicitly. The chart, if it has
     * export menu enabled, will automatically draw the menu.
     */
    ExportMenu.prototype.draw = function () {
        var _this = this;
        // Create top-level menu item, or clear it
        if (!this._element) {
            this._element = this.createMenuElement(0);
        }
        else {
            this._element.innerHTML = "";
            this._element.className = this.getMenuItemClass(0);
        }
        // See if we're loading external CSS
        // Hide it until CSS is loaded
        if (this.defaultStyles) {
            this._element.style.display = "none";
        }
        // Append to container
        getValue(this._container).appendChild(this._element);
        // Apply adapter to menu items before processing
        var items = this.adapter.apply("items", {
            items: this._items
        }).items;
        for (var len = items.length, i = 0; i < len; i++) {
            this.drawBranch(this._element, items[i], 0);
        }
        // Apply adapter to finalized menu element
        this._element = this.adapter.apply("menuElement", {
            menuElement: this._element
        }).menuElement;
        // Set up global "down" event
        this._disposers.push(getInteraction().body.events.on("down", function (ev) {
            if (!ev.pointer.touch) {
                _this._ignoreNextClose = false;
            }
            _this.close();
        }));
        // Set up global event on ESC press to close the menu
        this._disposers.push(getInteraction().body.events.on("keyup", function (ev) {
            var key = keyboard.getEventKey(ev.event);
            switch (key) {
                case "esc":
                    _this.close();
                    break;
                case "up":
                case "down":
                case "left":
                case "right":
                    _this.moveSelection(key);
                    break;
            }
        }));
        if (this.defaultStyles) {
            this.loadDefaultCSS();
        }
    };
    /**
     * Creates a new branch in export menu. This function is recursive for
     * building multi-level menus.
     *
     * @ignore Exclude from docs
     * @param container Container to put branch elements in
     * @param branch    Menu item
     * @param level     Current nesting level
     */
    ExportMenu.prototype.drawBranch = function (container, branch, level) {
        var _this = this;
        // Apply adapter
        branch = this.adapter.apply("branch", {
            branch: branch,
            level: level
        }).branch;
        // Unsupported?
        // ExportMenu does not check or know for specific browser/system
        // capabilities. It must happen in some other code and applied via Adapter.
        // Export itself will check compatibility, but there might be other plugins
        // that influence it or even add any specific export functionality.
        if (branch.unsupported === true) {
            return;
        }
        // Init ascendants
        if (!branch.ascendants) {
            branch.ascendants = new List_List();
        }
        // Get type
        var type = branch.type;
        // Create an item
        var element = this.createItemElement(level, type);
        // Create label
        var label;
        // Create icon
        if (branch.icon) {
            label = this.createIconElement(level, type);
            label.src = branch.icon;
            if (branch.label) {
                label.title = branch.label;
            }
        }
        else if (branch.svg) {
            label = this.createSvgElement(level, type, branch.svg);
            if (branch.label) {
                label.title = branch.label;
            }
        }
        else {
            label = this.createLabelElement(level, type);
            label.innerHTML = (branch.label ? this.language.translate(branch.label) : "");
        }
        // Apply reader text to label
        var readerLabel = this.getReaderLabel(branch, label.innerHTML);
        label.setAttribute("aria-label", readerLabel);
        // Add Label
        element.appendChild(label);
        // Create interaction object
        // TODO clean this up when it's disposed
        branch.interactions = getInteraction().getInteraction(label);
        branch.element = element;
        // Create interaction manager we can set event listeners to
        if (this.typeClickable(type)) {
            //branch.interactions.clickable = true;
            // TODO clean this up when it's disposed
            branch.interactions.events.on("hit", function (ev) {
                if (_this.events.isEnabled("hit")) {
                    var event_1 = {
                        "type": "hit",
                        "event": ev.event,
                        "target": _this,
                        "branch": branch
                    };
                    _this.events.dispatchImmediately("hit", event_1);
                }
            });
            // TODO clean this up when it's disposed
            branch.interactions.events.on("keyup", function (ev) {
                if (keyboard.isKey(ev.event, "enter")) {
                    if (_this.events.isEnabled("enter")) {
                        var event_2 = {
                            "type": "enter",
                            "event": ev.event,
                            "target": _this,
                            "branch": branch
                        };
                        _this.events.dispatchImmediately("enter", event_2);
                    }
                }
            });
        }
        {
            var submenu_1 = this.getSubMenu(branch);
            // Add ENTER event to open sub-menus
            if (submenu_1 != null) {
                // TODO clean this up when it's disposed
                branch.interactions.events.on("keyup", function (ev) {
                    if (keyboard.isKey(ev.event, "enter")) {
                        // This is item has sub-menu, activate the first child on ENTER
                        _this.selectBranch(submenu_1[0]);
                        // Attempt to set focus
                        _this.setFocus(submenu_1[0]);
                    }
                });
                branch.interactions.events.on("hit", function (ev) {
                    _this.selectBranch(branch);
                });
            }
        }
        // Add events
        // TODO clean this up when it's disposed
        branch.interactions.events.on("over", function (ev) {
            if (ev.pointer.touch) {
                // Cancel pending menu closure
                _this._ignoreNextClose = true;
            }
            _this.selectBranch(branch);
            if (_this.events.isEnabled("over")) {
                var event_3 = {
                    "type": "over",
                    "event": ev.event,
                    "target": _this,
                    "branch": branch
                };
                _this.events.dispatchImmediately("over", event_3);
            }
        });
        // TODO clean this up when it's disposed
        branch.interactions.events.on("out", function (ev) {
            if (!ev.pointer.touch) {
                _this.delayUnselectBranch(branch);
            }
            if (_this.events.isEnabled("out")) {
                var event_4 = {
                    "type": "out",
                    "event": ev.event,
                    "target": _this,
                    "branch": branch
                };
                _this.events.dispatchImmediately("out", event_4);
            }
        });
        // TODO clean this up when it's disposed
        branch.interactions.events.on("focus", function (ev) {
            _this.selectBranch(branch);
        });
        // TODO clean this up when it's disposed
        branch.interactions.events.on("blur", function (ev) {
            _this.delayUnselectBranch(branch);
        });
        // Increment level
        var local_level = level + 1;
        // Has sub-menu?
        if (branch.menu) {
            var submenu = this.createMenuElement(local_level);
            for (var len = branch.menu.length, i = 0; i < len; i++) {
                var ascendants = new List_List();
                branch.menu[i].ascendants = ascendants;
                if (branch.ascendants.length) {
                    ascendants.copyFrom(branch.ascendants);
                }
                ascendants.push(branch);
                this.drawBranch(submenu, branch.menu[i], local_level);
            }
            // Sub-menu is empty (all items are not supported)
            // Do not draw this menu item at all
            if (submenu.innerHTML == "") {
                return;
            }
            element.appendChild(submenu);
        }
        // Should this item be hidden?
        if (branch.hidden) {
            this.hideBranch(branch);
        }
        // Add id?
        if (branch.id) {
            element.setAttribute("id", branch.id);
        }
        // Background color?
        if (branch.color) {
            element.style.backgroundColor = branch.color.hex;
        }
        // Append to container
        container.appendChild(element);
    };
    /**
     * Creates a menu element to hold its elements in. Usually it's an `<ul>`
     * tag.
     *
     * @ignore Exclude from docs
     * @param level  Current nesting level
     * @return HTML element reference
     */
    ExportMenu.prototype.createMenuElement = function (level) {
        var element = document.createElement(this.menuTag);
        element.className = this.getMenuItemClass(level);
        // Accessibility
        if (level === 0) {
            element.setAttribute("role", "menu");
        }
        return element;
    };
    /**
     * Generates a class name for the menu element based on its nesting level.
     *
     * @ignore Exclude from docs
     * @param level  Current nesting level
     * @return Class name(s)
     */
    ExportMenu.prototype.getMenuItemClass = function (level) {
        var className = this.classPrefix + "-menu " + this.classPrefix + "-menu-level-" + level;
        if (level === 0) {
            className += " " + this.classPrefix + "-menu-root " +
                this.classPrefix + "-" + this.align + " " +
                this.classPrefix + "-" + this.verticalAlign;
        }
        return this.adapter.apply("menuClass", {
            className: className,
            level: level
        }).className;
    };
    /**
     * Creates menu item. Usually `<li>` tag. Its label and sub-elements will go
     * into this element.
     *
     * @ignore Exclude from docs
     * @param level  Current nesting level
     * @param type   Type of the menu item
     * @return HTML element reference
     */
    ExportMenu.prototype.createItemElement = function (level, type) {
        var element = document.createElement(this.itemTag);
        var className = this.classPrefix + "-item " + this.classPrefix
            + "-item-level-" + level
            + " " + this.classPrefix + "-item-" + (type || "blank");
        element.className = this.adapter.apply("itemClass", {
            className: className,
            level: level,
            type: type
        }).className;
        element.setAttribute("role", "menuitem");
        return element;
    };
    /**
     * Creates a "label" part of the menu item. It could be text or any HTML
     * content.
     *
     * @ignore Exclude from docs
     * @param level  Current nesting level
     * @param type   Type of the menu item
     * @return An HTML Element
     */
    ExportMenu.prototype.createLabelElement = function (level, type) {
        var element = document.createElement(this.labelTag);
        var className = this.classPrefix + "-label " + this.classPrefix
            + "-label-level-" + level
            + " " + this.classPrefix + "-item-" + (type || "blank");
        if (this.typeClickable(type)) {
            className += " " + this.classPrefix + "-clickable";
        }
        element.className = this.adapter.apply("labelClass", {
            className: className,
            level: level,
            type: type
        }).className;
        // Accessible navigation
        element.setAttribute("tabindex", this.tabindex.toString());
        element.setAttribute("role", "menuitem");
        return element;
    };
    /**
     * Creates a "icon" part of the menu item.
     *
     * @ignore Exclude from docs
     * @param level  Current nesting level
     * @param type   Type of the menu item
     * @return An HTML Element
     */
    ExportMenu.prototype.createIconElement = function (level, type) {
        var element = document.createElement(this.iconTag);
        var className = this.classPrefix + "-icon " + this.classPrefix
            + "-icon-level-" + level
            + " " + this.classPrefix + "-item-" + (type || "blank");
        if (this.typeClickable(type)) {
            className += " " + this.classPrefix + "-clickable";
        }
        element.className = this.adapter.apply("labelClass", {
            className: className,
            level: level,
            type: type
        }).className;
        // Accessible navigation
        element.setAttribute("tabindex", this.tabindex.toString());
        element.setAttribute("role", "menuitem");
        return element;
    };
    /**
     * Creates a a custom element out of raw HTML.
     *
     * @ignore Exclude from docs
     * @param level  Current nesting level
     * @param type   Type of the menu item
     * @return An HTML Element
     */
    ExportMenu.prototype.createSvgElement = function (level, type, svg) {
        var parser = new DOMParser();
        var element = parser.parseFromString(svg, "image/svg+xml").documentElement;
        var className = this.classPrefix + "-icon " + this.classPrefix
            + "-icon-level-" + level
            + " " + this.classPrefix + "-item-" + (type || "blank");
        if (this.typeClickable(type)) {
            className += " " + this.classPrefix + "-clickable";
        }
        element.setAttribute("class", this.adapter.apply("labelClass", {
            className: className,
            level: level,
            type: type
        }).className);
        // Accessible navigation
        element.setAttribute("tabindex", this.tabindex.toString());
        element.setAttribute("role", "menuitem");
        return element;
    };
    /**
     * Destroys the menu and all its elements.
     */
    ExportMenu.prototype.dispose = function () {
        if (!this._disposed) {
            _super.prototype.dispose.call(this);
            if (this._element && this._element.parentNode) {
                this._element.parentNode.removeChild(this._element);
            }
        }
    };
    /**
     * Checks whether menu item type is supposed to be clickable.
     *
     * @ignore Exclude from docs
     * @param type  Menu item type
     * @return Is clickable?
     */
    ExportMenu.prototype.typeClickable = function (type) {
        return hasValue(type);
    };
    /**
     * Checks whether menu item has any sub-items.
     *
     * @ignore Exclude from docs
     * @param branch  A menu item
     * @return Has sub-items?
     */
    ExportMenu.prototype.hasSubMenu = function (branch) {
        return (branch.menu && branch.menu.length) ? true : false;
    };
    /**
     * Returns sub-items (if they exist).
     *
     * @ignore Exclude from docs
     * @param branch  A menu item
     * @return Submenus
     */
    ExportMenu.prototype.getSubMenu = function (branch) {
        if (branch.menu && branch.menu.length) {
            return branch.menu;
        }
    };
    /**
     * Generates and returns an applicable label to be used for screen readers.
     *
     * @ignore Exclude from docs
     * @param item   A menu item instance
     * @param label  Current label
     * @return Reader text
     */
    ExportMenu.prototype.getReaderLabel = function (branch, label) {
        // Strip any HTML from the label
        label = stripTags(label);
        // Add textual note if the branch is clickable
        if (this.hasSubMenu(branch)) {
            label += " [" + this.language.translate("Click, tap or press ENTER to open") + "]";
        }
        else if (branch.type == "print") {
            label = this.language.translate("Click, tap or press ENTER to print.");
        }
        else if (this.typeClickable(branch.type)) {
            label = this.language.translate("Click, tap or press ENTER to export as %1.", undefined, label);
        }
        return this.adapter.apply("rederLabel", {
            label: label,
            branch: branch
        }).label;
    };
    Object.defineProperty(ExportMenu.prototype, "container", {
        /**
         * @return Container
         */
        get: function () {
            return this._container;
        },
        /**
         * Getters and setters
         */
        /**
         * An HTML container to place the Menu in.
         *
         * A container must be an HTML element, because menu itself is HTML, and
         * cannot be placed into SVG.
         *
         * @param container Reference to container element
         * @todo Check if menu is already build. If it is, just move it to a new container
         */
        set: function (container) {
            this._container = container;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "items", {
        /**
         * @return Menu items
         */
        get: function () {
            return this._items;
        },
        /**
         * A list of menu items. Can be nested.
         *
         * @param items  Menu items
         */
        set: function (items) {
            this._items = items;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "tag", {
        /**
         * Sets main menu tag to place menu in.
         *
         * This also sets up how menu items are built.
         *
         * If you set this to "ul", menu items will be wrapped into `<li>` tags.
         *
         * If set to "div", menu items will be wrapped in `<div>` tags.
         *
         * @default "ul"
         * @param tag Tag to use for menu
         */
        set: function (tag) {
            this._menuTag = tag;
            this._itemTag = tag == "ul" ? "li" : "div";
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "menuTag", {
        /**
         * Returns current menu tag.
         *
         * @ignore Exclude from docs
         * @return Menu tag (item that contains sub-items)
         */
        get: function () {
            return this.adapter.apply("menuTag", {
                tag: this._menuTag
            }).tag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "itemTag", {
        /**
         * Returns tag to wrap items into.
         *
         * @ignore Exclude from docs
         * @return Item tag
         */
        get: function () {
            return this.adapter.apply("itemTag", {
                tag: this._itemTag
            }).tag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "labelTag", {
        /**
         * Returns menu label tag.
         *
         * @ignore Exclude from docs
         * @return Label tag
         */
        get: function () {
            return this.adapter.apply("labelTag", {
                tag: this._labelTag
            }).tag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "iconTag", {
        /**
         * Returns icon tag.
         *
         * @ignore Exclude from docs
         * @return Icon tag
         */
        get: function () {
            return this.adapter.apply("iconTag", {
                tag: this._iconTag
            }).tag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "align", {
        /**
         * @return Horizontal alignment
         */
        get: function () {
            return this.adapter.apply("align", {
                align: this._align
            }).align;
        },
        /**
         * A horizontal alignment for the menu placement.
         *
         * @param value Horizontal alignment
         */
        set: function (value) {
            this._align = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "verticalAlign", {
        /**
         * @return Vertical alignment
         */
        get: function () {
            return this.adapter.apply("verticalAlign", {
                verticalAlign: this._verticalAlign
            }).verticalAlign;
        },
        /**
         * A vertical alignment for the menu placement.
         *
         * @param value Vertical alignment
         */
        set: function (value) {
            this._verticalAlign = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "classPrefix", {
        /**
         * @return Class name prefix
         */
        get: function () {
            return this.adapter.apply("classPrefix", {
                classPrefix: this._classPrefix
            }).classPrefix;
        },
        /**
         * Class name prefix.
         *
         * @default "amexport"
         * @param value Class name prefix
         */
        set: function (value) {
            this._classPrefix = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "defaultStyles", {
        /**
         * @return Should ExportMenu load its own CSS?
         */
        get: function () {
            return this.adapter.apply("defaultStyles", {
                defaultStyles: this._defaultStyles
            }).defaultStyles;
        },
        /**
         * Indicates whether [[ExportMenu]] should load external CSS to style itself.
         *
         * If set to `false`, the menu will not be styled, and will rely on some
         * external CSS.
         *
         * @default true
         * @param Should ExportMenu load its own CSS?
         */
        set: function (value) {
            if (this._defaultStyles != value) {
                this._defaultStyles = value;
                if (value) {
                    this.loadDefaultCSS();
                }
            }
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Loads the default CSS.
     *
     * @ignore Exclude from docs
     */
    ExportMenu.prototype.loadDefaultCSS = function () {
        this._disposers.push(ExportCSS(getShadowRoot(this.container), this.classPrefix));
        if (this._element) {
            this._element.style.display = "";
        }
    };
    Object.defineProperty(ExportMenu.prototype, "tabindex", {
        /**
         * @return Tab index
         */
        get: function () {
            return this.adapter.apply("tabindex", {
                tabindex: this._tabindex
            }).tabindex;
        },
        /**
         * A tab index for the menu.
         *
         * Tab index will influence the order in which elements on the chart and
         * the whole page are selected when pressing TAB key.
         *
         * @param value Tab index
         */
        set: function (value) {
            this._tabindex = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExportMenu.prototype, "language", {
        /**
         * @return A [[Language]] instance to be used
         */
        get: function () {
            var _this = this;
            var language = this._language.get();
            if (language == null) {
                language = new Language_Language();
                // TODO code duplication with `set language()`
                this._language.set(language, language.events.on("localechanged", function (ev) {
                    _this.invalidate();
                }));
            }
            return language;
        },
        /**
         * A [[Language]] instance.
         *
         * @param value An instance of [[Language]]
         */
        set: function (value) {
            var _this = this;
            this._language.set(value, value.events.on("localechanged", function (ev) {
                _this.invalidate();
            }));
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Controlling the menu
     */
    /**
     * Removes all active classes from menu items. Useful on touch devices and
     * keyboard navigation where open menu can be closed instantly by clicking or
     * tapping outside it.
     *
     * @ignore Exclude from docs
     */
    ExportMenu.prototype.close = function () {
        var _this = this;
        if (this._ignoreNextClose) {
            this._ignoreNextClose = false;
            return;
        }
        if (this.closeOnClick) {
            this._element.style.pointerEvents = "none";
            setTimeout(function () {
                _this._element.style.pointerEvents = "auto";
            }, 100);
        }
        if (this._currentSelection) {
            this.setBlur(this._currentSelection);
            this._currentSelection = undefined;
        }
        if (this._element) {
            var items = this._element.getElementsByClassName("active");
            for (var len = items.length, i = len - 1; i >= 0; i--) {
                if (items[i]) {
                    removeClass(items[i], "active");
                }
            }
        }
        this.events.dispatchImmediately("closed", {
            type: "closed",
            target: this
        });
    };
    /**
     * Selects a branch in the menu.
     *
     * Handles closing of currently open branch.
     *
     * @ignore Exclude from docs
     * @param branch Branch to select
     */
    ExportMenu.prototype.selectBranch = function (branch) {
        var _this = this;
        // Cancel previous closure
        if (branch.closeTimeout) {
            this.removeDispose(branch.closeTimeout);
            branch.closeTimeout = undefined;
        }
        // Add active class
        addClass(branch.interactions.element.parentElement, "active");
        // Remove current selection
        if (this._currentSelection && this._currentSelection !== branch && this._currentSelection.ascendants) {
            Iterator_each(concat(fromArray([this._currentSelection]), this._currentSelection.ascendants.iterator()), function (ascendant) {
                if (!branch.ascendants.contains(ascendant) && branch !== ascendant) {
                    _this.unselectBranch(ascendant, true);
                }
            });
        }
        // Select and/or cancel timeout for current ascendants
        Iterator_each(branch.ascendants.iterator(), function (ascendant) {
            if (ascendant.closeTimeout) {
                _this.removeDispose(ascendant.closeTimeout);
                ascendant.closeTimeout = undefined;
            }
            addClass(ascendant.interactions.element.parentElement, "active");
        });
        // Log current selection
        this._currentSelection = branch;
        // Invoke event
        if (this.events.isEnabled("branchselected")) {
            var event_5 = {
                type: "branchselected",
                target: this,
                branch: branch
            };
            this.events.dispatchImmediately("branchselected", event_5);
        }
    };
    /**
     * Unselects a branch. Also selects a branch one level up if necessary.
     *
     * @ignore Exclude from docs
     * @param branch Branch to unselect
     * @param simple If `true`, only the branch will be unselected without selecting parent branch
     */
    ExportMenu.prototype.unselectBranch = function (branch, simple) {
        // Remove active class
        removeClass(branch.interactions.element.parentElement, "active");
        // Remove current selection
        if (this._currentSelection == branch) {
            this._currentSelection = undefined;
        }
        // Invoke event
        if (this.events.isEnabled("branchunselected")) {
            var event_6 = {
                type: "branchunselected",
                target: this,
                branch: branch
            };
            this.events.dispatchImmediately("branchunselected", event_6);
        }
    };
    /**
     * Delay unselection of a branch. This can still be cancelled in some other
     * place if the branch or its children regain focus.
     *
     * @ignore Exclude from docs
     * @param branch Branch to unselect
     * @param simple If `true`, only the branch will be unselected without selecting parent branch
     */
    ExportMenu.prototype.delayUnselectBranch = function (branch, simple) {
        var _this = this;
        // Schedule branch unselection
        if (branch.closeTimeout) {
            this.removeDispose(branch.closeTimeout);
            branch.closeTimeout = undefined;
        }
        branch.closeTimeout = this.setTimeout(function () {
            _this.unselectBranch(branch, simple);
        }, this.closeDelay);
        // Schedule unselection of all ascendants
        // In case focus went away from the export menu altogether, this will ensure
        // that all items will be closed.
        // In case we're jumping to other menu item, those delayed unselections will
        // be cancelled by `selectBranch`
        if (simple !== true && branch.ascendants) {
            Iterator_each(branch.ascendants.iterator(), function (ascendant) {
                _this.delayUnselectBranch(ascendant, true);
            });
        }
    };
    /**
     * Navigates the menu based on which direction kayboard key was pressed.
     *
     * @ignore Exclude from docs
     * @param key A key that was pressed
     */
    ExportMenu.prototype.moveSelection = function (key) {
        // Check if there's a current selection
        if (!this._currentSelection) {
            return;
        }
        var newSelection;
        if (key == "up") {
            // Try moving up in current menu list, or to the last item if already
            // at the top
            newSelection = this.getPrevSibling(this._currentSelection);
        }
        else if (key == "down") {
            // Try moving down in current menu list, or to the top item if already
            // at the bottom
            newSelection = this.getNextSibling(this._currentSelection);
        }
        else if ((key == "left" && this.align == "right") || (key == "right" && this.align == "left")) {
            var menu = this.getSubMenu(this._currentSelection);
            // Go one level-deeper
            if (menu != null) {
                newSelection = menu[0];
            }
        }
        else if ((key == "right" && this.align == "right") || (key == "left" && this.align == "left")) {
            // Go one level-deeper
            newSelection = this.getParentItem(this._currentSelection);
        }
        if (newSelection && newSelection !== this._currentSelection) {
            this.selectBranch(newSelection);
            this.setFocus(newSelection);
            this._currentSelection = newSelection;
        }
    };
    /**
     * Returns all siblings of a menu item, including this same menu item.
     *
     * @ignore Exclude from docs
     * @param branch  Menu item
     * @return List of sibling menu items
     */
    ExportMenu.prototype.getSiblings = function (branch) {
        var parent = this.getParentItem(branch);
        if (parent && parent.menu) {
            return parent.menu;
        }
        else {
            return [];
        }
    };
    /**
     * Returns menu items parent item.
     *
     * @ignore Exclude from docs
     * @param branch  Menu item
     * @return Parent menu item
     */
    ExportMenu.prototype.getParentItem = function (branch) {
        if (branch.ascendants && branch.ascendants.length) {
            return branch.ascendants.getIndex(branch.ascendants.length - 1);
        }
        else {
            return undefined;
        }
    };
    /**
     * Returns next sibling in the same menu branch. If there is no next sibling,
     * the first one is returned. If there is just one item, that item is
     * returned. Unsupported menu items are skipped.
     *
     * @ignore Exclude from docs
     * @param branch  Menu item to search siblings for
     * @return Menu item
     */
    ExportMenu.prototype.getNextSibling = function (branch) {
        var siblings = this.getSiblings(branch);
        if (siblings.length > 1) {
            var next = siblings.indexOf(branch) + 1;
            next = siblings.length == next ? 0 : next;
            return siblings[next].unsupported ? this.getNextSibling(siblings[next]) : siblings[next];
        }
        else {
            return branch;
        }
    };
    /**
     * Returns previous sibling in the same menu branch. If there is no next
     * sibling, the first one is returned. If there is just one item, that item is
     * returned. Unsupported menu items are skipped.
     *
     * @ignore Exclude from docs
     * @param branch  Menu item to search siblings for
     * @return Menu item
     */
    ExportMenu.prototype.getPrevSibling = function (branch) {
        var siblings = this.getSiblings(branch);
        if (siblings.length > 1) {
            var prev = siblings.indexOf(branch) - 1;
            prev = prev == -1 ? siblings.length - 1 : prev;
            return siblings[prev].unsupported ? this.getPrevSibling(siblings[prev]) : siblings[prev];
        }
        else {
            return branch;
        }
    };
    /**
     * Attempts to set focus on particular menu element.
     *
     * @ignore Exclude from docs
     * @param branch Menu item
     */
    ExportMenu.prototype.setFocus = function (branch) {
        if (branch.interactions) {
            try {
                branch.interactions.element.focus();
            }
            catch (e) {
                // nothing
            }
        }
    };
    /**
     * Attempts to remove focus from the menu element.
     *
     * @ignore Exclude from docs
     * @param branch Menu item
     */
    ExportMenu.prototype.setBlur = function (branch) {
        if (branch.interactions) {
            try {
                branch.interactions.element.blur();
            }
            catch (e) {
                // nothing
            }
        }
    };
    /**
     * Hides the whole branch of menu.
     *
     * @param  branch  branch
     */
    ExportMenu.prototype.hideBranch = function (branch) {
        branch.element.style.display = "none";
    };
    /**
     * Show the branch of menu.
     *
     * @param  branch  branch
     */
    ExportMenu.prototype.showBranch = function (branch) {
        branch.element.style.display = "";
    };
    return ExportMenu;
}(Validatable_Validatable));

//# sourceMappingURL=ExportMenu.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Net.js
/**
 * A collection of network-related functions
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

/**
 * Loads an external file via its URL.
 *
 * Please note that this is an asynchronous function.
 *
 * It will not return the result, but rather a `Promise`.
 *
 * You can use the `await` notion, or `then()`.
 *
 * ```TypeScript
 * // Using await
 * let response = await Net.load( "http://www.my.com/data.json" );
 * console.log( response.response );
 *
 * // Using then()
 * Net.load( "http://www.my.com/data.json" ).then( ( response ) => {
 *   console.log( response.response );
 * } );
 * ```
 * ```JavaScript
 * // Using then()
 * Net.load( "http://www.my.com/data.json" ).then( function( response ) {
 *   console.log( response.response );
 * } );
 * ```
 *
 * @async
 * @param url      URL for the file to load
 * @param target   A target element that is requesting the net load
 * @param options  Request options
 * @return Result (Promise)
 */
function load(url, target, options) {
    return new Promise(function (success, error) {
        // Is return type Blob?
        var isBlob = hasValue(options) && options.responseType == "blob";
        // Create request and set up handlers
        var xhr = new XMLHttpRequest();
        xhr.onload = function () {
            if (xhr.status === 200) {
                var response = void 0;
                var blob_1;
                if (isBlob) {
                    blob_1 = xhr.response;
                    readBlob(blob_1).then(function (response) {
                        var output = {
                            xhr: xhr,
                            error: false,
                            response: response,
                            blob: blob_1,
                            type: xhr.getResponseHeader("Content-Type"),
                            target: target
                        };
                        success(output);
                    });
                    return;
                }
                else {
                    response = xhr.responseText || xhr.response;
                }
                var output = {
                    xhr: xhr,
                    error: false,
                    response: response,
                    blob: blob_1,
                    type: xhr.getResponseHeader("Content-Type"),
                    target: target
                };
                success(output);
            }
            else {
                error({
                    xhr: xhr,
                    error: true,
                    type: xhr.getResponseHeader("Content-Type"),
                    target: target
                });
            }
        };
        xhr.onerror = function () {
            error({
                xhr: xhr,
                error: true,
                type: xhr.getResponseHeader("Content-Type"),
                target: target
            });
        };
        // Open request
        xhr.open("GET", url, true);
        if (options && options.withCredentials) {
            xhr.withCredentials = true;
        }
        // Process options
        if (hasValue(options)) {
            if (hasValue(options.requestHeaders)) {
                for (var i = 0; i < options.requestHeaders.length; i++) {
                    var header = options.requestHeaders[i];
                    xhr.setRequestHeader(header.key, header.value);
                }
            }
            if (hasValue(options.responseType)) {
                xhr.responseType = options.responseType;
            }
        }
        // Send request
        xhr.send();
    });
}
/**
 * Returns textual representation of a Blob object.
 *
 * @param   blob  Target blob
 * @return        Text promise
 */
function readBlob(blob) {
    return new Promise(function (success, error) {
        var reader = new FileReader();
        reader.onload = function (event) {
            success(reader.result);
        };
        reader.onerror = function (e) {
            error(e);
        };
        reader.readAsText(blob);
    });
}
//# sourceMappingURL=Net.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/export/Export.js
/**
 * Export module.
 *
 * Parts of Export functionality rely on the following third party libraries:
 *
 * [canvg.js](https://github.com/canvg/canvg)
 * Copyright (c) Gabe Lerner
 * Licensed under [MIT](https://github.com/canvg/canvg/blob/master/LICENSE)
 *
 * [pdfmake](http://pdfmake.org/)
 * Copyright (c) 2014 bpampuch
 * Licensed under [MIT](https://github.com/bpampuch/pdfmake/blob/master/LICENSE)
 *
 * [SheetJS Community Edition](https://github.com/sheetjs/js-xlsx)
 * Licensed under [Apache License 2.0](https://github.com/SheetJS/js-xlsx/blob/master/LICENSE)
 *
 * [JSZip](http://stuartk.com/jszip)
 * Copyright (c) Stuart Knightley
 * Dual licenced under the [MIT license or GPLv3](https://raw.githubusercontent.com/Stuk/jszip/master/LICENSE.markdown).
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */
























// This is used to cache the pdfmake loading
var pdfmakePromise;
/**
 * Loads pdfmake dynamic module
 *
 * This is an asynchronous function. Check the description of `getImage()`
 * for description and example usage.
 *
 * @ignore Exclude from docs
 * @return Instance of pdfmake
 * @async
 */
function _pdfmake() {
    return __awaiter(this, void 0, void 0, function () {
        var a, pdfmake, vfs_fonts, global;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Promise.all([
                        __webpack_require__.e(/* import() | pdfmake */ 2).then(__webpack_require__.t.bind(null, 336, 7)),
                        __webpack_require__.e(/* import() | pdfmake */ 2).then(__webpack_require__.bind(null, 337))
                    ])];
                case 1:
                    a = _a.sent();
                    pdfmake = a[0];
                    vfs_fonts = a[1];
                    global = window;
                    global.pdfMake = global.pdfMake || {};
                    global.pdfMake.vfs = vfs_fonts.default;
                    pdfmake.vfs = vfs_fonts.default;
                    return [2 /*return*/, pdfmake];
            }
        });
    });
}
// TODO better parsing
var fontFamilySrcRegexp = /src: ([^;]+);/;
// TODO better checks
function supportsBlobUri() {
    return window.navigator.msSaveOrOpenBlob != null;
}
// TODO move into utils or something ?
function blobToDataUri(blob) {
    return new Promise(function (resolve, reject) {
        // TODO handle abort ?
        var f = new FileReader();
        f.onload = function (e) { resolve(f.result); };
        f.onerror = function (e) { reject(e); };
        f.readAsDataURL(blob);
    });
}
function getCssRules(s) {
    return __awaiter(this, void 0, void 0, function () {
        var sheet, e_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    sheet = s.sheet;
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 2, , 4]);
                    return [2 /*return*/, sheet.cssRules];
                case 2:
                    e_1 = _a.sent();
                    return [4 /*yield*/, new Promise(function (success, error) {
                            s.addEventListener("load", function () {
                                success(sheet.cssRules);
                            }, true);
                            s.addEventListener("error", function (e) {
                                error(e);
                            }, true);
                            setTimeout(function () {
                                error(new Error("Timeout while waiting for <style> to load"));
                            }, 10000);
                        })];
                case 3: 
                // Needed because of https://bugzilla.mozilla.org/show_bug.cgi?id=625013
                return [2 /*return*/, _a.sent()];
                case 4: return [2 /*return*/];
            }
        });
    });
}
// This loads a stylesheet by URL and then calls the function with it
// TODO this should be moved into utils or something
function loadStylesheet(doc, url, f) {
    return __awaiter(this, void 0, void 0, function () {
        var response, e_2, s, rules;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, load(url)];
                case 1:
                    response = _a.sent();
                    return [3 /*break*/, 3];
                case 2:
                    e_2 = _a.sent();
                    console.error("Failed to load stylesheet", url, e_2);
                    return [2 /*return*/];
                case 3:
                    s = doc.createElement("style");
                    s.textContent = response.response;
                    doc.head.appendChild(s);
                    _a.label = 4;
                case 4:
                    _a.trys.push([4, , 7, 8]);
                    return [4 /*yield*/, getCssRules(s)];
                case 5:
                    rules = _a.sent();
                    return [4 /*yield*/, eachStylesheet(doc, url, rules, f)];
                case 6:
                    _a.sent();
                    return [3 /*break*/, 8];
                case 7:
                    doc.head.removeChild(s);
                    return [7 /*endfinally*/];
                case 8: return [2 /*return*/];
            }
        });
    });
}
// This calls a function for each CSSRule inside of a CSSStyleSheet.
// If the CSSStyleSheet has any @import, then it will recursively call the function for those CSSRules too.
// TODO this should be moved into utils or something
function eachStylesheet(doc, topUrl, rules, f) {
    return __awaiter(this, void 0, void 0, function () {
        var promises, length, i, rule, url;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    promises = [];
                    length = rules.length;
                    for (i = 0; i < length; i++) {
                        rule = rules[i];
                        if (rule.type === CSSRule.IMPORT_RULE) {
                            url = rule.href;
                            if (url) {
                                url = joinUrl(topUrl, url);
                                promises.push(loadStylesheet(doc, url, f));
                            }
                        }
                        else {
                            f(topUrl, rule);
                        }
                    }
                    if (!promises.length) return [3 /*break*/, 2];
                    return [4 /*yield*/, Promise.all(promises)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [2 /*return*/];
            }
        });
    });
}
// This calls a function for each CSSRule for all of the stylesheets in the page.
// If the CSSStyleSheet has any @import, then it will recursively call the function for those CSSRules too.
// TODO this should be moved into utils or something
function eachStylesheets(f) {
    return __awaiter(this, void 0, void 0, function () {
        var iframe, doc_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    iframe = document.createElement("iframe");
                    // This causes it to use the same origin policy as the parent page
                    iframe.src = "about:blank";
                    // This tries to make it more accessible for screen readers
                    iframe.setAttribute("title", "");
                    document.head.appendChild(iframe);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    doc_1 = iframe.contentDocument;
                    // TODO use $dom.getRoot instead of document ?
                    return [4 /*yield*/, Promise.all(map(document.styleSheets, function (sheet) {
                            var url = sheet.href;
                            if (url == null) {
                                return eachStylesheet(doc_1, location.href, sheet.cssRules, f);
                            }
                            else {
                                url = joinUrl(location.href, url);
                                return loadStylesheet(doc_1, url, f);
                            }
                        }))];
                case 2:
                    // TODO use $dom.getRoot instead of document ?
                    _a.sent();
                    return [3 /*break*/, 4];
                case 3:
                    document.head.removeChild(iframe);
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    });
}
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * [[Export]] allows downloading of current snapshot of the chart as an
 * image, PDF, or its data in various formats.
 *
 * The export functionality is enabled by default in charts and is accessible
 * via API or optional export menu.
 *
 * To enable menu, simply access export's `menu` property. E.g.:
 *
 * ```TypeScript
 * chart.exporting.menu = new am4core.ExportMenu();
 * ```
 * ```JavaScript
 * chart.exporting.menu = new am4core.ExportMenu();
 * ```
 * ```JSON
 * {
 *   // ...
 *   "exporting": {
 *     "menu": {}
 *   }
 * }
 * ```
 *
 * To export via API, use `export()` method:
 *
 * ```TypeScript
 * chart.exporting.export(type, [options]);
 * ```
 * ```JavaScript
 * chart.exporting.export(type, [options]);
 * ```
 *
 * E.g.:
 *
 * ```TypeScript
 * chart.exporting.export("png");
 * ```
 * ```JavaScript
 * chart.exporting.export("png");
 * ```
 *
 * @todo Better loading indicator?
 * @todo Implement multiplier option
 * @todo Handling of hanged exports
 * @important
 */
var Export_Export = /** @class */ (function (_super) {
    __extends(Export, _super);
    /**
     * Constructor
     */
    function Export(container) {
        var _this = _super.call(this) || this;
        /**
         * Adapter.
         */
        _this.adapter = new Adapter_Adapter(_this);
        /**
         * Holds options for each format.
         *
         * @ignore Exclude from docs
         */
        _this._formatOptions = new Dictionary_Dictionary();
        /**
         * Extra [[Sprite]] elements to include in exports.
         */
        _this._extraSprites = [];
        /**
         * A list of [[Sprite]] elements that need to be valid before export
         * commences.
         */
        _this._validateSprites = [];
        /**
         * Holds an array of data field names. If set, exported data fields will try
         * to maintain this order.
         *
         * If not set (default), the export will try to maintain the same order as
         * in source data, or as in `dataFields` (if set).
         *
         * @since 4.9.7
         */
        _this.dataFieldsOrder = [];
        /**
         * Indicates whether data fields were generated dynamically (`true`) or
         * if they were pre-set by the user (`false`).
         */
        _this._dynamicDataFields = true;
        /**
         * Holds a list of objects that were temporarily removed from the DOM while
         * exporting. Those most probably are tainted images, or foreign objects that
         * would otherwise prevent SVG to be converted to canvas.
         *
         * @ignore Exclude from docs
         */
        _this._removedObjects = new List_List();
        /**
         * Holds references to the objects that were temporarily hidden when export
         * started, so that we can reveal them back when export ends.
         */
        _this._hiddenObjects = [];
        /**
         * Indicates if non-exportable objects are now hidden;
         */
        _this._objectsAlreadyHidden = false;
        /**
         * Exported files will be prefixed with whatever it is set here.
         *
         * @ignore Exclude from docs
         */
        _this._filePrefix = "amCharts";
        /**
         * If you are using web fonts (such as Google Fonts), your chart might be
         * using them as well.
         *
         * Normally, exporting to image will require to download these fonts so the
         * are carried over to exported image.
         *
         * This setting can be used to disable or enable this functionality.
         *
         * @default true
         */
        _this.useWebFonts = true;
        /**
         * Many modern displays have use more actual pixels per displayed pixel. This
         * results in sharper images on screen. Unfortunately, when exported to a
         * bitmap image of the sam width/height size it will lose those extra pixels,
         * resulting in somewhat blurry image.
         *
         * This is why we are going to export images larger than they are, so that we
         * don't lose any details.
         *
         * If you'd rather export images without change in size, set this to `false`.
         *
         * @default true
         */
        _this.useRetina = true;
        /**
         * By default Export will try to use built-in method for transforming chart
         * into an image for download, then fallback to external library (canvg) for
         * conversion if failed.
         *
         * Setting this to `false` will force use of external library for all export
         * operations.
         *
         * It might be useful to turn off simplified export if you are using strict
         * content security policies, that disallow images with blobs as their
         * source.
         *
         * @default true
         * @since 4.2.5
         */
        _this.useSimplifiedExport = true;
        /**
         * If export operation takes longer than milliseconds in this second, we will
         * show a modal saying export operation took longer than expected.
         */
        _this.timeoutDelay = 2000;
        _this._exportRunning = false;
        _this._container = container;
        _this.className = "Export";
        // Set default options
        _this._formatOptions.setKey("png", {});
        _this._formatOptions.setKey("jpg", {
            quality: 0.8
        });
        _this._formatOptions.setKey("gif", {});
        _this._formatOptions.setKey("svg", {});
        _this._formatOptions.setKey("pdf", {
            fontSize: 14,
            imageFormat: "png",
            align: "left",
            addURL: true,
            addColumnNames: true
        });
        _this._formatOptions.setKey("json", {
            indent: 2,
            useLocale: true
        });
        _this._formatOptions.setKey("csv", {
            addColumnNames: true,
            emptyAs: ""
        });
        _this._formatOptions.setKey("xlsx", {
            addColumnNames: true,
            useLocale: true,
            emptyAs: ""
        });
        _this._formatOptions.setKey("html", {
            addColumnNames: true,
            emptyAs: ""
        });
        _this._formatOptions.setKey("pdfdata", {
            fontSize: 14,
            imageFormat: "png",
            addURL: true,
            addColumnNames: true,
            emptyAs: ""
        });
        _this._formatOptions.setKey("print", {
            delay: 500,
            printMethod: "iframe"
        });
        // Add options adapter
        _this.adapter.add("options", function (arg) {
            var formatOptions = _this._formatOptions.getKey(arg.type);
            if (arg.options) {
                arg.options = merge(formatOptions, arg.options);
            }
            else {
                arg.options = formatOptions;
            }
            return arg;
        });
        _this.applyTheme();
        _this.dispatchImmediately("inited");
        return _this;
    }
    Object.defineProperty(Export.prototype, "menu", {
        /**
         * @return ExportMenu instance
         */
        get: function () {
            return this._menu;
        },
        /**
         * An instance of [[ExportMenu]].
         *
         * To add an export menu to a chart, set this to a new instance of
         * [[ExportMenu]].
         *
         * ```TypeScript
         * chart.exporting.menu = new am4core.ExportMenu();
         * ```
         * ```JavaScript
         * chart.exporting.menu = new am4core.ExportMenu();
         * ```
         * ```JSON
         * {
         *   // ...
         *   "exporting": {
         *     "menu": {}
         *   }
         * }
         * ```
         *
         * @param menu  ExportMenu instance
         */
        set: function (menu) {
            var _this = this;
            if (this._menu) {
                this.removeDispose(this._menu);
            }
            this._menu = menu;
            // Set container and language
            this._menu.container = this.container;
            this._menu.language = this._language;
            // Add adapter to check for browser support
            this._menu.adapter.add("branch", function (arg) {
                arg.branch.unsupported = !_this.typeSupported(arg.branch.type);
                return arg;
            });
            // Add click events
            this._menu.events.on("hit", function (ev) {
                _this.export(ev.branch.type, ev.branch.options);
                _this.menu.close();
            });
            this._menu.events.on("enter", function (ev) {
                _this.export(ev.branch.type, ev.branch.options);
                _this.menu.close();
            });
            this._menu.events.on("over", function (ev) {
                _this._disablePointers();
            });
            this._menu.events.on("out", function (ev) {
                setTimeout(function () { _this._releasePointers(); }, 10);
            });
            // Dispatch event
            this.dispatchImmediately("menucreated");
            // Prefix with Sprite's class name
            this._menu.adapter.add("classPrefix", function (obj) {
                obj.classPrefix = Options_options.classNamePrefix + obj.classPrefix;
                return obj;
            });
            // Add menu to disposers so that it's destroyed when Export is disposed
            this._disposers.push(this._menu);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if this specific menu item type is supported by current system.
     *
     * @param type  Menu item type
     * @return `false` if not supported
     */
    Export.prototype.typeSupported = function (type) {
        var supported = true;
        var options = this.getFormatOptions(type);
        if (hasValue(options) && options.disabled) {
            supported = false;
        }
        else if (type === "pdf") {
            //supported = this.downloadSupport();
        }
        else if (type === "xlsx") {
            //supported = (this.downloadSupport() && this._hasData()) ? true : false;
            supported = this._hasData() ? true : false;
        }
        else if (type == "print" && !window.print) {
            supported = false;
        }
        else if (["json", "csv", "html", "pdfdata"].indexOf(type) !== -1 && !this._hasData()) {
            supported = false;
        }
        return this.adapter.apply("supported", {
            supported: supported,
            type: type
        }).supported;
    };
    /**
     * Checks if data is available.
     *
     * @return Has data?
     */
    Export.prototype._hasData = function () {
        return this.data && this.data.length;
    };
    /**
     * Get function to handle export for particular format.
     *
     * @ignore Exclude from docs
     */
    Export.prototype._getFunction = function (type) {
        switch (type) {
            case "png":
            case "gif":
            case "jpg":
                return this.getImage;
            case "svg":
                return this.getSVG;
            case "pdf":
            case "pdfdata":
                return this.getPDF;
            case "xlsx":
                return this.getExcel;
            case "csv":
                return this.getCSV;
            case "json":
                return this.getJSON;
            case "html":
                return this.getHTML;
            case "print":
                return this.getPrint;
            default:
                return this.unsupported;
        }
    };
    /**
     * Initiates export procedure.
     *
     * @param type     Export type
     * @param options  Options
     * @return `true` if export was successful
     * @async
     */
    Export.prototype.export = function (type, options) {
        return __awaiter(this, void 0, void 0, function () {
            var event_1, func, data, event_2, event_3;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Check if it's a custom item, and do nothing or execute custom callback
                        if (type == "custom") {
                            this.handleCustom(options);
                            return [2 /*return*/, true];
                        }
                        // Set export running flag
                        this._exportRunning = true;
                        // Dispatch event
                        if (this.events.isEnabled("exportstarted")) {
                            event_1 = {
                                "type": "exportstarted",
                                "target": this,
                                "format": type,
                                "options": options
                            };
                            this.events.dispatchImmediately("exportstarted", event_1);
                        }
                        // Schedule a preloader
                        this.showPreloader();
                        // Schedule a timeout
                        if (this.timeoutDelay) {
                            this.hideTimeout();
                            this._timeoutTimeout = this.setTimeout(function () {
                                // Dispatch event
                                if (_this.events.isEnabled("exporttimedout")) {
                                    var event_4 = {
                                        "type": "exporttimedout",
                                        "target": _this,
                                        "format": type,
                                        "options": options
                                    };
                                    _this.events.dispatchImmediately("exporttimedout", event_4);
                                }
                                // Show modal
                                _this.showTimeout();
                            }, this.timeoutDelay);
                        }
                        // Hide items that should not be exported
                        this.hideNonExportableSprites();
                        func = this._getFunction(type);
                        // Give chance for plugins to override both function and options
                        options = this.adapter.apply("options", {
                            options: options,
                            type: type
                        }).options;
                        func = this.adapter.apply("exportFunction", {
                            func: func,
                            type: type,
                            options: options
                        }).func;
                        return [4 /*yield*/, func.call(this, type, options)];
                    case 1:
                        data = _a.sent();
                        // Release pointers
                        this._exportRunning = false;
                        this._releasePointers();
                        // Restore temporarily hidden elements
                        this.restoreNonExportableSprites();
                        if (data) {
                            // Dispatch event
                            if (this.events.isEnabled("exportfinished")) {
                                event_2 = {
                                    "type": "exportfinished",
                                    "target": this,
                                    "format": type,
                                    "options": options
                                };
                                this.events.dispatchImmediately("exportfinished", event_2);
                            }
                            // Hide preloader and timeout modals
                            this.hidePreloader();
                            this.hideTimeout();
                            if (this.menu) {
                                this.menu.close();
                            }
                            // Download or print
                            if (type === "print") {
                                return [2 /*return*/, this.print(data, options, this.adapter.apply("title", {
                                        title: this.title,
                                        options: options
                                    }).title)];
                            }
                            else {
                                if (type == "pdfdata") {
                                    return [2 /*return*/, this.download(data, this.filePrefix + ".pdf")];
                                }
                                return [2 /*return*/, this.download(data, this.filePrefix + "." + type)];
                            }
                        }
                        else {
                            // Throw exception?
                            // @todo
                            // Dispatch event
                            if (this.events.isEnabled("error")) {
                                event_3 = {
                                    "type": "error",
                                    "target": this,
                                    "format": type,
                                    "options": options
                                };
                                this.events.dispatchImmediately("error", event_3);
                            }
                            return [2 /*return*/, false];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * A function that should handle unsupported export types.
     *
     * @ignore Exclude from docs
     * @param type     Export type
     * @param options  Options
     * @return Promise
     * @async
     */
    Export.prototype.unsupported = function (type, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // TODO should this return `undefined`?
                return [2 /*return*/, ""];
            });
        });
    };
    /**
     * Handles click on a "custom" menu item.
     *
     * Basically, if it has "callback" enabled, it will be called. Nothing else.
     *
     * @ignore Exclude from docs
     * @param options  Options
     */
    Export.prototype.handleCustom = function (options) {
        if (hasValue(options) && hasValue(options.callback)) {
            options.callback.call(options.callbackTarget || this, options);
        }
    };
    /**
     * Requests a Print of the chart.
     *
     * @param type     Export type
     * @param options  Options
     * @return Promise
     * @async
     */
    Export.prototype.getPrint = function (type, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.getImage("png", options)];
            });
        });
    };
    /**
     * A function that returns data: URI encoded @font-family, so that way it can be embedded into SVG.
     *
     * @ignore Exclude from docs
     * @return String which can be embedded directly into a <style> element.
     * @async
     */
    Export.prototype.getFontFamilies = function () {
        return __awaiter(this, void 0, void 0, function () {
            var DOMURL, blobs, promises, a;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        DOMURL = this.getDOMURL();
                        blobs = [];
                        promises = [];
                        return [4 /*yield*/, eachStylesheets(function (topUrl, rule) {
                                if (rule.type === CSSRule.FONT_FACE_RULE) {
                                    var cssText_1 = rule.cssText;
                                    // TODO this is necessary because Edge doesn't let you access the src using getPropertyValue
                                    var src = fontFamilySrcRegexp.exec(cssText_1);
                                    if (src !== null) {
                                        // TODO make this faster (don't create Promises for non-url stuff)
                                        var urls = src[1].split(/ *, */).map(function (url) { return __awaiter(_this, void 0, void 0, function () {
                                            var a, after, fullUrl, response, url_1, e_3;
                                            return __generator(this, function (_a) {
                                                switch (_a.label) {
                                                    case 0:
                                                        a = /^url\(["']?([^"'\)]+)["']?\)([^,]*)$/.exec(url);
                                                        if (!(a === null)) return [3 /*break*/, 1];
                                                        return [2 /*return*/, url];
                                                    case 1:
                                                        after = a[2];
                                                        fullUrl = joinUrl(topUrl, a[1]);
                                                        _a.label = 2;
                                                    case 2:
                                                        _a.trys.push([2, 7, , 8]);
                                                        return [4 /*yield*/, load(fullUrl, undefined, { responseType: "blob" })];
                                                    case 3:
                                                        response = _a.sent();
                                                        if (!supportsBlobUri()) return [3 /*break*/, 4];
                                                        url_1 = DOMURL.createObjectURL(response.blob);
                                                        blobs.push(url_1);
                                                        return [3 /*break*/, 6];
                                                    case 4: return [4 /*yield*/, blobToDataUri(response.blob)];
                                                    case 5:
                                                        url_1 = _a.sent();
                                                        _a.label = 6;
                                                    case 6: 
                                                    // TODO should it should escape the URI ?
                                                    return [2 /*return*/, "url(\"" + url_1 + "\")" + after];
                                                    case 7:
                                                        e_3 = _a.sent();
                                                        console.error("Failed to load font", fullUrl, e_3);
                                                        return [2 /*return*/, null];
                                                    case 8: return [2 /*return*/];
                                                }
                                            });
                                        }); });
                                        promises.push(Promise.all(urls).then(function (a) {
                                            a = a.filter(function (x) { return x != null; });
                                            if (a.length === 0) {
                                                return "";
                                            }
                                            else {
                                                return cssText_1.replace(fontFamilySrcRegexp, "src: " + a.join(", ") + ";");
                                            }
                                        }));
                                    }
                                }
                            })];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        a = _a.sent();
                        return [2 /*return*/, {
                                blobs: blobs,
                                cssText: a.filter(function (x) { return !!x; }).join("\n")
                            }];
                }
            });
        });
    };
    /**
     * Produces image output from the element.
     *
     * Converts to a `Canvas` first, then produces an image to download.
     *
     * This is an asynchronous function. Rather than returning a result, it
     * returns a Promise.
     *
     * You can use `await` notion from other async functions, or `then()`
     * anywhere else.
     *
     * ```TypeScript
     * let img;
     *
     * // Async
     * img = await chart.exporting.getImage( "png" );
     *
     * // Sync
     * chart.exporting.getImage( "png" ).then( ( data ) => {
     *   img = data;
     * } );
     * ```
     * ```JavaScript
     * var img;
     * chart.exporting.getImage( "png" ).then( ( data ) => {
     *   img = data;
     * } );
     * ```
     *
     * @param  type           Image format
     * @param  options        Options
     * @param  includeExtras  Should extra sprites be included if set?
     * @return Promise
     */
    Export.prototype.getImage = function (type, options, includeExtras) {
        return __awaiter(this, void 0, void 0, function () {
            var prehidden, canvas, uri, e_4, data, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        prehidden = this._objectsAlreadyHidden;
                        if (!prehidden) {
                            this.hideNonExportableSprites();
                        }
                        if (!hasValue(options)) {
                            options = this.getFormatOptions(type);
                        }
                        // Wait for required elements to be ready before proceeding
                        return [4 /*yield*/, this.awaitValidSprites()];
                    case 1:
                        // Wait for required elements to be ready before proceeding
                        _a.sent();
                        return [4 /*yield*/, this.simplifiedImageExport()];
                    case 2:
                        if (!_a.sent()) return [3 /*break*/, 10];
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 7, , 9]);
                        return [4 /*yield*/, this.getCanvas(options)];
                    case 4:
                        canvas = _a.sent();
                        if (!(includeExtras !== false)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.addExtras(canvas, options)];
                    case 5:
                        canvas = _a.sent();
                        _a.label = 6;
                    case 6:
                        uri = canvas.toDataURL(this.getContentType(type), options.quality);
                        // Get rid of the canvas
                        this.disposeCanvas(canvas);
                        if (!prehidden) {
                            this.restoreNonExportableSprites();
                        }
                        return [2 /*return*/, uri];
                    case 7:
                        e_4 = _a.sent();
                        console.error(e_4.message + "\n" + e_4.stack);
                        console.warn("Simple export failed, falling back to advanced export");
                        return [4 /*yield*/, this.getImageAdvanced(type, options, includeExtras)];
                    case 8:
                        data = _a.sent();
                        if (!prehidden) {
                            this.restoreNonExportableSprites();
                        }
                        return [2 /*return*/, data];
                    case 9: return [3 /*break*/, 12];
                    case 10: return [4 /*yield*/, this.getImageAdvanced(type, options, includeExtras)];
                    case 11:
                        data = _a.sent();
                        if (!prehidden) {
                            this.restoreNonExportableSprites();
                        }
                        return [2 /*return*/, data];
                    case 12: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Adds extra elements to the canvas.
     *
     * @param  canvas   Original canvas
     * @param  options  Options
     */
    Export.prototype.addExtras = function (canvas, options, advanced) {
        return __awaiter(this, void 0, void 0, function () {
            var middleLeft_1, middleTop_1, middleWidth_1, middleHeight_1, extraRight_1, extraBottom_1, extras, newCanvas, ctx_1, background, left_1, top_1, right_1, bottom_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.extraSprites.length) return [3 /*break*/, 2];
                        middleLeft_1 = 0;
                        middleTop_1 = 0;
                        middleWidth_1 = canvas.width;
                        middleHeight_1 = canvas.height;
                        extraRight_1 = 0;
                        extraBottom_1 = 0;
                        return [4 /*yield*/, Promise.all(map(this.extraSprites, function (extraSprite) { return __awaiter(_this, void 0, void 0, function () {
                                var extra, extraCanvas, extraWidth, extraHeight;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (extraSprite instanceof Sprite_Sprite) {
                                                extra = {
                                                    sprite: extraSprite,
                                                    position: "bottom"
                                                };
                                            }
                                            else {
                                                extra = extraSprite;
                                            }
                                            // Set defaults
                                            extra.position = extra.position || "bottom";
                                            extra.marginTop = extra.marginTop || 0;
                                            extra.marginRight = extra.marginRight || 0;
                                            extra.marginBottom = extra.marginBottom || 0;
                                            extra.marginLeft = extra.marginLeft || 0;
                                            if (!advanced) return [3 /*break*/, 2];
                                            return [4 /*yield*/, extra.sprite.exporting.getCanvasAdvanced(options)];
                                        case 1:
                                            extraCanvas = _a.sent();
                                            return [3 /*break*/, 4];
                                        case 2: return [4 /*yield*/, extra.sprite.exporting.getCanvas(options)];
                                        case 3:
                                            extraCanvas = _a.sent();
                                            _a.label = 4;
                                        case 4:
                                            extraWidth = extraCanvas.width + extra.marginLeft + extra.marginRight;
                                            extraHeight = extraCanvas.height + extra.marginTop + extra.marginBottom;
                                            if (extra.position == "top") {
                                                middleWidth_1 = extra.crop ? middleHeight_1 : Math_max(middleWidth_1, extraWidth);
                                                middleTop_1 += extraHeight;
                                            }
                                            else if (extra.position == "right") {
                                                middleHeight_1 = extra.crop ? middleHeight_1 : Math_max(middleHeight_1, extraHeight);
                                                extraRight_1 += extraWidth;
                                            }
                                            else if (extra.position == "left") {
                                                middleHeight_1 = extra.crop ? middleHeight_1 : Math_max(middleHeight_1, extraHeight);
                                                middleLeft_1 += extraWidth;
                                            }
                                            else if (extra.position === "bottom") {
                                                middleWidth_1 = extra.crop ? middleHeight_1 : Math_max(middleWidth_1, extraWidth);
                                                extraBottom_1 += extraHeight;
                                            }
                                            return [2 /*return*/, {
                                                    canvas: extraCanvas,
                                                    position: extra.position,
                                                    left: extra.marginLeft,
                                                    top: extra.marginTop,
                                                    width: extraWidth,
                                                    height: extraHeight
                                                }];
                                    }
                                });
                            }); }))];
                    case 1:
                        extras = _a.sent();
                        newCanvas = this.getDisposableCanvas();
                        newCanvas.width = middleLeft_1 + middleWidth_1 + extraRight_1;
                        newCanvas.height = middleTop_1 + middleHeight_1 + extraBottom_1;
                        ctx_1 = newCanvas.getContext("2d");
                        background = this.backgroundColor || this.findBackgroundColor(this.sprite.dom);
                        if (background) {
                            ctx_1.fillStyle = background.toString();
                            ctx_1.fillRect(0, 0, newCanvas.width, newCanvas.height);
                        }
                        left_1 = middleLeft_1;
                        top_1 = middleTop_1;
                        right_1 = left_1 + middleWidth_1;
                        bottom_1 = top_1 + middleHeight_1;
                        // Radiates outwards from center
                        each(extras, function (extra) {
                            if (extra.position == "top") {
                                top_1 -= extra.height;
                                ctx_1.drawImage(extra.canvas, middleLeft_1 + extra.left, top_1 + extra.top);
                            }
                            else if (extra.position == "right") {
                                ctx_1.drawImage(extra.canvas, right_1 + extra.left, middleTop_1 + extra.top);
                                right_1 += extra.width;
                            }
                            else if (extra.position == "left") {
                                left_1 -= extra.width;
                                ctx_1.drawImage(extra.canvas, left_1 + extra.left, middleTop_1 + extra.top);
                            }
                            else if (extra.position === "bottom") {
                                ctx_1.drawImage(extra.canvas, middleLeft_1 + extra.left, bottom_1 + extra.top);
                                bottom_1 += extra.height;
                            }
                            _this.disposeCanvas(extra.canvas);
                        });
                        ctx_1.drawImage(canvas, middleLeft_1, middleTop_1);
                        return [2 /*return*/, newCanvas];
                    case 2: return [2 /*return*/, canvas];
                }
            });
        });
    };
    /**
     * Returns canvas representation of the [[Sprite]].
     *
     * @param   options  Options
     * @return           Canvas
     */
    Export.prototype.getCanvas = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var background, DOMURL, url, blobs, canvas, width, height, font, fontSize, pixelRatio, ctx, promises, a, data, svg, img;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Options are set?
                        if (!hasValue(options)) {
                            options = {};
                        }
                        background = this.backgroundColor || this.findBackgroundColor(this.sprite.dom);
                        DOMURL = this.getDOMURL();
                        url = null;
                        blobs = null;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 4, 5]);
                        width = this.sprite.pixelWidth, height = this.sprite.pixelHeight, font = findFont(this.sprite.dom), fontSize = findFontSize(this.sprite.dom);
                        // Create canvas and its 2D context
                        canvas = this.getDisposableCanvas();
                        pixelRatio = this.getPixelRatio(options);
                        canvas.style.width = width + 'px';
                        canvas.style.height = height + 'px';
                        canvas.width = width * pixelRatio;
                        canvas.height = height * pixelRatio;
                        ctx = canvas.getContext("2d");
                        if (pixelRatio != 1) {
                            ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                        }
                        // Add background if necessary
                        if (background) {
                            ctx.fillStyle = background.toString();
                            ctx.fillRect(0, 0, width, height);
                        }
                        promises = [];
                        if (this.useWebFonts) {
                            // TODO what if one of the other things errors before it's been able to set `blobs` ?
                            promises.push(this.getFontFamilies().then(function (fonts) {
                                blobs = fonts.blobs;
                                return fonts.cssText;
                            }));
                        }
                        promises.push(this.imagesToDataURI(this.sprite.dom, options));
                        promises.push(this.prepForeignObjects(this.sprite.dom, options));
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        a = _a.sent();
                        data = this.normalizeSVG("<style>" + a[0] + "</style>" + this.serializeElement(this.sprite.paper.defs) + this.serializeElement(this.sprite.dom), options, width, height, font, fontSize);
                        svg = new Blob([data], { type: "image/svg+xml" });
                        url = DOMURL.createObjectURL(svg);
                        return [4 /*yield*/, this.loadNewImage(url, width, height, "anonymous")];
                    case 3:
                        img = _a.sent();
                        // Draw image on canvas
                        ctx.drawImage(img, 0, 0);
                        return [3 /*break*/, 5];
                    case 4:
                        if (url !== null) {
                            DOMURL.revokeObjectURL(url);
                        }
                        if (blobs !== null) {
                            each(blobs, function (url) {
                                DOMURL.revokeObjectURL(url);
                            });
                        }
                        // Restore replaced tainted images in DOM
                        this.restoreRemovedObjects();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/, canvas];
                }
            });
        });
    };
    /**
     * Returns canvas representation of the [[Sprite]] using canvg.
     *
     * @param   options  Options
     * @return           Canvas
     */
    Export.prototype.getCanvasAdvanced = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var background, canvg, width, height, font, fontSize, data, canvas, pixelRatio, config;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // Options are set?
                        if (!hasValue(options)) {
                            options = {};
                        }
                        // Convert external images to data uris
                        return [4 /*yield*/, this.imagesToDataURI(this.sprite.dom, options)];
                    case 1:
                        // Convert external images to data uris
                        _a.sent();
                        background = this.backgroundColor || this.findBackgroundColor(this.sprite.dom);
                        return [4 /*yield*/, this.canvg];
                    case 2:
                        canvg = _a.sent();
                        width = this.sprite.pixelWidth, height = this.sprite.pixelHeight, font = findFont(this.sprite.dom), fontSize = findFontSize(this.sprite.dom);
                        data = this.normalizeSVG(this.serializeElement(this.sprite.paper.defs) + this.serializeElement(this.sprite.dom), options, width, height, font, fontSize, background);
                        canvas = this.getDisposableCanvas();
                        pixelRatio = this.getPixelRatio(options);
                        canvas.style.width = (width * pixelRatio) + 'px';
                        canvas.style.height = (height * pixelRatio) + 'px';
                        canvas.width = width * pixelRatio;
                        canvas.height = height * pixelRatio;
                        config = {
                            //ignoreDimensions: true,
                            useCORS: true
                        };
                        if (pixelRatio != 1) {
                            config.ignoreDimensions = true;
                            config.scaleWidth = width * pixelRatio;
                            config.scaleHeight = height * pixelRatio;
                        }
                        return [4 /*yield*/, canvg.fromString(canvas.getContext("2d"), data, config).render()];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, canvas];
                }
            });
        });
    };
    /**
     * Tries to dynamically load [canvg.js](https://github.com/canvg/canvg) and
     * export an image using its functions.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @param type     Image format
     * @param options  Options
     * @return Data uri
     */
    Export.prototype.getImageAdvanced = function (type, options, includeExtras) {
        return __awaiter(this, void 0, void 0, function () {
            var prehidden, canvas, uri;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        prehidden = this._objectsAlreadyHidden;
                        if (!prehidden) {
                            this.hideNonExportableSprites();
                        }
                        if (!hasValue(options)) {
                            options = this.getFormatOptions(type);
                        }
                        return [4 /*yield*/, this.getCanvasAdvanced(options)];
                    case 1:
                        canvas = _a.sent();
                        if (!(includeExtras !== false)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.addExtras(canvas, options, true)];
                    case 2:
                        canvas = _a.sent();
                        _a.label = 3;
                    case 3:
                        uri = canvas.toDataURL(this.getContentType(type), options.quality);
                        // Get rid of the canvas
                        this.disposeCanvas(canvas);
                        if (!prehidden) {
                            this.restoreNonExportableSprites();
                        }
                        return [2 /*return*/, uri];
                }
            });
        });
    };
    /**
     * Creates a `<canvas>` element and returns it.
     *
     * @return Canvas element
     */
    Export.prototype.getDisposableCanvas = function () {
        var canvas = document.createElement("canvas");
        canvas.style.position = "fixed";
        canvas.style.top = "-10000px";
        document.body.appendChild(canvas);
        return canvas;
    };
    /**
     * Removes canvas.
     *
     * @param canvas  Canvas element
     */
    Export.prototype.disposeCanvas = function (canvas) {
        document.body.removeChild(canvas);
    };
    /**
     * Returns pixel ratio for retina displays.
     *
     * @return Pixel ratio
     */
    Export.prototype.getPixelRatio = function (options) {
        var scale = options && options.scale ? options.scale : 1;
        return (this.useRetina ? getPixelRatio() : 1) * scale;
    };
    /**
     * Converts all `<image>` tags in SVG to use data uris instead of external
     * URLs
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @ignore Exclude from docs
     * @param el       SVG node
     * @param options  Options
     * @return Promise
     */
    Export.prototype.imagesToDataURI = function (el, options) {
        return __awaiter(this, void 0, void 0, function () {
            var images, promises, count, i, image, href;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        images = el.querySelectorAll("image");
                        if (!images.length) return [3 /*break*/, 2];
                        promises = [];
                        // There are images, process each of them
                        for (count = images.length, i = 0; i < count; i++) {
                            image = images[i];
                            href = image.getAttributeNS(Export.XLINK, "href");
                            // no href?
                            if (!href) {
                                continue;
                            }
                            if (href.indexOf("data:image") !== -1) {
                                // Ignore image if it's already in Data URI format
                            }
                            else {
                                // SVG or bitmap image?
                                if (href.indexOf(".svg") !== -1) {
                                    promises.push(this.svgToDataURI(image, options));
                                }
                                else {
                                    promises.push(this.imageToDataURI(image, options));
                                }
                            }
                        }
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * `foreignObject` elements cannot be exported. This function hides them
     * temprarily. In the future it might try to convert them to SVG to make them
     * exportable.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @ignore Exclude from docs
     * @param el       SVG node
     * @param options  Options
     * @return Promise
     */
    Export.prototype.prepForeignObjects = function (el, options) {
        return __awaiter(this, void 0, void 0, function () {
            var objects, count, i;
            return __generator(this, function (_a) {
                objects = el.querySelectorAll("foreignObject");
                if (objects.length) {
                    // There are foreign objects, process each of them
                    for (count = objects.length, i = 0; i < count; i++) {
                        this.temporarilyRemoveObject(objects[i]);
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Converts an SVG `<image>` to use its data uri for `href` instead of
     * external file.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @ignore Exclude from docs
     * @param el       SVG element
     * @param options  Options
     */
    Export.prototype.imageToDataURI = function (el, options) {
        return __awaiter(this, void 0, void 0, function () {
            var img, canvas, uri, e_5;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.loadNewImage(el.getAttributeNS(Export.XLINK, "href"), null, null, "anonymous")];
                    case 1:
                        // Create image
                        img = _a.sent();
                        canvas = document.createElement("canvas");
                        canvas.width = img.width;
                        canvas.height = img.height;
                        // Draw new image on it via `toDataURL`
                        canvas.getContext("2d").drawImage(img, 0, 0);
                        // Replace image `href` with data uri
                        // If we got to this point it means image has loaded, however we might
                        // still get an error with `toDataURL()`
                        try {
                            uri = canvas.toDataURL();
                            el.setAttribute("href", uri);
                            return [2 /*return*/, uri];
                        }
                        catch (e) {
                            // Give up and temporarily remove the element href temporarily
                            if (options.keepTainted !== false) {
                                /*this._removedObjects.push({
                                    "element": el,
                                    "originalHref": el.getAttributeNS(Export.XLINK, "href")
                                });
                                el.setAttributeNS(Export.XLINK, "href", "");*/
                                this.temporarilyRemoveObject(el);
                            }
                            return [2 /*return*/, undefined];
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        e_5 = _a.sent();
                        // Give up and temporarily remove the element's href
                        if (!options || options.keepTainted !== false) {
                            /*this._removedObjects.push({
                                "element": el,
                                "originalHref": el.getAttributeNS(Export.XLINK, "href")
                            });
                            el.setAttributeNS(Export.XLINK, "href", "");*/
                            this.temporarilyRemoveObject(el);
                        }
                        return [2 /*return*/, undefined];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Converts `<image>` with external SVG source to data uri. Loads external SVG
     * file, then converts it to data uri and replaces the `xlink:href` parameter.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @ignore Exclude from docs
     * @param el        An SVG element
     * @param options   Options
     */
    Export.prototype.svgToDataURI = function (el, options) {
        return __awaiter(this, void 0, void 0, function () {
            var href, data, charset, uri, e_6;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        href = el.getAttributeNS(Export.XLINK, "href");
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, load(href)];
                    case 2:
                        data = _a.sent();
                        charset = this.adapter.apply("charset", {
                            charset: "base64",
                            type: "svg",
                            options: options
                        }).charset;
                        uri = this.adapter.apply("svgToDataURI", {
                            data: "data:" + this.getContentType("svg") + ";" + charset + "," + btoa(data.response),
                            options: options
                        }).data;
                        el.setAttributeNS(Export.XLINK, "href", uri);
                        return [2 /*return*/, uri];
                    case 3:
                        e_6 = _a.sent();
                        // Disable temporarily
                        if (!options || options.keepTainted !== false) {
                            /*this._removedObjects.push({
                                "element": el,
                                "originalHref": href
                            });
                            el.setAttributeNS(Export.XLINK, "href", "");*/
                            this.temporarilyRemoveObject(el);
                        }
                        return [2 /*return*/, undefined];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Temporarily removes element from DOM, and replaces it with a dummy
     * placeholder, as well as stores it for later restoration.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @ignore Exclude from docs
     * @param el Node
     */
    Export.prototype.temporarilyRemoveObject = function (el, placeholder) {
        // Get parent
        var parent = el.parentElement || el.parentNode;
        // Create a placeholder group element if it has not been passed in
        if (!placeholder) {
            placeholder = this.sprite.paper.add("g").node;
        }
        parent.insertBefore(placeholder, el);
        // Check if we have a textContents we can replace with
        // @todo Perhaps we should explore alternatives to creating text nodes
        // i.e. creating a text version of the HTML-based Text, just for export
        // purposes. Converting HTML into SVG is very complicated
        if (el.textContent) {
            /*let text = this.sprite.paper.add("text").node;
            text.textContent = el.textContent;
            placeholder.appendChild(text);

            // Copy properties from the removing element to the placeholder
            $dom.copyAttributes(el, placeholder);*/
        }
        // Remove the old element
        parent.removeChild(el);
        // Log removed item
        this._removedObjects.push({
            "element": el,
            "placeholder": placeholder
        });
    };
    /**
     * Restores all (possibly tainted or unsupported) objects that were
     * temporarily removed when exporting.
     *
     * @ignore Exclude from docs
     */
    Export.prototype.restoreRemovedObjects = function () {
        var obj;
        while (true) {
            obj = this._removedObjects.pop();
            if (!obj) {
                break;
            }
            //obj.element.setAttribute("href", obj.originalHref);
            var parent_1 = obj.placeholder.parentElement || obj.placeholder.parentNode;
            parent_1.insertBefore(obj.element, obj.placeholder);
            //parent.removeChild(obj.placeholder);
        }
    };
    /**
     * Checkes if simplified export can be used using `createObjectURL` and SVG
     * document does not contain any external images.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @ignore Exclude from docs
     * @return `true` if simplified export can be used
     */
    Export.prototype.simplifiedImageExport = function () {
        return __awaiter(this, void 0, void 0, function () {
            var cache, canvas, ctx, DOMURL, svg, url, img, e_7, e_8;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.useSimplifiedExport === false) {
                            return [2 /*return*/, false];
                        }
                        cache = registry.getCache("simplifiedImageExport");
                        if (cache === false || cache === true) {
                            return [2 /*return*/, cache];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        canvas = document.createElement("canvas");
                        canvas.width = 1;
                        canvas.height = 1;
                        ctx = canvas.getContext("2d");
                        DOMURL = this.getDOMURL();
                        svg = new Blob([this.normalizeSVG("<g></g>", {}, 1, 1)], { type: "image/svg+xml" });
                        url = DOMURL.createObjectURL(svg);
                        img = void 0;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.loadNewImage(url, 1, 1)];
                    case 3:
                        img = _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        e_7 = _a.sent();
                        return [2 /*return*/, false];
                    case 5:
                        ctx.drawImage(img, 0, 0);
                        DOMURL.revokeObjectURL(url);
                        try {
                            //let uri = canvas.toDataURL("image/png");
                            registry.setCache("simplifiedImageExport", true);
                            return [2 /*return*/, true];
                        }
                        catch (e) {
                            registry.setCache("simplifiedImageExport", false);
                            return [2 /*return*/, false];
                        }
                        return [3 /*break*/, 7];
                    case 6:
                        e_8 = _a.sent();
                        registry.setCache("simplifiedImageExport", false);
                        return [2 /*return*/, false];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns a new `<image>` element.
     *
     * @ignore Exclude from docs
     * @param url          URL of the image
     * @param width        Width (px)
     * @param height       Height (px)
     * @param crossOrigin  Cross-Origin setting
     * @return Promise
     */
    Export.prototype.loadNewImage = function (url, width, height, crossOrigin) {
        return new Promise(function (success, error) {
            // New image
            var image;
            if (width && height) {
                image = new Image(width, height);
            }
            else {
                image = new Image();
            }
            // Set crossorigin
            if (crossOrigin) {
                image.setAttribute("crossOrigin", crossOrigin);
            }
            // Report success on load
            image.onload = function () {
                success(image);
            };
            function onerror() {
                // Error occurred. Just in case it's the crossOrigin issue, let's try
                // stripping off this attribute and trying again
                if (crossOrigin) {
                    // Retain old uri
                    var currentHref = image.src;
                    // Set up another `onerror` to handle situations where image is not
                    // loadable at all (i.e. protected by CORS)
                    image.onerror = function () {
                        // Nope, no luck
                        error(new Error("Loading image \"" + url + "\" failed"));
                    };
                    // remove the `crossOrigin` attribute
                    image.removeAttribute("crossorigin");
                    // retry
                    image.src = "";
                    image.src = currentHref;
                }
                else {
                    error(new Error("Loading image \"" + url + "\" failed"));
                }
            }
            // Set image error handlers
            image.onabort = onerror;
            image.onerror = onerror;
            // Trigger load
            image.src = url;
        });
    };
    /**
     * Returns current DOM URL.
     *
     * @ignore Exclude from docs
     * @return URL
     */
    Export.prototype.getDOMURL = function () {
        return self.URL || self.webkitURL || self;
    };
    /**
     * Returns an SVG representation of the chart.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @param type     Type of the export
     * @param options  Options
     * @return Promise
     */
    Export.prototype.getSVG = function (type, options) {
        return __awaiter(this, void 0, void 0, function () {
            var prehidden, width, height, font, fontSize, svg, charset, uri;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        prehidden = this._objectsAlreadyHidden;
                        if (!prehidden) {
                            this.hideNonExportableSprites();
                        }
                        // Wait for required elements to be ready before proceeding
                        return [4 /*yield*/, this.awaitValidSprites()];
                    case 1:
                        // Wait for required elements to be ready before proceeding
                        _a.sent();
                        width = this.sprite.pixelWidth, height = this.sprite.pixelHeight, font = findFont(this.sprite.dom), fontSize = findFontSize(this.sprite.dom);
                        svg = this.normalizeSVG(this.serializeElement(this.sprite.paper.defs) + this.serializeElement(this.sprite.dom), options, width, height, font, fontSize);
                        charset = this.adapter.apply("charset", {
                            charset: "charset=utf-8",
                            type: "svg",
                            options: options
                        }).charset;
                        uri = this.adapter.apply("getSVG", {
                            data: "data:" + this.getContentType(type) + ";" + charset + "," + encodeURIComponent(svg),
                            options: options
                        }).data;
                        if (!prehidden) {
                            this.restoreNonExportableSprites();
                        }
                        return [2 /*return*/, uri];
                }
            });
        });
    };
    /**
     * Checks if SVG is fully formatted. Encloses in `<svg>...</svg>` if
     * necessary.
     *
     * @ignore Exclude from docs
     * @param svg       Input SVG
     * @param options   Options
     * @param width     Width of the SVG viewport
     * @param height    Height of the SVG viewport
     * @param font      Font family to use as a base
     * @param fontSize  Font size to use as a base
     * @return Output SVG
     * @todo Add style params to existing <svg>
     */
    Export.prototype.normalizeSVG = function (svg, options, width, height, font, fontSize, background) {
        // Construct width/height params
        var dimParams = "";
        if (width) {
            dimParams += "width=\"" + width + "px\" ";
        }
        if (height) {
            dimParams += "height=\"" + height + "px\" ";
        }
        // Apply font settings
        var styleParams = "";
        if (font) {
            styleParams += "font-family: " + font.replace(/"/g, "") + ";";
        }
        if (fontSize) {
            styleParams += "font-size: " + fontSize + ";";
        }
        // Remove foreign objects temporarily
        var fos = [];
        var ms = svg.match(/<foreignObject[\s\S]*<\/foreignObject>/gi);
        if (ms) {
            for (var i = 0; i < ms.length; i++) {
                svg = svg.replace(ms[i], PLACEHOLDER);
                fos.push(ms[i]);
            }
        }
        // Add missing <svg> enclosure
        if (!svg.match(/<svg/)) {
            svg = "<?xml version=\"1.0\" encoding=\"utf-8\"?><svg " + dimParams + " style=\"" + styleParams + "\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">" + svg + "</svg>";
        }
        else {
            if (dimParams !== "") {
                // Clear current params
                svg = svg.replace(/(<svg[^>]*)width="[^"]*"/, "$1");
                svg = svg.replace(/(<svg[^>]*)height="[^"]*"/, "$1");
                // Add new params
                svg = svg.replace(/(<svg)/, "$1" + dimParams);
            }
            /*if (styleParams !== "") {
                // Clear current params
                svg = svg.replace(/(<svg[^>]*)stylewidth="[^"]*"/, "$1");
                svg = svg.replace(/(<svg[^>]*)height="[^"]*"/, "$1");

                // Add new params
                svg = svg.replace(/(<svg)/, "$1" + dimParams);
            }*/
        }
        if (background) {
            svg = svg.replace(/(<svg[^>]*>)/, "$1<rect width=\"100%\" height=\"100%\" fill=\"" + background.rgba + "\"/>");
            //svg = svg.replace(/<\/svg>/, "<rect width=\"100%\" height=\"100%\" fill=\"" + background.rgba + "\"/></svg>");
        }
        if (isInternetExplorer()) {
            // IE can't handle exporting <feColorMatrix> for some reason
            svg = svg.replace(/<feColorMatrix [^\/>]*\/>/gi, "");
        }
        // Remove base uri-related stuff
        var reg = new RegExp("url\\(" + escapeForRgex(getBaseURI()), "g");
        svg = svg.replace(reg, "url(#");
        // Put foreignObjects back in
        if (fos.length) {
            for (var i = 0; i < fos.length; i++) {
                svg = svg.replace(PLACEHOLDER, fos[i]);
            }
        }
        svg = this.adapter.apply("normalizeSVG", {
            data: svg,
            options: options
        }).data;
        return svg;
    };
    /**
     * Serializes an element and returns its contents.
     *
     * @ignore Exclude from docs
     * @param element  An element to serialize
     * @return A serialized XML
     */
    Export.prototype.serializeElement = function (element) {
        return new XMLSerializer().serializeToString(element);
    };
    /**
     * Returns a PDF containing chart image.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @param type     Type of the export
     * @param options  Options
     * @return Promise
     * @async
     * @todo Account for header when calculating vertical fit
     */
    Export.prototype.getPDF = function (type, options) {
        return __awaiter(this, void 0, void 0, function () {
            function addFont(font) {
                var paths = {};
                paths.normal = font.normal.path;
                vfs[font.normal.path] = font.normal.bytes;
                if (font.bold) {
                    paths.bold = font.bold.path;
                    vfs[font.bold.path] = font.bold.bytes;
                }
                else {
                    paths.bold = font.normal.path;
                }
                if (font.italics) {
                    paths.italics = font.italics.path;
                    vfs[font.italics.path] = font.italics.bytes;
                }
                else {
                    paths.italics = font.normal.path;
                }
                if (font.bolditalics) {
                    paths.bolditalics = font.bolditalics.path;
                    vfs[font.bolditalics.path] = font.bolditalics.bytes;
                }
                else {
                    paths.bolditalics = font.normal.path;
                }
                fonts[font.name] = paths;
            }
            var image, pdfmake, defaultMargins, doc, title, extraMargin, _a, _b, _c, fonts, vfs;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, this.getImage(options.imageFormat || "png", options)];
                    case 1:
                        image = _d.sent();
                        return [4 /*yield*/, this.pdfmake];
                    case 2:
                        pdfmake = _d.sent();
                        defaultMargins = [30, 30, 30, 30];
                        doc = {
                            pageSize: options.pageSize || "A4",
                            pageOrientation: options.pageOrientation || "portrait",
                            pageMargins: options.pageMargins || defaultMargins,
                            defaultStyle: {
                                font: options.font ? options.font.name : undefined,
                            },
                            //header: <any>[],
                            content: []
                        };
                        title = this.adapter.apply("title", {
                            title: this.title,
                            options: options
                        }).title;
                        extraMargin = 0;
                        if (title) {
                            doc.content.push({
                                text: title,
                                fontSize: options.fontSize,
                                bold: true,
                                margin: [0, 0, 0, 15]
                            });
                            // Add some leftover margin for title
                            extraMargin += 50;
                        }
                        // Add page URL?
                        if (options.addURL) {
                            doc.content.push({
                                text: this.language.translate("Saved from") + ": " + document.location.href,
                                fontSize: options.fontSize,
                                margin: [0, 0, 0, 15]
                            });
                            // Add some leftover margin for URL
                            extraMargin += 50;
                        }
                        // Add image
                        if (type != "pdfdata") {
                            doc.content.push({
                                image: image,
                                alignment: options.align || "left",
                                fit: this.getPageSizeFit(doc.pageSize, doc.pageMargins, extraMargin)
                            });
                        }
                        if (!(type == "pdfdata" || options.addData)) return [3 /*break*/, 4];
                        _b = (_a = doc.content).push;
                        _c = {};
                        return [4 /*yield*/, this.getPDFData("pdf", options)];
                    case 3:
                        _b.apply(_a, [(_c.table = _d.sent(),
                                _c)]);
                        _d.label = 4;
                    case 4:
                        // Apply adapters
                        doc = this.adapter.apply("pdfmakeDocument", {
                            doc: doc,
                            options: options
                        }).doc;
                        fonts = null;
                        vfs = null;
                        if (options.font) {
                            fonts = {};
                            vfs = {};
                            addFont(options.font);
                            if (options.extraFonts) {
                                each(options.extraFonts, addFont);
                            }
                        }
                        return [4 /*yield*/, new Promise(function (success, error) {
                                pdfmake.createPdf(doc, null, fonts, vfs).getDataUrl(function (uri) {
                                    success(uri);
                                });
                            })];
                    case 5: 
                    // Create PDF
                    return [2 /*return*/, _d.sent()];
                }
            });
        });
    };
    /**
     * Returns chart's data formatted suitable for PDF export (pdfmake).
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @since 4.7.0
     * @param type     Type of the export
     * @param options  Options
     * @return Promise
     * @async
     */
    Export.prototype.getPDFData = function (type, options) {
        return __awaiter(this, void 0, void 0, function () {
            var content, dataFields, data, dataFieldsOrder_1, len, i;
            var _this = this;
            return __generator(this, function (_a) {
                content = {
                    "body": []
                };
                dataFields = this.adapter.apply("formatDataFields", {
                    dataFields: this.dataFields,
                    format: "pdf"
                }).dataFields;
                data = this.data;
                // Vertical or horizontal (default) layout
                if (options.pivot) {
                    dataFieldsOrder_1 = this.adapter.apply("dataFieldsOrder", {
                        dataFieldsOrder: this.dataFieldsOrder,
                        format: "pdfdata"
                    }).dataFieldsOrder;
                    eachOrdered(dataFields, function (key, val) {
                        var dataRow = [];
                        if (options.addColumnNames) {
                            dataRow.push(val);
                        }
                        for (var len = data.length, i = 0; i < len; i++) {
                            var dataValue = data[i][key];
                            dataRow.push(_this.convertToSpecialFormat(key, dataValue, options, true));
                        }
                        content.body.push(_this.getPDFDataRow(dataRow, options, undefined, true));
                    }, function (a, b) {
                        //console.log(a, b)
                        var ai = dataFieldsOrder_1.indexOf(a);
                        var bi = dataFieldsOrder_1.indexOf(b);
                        if (ai > bi) {
                            return 1;
                        }
                        else if (ai < bi) {
                            return -1;
                        }
                        return 0;
                    });
                }
                else {
                    // Add column names?
                    if (options.addColumnNames) {
                        content.body.push(this.getPDFDataRow(dataFields, options, undefined, true));
                        content.headerRows = 1;
                    }
                    for (len = data.length, i = 0; i < len; i++) {
                        content.body.push(this.getPDFDataRow(data[i], options, dataFields));
                    }
                }
                return [2 /*return*/, this.adapter.apply("pdfmakeTable", {
                        table: content,
                        options: options
                    }).table];
            });
        });
    };
    /**
     * Formats a row of data for use in PDF data table (pdfmake).
     *
     * @ignore Exclude from docs
     * @since 4.7.0
     * @param  row         An object holding data for the row
     * @param  options     Options
     * @param  dataFields  Data fields
     * @param  asIs        Do not try to convert to dates
     * @return Formated Data line
     */
    Export.prototype.getPDFDataRow = function (row, options, dataFields, asIs) {
        var _this = this;
        if (asIs === void 0) { asIs = false; }
        // Init
        var items = [];
        // Data fields
        if (!dataFields) {
            dataFields = row;
        }
        // Data fields order
        var dataFieldsOrder = this.adapter.apply("dataFieldsOrder", {
            dataFieldsOrder: this.dataFieldsOrder,
            format: "pdfdata"
        }).dataFieldsOrder;
        // Process each row item
        eachOrdered(dataFields, function (key, name) {
            // Get value
            var value = _this.convertEmptyValue(key, row[key], options);
            // Convert dates
            var item = asIs ? value : _this.convertToSpecialFormat(key, value, options);
            item = "" + item;
            // Add to item
            items.push(item);
        }, function (a, b) {
            //console.log(a, b)
            var ai = dataFieldsOrder.indexOf(a);
            var bi = dataFieldsOrder.indexOf(b);
            if (ai > bi) {
                return 1;
            }
            else if (ai < bi) {
                return -1;
            }
            return 0;
        });
        return items;
    };
    /**
     * Returns fit dimensions for available page sizes.
     *
     * @ignore Exclude from docs
     * @param pageSize Page size
     * @return `[width, height]` in pixels
     */
    Export.prototype.getPageSizeFit = function (pageSize, margins, extraMargin) {
        if (extraMargin === void 0) { extraMargin = 0; }
        // Check margins
        var newMargins = [0, 0, 0, 0];
        if (typeof margins == "number") {
            newMargins = [margins, margins, margins, margins];
        }
        else if (margins.length == 2) {
            newMargins = [margins[0], margins[1], margins[0], margins[1]];
        }
        else if (margins.length == 4) {
            newMargins = margins;
        }
        // Define available page sizes
        var sizes = {
            "4A0": [4767.87, 6740.79],
            "2A0": [3370.39, 4767.87],
            A0: [2383.94, 3370.39],
            A1: [1683.78, 2383.94],
            A2: [1190.55, 1683.78],
            A3: [841.89, 1190.55],
            A4: [595.28, 841.89],
            A5: [419.53, 595.28],
            A6: [297.64, 419.53],
            A7: [209.76, 297.64],
            A8: [147.40, 209.76],
            A9: [104.88, 147.40],
            A10: [73.70, 104.88],
            B0: [2834.65, 4008.19],
            B1: [2004.09, 2834.65],
            B2: [1417.32, 2004.09],
            B3: [1000.63, 1417.32],
            B4: [708.66, 1000.63],
            B5: [498.90, 708.66],
            B6: [354.33, 498.90],
            B7: [249.45, 354.33],
            B8: [175.75, 249.45],
            B9: [124.72, 175.75],
            B10: [87.87, 124.72],
            C0: [2599.37, 3676.54],
            C1: [1836.85, 2599.37],
            C2: [1298.27, 1836.85],
            C3: [918.43, 1298.27],
            C4: [649.13, 918.43],
            C5: [459.21, 649.13],
            C6: [323.15, 459.21],
            C7: [229.61, 323.15],
            C8: [161.57, 229.61],
            C9: [113.39, 161.57],
            C10: [79.37, 113.39],
            RA0: [2437.80, 3458.27],
            RA1: [1729.13, 2437.80],
            RA2: [1218.90, 1729.13],
            RA3: [864.57, 1218.90],
            RA4: [609.45, 864.57],
            SRA0: [2551.18, 3628.35],
            SRA1: [1814.17, 2551.18],
            SRA2: [1275.59, 1814.17],
            SRA3: [907.09, 1275.59],
            SRA4: [637.80, 907.09],
            EXECUTIVE: [521.86, 756.00],
            FOLIO: [612.00, 936.00],
            LEGAL: [612.00, 1008.00],
            LETTER: [612.00, 792.00],
            TABLOID: [792.00, 1224.00]
        };
        // Calculate size
        var fitSize = sizes[pageSize];
        fitSize[0] -= newMargins[0] + newMargins[2];
        fitSize[1] -= newMargins[1] + newMargins[3] + extraMargin;
        return fitSize;
    };
    /**
     * Returns an Excel file of chart's data.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @param type     Type of the export
     * @param options  Options
     * @return Promise
     * @async
     * @todo Handle dates
     * @todo Support for multi-sheet
     */
    Export.prototype.getExcel = function (type, options) {
        return __awaiter(this, void 0, void 0, function () {
            var XLSX, wbOptions, sheetName, wb, data, dataFields, dataFieldsOrder_2, len, i, uri;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.xlsx];
                    case 1:
                        XLSX = _a.sent();
                        wbOptions = this.adapter.apply("xlsxWorkbookOptions", {
                            options: {
                                bookType: "xlsx",
                                bookSST: false,
                                type: "base64",
                            }
                        }).options;
                        sheetName = this.normalizeExcelSheetName(this.adapter.apply("xlsxSheetName", {
                            name: this.title || this.language.translate("Data")
                        }).name);
                        wb = {
                            SheetNames: [sheetName],
                            Sheets: {}
                        };
                        data = [];
                        dataFields = this.adapter.apply("formatDataFields", {
                            dataFields: this.dataFields,
                            format: "xslx"
                        }).dataFields;
                        // Vertical or horizontal (default) layout
                        if (options.pivot) {
                            dataFieldsOrder_2 = this.adapter.apply("dataFieldsOrder", {
                                dataFieldsOrder: this.dataFieldsOrder,
                                format: "xlsx"
                            }).dataFieldsOrder;
                            eachOrdered(dataFields, function (key, val) {
                                var dataRow = [];
                                if (options.addColumnNames) {
                                    dataRow.push(val);
                                }
                                for (var len = _this.data.length, i = 0; i < len; i++) {
                                    var dataValue = _this.data[i][key];
                                    dataRow.push(_this.convertToSpecialFormat(key, dataValue, options, true));
                                }
                                data.push(_this.getExcelRow(dataRow, options, undefined, true));
                            }, function (a, b) {
                                //console.log(a, b)
                                var ai = dataFieldsOrder_2.indexOf(a);
                                var bi = dataFieldsOrder_2.indexOf(b);
                                if (ai > bi) {
                                    return 1;
                                }
                                else if (ai < bi) {
                                    return -1;
                                }
                                return 0;
                            });
                        }
                        else {
                            // Add column names?
                            if (options.addColumnNames) {
                                data.push(this.getExcelRow(dataFields, options, undefined, true));
                            }
                            // Add lines
                            for (len = this.data.length, i = 0; i < len; i++) {
                                data.push(this.getExcelRow(this.data[i], options, dataFields));
                            }
                        }
                        // Create sheet and add data
                        wb.Sheets[sheetName] = XLSX.utils.aoa_to_sheet(data);
                        uri = this.adapter.apply("getExcel", {
                            data: "data:" + this.getContentType(type) + ";base64," + XLSX.write(wb, wbOptions),
                            options: options
                        }).data;
                        return [2 /*return*/, uri];
                }
            });
        });
    };
    /**
     * This is needed to work around Excel limitations.
     *
     * @param name  Source name
     * @return Normalized name
     */
    Export.prototype.normalizeExcelSheetName = function (name) {
        name = name.replace(/([:\\\/?*\[\]]+)/g, " ");
        return truncateWithEllipsis(name, 31, "...", true);
    };
    /**
     * Rertuns an array of values to be used as Excel row.
     *
     * @ignore Exclude from docs
     * @param  row         Row data
     * @param  options     Options
     * @param  dataFields  Data fields
     * @param  asIs        Do not try to convert to dates
     * @return Array of values
     */
    Export.prototype.getExcelRow = function (row, options, dataFields, asIs) {
        var _this = this;
        if (asIs === void 0) { asIs = false; }
        // Init
        var items = [];
        // Data fields
        if (!dataFields) {
            dataFields = row;
        }
        // Data fields order
        var dataFieldsOrder = this.adapter.apply("dataFieldsOrder", {
            dataFieldsOrder: this.dataFieldsOrder,
            format: "xlsx"
        }).dataFieldsOrder;
        // Process each row item
        eachOrdered(dataFields, function (key, name) {
            // Get value
            var value = _this.convertEmptyValue(key, row[key], options);
            // Convert dates
            var item = asIs ? value : _this.convertToSpecialFormat(key, value, options, true);
            items.push(item);
        }, function (a, b) {
            //console.log(a, b)
            var ai = dataFieldsOrder.indexOf(a);
            var bi = dataFieldsOrder.indexOf(b);
            if (ai > bi) {
                return 1;
            }
            else if (ai < bi) {
                return -1;
            }
            return 0;
        });
        return items;
    };
    /**
     * Returns chart's data formatted as CSV.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @param type     Type of the export
     * @param options  Options
     * @return Promise
     * @async
     */
    Export.prototype.getCSV = function (type, options) {
        return __awaiter(this, void 0, void 0, function () {
            var csv, dataFields, br, data, dataFieldsOrder_3, len, i, row, charset, uri;
            var _this = this;
            return __generator(this, function (_a) {
                csv = "";
                dataFields = this.adapter.apply("formatDataFields", {
                    dataFields: this.dataFields,
                    format: "csv"
                }).dataFields;
                br = "";
                data = this.data;
                // Vertical or horizontal (default) layout
                if (options.pivot) {
                    dataFieldsOrder_3 = this.adapter.apply("dataFieldsOrder", {
                        dataFieldsOrder: this.dataFieldsOrder,
                        format: "csv"
                    }).dataFieldsOrder;
                    eachOrdered(dataFields, function (key, val) {
                        var dataRow = [];
                        if (options.addColumnNames) {
                            dataRow.push(val);
                        }
                        for (var len = data.length, i = 0; i < len; i++) {
                            var dataValue = data[i][key];
                            dataRow.push(_this.convertToSpecialFormat(key, dataValue, options, true));
                        }
                        csv += br + _this.getCSVRow(dataRow, options, undefined, true);
                        br = "\n";
                    }, function (a, b) {
                        var ai = dataFieldsOrder_3.indexOf(a);
                        var bi = dataFieldsOrder_3.indexOf(b);
                        if (ai > bi) {
                            return -1;
                        }
                        else if (ai < bi) {
                            return 1;
                        }
                        return 0;
                    });
                }
                else {
                    for (len = data.length, i = 0; i < len; i++) {
                        row = this.getCSVRow(data[i], options, dataFields);
                        if (options.reverse) {
                            csv = row + br + csv;
                        }
                        else {
                            csv += br + row;
                        }
                        br = "\n";
                    }
                    // Add column names?
                    if (options.addColumnNames) {
                        csv = this.getCSVRow(dataFields, options, undefined, true) + br + csv;
                    }
                }
                charset = this.adapter.apply("charset", {
                    charset: "charset=utf-8",
                    type: type,
                    options: options
                }).charset;
                uri = this.adapter.apply("getCSV", {
                    data: "data:" + this.getContentType(type) + ";" + charset + "," + encodeURIComponent(csv),
                    options: options
                }).data;
                return [2 /*return*/, uri];
            });
        });
    };
    /**
     * Formats a row of CSV data.
     *
     * @ignore Exclude from docs
     * @param  row         An object holding data for the row
     * @param  options     Options
     * @param  dataFields  Data fields
     * @param  asIs        Do not try to convert to dates
     * @return Formated CSV line
     */
    Export.prototype.getCSVRow = function (row, options, dataFields, asIs) {
        var _this = this;
        if (asIs === void 0) { asIs = false; }
        // Init
        var separator = options.separator || ",";
        var items = [];
        // Data fields
        if (!dataFields) {
            dataFields = row;
        }
        // Data fields order
        var dataFieldsOrder = this.adapter.apply("dataFieldsOrder", {
            dataFieldsOrder: this.dataFieldsOrder,
            format: "csv"
        }).dataFieldsOrder;
        // Process each row item
        eachOrdered(dataFields, function (key, name) {
            // Get value
            var value = _this.convertEmptyValue(key, row[key], options);
            // Check if we need to skip
            // This is no longer required because we are iterating via dataFields anyway
            /*if ($type.hasValue(this.dataFields) && !$type.hasValue(this.dataFields[key])) {
                return;
            }*/
            // Convert dates
            var item = asIs ? value : _this.convertToSpecialFormat(key, value, options);
            // Cast and escape doublequotes
            item = "" + item;
            item = item.replace(/"/g, '""');
            // Enclose into double quotes
            if (options.forceQuotes || (item.search(new RegExp("\"|\n|" + separator, "g")) >= 0)) {
                item = "\"" + item + "\"";
            }
            // Add to item
            items.push(item);
        }, function (a, b) {
            //console.log(a, b)
            var ai = dataFieldsOrder.indexOf(a);
            var bi = dataFieldsOrder.indexOf(b);
            if (ai > bi) {
                return 1;
            }
            else if (ai < bi) {
                return -1;
            }
            return 0;
        });
        return items.join(separator);
    };
    /**
     * Returns chart's data formatted as HTML table.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @since 4.7.0
     * @param type     Type of the export
     * @param options  Options
     * @return Promise
     * @async
     */
    Export.prototype.getHTML = function (type, options) {
        return __awaiter(this, void 0, void 0, function () {
            var html, dataFields, data, dataFieldsOrder_4, len, i, charset, uri;
            var _this = this;
            return __generator(this, function (_a) {
                html = "<table>";
                if (options.tableClass) {
                    html = "<table class=\"" + options.tableClass + "\">";
                }
                dataFields = this.adapter.apply("formatDataFields", {
                    dataFields: this.dataFields,
                    format: "html"
                }).dataFields;
                data = this.data;
                // Vertical or horizontal (default) layout
                if (options.pivot) {
                    dataFieldsOrder_4 = this.adapter.apply("dataFieldsOrder", {
                        dataFieldsOrder: this.dataFieldsOrder,
                        format: "html"
                    }).dataFieldsOrder;
                    eachOrdered(dataFields, function (key, val) {
                        var dataRow = [];
                        if (options.addColumnNames) {
                            dataRow.push(val);
                        }
                        for (var len = data.length, i = 0; i < len; i++) {
                            var dataValue = data[i][key];
                            dataRow.push(_this.convertToSpecialFormat(key, dataValue, options, true));
                        }
                        html += "\n" + _this.getHTMLRow(dataRow, options, undefined, true);
                    }, function (a, b) {
                        var ai = dataFieldsOrder_4.indexOf(a);
                        var bi = dataFieldsOrder_4.indexOf(b);
                        if (ai > bi) {
                            return -1;
                        }
                        else if (ai < bi) {
                            return 1;
                        }
                        return 0;
                    });
                }
                else {
                    // Add column names?
                    if (options.addColumnNames) {
                        html += "\n" + this.getHTMLRow(dataFields, options, undefined, true, true);
                    }
                    for (len = data.length, i = 0; i < len; i++) {
                        html += "\n" + this.getHTMLRow(data[i], options, dataFields);
                    }
                }
                html += "</table>";
                charset = this.adapter.apply("charset", {
                    charset: "charset=utf-8",
                    type: type,
                    options: options
                }).charset;
                uri = this.adapter.apply("getHTML", {
                    data: "data:" + this.getContentType(type) + ";" + charset + "," + encodeURIComponent(html),
                    options: options
                }).data;
                return [2 /*return*/, uri];
            });
        });
    };
    /**
     * Formats a row of HTML data.
     *
     * @since 4.7.0
     * @ignore Exclude from docs
     * @param  row         An object holding data for the row
     * @param  options     Options
     * @param  dataFields  Data fields
     * @param  asIs        Do not try to convert to dates
     * @return Formated HTML row
     */
    Export.prototype.getHTMLRow = function (row, options, dataFields, asIs, headerRow) {
        var _this = this;
        if (asIs === void 0) { asIs = false; }
        if (headerRow === void 0) { headerRow = false; }
        // Init output
        var html = "\t<tr>";
        if (options.rowClass) {
            html = "\t<tr class=\"" + options.rowClass + "\">";
        }
        // Data fields
        if (!dataFields) {
            dataFields = row;
        }
        // Data fields order
        var dataFieldsOrder = this.adapter.apply("dataFieldsOrder", {
            dataFieldsOrder: this.dataFieldsOrder,
            format: "html"
        }).dataFieldsOrder;
        // th or dh?
        var tag = headerRow ? "th" : "td";
        // Process each row item
        var first = true;
        eachOrdered(dataFields, function (key, name) {
            // Get value
            var value = _this.convertEmptyValue(key, row[key], options);
            // Convert dates
            var item = asIs ? value : _this.convertToSpecialFormat(key, value, options);
            // Escape HTML entities
            item = "" + item;
            item = item.replace(/[\u00A0-\u9999<>\&]/gim, function (i) {
                return "&#" + i.charCodeAt(0) + ";";
            });
            // Which tag to use
            var useTag = tag;
            if (options.pivot && first) {
                useTag = "th";
            }
            // Add cell
            if (options.cellClass) {
                html += "\n\t\t<" + useTag + " class=\"" + options.cellClass + "\">" + item + "</" + useTag + ">";
            }
            else {
                html += "\n\t\t<" + useTag + ">" + item + "</" + useTag + ">";
            }
            first = false;
        }, function (a, b) {
            var ai = dataFieldsOrder.indexOf(a);
            var bi = dataFieldsOrder.indexOf(b);
            if (ai > bi) {
                return 1;
            }
            else if (ai < bi) {
                return -1;
            }
            return 0;
        });
        html += "\n\t</tr>";
        return html;
    };
    /**
     * Returns chart's data in JSON format.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @param type     Type of the export
     * @param options  Options
     * @return Promise
     * @async
     */
    Export.prototype.getJSON = function (type, options) {
        return __awaiter(this, void 0, void 0, function () {
            var data, dataFields, sourceData, _loop_1, len, i, json, charset, uri;
            var _this = this;
            return __generator(this, function (_a) {
                dataFields = this.adapter.apply("formatDataFields", {
                    dataFields: this.dataFields,
                    format: "csv"
                }).dataFields;
                if (!this._dynamicDataFields) {
                    data = [];
                    sourceData = this.data;
                    _loop_1 = function (len, i) {
                        var value = sourceData[i];
                        if (typeof value == "object") {
                            var newValue_1 = {};
                            Object_each(value, function (field, item) {
                                if (hasValue(dataFields[field])) {
                                    newValue_1[dataFields[field]] = _this.convertToSpecialFormat(field, item, options);
                                }
                            });
                            data.push(newValue_1);
                        }
                    };
                    for (len = sourceData.length, i = 0; i < len; i++) {
                        _loop_1(len, i);
                    }
                }
                else {
                    data = this.data;
                }
                json = JSON.stringify(data, function (key, value) {
                    if (typeof value == "object") {
                        Object_each(value, function (field, item) {
                            value[field] = _this.convertToSpecialFormat(field, item, options);
                        });
                    }
                    return value;
                }, options.indent);
                charset = this.adapter.apply("charset", {
                    charset: "charset=utf-8",
                    type: type,
                    options: options
                }).charset;
                uri = this.adapter.apply("getJSON", {
                    data: "data:" + this.getContentType(type) + ";" + charset + "," + encodeURIComponent(json),
                    options: options
                }).data;
                return [2 /*return*/, uri];
            });
        });
    };
    /**
     * Converts the value to proper date format.
     *
     * @ignore Exclude from docs
     * @param  field         Field name
     * @param  value         Value
     * @param  options       Options
     * @param  keepOriginal  Will ignore formatting and will keep value as it is in data
     * @return Formatted date value or unmodified value
     */
    Export.prototype.convertToSpecialFormat = function (field, value, options, keepOriginal) {
        // Is this a timestamp or duration?
        if (typeof value == "number") {
            if (this.isDateField(field)) {
                value = new Date(value);
            }
            else if (this.isDurationField(field)) {
                return this.durationFormatter.format(value, this.durationFormat);
            }
            else if (this.isNumberField(field) && this.numberFormat) {
                return this.numberFormatter.format(value, this.numberFormat);
            }
        }
        if (value instanceof Date) {
            if (options.useTimestamps) {
                value = value.getTime();
            }
            else if (options.useLocale) {
                if (!keepOriginal) {
                    value = value.toLocaleString();
                }
            }
            else {
                value = this.dateFormatter.format(value, this.dateFormat);
            }
        }
        else if (isString(value) && this.isDateField(field) && this.dateFormat) {
            value = this.dateFormatter.format(this.dateFormatter.parse(value), this.dateFormat);
        }
        return value;
    };
    /**
     * Converts empty value based on `emptyAs` option.
     *
     * @ignore Exclude from docs
     */
    Export.prototype.convertEmptyValue = function (field, value, options) {
        return hasValue(value) ? value : options.emptyAs;
    };
    /**
     * Triggers download of the file.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @param uri       Data URI with file content
     * @param fileName  File name
     * @return Promise
     * @async
     */
    Export.prototype.download = function (uri, fileName) {
        return __awaiter(this, void 0, void 0, function () {
            var parts, contentType, decoded, blob_1, chars, i, charCode, blob, link_1, parts, contentType, decoded, blob_2, url_2, chars, i, charCode, blob, url_3, link, parts, contentType, iframe, idoc;
            return __generator(this, function (_a) {
                if (this.msBlobDownloadSupport()) {
                    parts = uri.split(";");
                    contentType = parts.shift().replace(/data:/, "");
                    uri = decodeURIComponent(parts.join(";").replace(/^[^,]*,/, ""));
                    // Check if we need to Base64-decode
                    if (["image/svg+xml", "application/json", "text/csv"].indexOf(contentType) == -1) {
                        try {
                            decoded = atob(uri);
                            uri = decoded;
                        }
                        catch (e) {
                            // Error occurred, meaning string was not Base64-encoded. Do nothing.
                            return [2 /*return*/, false];
                        }
                    }
                    else {
                        blob_1 = new Blob([uri], { type: contentType });
                        window.navigator.msSaveBlob(blob_1, fileName);
                        return [2 /*return*/, true];
                    }
                    chars = new Array(uri.length);
                    for (i = 0; i < uri.length; ++i) {
                        charCode = uri.charCodeAt(i);
                        chars[i] = charCode;
                    }
                    blob = new Blob([new Uint8Array(chars)], { type: contentType });
                    window.navigator.msSaveBlob(blob, fileName);
                }
                else if (this.blobDownloadSupport()) {
                    link_1 = document.createElement("a");
                    link_1.download = fileName;
                    document.body.appendChild(link_1);
                    parts = uri.split(";");
                    contentType = parts.shift().replace(/data:/, "");
                    uri = decodeURIComponent(parts.join(";").replace(/^[^,]*,/, ""));
                    if (["image/svg+xml", "application/json", "text/csv", "text/html"].indexOf(contentType) == -1) {
                        try {
                            decoded = atob(uri);
                            uri = decoded;
                        }
                        catch (e) {
                            // Error occurred, meaning string was not Base64-encoded. Do nothing.
                            return [2 /*return*/, false];
                        }
                    }
                    else {
                        blob_2 = new Blob([uri], { type: contentType });
                        url_2 = window.URL.createObjectURL(blob_2);
                        link_1.href = url_2;
                        link_1.download = fileName;
                        link_1.click();
                        setTimeout(function () {
                            document.body.removeChild(link_1);
                            window.URL.revokeObjectURL(url_2);
                        }, 100);
                        return [2 /*return*/, true];
                    }
                    chars = new Array(uri.length);
                    for (i = 0; i < uri.length; ++i) {
                        charCode = uri.charCodeAt(i);
                        chars[i] = charCode;
                    }
                    blob = new Blob([new Uint8Array(chars)], { type: contentType });
                    url_3 = window.URL.createObjectURL(blob);
                    link_1.href = url_3;
                    link_1.download = fileName;
                    document.body.appendChild(link_1);
                    link_1.click();
                    document.body.removeChild(link_1);
                    setTimeout(function () {
                        window.URL.revokeObjectURL(url_3);
                    }, 100);
                }
                else if (this.linkDownloadSupport()) {
                    link = document.createElement("a");
                    link.download = fileName;
                    link.href = uri;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
                else if (this.legacyIE()) {
                    parts = uri.match(/^data:(.*);[ ]*([^,]*),(.*)$/);
                    if (parts.length === 4) {
                        // Base64-encoded or text-based stuff?
                        if (parts[2] == "base64") {
                            // Base64-encoded - probably an image
                            if (parts[1].match(/^image\//)) {
                                // Yep, an image. Let's create a temporary image placeholder,
                                // so that user can use do Save As.
                                this.showModal("<img src=\"" + uri + "\" style=\"float: left; max-width: 50%; max-height: 80%; margin: 0 1em 0.5em 0; border: 1px solid #eee;\" />" +
                                    "<p>" + this.language.translate("To save the image, right-click thumbnail on the left and choose \"Save picture as...\"") +
                                    "</p>" +
                                    "<p style=\"text-align: center;\"><small>" + this.language.translate("(Press ESC to close this message)") + "</small></p>", this.language.translate("Image Export Complete"));
                            }
                        }
                        else {
                            contentType = void 0;
                            if (fileName.match(/\.svg$/)) {
                                contentType = "image/svg+xml";
                            }
                            else {
                                contentType = "text/plain";
                                fileName += ".txt";
                            }
                            iframe = document.createElement("iframe");
                            iframe.width = "1px";
                            iframe.height = "1px";
                            iframe.style.display = "none";
                            document.body.appendChild(iframe);
                            idoc = iframe.contentDocument;
                            idoc.open(contentType, "replace");
                            // TODO test this with various encodings (e.g. UTF)
                            //idoc.charset = parts[2].replace(/charset=/, "");
                            idoc.write(decodeURIComponent(parts[3]));
                            idoc.close();
                            idoc.execCommand("SaveAs", true, fileName);
                            // Destroy the iframe
                            document.body.removeChild(iframe);
                        }
                    }
                }
                else {
                    /**
                     * Something else - perhaps a mobile.
                     * Let's just display it in the same page.
                     * (hey we don't like it either)
                     */
                    window.location.href = uri;
                }
                return [2 /*return*/, true];
            });
        });
    };
    /**
     * Returns `true` if browser has any supported methods to trigger download
     * of a binary file.
     *
     * @return Supports downloads?
     */
    Export.prototype.downloadSupport = function () {
        //return !this.legacyIE();
        return this.linkDownloadSupport() || this.msBlobDownloadSupport();
    };
    /**
     * Checks if the browser supports "download" attribute on links.
     *
     * @ignore Exclude from docs
     * @return Browser supports triggering downloads?
     */
    Export.prototype.linkDownloadSupport = function () {
        // Do we have this cached?
        var cache = registry.getCache("linkDownloadSupport");
        if (cache === false || cache === true) {
            return cache;
        }
        var a = document.createElement("a");
        var res = typeof a.download !== "undefined";
        registry.setCache("linkDownloadSupport", res);
        return res;
    };
    /**
     * Checks if the browser supports download via `msBlob`.
     *
     * @ignore Exclude from docs
     * @return Browser supports triggering downloads?
     */
    Export.prototype.blobDownloadSupport = function () {
        return hasValue(window.Blob);
    };
    /**
     * Checks if the browser supports download via `msBlob`.
     *
     * @ignore Exclude from docs
     * @return Browser supports triggering downloads?
     */
    Export.prototype.msBlobDownloadSupport = function () {
        return hasValue(window.navigator.msSaveOrOpenBlob);
    };
    /**
     * Checks if this is a legacy version of IE.
     *
     * @ignore Exclude from docs
     * @return IE9 or less?
     */
    Export.prototype.legacyIE = function () {
        // Create a temporary <div> with conditional tags in it an an <i> tag.
        // Count <i>s. If there are some, we have IE9 or late on our hands.
        var div = document.createElement("div");
        div.innerHTML = "<!--[if lt IE 10]><i></i><![endif]-->";
        return div.getElementsByTagName("i").length == 1;
    };
    /**
     * Initiates print of the chart.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @param data     Data URI for the image
     * @param options  Options
     * @param title    Optional title to use (uses window's title by default)
     * @return Promise
     * @async
     */
    Export.prototype.print = function (data, options, title) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (options.printMethod == "css") {
                    return [2 /*return*/, this.printViaCSS(data, options, title)];
                }
                else {
                    return [2 /*return*/, this.printViaIframe(data, options, title)];
                }
                return [2 /*return*/];
            });
        });
    };
    Export.prototype.printViaCSS = function (data, options, title) {
        return __awaiter(this, void 0, void 0, function () {
            var scroll, rule, originalTitle, img, isIOS;
            return __generator(this, function (_a) {
                scroll = document.documentElement.scrollTop || document.body.scrollTop;
                rule = new DOM_StyleRule(getShadowRoot(this.container), "body > *", {
                    "display": "none",
                    "position": "fixed",
                    "visibility": "hidden",
                    "opacity": "0",
                    "clipPath": "polygon(0px 0px,0px 0px,0px 0px,0px 0px);"
                });
                if (title && document && document.title) {
                    originalTitle = document.title;
                    document.title = title;
                }
                img = new Image();
                img.src = data;
                img.style.maxWidth = "100%";
                img.style.display = "block";
                img.style.position = "relative";
                img.style.visibility = "visible";
                img.style.opacity = "1";
                img.style.clipPath = "none";
                document.body.appendChild(img);
                // Print
                this.setTimeout(function () {
                    window.print();
                }, 50);
                isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                if (isIOS && (options.delay < 1000)) {
                    options.delay = 1000;
                }
                else if (options.delay < 100) {
                    options.delay = 100;
                }
                // Delay function that resets back the document the way ot was before
                this.setTimeout(function () {
                    // Remove image
                    document.body.removeChild(img);
                    // Reset back all elements
                    /*for (let len = items.length, i = 0; i < len; i++) {
                        let item = <HTMLElement>items[i];
                        if ($dom.isElement(item)) {
                            item.style.display = states[i];
                        }
                    }*/
                    rule.dispose();
                    // Restore title
                    if (originalTitle) {
                        document.title = document.title;
                    }
                    // Scroll back the document the way it was before
                    document.documentElement.scrollTop = document.body.scrollTop = scroll;
                }, options.delay || 500);
                return [2 /*return*/, true];
            });
        });
    };
    Export.prototype.printViaIframe = function (data, options, title) {
        return __awaiter(this, void 0, void 0, function () {
            var iframe, img, isIOS;
            return __generator(this, function (_a) {
                iframe = document.createElement("iframe");
                iframe.style.visibility = "hidden";
                document.body.appendChild(iframe);
                // This is needed for FireFox
                iframe.contentWindow.document.open();
                iframe.contentWindow.document.close();
                img = new Image();
                img.src = data;
                img.style.maxWidth = "100%";
                if (title) {
                    iframe.contentWindow.document.title = title;
                }
                iframe.contentWindow.document.body.appendChild(img);
                iframe.load = function () {
                    iframe.contentWindow.document.body.appendChild(img);
                };
                // Print
                this.setTimeout(function () {
                    try {
                        if (!iframe.contentWindow.document.execCommand("print", false, null)) {
                            iframe.contentWindow.print();
                        }
                    }
                    catch (e) {
                        iframe.contentWindow.print();
                    }
                }, options.delay || 50);
                isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                if (isIOS && (options.delay < 1000)) {
                    options.delay = 1000;
                }
                else if (options.delay < 100) {
                    options.delay = 100;
                }
                // Delay function that resets back the document the way ot was before
                this.setTimeout(function () {
                    // Remove image
                    document.body.removeChild(iframe);
                }, options.delay + 50 || 100);
                return [2 /*return*/, true];
            });
        });
    };
    /**
     * Finds a background color for the element. If element is transparent it goes
     * up the DOM hierarchy to find a parent element that does.
     *
     * @ignore Exclude from docs
     * @param element Element
     * @return Color code
     */
    Export.prototype.findBackgroundColor = function (element) {
        // Check if element has styles set
        var opacity = 1, currentColor = DOM_getComputedStyle(element, "background-color");
        // Check opacity
        if (currentColor.match(/[^,]*,[^,]*,[^,]*,[ ]?0/) || currentColor == "transparent") {
            opacity = 0;
        }
        if (opacity == 0) {
            var parent_2 = element.parentElement; // || <Element>element.parentNode;
            // Completely transparent. Look for a parent
            if (parent_2) {
                return this.findBackgroundColor(parent_2);
            }
            else {
                return Color_color("#fff");
            }
        }
        else {
            return Color_color(currentColor, opacity);
        }
    };
    Object.defineProperty(Export.prototype, "container", {
        /**
         * @return Reference
         */
        get: function () {
            return this.adapter.apply("container", {
                container: this._container
            }).container;
        },
        /**
         * A reference to a container to be used to place [[ExportMenu]] in.
         *
         * @param value Reference
         */
        set: function (value) {
            this._container = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "sprite", {
        /**
         * @return Sprite
         */
        get: function () {
            return this.adapter.apply("sprite", {
                sprite: this._sprite
            }).sprite;
        },
        /**
         * A reference to [[Sprite]] to export. Can be any Sprite, including some
         * internal elements.
         *
         * @param value Sprite
         */
        set: function (value) {
            this._sprite = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "extraSprites", {
        /**
         * @return Sprite
         */
        get: function () {
            return this.adapter.apply("extraSprites", {
                extraSprites: this._extraSprites
            }).extraSprites;
        },
        /**
         * An array of extra [[Sprite]] elements to include in export.
         *
         * It can be used to export any external elements, or even other charts.
         *
         * E.g.:
         *
         * ```TypeScript
         * chart.exporting.extraSprites.push(chart2);
         * ```
         * ```JavaScript
         * chart.exporting.extraSprites.push(chart2);
         * ```
         *
         * @since 4.2.0
         * @param value Sprite
         */
        set: function (value) {
            this._extraSprites = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "validateSprites", {
        /**
         * @return Sprite
         */
        get: function () {
            return this.adapter.apply("validateSprites", {
                validateSprites: this._validateSprites
            }).validateSprites;
        },
        /**
         * An array of [[Sprite]] elements that need to be valid before export
         * commences.
         *
         * If any of those elements is not completely ready when export is triggered,
         * the export will wait until they are (their `validated` event triggers)
         * before going through with the export opertaion.
         *
         * This is useful if you need to modify chart appearance for the export.
         *
         * E.g.:
         *
         * ```TypeScript
         * // Add watermark
         * let watermark = chart.createChild(am4core.Label);
         * watermark.text = "Copyright (C) 2019";
         * watermark.disabled = true;
         *
         * // Add watermark to validated sprites
         * chart.exporting.validateSprites.push(watermark);
         *
         * // Enable watermark on export
         * chart.exporting.events.on("exportstarted", function(ev) {
         *   watermark.disabled = false;
         * });
         *
         * // Disable watermark when export finishes
         * chart.exporting.events.on("exportfinished", function(ev) {
         *   watermark.disabled = true;
         * });
         * ```
         * ```JavaScript
         * // Add watermark
         * var watermark = chart.createChild(am4core.Label);
         * watermark.text = "Copyright (C) 2019";
         * watermark.disabled = true;
         *
         * // Add watermark to validated sprites
         * chart.exporting.validateSprites.push(watermark);
         *
         * // Enable watermark on export
         * chart.exporting.events.on("exportstarted", function(ev) {
         *   watermark.disabled = false;
         * });
         *
         * // Disable watermark when export finishes
         * chart.exporting.events.on("exportfinished", function(ev) {
         *   watermark.disabled = true;
         * });
         * ```
         *
         * @since 4.6.8
         * @param value Sprite
         */
        set: function (value) {
            this._validateSprites = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "data", {
        /**
         * @return Data
         */
        get: function () {
            return this.adapter.apply("data", {
                data: this._data
            }).data;
        },
        /**
         * Data to export.
         *
         * @param value Data
         */
        set: function (value) {
            this._data = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "dataFields", {
        /**
         * @return Field names `{ field: fieldName }`
         */
        get: function () {
            if (!this._dataFields) {
                this.generateDataFields();
            }
            return this.adapter.apply("dataFields", {
                dataFields: this._dataFields
            }).dataFields;
        },
        /**
         * Data fields in `{ field: fieldName }` format. Those are used for
         * exporting in data formats to name the columns.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/exporting/#Changing_order_and_names_of_columns} for examples and details
         * @param value Field names
         */
        set: function (value) {
            this._dataFields = value;
            this._dynamicDataFields = false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called after target chart's data updates.
     *
     * @ignore
     */
    Export.prototype.handleDataUpdated = function () {
        if (this._dynamicDataFields) {
            this._dataFields = undefined;
        }
    };
    Object.defineProperty(Export.prototype, "dateFormatter", {
        /**
         * @return A DateFormatter instance
         */
        get: function () {
            if (!this._dateFormatter) {
                this._dateFormatter = new DateFormatter_DateFormatter();
                this._dateFormatter.language = this.language;
            }
            return this.adapter.apply("dateFormatter", {
                dateFormatter: this._dateFormatter
            }).dateFormatter;
        },
        /**
         * A [[DateFormatter]] to use when formatting dates when exporting data.
         *
         * @param value DateFormatter instance
         */
        set: function (value) {
            this._dateFormatter = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "dateFormat", {
        /**
         * @return Date format
         */
        get: function () {
            return this.adapter.apply("dateFormat", {
                dateFormat: this._dateFormat
            }).dateFormat;
        },
        /**
         * A date format to use for exporting dates. Will use [[DateFormatter]]
         * format if not set.
         *
         * @param value Date format
         */
        set: function (value) {
            this._dateFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "dateFields", {
        /**
         * @return Date field list
         */
        get: function () {
            if (!this._dateFields) {
                this._dateFields = new List_List();
            }
            return this.adapter.apply("dateFields", {
                dateFields: this._dateFields
            }).dateFields;
        },
        /**
         * A list of fields that hold date values.
         *
         * @param value Date field list
         */
        set: function (value) {
            this._dateFields = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "numberFormatter", {
        /**
         * @return A NumberFormatter instance
         */
        get: function () {
            if (!this._numberFormatter) {
                this._numberFormatter = new NumberFormatter_NumberFormatter();
                this._numberFormatter.language = this.language;
            }
            return this.adapter.apply("numberFormatter", {
                numberFormatter: this._numberFormatter
            }).numberFormatter;
        },
        /**
         * A [[NumberFormatter]] to use when formatting dates when exporting data.
         *
         * @since 4.5.15
         * @param value NumberFormatter instance
         */
        set: function (value) {
            this._numberFormatter = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "numberFormat", {
        /**
         * @return Number format
         */
        get: function () {
            return this.adapter.apply("numberFormat", {
                numberFormat: this._numberFormat
            }).numberFormat;
        },
        /**
         * A number format to use for exporting dates. Will use [[NumberFormatter]]
         * format if not set.
         *
         * @since 4.5.15
         * @param value Number format
         */
        set: function (value) {
            this._numberFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "numberFields", {
        /**
         * @return Number field list
         */
        get: function () {
            if (!this._numberFields) {
                this._numberFields = new List_List();
            }
            return this.adapter.apply("numberFields", {
                numberFields: this._numberFields
            }).numberFields;
        },
        /**
         * A list of fields that hold number values.
         *
         * @since 4.5.15
         * @param value Number field list
         */
        set: function (value) {
            this._numberFields = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "durationFormatter", {
        /**
         * @return A DurationFormatter instance
         */
        get: function () {
            if (!this._durationFormatter) {
                this._durationFormatter = new DurationFormatter_DurationFormatter();
                this._durationFormatter.language = this.language;
            }
            return this.adapter.apply("durationFormatter", {
                durationFormatter: this._durationFormatter
            }).durationFormatter;
        },
        /**
         * A [[DurationFormatter]] to use when formatting duration values when
         * exporting data.
         *
         * @param value  DurationFormatter instance
         */
        set: function (value) {
            this._durationFormatter = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "durationFormat", {
        /**
         * @return Duration format
         */
        get: function () {
            return this.adapter.apply("durationFormat", {
                durationFormat: this._durationFormat
            }).durationFormat;
        },
        /**
         * A format to use when formatting values from `durationFields`.
         * Will use [[DurationFormatter]] format if not set.
         *
         * @param value Duration format
         */
        set: function (value) {
            this._durationFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "durationFields", {
        /**
         * @return Duration field list
         */
        get: function () {
            if (!this._durationFields) {
                this._durationFields = new List_List();
            }
            return this.adapter.apply("durationFields", {
                durationFields: this._durationFields
            }).durationFields;
        },
        /**
         * A list of fields that hold duration values.
         *
         * @param value Duration field list
         */
        set: function (value) {
            this._durationFields = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Generates data fields out of the first row of data.
     *
     * @ignore Exclude from docs
     */
    Export.prototype.generateDataFields = function () {
        var _this = this;
        this._dataFields = {};
        if (this.data.length) {
            each(this.data, function (row) {
                Object_each(row, function (key, value) {
                    if (!hasValue(_this._dataFields[key])) {
                        _this._dataFields[key] = _this.adapter.apply("dataFieldName", {
                            name: key,
                            field: key
                        }).name;
                    }
                });
            });
        }
    };
    /**
     * Cheks against `dateFields` property to determine if this field holds
     * dates.
     *
     * @ignore Exclude from docs
     * @param field   Field name
     * @param options Options
     * @return `true` if it's a date field
     */
    Export.prototype.isDateField = function (field) {
        return this.adapter.apply("isDateField", {
            isDateField: this.dateFields.contains(field),
            field: field
        }).isDateField;
    };
    /**
     * Cheks against `numberFields` property to determine if this field holds
     * numbers.
     *
     * @ignore Exclude from docs
     * @param field   Field name
     * @param options Options
     * @return `true` if it's a number field
     */
    Export.prototype.isNumberField = function (field) {
        return this.adapter.apply("isNumberField", {
            isNumberField: this.numberFields.contains(field),
            field: field
        }).isNumberField;
    };
    /**
     * Cheks against `durationFields` property to determine if this field holds
     * durations.
     *
     * @ignore Exclude from docs
     * @param field   Field name
     * @param options Options
     * @return `true` if it's a date field
     */
    Export.prototype.isDurationField = function (field) {
        return this.adapter.apply("isDurationField", {
            isDurationField: this.durationFields.contains(field),
            field: field
        }).isDurationField;
    };
    /**
     * Returns proper content type for the export type.
     *
     * @param type  Export format/type
     * @return Proper content type, i.e. "image/jpeg"
     */
    Export.prototype.getContentType = function (type) {
        var contentType = "";
        switch (type) {
            case "png":
            case "gif":
                contentType = "image/" + type;
                break;
            case "jpg":
                contentType = "image/jpeg";
                break;
            case "svg":
                contentType = "image/svg+xml";
                break;
            case "csv":
                contentType = "text/csv";
                break;
            case "json":
                contentType = "application/json";
                break;
            case "html":
                contentType = "text/html";
                break;
            case "pdf":
            case "pdfdata":
                contentType = "application/pdf";
                break;
            case "xlsx":
                contentType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
                break;
        }
        return this.adapter.apply("contentType", {
            contentType: contentType,
            type: type
        }).contentType;
    };
    Object.defineProperty(Export.prototype, "filePrefix", {
        /**
         * @return File prefix
         */
        get: function () {
            return this.adapter.apply("filePrefix", {
                filePrefix: this._filePrefix
            }).filePrefix;
        },
        /**
         * A file prefix to be used for all exported formats.
         *
         * Export will apply format-related extension to it. E.g. if this is set to
         * "myExport", the file name of the PNG exported image will be "myExport.png".
         *
         * @param value File prefix
         */
        set: function (value) {
            this._filePrefix = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "backgroundColor", {
        /**
         * @return Background color
         */
        get: function () {
            return this.adapter.apply("backgroundColor", {
                backgroundColor: this._backgroundColor
            }).backgroundColor;
        },
        /**
         * A background color to be used for exported images. If set, this will
         * override the automatically acquired background color.
         *
         * @param value Color
         */
        set: function (value) {
            this._backgroundColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "title", {
        /**
         * @return Title
         */
        get: function () {
            return this.adapter.apply("title", {
                title: this._title
            }).title;
        },
        /**
         * A title to be used when printing.
         *
         * @param value Title
         */
        set: function (value) {
            this._title = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Displays a preloader/exporting indicator.
     *
     * @ignore Exclude from docs
     * @todo Add ability to change text
     */
    Export.prototype.showPreloader = function () {
        var preloader = this.preloader;
        if (preloader) {
            preloader.progress = 0.5;
            preloader.label.text = "...";
        }
    };
    /**
     * Hides preloader/exporting indicator
     *
     * @ignore Exclude from docs
     */
    Export.prototype.hidePreloader = function () {
        var preloader = this.preloader;
        if (preloader) {
            preloader.progress = 1;
        }
    };
    Object.defineProperty(Export.prototype, "preloader", {
        /**
         * Returns a an instance of [[Preloader]] associated with the Sprite being
         * exported.
         *
         * @return Preloader
         */
        get: function () {
            return this._sprite && this._sprite.parent && this._sprite.parent.preloader ?
                this._sprite.parent.preloader :
                undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Displays a modal saying export is taking longer than expected.
     *
     * @ignore Exclude from docs
     */
    Export.prototype.showTimeout = function () {
        this.showModal(this.adapter.apply("timeoutMessage", {
            message: this.language.translate("Export operation took longer than expected. Something might have gone wrong.")
        }).message);
    };
    /**
     * Hides preloader/exporting indicator.
     *
     * @ignore Exclude from docs
     */
    Export.prototype.hideTimeout = function () {
        if (this._timeoutTimeout) {
            this.removeDispose(this._timeoutTimeout);
            this._timeoutTimeout = null;
        }
        this.hideModal();
    };
    Object.defineProperty(Export.prototype, "language", {
        /**
         * @return A [[Language]] instance to be used
         */
        get: function () {
            if (!this._language) {
                this._language = new Language_Language();
            }
            return this._language;
        },
        /**
         * A [[Language]] instance to be used for translations.
         *
         * @param value An instance of [[Language]]
         */
        set: function (value) {
            this._language = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "modal", {
        /**
         * Returns (and creates) [[Modal]].
         *
         * @ignore Exclude from docs
         * @return Modal instance
         */
        get: function () {
            if (!this._modal) {
                this._modal = new Modal_Modal();
                // Prefix with Sprite's class name
                this._modal.adapter.add("classPrefix", function (value) {
                    value = Options_options.classNamePrefix + value;
                    return value;
                });
            }
            return this._modal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows [[Modal]] with specific text.
     *
     * @ignore Exclude from docs
     * @param text Modal contents
     */
    Export.prototype.showModal = function (text, title) {
        // Hide previous modal and preloader
        this.hideModal();
        this.hidePreloader();
        // Create modal
        var modal = this.modal;
        modal.container = this.sprite.svgContainer.SVGContainer;
        modal.content = text;
        modal.readerTitle = title;
        modal.open();
    };
    /**
     * Hides modal window if one's currently open.
     *
     * @ignore Exclude from docs
     */
    Export.prototype.hideModal = function () {
        if (this._modal) {
            this.modal.close();
        }
    };
    /**
     * Loads canvg dynamic module.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @ignore Exclude from docs
     * @return Instance of canvg
     * @async
     */
    Export.prototype._canvg = function () {
        return __awaiter(this, void 0, void 0, function () {
            var canvg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, __webpack_require__.e(/* import() | canvg */ 1).then(__webpack_require__.bind(null, 338))];
                    case 1:
                        canvg = (_a.sent());
                        if (canvg.default != null) {
                            return [2 /*return*/, canvg.default];
                        }
                        else {
                            return [2 /*return*/, canvg];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Object.defineProperty(Export.prototype, "canvg", {
        /**
         * Returns canvg instance.
         *
         * @ignore Exclude from docs
         * @return Instance of canvg
         */
        get: function () {
            return this._canvg();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Export.prototype, "pdfmake", {
        /**
         * Returns pdfmake instance.
         *
         * @ignore Exclude from docs
         * @return Instance of pdfmake
         */
        get: function () {
            if (pdfmakePromise == null) {
                pdfmakePromise = _pdfmake();
            }
            return pdfmakePromise;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Loads xlsx dynamic module.
     *
     * This is an asynchronous function. Check the description of `getImage()`
     * for description and example usage.
     *
     * @ignore Exclude from docs
     * @return Instance of pdfmake
     * @async
     */
    Export.prototype._xlsx = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, Promise.all(/* import() | xlsx */[__webpack_require__.e(3), __webpack_require__.e(4)]).then(__webpack_require__.t.bind(null, 339, 7))];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    Object.defineProperty(Export.prototype, "xlsx", {
        /**
         * Returns xlsx instance.
         *
         * @ignore Exclude from docs
         * @return Instance of pdfmake
         */
        get: function () {
            return this._xlsx();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets options for a format.
     */
    Export.prototype.setFormatOptions = function (type, options) {
        this._formatOptions.setKey(type, options);
    };
    /**
     * Returns current options for a format.
     */
    Export.prototype.getFormatOptions = function (type) {
        return this._formatOptions.getKey(type);
    };
    Object.defineProperty(Export.prototype, "formatOptions", {
        /**
         * A [[Dictionary]] object containing format-specific options.
         *
         * May be used to change specific option for the format:
         *
         * ```TypeScript
         * chart.exporting.formatOptions.getKey("csv").disabled = true;
         * ```
         * ```JavaScript
         * chart.exporting.formatOptions.getKey("csv").disabled = true;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "exporting": {
         *     // ...
         *     "formatOptions": {
         *       "csv": {
         *         "disabled": true
         *       }
         *     }
         *   }
         * }
         * ```
         *
         * @since 4.9.12
         * @return  Options
         */
        get: function () {
            return this._formatOptions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disables interactivity on parent chart.
     */
    Export.prototype._disablePointers = function () {
        if (!hasValue(this._spriteInteractionsEnabled)) {
            this._spriteInteractionsEnabled = this.sprite.interactionsEnabled;
        }
        this.sprite.interactionsEnabled = false;
    };
    /**
     * Releases temporarily disabled pointers on parent chart.
     */
    Export.prototype._releasePointers = function () {
        if (hasValue(this._spriteInteractionsEnabled) && !this._exportRunning) {
            this.sprite.interactionsEnabled = this._spriteInteractionsEnabled;
        }
    };
    /**
     * Hides all elements that should not be included in the exported image.
     */
    Export.prototype.hideNonExportableSprites = function () {
        var _this = this;
        if (this._objectsAlreadyHidden) {
            return;
        }
        var svgContainer = this.sprite.svgContainer;
        if (svgContainer) {
            each(svgContainer.nonExportableSprites, function (item) {
                if (!item.isHidden && !item.isHiding && item.visible) {
                    _this._hiddenObjects.push(item);
                }
                item.hide(0);
            });
        }
        this._objectsAlreadyHidden = true;
    };
    /**
     * Respores elements that were hidden before export.
     */
    Export.prototype.restoreNonExportableSprites = function () {
        if (!this._objectsAlreadyHidden) {
            return;
        }
        each(this._hiddenObjects, function (item) {
            item.show(0);
        });
        this._hiddenObjects = [];
        this._objectsAlreadyHidden = false;
    };
    /**
     * Checks if there are elements that absolutely need to be validated before
     * export.
     *
     * If there are invalid elements, it will await for them to be validated.
     *
     * @return Promise
     */
    Export.prototype.awaitValidSprites = function () {
        return __awaiter(this, void 0, void 0, function () {
            var promises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = [];
                        if (this.validateSprites.length) {
                            each(this.validateSprites, function (sprite, index) {
                                if (sprite.invalid) {
                                    promises.push(new Promise(function (resolve, reject) {
                                        sprite.events.once("validated", function (ev) {
                                            resolve();
                                        });
                                    }));
                                }
                            });
                        }
                        if (!promises.length) return [3 /*break*/, 2];
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    Export.prototype.processConfig = function (config) {
        registry.registeredClasses["ExportMenu"] = ExportMenu_ExportMenu;
        if (config) {
            // Set up menu
            if (hasValue(config.menu) && !hasValue(config.menu.type)) {
                config.menu.type = "ExportMenu";
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    /**
     * XLINK namespace definition.
     *
     * @ignore Exclude from docs
     */
    Export.XLINK = "http://www.w3.org/1999/xlink";
    return Export;
}(Validatable_Validatable));

//# sourceMappingURL=Export.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/Sprite.js
/**
 * This is the main class that encapsulates every object on the chart.
 *
 * If it's an element that is to be displayed on the screen at some point, its
 * class must extend [[Sprite]] class.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


































/**
 * Defines list ofvisual properties
 */
var visualProperties = ["fill", "fillOpacity", "stroke", "strokeOpacity", "strokeWidth", "strokeDasharray", "strokeDashoffset", "strokeLinecap", "strokeLinejoin"]; // do not add opacity here, as it is used for showing/hiding
;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Sprite represents any displayable element.
 *
 * This is the main class that encapsulates every object on the chart.
 *
 * If it's an element that is to be displayed on the screen at some point, its
 * class must extend [[Sprite]] class.
 *
 * [[Sprite]] class represents the a hierarchical structure. Every object that
 * extends [[Sprite]] can have children, that would inherit their properties,
 * such as language, formatters, etc.
 *
 * @see {@link SpriteState}
 * @see {@link ISpriteEvents} for a list of available events
 * @see {@link ISpriteAdapters} for a list of available Adapters
 *
 * @todo Review child elements that need to go into `_disposers`
 * @important
 */
var Sprite_Sprite = /** @class */ (function (_super) {
    __extends(Sprite, _super);
    /**
     * Constructor:
     * * Creates initial node
     * * Sets default properties
     * * Creates required default states
     * * Inits accessibility
     */
    function Sprite() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Holds values for Sprite's properties.
         */
        _this.properties = {};
        /**
         * @ignore
         */
        _this._eventDispatcher = new SpriteEvents_SpriteEventDispatcher(_this);
        /**
         * @ignore Exclude from docs
         * @todo Description
         */
        _this._bindings = {};
        /**
         * Holds indicator if this Sprite is a "template" to be used for creating
         * other Sprites from and should not be treated as full-fledged element.
         *
         * @ignore Exclude from docs
         */
        _this._isTemplate = false;
        _this._isPath = false;
        /**
         * Holds indicator whether this sprite was already initialized.
         *
         * @ignore Exclude from docs
         */
        _this._inited = false;
        /**
         * Holds indicator whether this sprite was already initialized and ready.
         *
         * @ignore Exclude from docs
         */
        _this._ready = false;
        /**
         * If `sprite.hide()` is called and we have "hidden" state and
         * `transitionDuration > 0`, we set `isHiding` flag to `true` in order to
         * avoid restarting animations in case `hide()` method is called multiple
         * times.
         */
        _this.isHiding = false;
        /**
         * If `sprite.hide()` is called, we set isHidden to true when sprite is hidden.
         * This was added becaus hidden state might have visibility set to true and so
         * there would not be possible to find out if a sprite is technically hidden or not.
         */
        _this._isHidden = false;
        /**
         * This property indicates if Sprite is currently being revealed from hidden
         * state. This is used to prevent multiple calls to `sprite.show()` to
         * restart reveal animation. (if enabled)
         */
        _this.isShowing = false;
        /**
         * Indicates if this element is a standalone instance. A "standalone
         * instance" means this is a autonomous object which maintains its own
         * set of controls like Preloader, Export, etc.
         *
         * @ignore Exclude from docs
         */
        _this.isStandaloneInstance = false;
        /**
         * Indicates if togglable Sprite is currently active (toggled on).
         *
         * @ignore Exclude from docs
         */
        _this._isActive = false;
        /**
         * A Sprite element to use as a mask for this Sprite.
         *
         * @ignore Exclude from docs
         */
        _this._mask = new Disposer_MutableValueDisposer();
        /**
         * @ignore Exclude from docs
         * @todo Description
         */
        _this._positionPrecision = 3;
        /**
         * An instance of [[Language]].
         *
         * @ignore Exclude from docs
         */
        _this._language = new Disposer_MutableValueDisposer();
        /**
         * Holds [[Export]] object.
         *
         * @ignore Exclude from docs
         */
        _this._exporting = new Disposer_MutableValueDisposer();
        /**
         * Should this Sprite be included when exporting?
         */
        _this._exportable = true;
        /**
         * Defines bounding box (square) for this element.
         *
         * @ignore Exclude from docs
         */
        _this._bbox = { x: 0, y: 0, width: 0, height: 0 };
        /**
         * Indicates if this element is invalid and should be re-validated (redrawn).
         *
         * @ignore Exclude from docs
         */
        _this.invalid = false;
        /**
         * Indicates if this elements position is invalid and should be repositioned
         *
         * @ignore Exclude from docs
         */
        _this.positionInvalid = false;
        /**
         * A collection of key/value pairs that can be used to bind specific Sprite
         * properties to [[DataItem]].
         *
         * For example: `fill` property can be bound to `myCustomColor` field in
         * DataItem. The Sprite will automatically get the value for `fill` from its
         * DataItem.
         *
         * Can be set for each [[SpriteState]] individually to override default
         * bindings.
         *
         * @see {@link SpriteState}
         */
        _this.propertyFields = {};
        /**
         * Specifies if property changes on this object should be propagated to the
         * objects cloned from this object.
         *
         * This setting affects property changes *after* cloning, since at the moment
         * of cloning all of properties from source object are copied to the clone
         * anyway.
         *
         * @default false
         */
        _this.applyOnClones = false;
        // unrotated unscaled
        _this._measuredWidthSelf = 0;
        _this._measuredHeightSelf = 0;
        // read only, sprite extreme coordinates
        /**
         * @ignore
         */
        _this.maxLeft = 0;
        /**
         * @ignore
         */
        _this.maxRight = 0;
        /**
         * @ignore
         */
        _this.maxTop = 0;
        /**
         * @ignore
         */
        _this.maxBottom = 0;
        // not rotated and not scaled
        /**
         * @ignore
         */
        _this.maxLeftSelf = 0;
        /**
         * @ignore
         */
        _this.maxRightSelf = 0;
        /**
         * @ignore
         */
        _this.maxTopSelf = 0;
        /**
         * @ignore
         */
        _this.maxBottomSelf = 0;
        _this._isDragged = false;
        _this._isResized = false;
        /**
         * @deprecated Moved to [[SpriteProperties]]
         */
        _this._disabled = false;
        _this._internalDisabled = false;
        _this._updateDisabled = false;
        _this._internalDefaultsApplied = false;
        /**
         * Time in milliseconds after which rollout event happens when user rolls-out of the sprite. This helps to avoid flickering in some cases.
         */
        _this.rollOutDelay = 0;
        /**
         * This flag is set to `true` for the initial sprite you create and place
         * to the div so that we could clear all additional
         * sprites/containers when this sprite is disposed.
         *
         * @ignore
         */
        _this.isBaseSprite = false;
        /**
         * Indicates whether this sprite should be cloned when cloning its parent
         * container. We set this to `false` in those cases when a sprite is created
         * by the class, so that when cloning a duplicate sprite would not appear.
         */
        _this.shouldClone = true;
        /**
         * A read-only flag which indicates if a sprite has completed its initial
         * animation (if `showOnInit = true`).
         *
         * In case `showOnInit = false`, `appeared` is set to `true` on init.
         *
         * @readonly
         */
        _this.appeared = false;
        /**
         * [ex description]
         *
         * @todo Description
         * @ignore
         */
        _this.ex = 0;
        /**
         * [ey description]
         *
         * @todo Description
         * @ignore
         */
        _this.ey = 0;
        /**
         * Indicates if the sprite can be moved around when resizing it with two fingers (will only work if draggable = false)
         * @ignore
         */
        _this.dragWhileResize = false;
        /**
         *  @ignore
         */
        _this.measureFailed = false;
        /**
         * If this flag is set to true, calling show() will not reveal the sprite.
         *
         * @ignore
         */
        _this.preventShow = false;
        /**
         * When cloning a sprite, if the template has it's own tooltip assigned, this tooltip is also cloned by default.
         * This is not good for cpu and sometimes you might only need one single tooltip for all clones. Set this to false in order not to clone tooltip.
         */
        _this.cloneTooltip = true;
        _this.className = "Sprite";
        _this._disposers.push(_this._eventDispatcher);
        // Generate a unique ID
        used(_this.uid);
        // Create SVG group to hold everything in
        _this.group = _this.paper.addGroup("g");
        // Set defaults
        // it is better to set defauls like this in order to save invaliation calls and events
        _this.setPropertyValue("scale", 1);
        _this.setPropertyValue("rotation", 0);
        _this.setPropertyValue("align", "none");
        _this.setPropertyValue("valign", "none");
        _this.setPropertyValue("pixelPerfect", false);
        _this.setPropertyValue("visible", true);
        _this.setPropertyValue("tooltipPosition", "fixed");
        _this.setPropertyValue("verticalCenter", "none");
        _this.setPropertyValue("horizontalCenter", "none");
        _this.setPropertyValue("tooltipX", Percent_percent(50));
        _this.setPropertyValue("tooltipX", Percent_percent(50));
        _this.setPropertyValue("marginTop", 0);
        _this.setPropertyValue("marginBottom", 0);
        _this.setPropertyValue("marginLeft", 0);
        _this.setPropertyValue("marginRight", 0);
        _this.setPropertyValue("dx", 0);
        _this.setPropertyValue("dy", 0);
        _this.setPropertyValue("paddingTop", 0);
        _this.setPropertyValue("paddingBottom", 0);
        _this.setPropertyValue("paddingRight", 0);
        _this.setPropertyValue("paddingLeft", 0);
        _this.setPropertyValue("togglable", false);
        _this.setPropertyValue("hidden", false);
        _this.setPropertyValue("urlTarget", "_self");
        _this.setPropertyValue("alwaysShowTooltip", false);
        _this.setPropertyValue("showTooltipOn", "hover");
        _this._prevMeasuredWidth = 0;
        _this._prevMeasuredHeight = 0;
        _this._measuredWidth = 0;
        _this._measuredHeight = 0;
        _this._isMeasured = true;
        // Invalidate the Sprite so that renderer knows it needs to be drawn
        _this.invalidate();
        //this.states.create("default").properties.opacity = 1;
        // Apply the theme
        _this.applyTheme();
        //this._disposers.push(this._clickable);
        // Decorate adapter with events so that we can apply its settings whenever
        // it is modified
        // @todo Think what to do here. We can't just apply the adapter value to
        // property since not all of those are for properties. Commented out for
        // now.
        /*this.adapter.events.on("inserted", (ev: any) => {
            (<any>this)[ev.newValue.key] = (<any>this)[ev.newValue.key];
        });
        this.adapter.events.on("removed", (ev: any) => {
            (<any>this)[ev.newValue.key] = (<any>this)[ev.newValue.key];
        });*/
        // Add disposable dependencies to `_disposers` so they are automatically
        // disposed of when this object is disposed
        _this._disposers.push(_this.events);
        _this._disposers.push(_this.group);
        _this._disposers.push(_this._mask);
        _this._disposers.push(_this._language);
        _this._disposers.push(_this._exporting);
        //this._disposers.push(this._parent);
        //this._disposers.push(this._modal);
        _this._disposers.push(new Disposer(function () {
            Object_each(_this._bindings, function (key, value) {
                value.dispose();
            });
        }));
        _this.setPropertyValue("interactionsEnabled", true);
        return _this;
    }
    Object.defineProperty(Sprite.prototype, "events", {
        /**
         * Event dispatcher.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/event-listeners/} for more info about Events
         */
        get: function () {
            return this._eventDispatcher;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "adapter", {
        /**
         * Holds Adapter.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/adapters/} for more info about Adapters
         */
        get: function () {
            if (!this._adapterO) {
                this._adapterO = new Adapter_Adapter(this);
            }
            return this._adapterO;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * ==========================================================================
     * ELEMENT VALIDATION, INIT, AND DRAWING STUFF
     * ==========================================================================
     * @hidden
     */
    /**
     * Applies properties from all assigned themes.
     *
     * We do this here so that we can apply class names as well.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.applyTheme = function () {
        _super.prototype.applyTheme.call(this);
        if (Options_options.autoSetClassName) {
            this.setClassName();
        }
    };
    /**
     * Returns theme(s) used by this object either set explicitly on this
     * element, inherited from parent, or inherited from [[System]].
     *
     * @return An array of theme references
     */
    Sprite.prototype.getCurrentThemes = function () {
        var themes = this._themes;
        if (themes) {
            return themes;
        }
        else {
            var parent_1 = this._parent;
            if (parent_1) {
                return parent_1.getCurrentThemes();
            }
            else {
                return registry.themes;
            }
        }
    };
    /**
     * Called just before element's validation, this function allows setting
     * defaults.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.applyInternalDefaults = function () {
        // Nothing here, but extending classes might override this function
        // so that they can set their defaults
        this._internalDefaultsApplied = true;
    };
    /**
     * Invalidates element.
     *
     * Object will be redrawn during the next update cycle.
     *
     * Please note that in most cases elements will auto-invalidate when needed. If
     * everything works, DO NOT use this method. Use it only if some changes do
     * not take otherwise.
     */
    Sprite.prototype.invalidate = function () {
        if (this.disabled || this._isTemplate) {
            return;
        }
        // We no longer reset this on each invalidate, so that they are applied
        // only once, and do not overwrite user-defined settings
        //this._internalDefaultsApplied = false;
        if (!this.invalid) {
            this.invalid = true;
            registry.addToInvalidSprites(this);
            system.requestFrame();
        }
    };
    /**
     * Validates element:
     * * Triggers events
     * * Redraws the element
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.validate = function () {
        this.dispatchImmediately("beforevalidated");
        // prevents from drawing if topparent is 0x0
        /*
        let topParent = this.topParent;

        if (topParent) {
            if (!topParent.maxWidth || !topParent.maxHeight) {
                this._disposers.push(topParent.events.once("maxsizechanged", this.invalidate, this));
            }
        }*/
        // Set internal defaults
        if (!this._internalDefaultsApplied) {
            this.applyInternalDefaults();
        }
        this.beforeDraw();
        this.draw();
        this.invalid = false;
        registry.removeFromInvalidSprites(this);
        this.afterDraw();
    };
    /**
     * Invalidates element's position.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.invalidatePosition = function () {
        if (this.disabled || this._isTemplate) {
            return;
        }
        if (!this.positionInvalid) {
            this.positionInvalid = true;
            registry.addToInvalidPositions(this);
            system.requestFrame();
        }
    };
    /**
     * Transforms the element.
     *
     * @todo Description (review)
     * @ignore Exclude from docs
     */
    Sprite.prototype.validatePosition = function () {
        var pixelX = this.pixelX;
        var pixelY = this.pixelY;
        var dx = this.dx;
        var dy = this.dy;
        var x = pixelX + dx;
        var y = pixelY + dy;
        if (this._updateDisabled) {
            if (this._internalDisabled) {
                this.group.attr({ "display": "none" });
            }
            else {
                if (!this.disabled) {
                    this.removeSVGAttribute("display");
                }
            }
            this._updateDisabled = false;
        }
        var sizeChanged = this.measure();
        //if (!this.invalid) {
        var prevGroupTransform = this.group.transformString;
        this.group.moveTo({ x: x, y: y });
        this.group.rotation = this.rotation;
        if (this.nonScaling) {
            this.group.scale = this.scale / this.globalScale;
        }
        else {
            this.group.scale = this.scale;
        }
        if (prevGroupTransform != this.group.transformString || sizeChanged) {
            // not yet sure, this is to avoid many transforms=>container layout invalidation on initial buid
            if (prevGroupTransform == null) {
                this.dispatch("transformed");
            }
            else {
                this.dispatchImmediately("transformed");
            }
            // TODO clear existing positionchanged dispatches ?
            this.dispatch("positionchanged");
            if (this.showTooltipOn == "hit" || this.showTooltipOn == "always") {
                this.updateTooltipPosition();
            }
        }
        //}
        // it might happen that x and y changed again, so we only remove if they didn't
        if (pixelX + dx == x && pixelY + dy == y) {
            registry.removeFromInvalidPositions(this);
            this.positionInvalid = false;
        }
        var maskRectangle = this._maskRectangle;
        // todo: verify this
        if (maskRectangle) {
            this._clipElement.moveTo({ x: maskRectangle.x - pixelX, y: maskRectangle.y - pixelY });
        }
    };
    /**
     * A placeholder method that is called **before** element begins to be drawn.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.beforeDraw = function () {
    };
    /**
     * A placeholder method that draws the element.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.draw = function () {
    };
    /**
     * A placeholder method that is called **after** element finishes drawing
     * itself.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.afterDraw = function () {
        var e_1, _a;
        if (this.isMeasured || this.horizontalCenter !== "none" || this.verticalCenter !== "none") {
            this.measureElement();
        }
        //this.applyMask();
        if (!this._inited) {
            if (this._adapterO) {
                try {
                    // used to be applySVGAttrbutes here, this is more efficient
                    for (var _b = __values(this._adapterO.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var key = _c.value;
                        switch (key) {
                            case "mask":
                            case "fill":
                            case "opacity":
                            case "fillOpacity":
                            case "stroke":
                            case "strokeOpacity":
                            case "strokeWidth":
                            case "shapeRendering":
                            case "strokeDasharray":
                            case "strokeDashoffset":
                            case "strokeLinecap":
                            case "strokeLinejoin":
                            case "textDecoration":
                            case "fontSize":
                            case "fontFamily":
                            case "fontWeight":
                                //case "focusable":
                                //case "tabindex":
                                //case "role":
                                this[key] = this[key];
                                break;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            this.applyFilters();
            this.visible = this.visible;
            this.interactionsEnabled = this.getPropertyValue("interactionsEnabled"); // can't use .interactionsEnabled as it get's parent's
            this._inited = true;
            if (!this.showOnInit) {
                this.appeared = true;
            }
            if (this.hidden) {
                this.hide(0);
            }
            this.applyMask();
            this.dispatch("validated");
            this.dispatch("inited");
            this.dispatchReady();
        }
        else {
            this.dispatch("validated");
        }
        if (this.showTooltipOn == "always") {
            if (this.visible && !this.disabled && !this.__disabled) {
                this.showTooltip();
            }
            else {
                this.hideTooltip(0);
            }
        }
    };
    /**
     * Dispatches `"ready"` event. Sprite dispatches it right after `"inited"` event.
     *
     * @ignore
     */
    Sprite.prototype.dispatchReady = function () {
        if (!this.isReady()) {
            this._ready = true;
            this.dispatch("ready");
        }
    };
    /**
     * Triggers a re-initialization of this element.
     *
     * Will result in complete redrawing of the element.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.reinit = function () {
        this._inited = false;
        this.setState(this.defaultState);
        this.invalidate();
    };
    /**
     * Handles the situation where parent element is resized.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.handleGlobalScale = function () {
        this.dispatch("globalscalechanged");
        if (this.nonScalingStroke) {
            this.strokeWidth = this.strokeWidth;
        }
        if (this.nonScaling) {
            this.validatePosition();
        }
        this.updateFilterScale();
    };
    /**
     * Updates filter properties which might depend on scale
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.updateFilterScale = function () {
        var _this = this;
        Iterator_each(this.filters.iterator(), function (filter) {
            filter.scale = _this.globalScale;
        });
    };
    /**
     * Removes itself from system's invalid lists.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.removeFromInvalids = function () {
        registry.removeFromInvalidSprites(this);
        registry.removeFromInvalidPositions(this);
    };
    /**
     * Copies all parameters from another [[Sprite]].
     *
     * @param source Source Sprite
     */
    Sprite.prototype.copyFrom = function (source) {
        var _this = this;
        _super.prototype.copyFrom.call(this, source);
        this.isMeasured = source.isMeasured;
        this.states.copyFrom(source.states);
        if (source.filters.length > 0) {
            source.filters.each(function (filter) {
                _this.filters.push(filter.clone());
            });
        }
        if (source._adapterO) {
            this.adapter.copyFrom(source._adapterO);
        }
        //helps to avoid calling getter which creates instance
        if (source["_interaction"]) {
            this.interactions.copyFrom(source.interactions);
        }
        if (source["_plugins"]) {
            this.plugins.copyFrom(source.plugins);
        }
        this.configField = source.configField;
        this.applyOnClones = source.applyOnClones;
        // this.numberFormatter = source.numberFormatter; // todo: this creates loose number formatter and copies it to all clones. somehow we need to know if source had numberFormatter explicitly created and not just because a getter was called.
        //this.mask = source.mask; need to think about this, generally this causes a lot of problems
        this.disabled = source.disabled;
        this.virtualParent = source.virtualParent;
        this.exportable = source.exportable;
        //@todo: create tooltip if it's on source but not on this?
        //const tooltip = this._tooltip;
        //if (tooltip) {
        //	tooltip.copyFrom(source.tooltip);
        //}
        if (source._tooltip) {
            if (this._tooltip) {
                this._tooltip.copyFrom(source.tooltip);
            }
            else {
                if (source.cloneTooltip) {
                    this.tooltip = source.tooltip.clone();
                }
                else {
                    this._tooltip = source.tooltip;
                }
            }
        }
        //if ((<any>source)["_tooltip"] && !this._tooltip) {
        //	this._tooltip = (<any>source)["_tooltip"];
        //}
        this._showSystemTooltip = source.showSystemTooltip;
        Utils_copyProperties(source.propertyFields, this.propertyFields);
        Utils_copyProperties(source.properties, this);
        if (source.fillModifier) {
            this.fillModifier = source.fillModifier.clone();
        }
        if (source.strokeModifier) {
            this.strokeModifier = source.strokeModifier.clone();
        }
    };
    /**
     * Destroys this object and all related data.
     */
    Sprite.prototype.dispose = function () {
        if (!this.isDisposed()) {
            if (this.showTooltipOn == "always" && this.tooltip) {
                this.tooltip.hide();
            }
            this.dispatchImmediately("beforedisposed");
            if (this.isBaseSprite) {
                if (this.htmlContainer) {
                    while (this.htmlContainer.childNodes.length > 0) {
                        this.htmlContainer.removeChild(this.htmlContainer.firstChild);
                    }
                }
                this.isBaseSprite = false;
            }
            _super.prototype.dispose.call(this);
            // Clear adapters
            if (this._adapterO) {
                this._adapterO.clear();
            }
            if (this.applyOnClones) {
                if (this._clones) {
                    for (var i = this._clones.length - 1; i >= 0; i--) {
                        var clone = this._clones.getIndex(i);
                        clone.dispose();
                    }
                }
            }
            if (this._svgContainer) {
                this._svgContainer.dispose();
            }
            if (this._interactionDisposer) {
                this._interactionDisposer.dispose();
                this._interactionDisposer = undefined;
            }
            if (this._urlDisposer) {
                this._urlDisposer.dispose();
            }
            this.removeFromInvalids();
            if (this.element) {
                this.element.dispose();
            }
            if (this.group) {
                this.group.dispose();
            }
            if (this._numberFormatter) {
                this._numberFormatter.dispose();
            }
            if (this._focusFilter) {
                this._focusFilter.dispose();
            }
            var stroke = this.stroke;
            if (stroke && !(stroke instanceof Color_Color) && stroke.dispose) {
                if (this.clonedFrom && this.clonedFrom.stroke == stroke) {
                    // do nothing
                }
                else {
                    stroke.dispose();
                }
            }
            // TODO a bit hacky
            var fill = this.fill;
            if (fill && !(fill instanceof Color_Color) && fill.dispose) {
                if (this.clonedFrom && this.clonedFrom.fill == fill) {
                    // do nothing
                }
                else {
                    fill.dispose();
                }
            }
            // remove from map
            if (hasValue(this.id)) {
                this.map.removeKey(this.id);
            }
            this.parent = undefined;
            if (this._filters) {
                while (this._filters.length > 0) {
                    var filter = this._filters.getIndex(0);
                    filter.dispose();
                    this._filters.removeValue(filter);
                }
            }
            this._alwaysShowDisposers = undefined;
        }
    };
    Object.defineProperty(Sprite.prototype, "isTemplate", {
        /**
         * @ignore Exclude from docs
         * @return Is template?
         */
        get: function () {
            return this._isTemplate;
        },
        /**
         * Indicates if this element is a "template".
         *
         * Template Sprites act only as a holders for config for other "real"
         * elements to be cloned from.
         *
         * Templates are treated differently, as they are not validated, redrawn, or
         * otherwise are processed.
         *
         * @ignore Exclude from docs
         * @param value Is template?
         */
        set: function (value) {
            value = toBoolean(value);
            if (this._isTemplate != value) {
                this._isTemplate = value;
                if (this instanceof Container_Container) {
                    Iterator_each(this.children.iterator(), function (child) {
                        child.isTemplate = value;
                    });
                }
                if (value) {
                    this.parent = this._parent;
                    this.removeFromInvalids();
                }
                else {
                    this.invalidate();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "showSystemTooltip", {
        /**
         * @return Show system tooltip?
         */
        get: function () {
            if (!hasValue(this._showSystemTooltip)) {
                if (this.virtualParent) {
                    return this.virtualParent.showSystemTooltip;
                }
                else if (this._parent) {
                    return this._parent.showSystemTooltip;
                }
                else {
                    return false;
                }
            }
            return this._showSystemTooltip;
        },
        /**
         * Indicates whether the element should attempt to construct itself in a way
         * so that system tooltip is shown if its `readerTitle` is set.
         *
         * @param value Show system tooltip?
         */
        set: function (value) {
            value = toBoolean(value);
            if (this._showSystemTooltip != value) {
                this._showSystemTooltip = value;
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "topParent", {
        /**
         * ==========================================================================
         * HIERARCHY AND STRUCTURE RELATED STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * Sprites's top-level [[Container]].
         *
         * Please note that in most cases it won't be the chart element.
         *
         * To access base chart element, use `baseSprite` instead.
         *
         * @return Top-level ascendant
         */
        get: function () {
            if (this._topParent) {
                return this._topParent;
            }
            else {
                if (this._parent) {
                    return this._parent.topParent;
                }
            }
        },
        /**
         * @ignore
         * @param value {Container} top parent of a sprite
         */
        set: function (value) {
            this._topParent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "parent", {
        /**
         * @return Parent container
         */
        get: function () {
            return this._parent;
        },
        /**
         * Elements' parent [[Container]].
         *
         * @param parent  Parent container
         */
        set: function (parent) {
            if (this._isTemplate) {
                return;
            }
            // TODO is this needed ?
            used(this.paper);
            var oldParent = this._parent;
            if (oldParent != parent) {
                if (oldParent) {
                    oldParent.children.removeValue(this);
                }
                this._parent = parent;
                if (parent) {
                    this.topParent = parent.topParent;
                    if (parent.isTemplate) {
                        this.isTemplate = true;
                    }
                    this.baseId = parent.baseId;
                    parent.children.push(this);
                    // insert handler at Container invalidates +  invalidatesLayout + adds to group
                    if (this._tooltip && !this._tooltipContainer) {
                        this._tooltip.parent = parent.tooltipContainer;
                    }
                    if (!this._dataItem) {
                        this.dataItem = parent.dataItem;
                    }
                    this.handleAlwaysShowTooltip();
                    this.dispatchImmediately("parentset");
                }
                else {
                    this.topParent = undefined;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    Sprite.prototype.handleAlwaysShow = function () {
        this.showTooltip();
    };
    /**
     * @ignore
     */
    Sprite.prototype.handleAlwaysShowTooltip = function () {
        var sprite = this;
        var oldDisposers = this._alwaysShowDisposers;
        if (oldDisposers) {
            each(oldDisposers, function (oldDisposer) {
                oldDisposer.dispose();
            });
        }
        this._alwaysShowDisposers = [];
        if (this.showTooltipOn == "always") {
            while (sprite != undefined) {
                var disposer = sprite.events.on("visibilitychanged", this.handleAlwaysShow, this, false);
                this.addDisposer(disposer);
                this._alwaysShowDisposers.push(disposer);
                sprite = sprite.parent;
            }
        }
    };
    Object.defineProperty(Sprite.prototype, "virtualParent", {
        /**
         * @return Virtual parent
         */
        get: function () {
            return this._virtualParent;
        },
        /**
         * Element's "virtual" parent.
         *
         * This is required in ordere to maintain proper inheritance (like
         * formatters).
         *
         * Sometimes an element is a "logical" parent, even though it's not a direct
         * ascendant.
         *
         * Example: a bullet is not a child of the axis, but it would make sense
         * for it to inherit series' formatters.
         *
         * @ignore Exclude from docs
         * @param value  Virtual parent
         */
        set: function (value) {
            this._virtualParent = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Moves `<defs>` to correct place in DOM.
     *
     * Some elements are initially created in "ghost" container. When moving
     * those into proper place in DOM, their respective `<defs>` need to be moved
     * as well.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.appendDefs = function () {
        if (this.filterElement) {
            this.paper.appendDef(this.filterElement);
        }
        var fill = this.fill;
        if (fill && fill.element) {
            this.paper.appendDef(fill.element);
        }
        var stroke = this.stroke;
        if (stroke && stroke.element) {
            this.paper.appendDef(stroke.element);
        }
        if (this.fillModifier && this.fill instanceof Color_Color) {
            var fill_1 = this.fillModifier.modify(this.fill);
            if (fill_1 && fill_1.element) {
                this.paper.appendDef(fill_1.element);
            }
        }
        if (this.strokeModifier && this.stroke instanceof Color_Color) {
            var stroke_1 = this.strokeModifier.modify(this.stroke);
            if (stroke_1 && stroke_1.element) {
                this.paper.appendDef(stroke_1.element);
            }
        }
        if (this._clipPath) {
            this.paper.appendDef(this._clipPath);
        }
        if (this._exportable === false) {
            this.exportable = false;
        }
    };
    Object.defineProperty(Sprite.prototype, "map", {
        /**
         * Returns a [[Dictionary]] which maps object ids with their respective
         * objects.
         *
         * Can be used to retrieve any object by id, e.g.:
         *
         * ```TypeScript
         * console.log(mySprite.map.getKey("myid"));
         * ```
         * ```JavaScript
         * console.log(mySprite.map.getKey("myid"));
         * ```
         *
         * @return Map collection
         */
        get: function () {
            var top = this.topParent;
            if (top) {
                return top.map;
            }
            else if (!this._map) {
                this._map = new Dictionary_Dictionary();
            }
            return this._map;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "delayedMap", {
        /**
         * @ignore
         * @return Map collection
         */
        get: function () {
            var top = this.topParent;
            if (top) {
                return top.delayedMap;
            }
            else if (!this._delayedMap) {
                this._delayedMap = new Dictionary_Dictionary();
            }
            return this._delayedMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "id", {
        /**
         * @return ID
         */
        get: function () {
            return this._id;
        },
        /**
         * Element's user-defined ID.
         *
         * Will throw an Error if there already is an object with the same ID.
         *
         * Please note that above check will be performed withing the scope of the
         * current chart instance. It will not do checks across other chart instances
         * or in globally in DOM.
         *
         * Make sure the IDs are unique.
         *
         * @param value ID
         */
        set: function (value) {
            if (this._id != value) {
                this._id = value;
                if (this.map.hasKey(value)) {
                    throw Error("Duplicate id (" + value + ") used on multiple objects.");
                }
                else {
                    this.map.setKey(value, this);
                }
                if (Options_options.autoSetClassName) {
                    this.setClassName();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "dom", {
        /**
         * ==========================================================================
         * ELEMENT AND DOM TREE MANIPULATION AND MEASURING
         * ==========================================================================
         * @hidden
         */
        /**
         * Returns DOM element reference associated with this element.
         *
         * @readonly
         * @return DOM element
         */
        get: function () {
            return this.group.node;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "paper", {
        /**
         * @ignore Exclude from docs
         * @return Paper
         */
        get: function () {
            if (this._paper) {
                return this._paper;
            }
            else {
                var parent_2 = this._parent;
                if (parent_2) {
                    return parent_2.paper;
                }
            }
            return getGhostPaper();
        },
        /**
         * A [[Paper]] instance to place elements on.
         *
         * If there's no Paper set for this element, it goes up the ascendant tree
         * until it finds one.
         *
         * This method is used by important `addChild()` method, so it's essential
         * to have a [[Paper]] instance.
         *
         * If this element has a separate `htmlContainer` set, it will have a
         * [[Paper]] instance itself.
         *
         * @ignore Exclude from docs
         * @param paper  Paper
         */
        set: function (paper) {
            this.setPaper(paper);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets [[Paper]] instance to use to draw elements.
     * @ignore
     * @param paper Paper
     * @return true if paper was changed, false, if it's the same
     */
    Sprite.prototype.setPaper = function (paper) {
        var oldPaper = this._paper;
        if (oldPaper != paper) {
            this._paper = paper;
            this.appendDefs();
            return true;
        }
        return false;
    };
    Object.defineProperty(Sprite.prototype, "htmlContainer", {
        /**
         * @return HTML element
         */
        get: function () {
            if (this._htmlContainer) {
                return this._htmlContainer;
            }
            else {
                var parent_3 = this._parent;
                if (parent_3) {
                    return parent_3.htmlContainer;
                }
            }
        },
        /**
         * An HTML element to be used when placing wrapper element (`<div>`)
         * for the whole chart.
         *
         * This is the same for **all** elements within the same chart.
         *
         * @param htmlContainer HTML element
         */
        set: function (htmlContainer) {
            this._htmlContainer = htmlContainer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "titleElement", {
        /**
         * Creates (if not yet created) and returns element's `<title>` element.
         *
         * @ignore Exclude from docs
         * @return Title element
         */
        get: function () {
            if (!this._titleElement) {
                this._titleElement = this.paper.add("title");
                this.group.add(this._titleElement);
            }
            return this._titleElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "descriptionElement", {
        /**
         * Creates (if not yet created) and returns element's `<desc>` element.
         *
         * @ignore Exclude from docs
         * @return Desc element
         */
        get: function () {
            if (!this._descriptionElement) {
                this._descriptionElement = this.paper.add("desc");
                this.group.add(this._descriptionElement);
            }
            return this._descriptionElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "filters", {
        /**
         * Returns list of SVG filters (effects) applied to element. If the filter
         * list is not yet initilized, creates and returns an empty one.
         * Note, not all filters combine well with one another. We recommend using one filter per sprite.
         *
         * @return List of filters
         */
        get: function () {
            if (!this._filters) {
                this._filters = new List_List();
                // TODO only add certain events ?
                this._disposers.push(this._filters.events.onAll(this.applyFilters, this));
                this._disposers.push(new List_ListDisposer(this._filters));
            }
            return this._filters;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets required SVG attributes. Must be called every time an element is
     * redrawn so that attributes are (re)applied.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.setSVGAttributes = function () {
        this.fill = this.fill;
        this.opacity = this.opacity;
        this.fillOpacity = this.fillOpacity;
        this.stroke = this.stroke;
        this.strokeOpacity = this.strokeOpacity;
        this.shapeRendering = this.shapeRendering;
        this.strokeDasharray = this.strokeDasharray;
        this.strokeDashoffset = this.strokeDashoffset;
        this.strokeLinecap = this.strokeLinecap;
        this.strokeLinejoin = this.strokeLinejoin;
        this.focusable = this.focusable;
        this.tabindex = this.tabindex;
        this.role = this.role;
    };
    /**
     * Sets an attribute directly on an SVG element.
     *
     * @ignore Exclude from docs
     * @param attribute Attribute object
     */
    Sprite.prototype.setSVGAttribute = function (attribute) {
        this.group.attr(attribute);
    };
    /**
     * Removes an attribute directly from SVG element.
     *
     * @param attribute Attribute key to remove
     */
    Sprite.prototype.removeSVGAttribute = function (attribute) {
        this.group.removeAttr(attribute);
    };
    /**
     * Sets `class` attribute of the elements SVG node.
     *
     * Uses `am4core.options.classNamePrefix`.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.setClassName = function () {
        var className = this.className;
        var classNamePrefix = Options_options.classNamePrefix;
        if (this.element) {
            this.element.addClass(classNamePrefix + className);
        }
        this.group.addClass(classNamePrefix + className + "-group");
        if (hasValue(this.id)) {
            this.group.addClass(classNamePrefix + this.id);
        }
        if (this.userClassName) {
            this.group.addClass(this.userClassName);
        }
    };
    /**
     * Adds an `id` attribute the the element and returns the id.
     *
     * @ignore Exclude from docs
     * @return Element's ID
     */
    Sprite.prototype.uidAttr = function () {
        this.setSVGAttribute({ "id": this.uid });
        return this.uid;
    };
    /**
     * [updateClipPath description]
     *
     * @todo Description
     */
    Sprite.prototype.updateClipPath = function () {
        var element = this._clipElement;
        if (element) {
            element.moveTo({ x: this.mask.pixelX, y: this.mask.pixelY });
        }
    };
    /**
     * @ignore
     */
    Sprite.prototype.createClipPath = function () {
        if (!this._clipPath) {
            this._clipPath = this.paper.addGroup("clipPath");
            this.paper.appendDef(this._clipPath);
            this._disposers.push(this._clipPath);
            var id = registry.getUniqueId();
            this._clipPath.attr({ "id": id });
            this.group.attr({ "clip-path": "url(\"" + getBaseURI() + id + "\")" });
        }
    };
    /**
     * Applies the mask Sprite.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.applyMask = function () {
        var mask = this.mask;
        if (this._clipPath && mask) {
            // Container
            if (mask instanceof Container_Container) {
                this._clipElement.attr({ "width": Math_max(0, mask.pixelWidth), "height": Math_max(0, mask.pixelHeight) });
                var point = spritePointToSprite({ x: mask.pixelX, y: mask.pixelY }, mask.parent, this);
                this._clipPath.x = point.x;
                this._clipPath.y = point.y;
            }
            // Sprite
            else {
                if (mask.element && mask.element != this._clipElement) {
                    this._clipElement = mask.element;
                    this._clipPath.add(this._clipElement);
                }
                this._clipPath.scale = mask.scale;
                this._clipPath.x = mask.pixelX;
                this._clipPath.y = mask.pixelY;
                this._clipPath.rotation = mask.rotation;
            }
        }
    };
    /**
     * Applies filters to the element.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.applyFilters = function () {
        var _this = this;
        // we create a separate filter for each sprite as otherwise it would be impossible to animate filter.
        // svg doesn't support multiple filters applied to one element, so we put all the primitives to one filterElement of a sprite.
        if (this._filters && this._filters.length > 0) {
            var width_1 = 100;
            var height_1 = 100;
            if (!this.filterElement) {
                this.filterElement = this.paper.addGroup("filter");
                this._disposers.push(this.filterElement);
            }
            else {
                this.filterElement.removeChildNodes();
            }
            this.paper.appendDef(this.filterElement);
            var id = "filter-" + this.uid;
            this.filterElement.attr({ "id": id });
            Iterator_each(this.filters.iterator(), function (filter) {
                filter.sprite = _this;
                filter.paper = _this.paper;
                _this.filterElement.attr({ filterUnits: filter.filterUnits });
                filter.appendPrimitives(_this.filterElement);
                if (filter.width > width_1) {
                    width_1 = filter.width;
                }
                if (filter.height > height_1) {
                    height_1 = filter.height;
                }
                filter.scale = _this.globalScale;
            });
            var w = width_1 + "%";
            var h = height_1 + "%";
            /* temporarily removed as it is breaking tooltips on Safari @todo come back to this
            if (this._measuredHeight <= 1) {
                h = height + "";
            }

            if (this._measuredWidth <= 1) {
                h = width + "";
            }*/
            this.filterElement.attr({ "width": w, "height": h, "x": -(width_1 - 100) / 2 + "%", "y": -(height_1 - 100) / 2 + "%" });
            this.group.attr({ "filter": "url(\"" + getBaseURI() + id + "\")" });
        }
        else if (this.filterElement) {
            this.group.removeAttr("filter");
            this.filterElement.removeChildNodes();
        }
    };
    /**
     * [removeClipPath description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    Sprite.prototype.removeClipPath = function () {
        if (this._clipPath) {
            //this._clipPath.dispose();
            this.removeDispose(this._clipPath);
            this._clipPath = undefined;
        }
    };
    /**
     * [setElement description]
     *
     * @ignore
     * @todo Description
     * @param element [description]
     */
    Sprite.prototype.setElement = function (element) {
        this.element = element;
        this.setSVGAttributes();
        this.applyAccessibility();
    };
    Object.defineProperty(Sprite.prototype, "element", {
        /**
         * @return Element
         */
        get: function () {
            return this._element;
        },
        /**
         * The main element for this Sprite, usually an SVG `<g>`.
         *
         * All other sub-elements are created in it.
         *
         * @param element  Element
         */
        set: function (element) {
            // Destroy previous element if there was one before
            this.removeElement();
            // Set new element
            this._element = element;
            // Add element to group
            // Since we are adding Element to group, which is already in the
            // `.disposers` it will be removed automatically when Sprite is disposed
            // of
            this.group.add(element);
            if (element.node instanceof SVGPathElement) {
                this._isPath = true;
            }
            // This is needed if someone is setting element not in draw method but
            // from outside
            if (!this.invalid) {
                this.validate();
            }
            if (Options_options.autoSetClassName) {
                this.setClassName();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "svgContainer", {
        /**
         * HTML container (`<div>`) which is used to place chart's `<svg>` element
         * in.
         *
         * @return Container for chart elements
         */
        get: function () {
            if (this._svgContainer) {
                return this._svgContainer;
            }
            else if (this._parent) {
                return this._parent.svgContainer;
            }
        },
        /**
         * Sets HTML container to add SVG and other chart elements to.
         *
         * @param svgContainer Container for chart elements
         */
        set: function (svgContainer) {
            this._svgContainer = svgContainer;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Measures main element.
     *
     * Saves measurements into private `_bbox` property.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.measureElement = function () {
        if (this.element) {
            if (this.definedBBox) {
                this._bbox = this.definedBBox;
            }
            else {
                var svgBBox = this.element.getBBox();
                this._bbox = { x: svgBBox.x, y: svgBBox.y, width: svgBBox.width, height: svgBBox.height };
            }
        }
    };
    /**
     * Positions element according its center settings.
     *
     * @todo Description (review)
     * @ignore Exclude from docs
     */
    Sprite.prototype.updateCenter = function () {
        if (this.element) {
            var prevElementTransform = this.element.transformString;
            var bbox = this.bbox;
            var ex = 0;
            var ey = 0;
            var elementX = bbox.x;
            var elementY = bbox.y;
            var elementWidth = bbox.width;
            var elementHeigth = bbox.height;
            var pixelPaddingLeft = this.pixelPaddingLeft;
            var pixelPaddingRight = this.pixelPaddingRight;
            var pixelPaddingTop = this.pixelPaddingTop;
            var pixelPaddingBottom = this.pixelPaddingBottom;
            // add padding to the measured size
            var measuredWidth = Math_max(elementWidth + pixelPaddingLeft + pixelPaddingRight, this.pixelWidth);
            var measuredHeight = Math_max(elementHeigth + pixelPaddingTop + pixelPaddingBottom, this.pixelHeight);
            // extremes
            var left = bbox.x;
            var right = bbox.x + measuredWidth;
            var top_1 = bbox.y;
            var bottom = bbox.y + measuredHeight;
            var horizontalCenter = this.horizontalCenter;
            var verticalCenter = this.verticalCenter;
            switch (horizontalCenter) {
                case "none":
                    ex = elementX + pixelPaddingLeft;
                    break;
                case "left":
                    ex = pixelPaddingLeft;
                    break;
                case "middle":
                    ex = pixelPaddingLeft - (elementWidth + pixelPaddingRight + pixelPaddingLeft) / 2;
                    break;
                case "right":
                    ex = -pixelPaddingRight - elementWidth;
                    break;
            }
            switch (verticalCenter) {
                case "none":
                    ey = elementY + pixelPaddingTop;
                    break;
                case "top":
                    ey = pixelPaddingTop;
                    break;
                case "middle":
                    ey = pixelPaddingTop - (elementHeigth + pixelPaddingBottom + pixelPaddingTop) / 2;
                    break;
                case "bottom":
                    ey = -pixelPaddingBottom - elementHeigth;
                    break;
            }
            this._measuredHeight = measuredHeight;
            this._measuredWidth = measuredWidth;
            var x = Math_round(ex - elementX, this._positionPrecision, true);
            var y = Math_round(ey - elementY, this._positionPrecision, true);
            this.ex = x - pixelPaddingLeft;
            this.ey = y - pixelPaddingTop;
            this.maxLeft = left + x - pixelPaddingLeft;
            this.maxRight = right + x - pixelPaddingLeft;
            this.maxTop = top_1 + y - pixelPaddingTop;
            this.maxBottom = bottom + y - pixelPaddingTop;
            if (this.pixelPerfect) {
                x -= 0.5;
                y -= 0.5;
            }
            this.element.moveTo({ x: x, y: y });
            if (prevElementTransform != this.element.transformString) {
                this.dispatchImmediately("transformed");
            }
        }
    };
    /**
     * Measures the whole element.
     *
     * Returns `true` if the size has changed from the last measurement.
     *
     * @ignore Exclude from docs
     * @return Did the size changed from the last measurement?
     */
    Sprite.prototype.measure = function () {
        this.updateCenter();
        var measuredWidth = this._measuredWidth;
        var measuredHeight = this._measuredHeight;
        // extremes
        var left = this.maxLeft;
        var right = this.maxRight;
        var top = this.maxTop;
        var bottom = this.maxBottom;
        // non-parent wise size
        this._measuredWidthSelf = measuredWidth;
        this._measuredHeightSelf = measuredHeight;
        var positionPrecision = this._positionPrecision;
        this.maxLeftSelf = this.maxLeft;
        this.maxRightSelf = this.maxRight;
        this.maxTopSelf = this.maxTop;
        this.maxBottomSelf = this.maxBottom;
        // if a sprite is rotated or scaled, calculate measured size after transformations
        if (this.rotation !== 0 || this.scale !== 1) {
            // not good to handleGlobalScale here.
            if (this.nonScalingStroke) {
                this.strokeWidth = this.strokeWidth;
            }
            var svg = this.paper.svg;
            var matrix = svg.createSVGMatrix();
            var rotation = this.rotation;
            matrix.a = Math_cos(rotation) * this.scale;
            matrix.c = -Math_sin(rotation) * this.scale;
            matrix.e = 0;
            matrix.b = Math_sin(rotation) * this.scale;
            matrix.d = Math_cos(rotation) * this.scale;
            matrix.f = 0;
            var p1 = svg.createSVGPoint();
            p1.x = left;
            p1.y = top;
            var p2 = svg.createSVGPoint();
            p2.x = right;
            p2.y = top;
            var p3 = svg.createSVGPoint();
            p3.x = right;
            p3.y = bottom;
            var p4 = svg.createSVGPoint();
            p4.x = left;
            p4.y = bottom;
            var pt1 = p1.matrixTransform(matrix);
            var pt2 = p2.matrixTransform(matrix);
            var pt3 = p3.matrixTransform(matrix);
            var pt4 = p4.matrixTransform(matrix);
            left = Math.min(pt1.x, pt2.x, pt3.x, pt4.x);
            right = Math.max(pt1.x, pt2.x, pt3.x, pt4.x);
            top = Math.min(pt1.y, pt2.y, pt3.y, pt4.y);
            bottom = Math.max(pt1.y, pt2.y, pt3.y, pt4.y);
            measuredWidth = right - left;
            measuredHeight = bottom - top;
            this.maxLeft = Math_round(left, positionPrecision, true);
            this.maxRight = Math_round(right, positionPrecision, true);
            this.maxTop = Math_round(top, positionPrecision, true);
            this.maxBottom = Math_round(bottom, positionPrecision, true);
        }
        this._measuredWidth = Math_round(measuredWidth, positionPrecision, true);
        this._measuredHeight = Math_round(measuredHeight, positionPrecision, true);
        // dispatch event
        if (this._measuredWidth != this._prevMeasuredWidth || this._measuredHeight != this._prevMeasuredHeight) {
            this._prevMeasuredHeight = this._measuredHeight;
            this._prevMeasuredWidth = this._measuredWidth;
            // TODO clear existing sizechanged dispatches ?
            this.dispatch("sizechanged");
            if ((this.isHover || this.showTooltipOn == "hit" || this.showTooltipOn == "always") && this.tooltip && this.tooltip.visible && (hasValue(this.tooltipText) || hasValue(this.tooltipHTML))) {
                this.updateTooltipPosition();
            }
            return true;
        }
        return false;
    };
    /**
     * Insert this element before sibling element.
     *
     * @param sprite  Target element
     * @return This element
     */
    Sprite.prototype.insertBefore = function (sprite) {
        var parent = this._parent;
        if (parent) {
            var index = parent.children.indexOf(sprite);
            if (index !== -1) {
                parent.children.moveValue(this, index);
                parent.sortChildren();
            }
        }
        return this;
    };
    /**
     * Insert this element after sibling element.
     *
     * @param sprite  Target element
     * @return This element
     */
    Sprite.prototype.insertAfter = function (sprite) {
        var parent = this._parent;
        if (parent) {
            var index = parent.children.indexOf(sprite);
            if (index !== -1) {
                parent.children.moveValue(this, index + 1);
                parent.sortChildren();
            }
        }
        return this;
    };
    /**
     * Removes the main SVG element.
     *
     * This does not destroy the whole Sprite element. To do that use
     * `dispose()` instead.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.removeElement = function () {
        // remove visual element
        if (this._element) {
            this.removeDispose(this._element);
            this._element = undefined;
        }
    };
    /**
     * Returns relative (percent) value of the X coordindate within this element.
     *
     * A relative value is a hundredth of a percent. So 100% would result in a 1
     * as relative value.
     *
     * @param value  Absolute or relative X coordinate
     * @return Relative value
     */
    Sprite.prototype.getRelativeX = function (value) {
        if (value instanceof Percent) {
            return value.value;
        }
        else if (this._parent) {
            return value / this._parent.innerWidth;
        }
        return 0;
    };
    /**
     * Returns relative (percent) value of the Y coordindate within this element.
     *
     * A relative value is a hundredth of a percent. So 100% would result in a 1
     * as relative value.
     *
     * @param value  Absolute or relative Y coordinate
     * @return Relative value
     */
    Sprite.prototype.getRelativeY = function (value) {
        if (value instanceof Percent) {
            return value.value;
        }
        else if (this._parent) {
            return value / this._parent.innerHeight;
        }
        return 0;
    };
    /**
     * Returns an X coordinate in pixel within the element.
     *
     * If number is passed in as parameter, the same number will be returned
     * back.
     *
     * If [[Percent]] is passed in, it will be recalculated to pixels.
     *
     * @param value  Absolute or relative X coordinate
     * @return X coordinate in pixels
     */
    Sprite.prototype.getPixelX = function (value) {
        // we don't use $utils.valueToRelative as this would mean that we should access parent.innerWidth
        // all the time and this would result chain of the same actions and will slow down the system a lot
        var pixel = 0;
        if (isNumber(value)) {
            pixel = value;
        }
        else if (value instanceof Percent) {
            var relative = value.value;
            if (this._parent) {
                pixel = Math_round(this._parent.innerWidth * relative, this._positionPrecision, true);
            }
        }
        return pixel;
    };
    /**
     * Returns an Y coordinate in pixel within the element.
     *
     * If number is passed in as parameter, the same number will be returned
     * back.
     *
     * If [[Percent]] is passed in, it will be recalculated to pixels.
     *
     * @param value  Absolute or relative Y coordinate
     * @return Y coordinate in pixels
     */
    Sprite.prototype.getPixelY = function (value) {
        // we don't use $utils.valueToRelative as this would mean that we should access parent.innerWidth
        // all the time and this would result chain of the same actions and will slow down the system a lot
        var pixel = 0;
        if (isNumber(value)) {
            pixel = value;
        }
        else if (value instanceof Percent) {
            var relative = value.value;
            if (this._parent) {
                pixel = Math_round(this._parent.innerHeight * relative, this._positionPrecision, true);
            }
        }
        return pixel;
    };
    /**
     * Moves the element to a specified coordinates.
     *
     * Using this method is preferred method of moving element, as it saves some
     * CPU processing power over setting `x` and `y` properties separately.
     *
     * The method respects element's center settings. The element will be
     * positioned so that `point` coordinates come in whatever "center" of the
     * element is, as set in `horizontalCenter` and `verticalCenter`.
     *
     * Besides moving the element, you can also at the same time scale and
     * rotate the element.
     *
     * @param point     New coordinates
     * @param rotation  New rotation
     * @param scale     New Scale
     */
    Sprite.prototype.moveTo = function (point, rotation, scale, isDragged) {
        if (this.isDragged && !isDragged) {
            return;
        }
        if (point) {
            if (isNumber(point.x)) {
                this.setPropertyValue("x", Math_round(point.x, this._positionPrecision, true));
            }
            if (isNumber(point.y)) {
                this.setPropertyValue("y", Math_round(point.y, this._positionPrecision, true));
            }
        }
        if (isNumber(rotation)) {
            this.rotation = rotation;
        }
        if (isNumber(scale)) {
            this.scale = scale;
        }
        // must leave this
        this.invalidatePosition();
    };
    Object.defineProperty(Sprite.prototype, "mask", {
        /**
         * Returns [[Sprite]] element currently used as mask for this element.
         *
         * @ignore Exclude from docs
         * @return A [[Sprite]] to use as mask
         */
        get: function () {
            if (!this._adapterO) {
                return this._mask.get();
            }
            else {
                return this._adapterO.apply("mask", this._mask.get());
            }
        },
        /**
         * Sets another [[Sprite]] element as this elements mask.
         *
         * @ignore Exclude from docs
         * @param mask A [[Sprite]] to use as mask
         */
        set: function (mask) {
            var _this = this;
            if (this._mask.get() !== mask) {
                // this is good
                if (mask) {
                    this.createClipPath();
                    if (!(mask instanceof Container_Container)) {
                        mask.isMeasured = false;
                        if (mask.element) {
                            this._clipElement = mask.element;
                        }
                    }
                    else {
                        this._clipElement = this.paper.add("rect");
                    }
                    if (this._clipElement) {
                        this._clipPath.add(this._clipElement);
                    }
                    this._mask.set(mask, new Disposer_MultiDisposer([
                        //mask.addEventListener(SpriteEvent.TRANSFORMED, this.applyMask, false, this);
                        mask.events.on("maxsizechanged", function () { if (_this.inited) {
                            _this.applyMask();
                        } }, undefined, false),
                        mask.events.on("validated", this.applyMask, this, false),
                        mask.events.on("positionchanged", this.applyMask, this, false)
                    ]));
                    this.applyMask();
                }
                else {
                    this._mask.reset();
                    this.group.removeAttr("clip-path");
                    this.removeClipPath();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "maskRectangle", {
        /**
         * @ignore Exclude from docs
         * @return Mask Rectangle
         */
        get: function () {
            return this._maskRectangle;
        },
        // you can set IRectangle as a mask instead o a sprite. Note, the changes of the object won't be monitored
        /**
         * Instead of creating a [[Sprite]] for mask, you can just use a
         * [[Rectangle]] by setting this accessor.
         *
         * Please note that the element will not monitor any changes to the mask
         * rectangle.
         *
         * @ignore Exclude from docs
         * @param rect Mask Rectangle
         */
        set: function (rect) {
            if (rect) {
                this.createClipPath();
                if (!this._clipElement) {
                    this._clipElement = this.paper.add("rect");
                    this._clipPath.add(this._clipElement);
                }
                this._clipElement.attr({ "width": rect.width, "height": rect.height });
            }
            else {
                this.removeClipPath();
                this._clipElement = undefined;
            }
            this._maskRectangle = rect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "isMeasured", {
        /**
         * @ignore Exclude from docs
         * @return Was element already measured?
         */
        get: function () {
            return this._isMeasured;
        },
        /**
         * Indicates if this element was already measured.
         *
         * @ignore Exclude from docs
         * @param value Was element already measured?
         */
        set: function (value) {
            value = toBoolean(value);
            if (!value) {
                this._measuredWidth = 0;
                this._measuredHeight = 0;
                //this._pixelHeight = 0;
                //this._pixelWidth = 0;
            }
            if (this._isMeasured != value) {
                this._isMeasured = value;
                this.invalidatePosition();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if the this element has any of its parts overlapping with another
     * element.
     *
     * @todo Description (review)
     * @param sprite  Second element to test again
     * @return Overlapping?
     */
    Sprite.prototype.hitTest = function (sprite) {
        // validate, otherwise we will not know measuredWidth and measuredHeight
        if (this.invalid) {
            this.validate();
        }
        if (sprite.invalid) {
            sprite.validate();
        }
        var ax1 = this.pixelX;
        var ay1 = this.pixelY;
        var ax2 = ax1 + this.measuredWidth;
        var ay2 = ay1 + this.measuredHeight;
        var bx1 = sprite.pixelX;
        var by1 = sprite.pixelY;
        var bx2 = bx1 + sprite.measuredWidth;
        var by2 = by1 + sprite.measuredHeight;
        return !(bx1 > ax2 || bx2 < ax1 || by1 > ay2 || by2 < ay1);
    };
    Object.defineProperty(Sprite.prototype, "inited", {
        /**
         * ==========================================================================
         * STATE-RELATED
         * ==========================================================================
         * @hidden
         */
        /**
         * Returns `true` if Sprite has already finished initializing.
         *
         * @return Initialized?
         */
        get: function () {
            return this._inited;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns `true` if Sprite has already finished initializing and is ready.
     *
     * If this object is a [[Container]] it will wait for all of its children
     * are ready before becoming ready itself and firing a `"ready"` event.
     *
     * @return is ready?
     */
    Sprite.prototype.isReady = function () {
        return this._ready;
    };
    Object.defineProperty(Sprite.prototype, "states", {
        /**
         * Returns a collection of element's available [[SpriteState]] entries.
         *
         * @see {@link SpriteState}
         * @return States
         */
        get: function () {
            if (!this._states) {
                var state = new SpriteState_SpriteState();
                // works
                this._states = new Dictionary_DictionaryTemplate(state);
                // TODO what about removeKey ?
                this._disposers.push(this._states.events.on("insertKey", this.processState, this, false));
                this._disposers.push(this._states.events.on("setKey", this.processState, this, false));
                this._disposers.push(new Dictionary_DictionaryDisposer(this._states));
                this._disposers.push(state);
            }
            return this._states;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "hiddenState", {
        /**
         * Returns a [[SpriteState]] object for "hidden" state.
         *
         * This is a shortcut to `this.states.getKey("hidden")`.
         *
         * @return Hidden state
         */
        get: function () {
            if (!this.states.getKey("hidden")) {
                var hiddenState = this.states.create("hidden");
                hiddenState.properties.opacity = 0;
                hiddenState.properties.visible = false;
            }
            return this.states.getKey("hidden");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "defaultState", {
        /**
         * Returns a [[SpriteState]] object for "default" state.
         *
         * This is a shortcut to `this.states.getKey("default")`.
         *
         * @return Hidden state
         */
        get: function () {
            if (!this.states.getKey("default")) {
                var defaultState = this.states.create("default");
                defaultState.properties.opacity = 1;
            }
            return this.states.getKey("default");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if some key states are defined and updates Sprite properties
     * accordingly.
     *
     * For example if there's a state "down" defined for Sprite, we automatically
     * make it "clickable".
     *
     * @ignore Exclude from docs
     * @param event An event which caused state list update
     */
    Sprite.prototype.processState = function (event) {
        var state = event.newValue;
        state.sprite = this;
        state.name = event.key;
        if (this.states.hasKey("hover") || (this.showTooltipOn == "hover" && (hasValue(this.tooltipHTML) || hasValue(this.tooltipText)))) {
            this.hoverable = true;
        }
        if (this.states.hasKey("down") || (this.showTooltipOn == "hover" && (hasValue(this.tooltipHTML) || hasValue(this.tooltipText)))) {
            this.clickable = true;
        }
        if (this.states.hasKey("focus")) {
            this.focusable = true;
        }
        // Propagate the new state to clones
        if (this.applyOnClones) {
            var clones = this.clones.values;
            var length_1 = clones.length;
            for (var i = 0; i < length_1; ++i) {
                var clone = clones[i];
                if (!clone.isDisposed()) {
                    clone.states.setKey(state.name, state);
                }
            }
        }
    };
    Object.defineProperty(Sprite.prototype, "animations", {
        /**
         * Returns a list elements's animations currently being played.
         *
         * If the list has not been initialized it is created.
         *
         * @return List of animations
         */
        get: function () {
            if (!this._animations) {
                this._animations = [];
                this._disposers.push(new Animation_AnimationDisposer(this._animations));
            }
            return this._animations;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts element's local coordinates to the coordinates within the main
     * chart container.
     *
     * @param point  Local point
     * @return Global point
     */
    Sprite.prototype.getSvgPoint = function (point) {
        try {
            // Calculate SVG point
            var bbox = this.htmlContainer.getBoundingClientRect();
            return {
                "x": point.x - bbox.left,
                "y": point.y - bbox.top
            };
        }
        catch (e) {
            return point;
        }
    };
    /**
     * Creates and starts an [[Animation]] with given `animationOptions`.
     *
     * @see {@link Animation} for additional information about available options
     * @param animationOptions  Animation options
     * @param duration          Duration in milliseconds
     * @param easing            Easing function
     * @return Animation instance
     */
    Sprite.prototype.animate = function (animationOptions, duration, easing) {
        return new Animation_Animation(this, animationOptions, duration, easing).start();
    };
    /**
     * Applies a [[SpriteState]] on this element.
     *
     * The first parameter can either be a name state or a [[SpriteState]]
     * instance.
     *
     * When run, this method will apply SVG properties defined in a
     * [[SpriteState]], but only those that are relevant to this particular
     * element, i.e. are in the `properties` array.
     *
     * @see {@link SpriteState}
     * @param value               A state - name key or instance
     * @param transitionDuration  Duration of the transition between current and new state
     * @param easing              An easing function
     */
    Sprite.prototype.setState = function (value, transitionDuration, easing) {
        var state;
        if (value instanceof SpriteState_SpriteState) {
            this.states.setKey(value.name, value);
            state = value;
        }
        else {
            state = this.states.getKey(value);
            if (!state) {
                return;
            }
        }
        // stop previous transition
        // not good - foe expample, we are animating to some "active" state and in them middle "hover" state happens. then "active" stat won't be applied
        //if (this._transition) {
        //this._transition.stop();
        //}
        if (state.name == "hover") {
            if (this.isHidden) {
                return;
            }
            this.isHover = true;
        }
        if (state.name == "hidden") {
            this.isHiding = true;
        }
        else {
            if (!this.visible) {
                this.setVisibility(state.properties.visible || this.defaultState.properties.visible);
            }
        }
        if (state.name == "active") {
            this.isActive = true;
        }
        // we do not set isActive = false here if it's not active, but container does that if setStateOnChildren = true
        if (!isNumber(transitionDuration)) {
            transitionDuration = state.transitionDuration;
        }
        if (!hasValue(easing)) {
            easing = state.transitionEasing;
        }
        return this.transitTo(state, transitionDuration, easing);
    };
    /**
     * Applies proper state based on the condition of the element. A condition is
     * deducted in this order:
     * * "hover" if Sprite has currently any pointers over it
     * * "down" if Sprite has any pointers (touch or mouse) currently pressed over it
     * * "focus" if Sprite has currently got focus (accessibility)
     * * "hidden" if Sprite is currently hidden
     *
     * Returns an [[Animation]] object, which is handling gradual transition from
     * current values of properties, to the new target state(s).
     *
     * @param duration  Duration for the animation (ms)
     * @return [[Animation]] object which is handling the transition
     */
    Sprite.prototype.applyCurrentState = function (duration) {
        //if (!this.isHidden) { // this was done for hover state not to take effect if "hidden" is actually visible, need to think about it.
        var animation = this.setState(this.defaultState, duration);
        if (this.isHover) {
            animation = this.setState("hover", duration);
        }
        if (this.isDown && this.interactions.downPointers.length) {
            animation = this.setState("down", duration);
        }
        this.isFocused = this.isFocused;
        if (this.isActive) {
            animation = this.setState("active", duration);
            if (this.isHover && this.states.hasKey("hoverActive")) {
                animation = this.setState("hoverActive", duration);
            }
        }
        return animation;
        //}
    };
    /**
     * Starts an [[Animation]] of the properties to specific values as they are
     * set in `state`.
     *
     * @ignore Exclude from docs
     * @param state     Target State
     * @param duration  Duration in milliseconds
     * @param easing    Easing function
     * @return Transition Animation
     */
    Sprite.prototype.transitTo = function (state, duration, easing) {
        var _this = this;
        // Init
        var options = [], propValues = state.allValues, transition;
        // todo: do this for numeric/color properties only?
        // @todo use state.getPropertyValue instead
        Object_each(propValues, function (propertyName, finalValue) {
            var currentValue = _this[propertyName];
            // save current value to default state. this solves a big problem where values must be set both on sprite and default state
            if (finalValue != currentValue && _this.defaultState.properties[propertyName] == undefined) {
                _this.defaultState.properties[propertyName] = currentValue;
            }
            //if (finalValue != currentValue && $type.hasValue(finalValue)) {
            if (finalValue != "__unset") {
                var option = { from: currentValue, to: finalValue, property: propertyName };
                options.push(option);
            }
        });
        if (options.length > 0) {
            transition = this.animate(options, duration, easing);
            if (transition && !transition.isFinished()) {
                // TODO should this use events.once ?
                // TODO push onto _disposers array ?
                this._disposers.push(transition.events.on("animationended", function () {
                    _this.dispatchImmediately("transitionended");
                }));
            }
            else {
                this.dispatchImmediately("transitionended");
            }
        }
        // apply filters if set
        if (state.filters.length > 0) {
            var newFilters_1 = [];
            // check for the same filters
            Iterator_each(state.filters.iterator(), function (stateFilter) {
                var newFilter = stateFilter.clone();
                newFilters_1.push(newFilter);
                var animationOptions = [];
                Iterator_each(_this.filters.iterator(), function (currentFilter) {
                    // if we have the same filters
                    if (currentFilter.className == newFilter.className) {
                        if (!contains(_this.defaultState.filters.iterator(), function (x) { return x.className === newFilter.className; })) {
                            _this.defaultState.filters.push(currentFilter);
                        }
                        Object_each(newFilter.properties, function (propertyName, newValue) {
                            var currentValue = currentFilter.properties[propertyName];
                            // if values are not the same, push to animation options array
                            if (currentValue != newValue) {
                                animationOptions.push({ property: propertyName, from: currentValue, to: newValue });
                            }
                        });
                    }
                });
                // animate to new value
                newFilter.animate(animationOptions, duration, easing);
            });
            this.filters.clear();
            this.filters.pushAll(newFilters_1);
        }
        return transition;
    };
    /**
     * Returns `true` if Sprite is currently transiting from one state/value to
     * another.
     *
     * @return Is in transition?
     */
    Sprite.prototype.isInTransition = function () {
        return this.animations.length > 0;
    };
    Object.defineProperty(Sprite.prototype, "isHover", {
        /**
         * Returns indicator if this element has a mouse pointer currently hovering
         * over it, or if it has any touch pointers pressed on it.
         *
         * @return Is hovered?
         */
        get: function () {
            if (this.isInteractive()) {
                return this.interactions.isHover;
            }
            return false;
        },
        /**
         * Indicates if this element has a mouse pointer currently hovering
         * over it, or if it has any touch pointers pressed on it.
         *
         * @param value Is hovered?
         */
        set: function (value) {
            value = toBoolean(value);
            if (value !== this.isHover) {
                if (this.isInteractive()) {
                    this.interactions.isHover = value;
                    if (value) {
                        this.handleOver();
                    }
                    else {
                        this.interactions.isRealHover = false;
                        this.handleOut();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "isDragged", {
        /**
         * Returns indicator if this element is being dragged at the moment.
         *
         * @return Is dragged?
         */
        get: function () {
            return this._isDragged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "isResized", {
        /**
         * Returns indicator if this element is being resized at the moment.
         *
         * @return Is resized?
         */
        get: function () {
            return this._isResized;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "isDown", {
        /**
         * @return Is down?
         */
        get: function () {
            if (this.isInteractive()) {
                return this.interactions.isDown;
            }
            return false;
        },
        /**
         * Indicates if this element has any pointers (mouse or touch) pressing down
         * on it.
         *
         * @param value Is down?
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.isInteractive() && this.isDown != value) {
                this.interactions.isDown = value;
                if (value) {
                    this.handleDown();
                }
                else {
                    this.handleUp();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "isFocused", {
        /**
         * @return Is focused?
         */
        get: function () {
            if (this.isInteractive()) {
                return this.interactions.isFocused;
            }
            return false;
        },
        /**
         * Indicates if this element is focused (possibly by tab navigation).
         *
         * @param value Is focused?
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.focusable && this.isFocused != value) {
                if (this.isInteractive()) {
                    this.interactions.isFocused = value;
                    if (value === true) {
                        this.handleFocus();
                    }
                    else {
                        this.handleBlur();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "isActive", {
        /**
         * @return Is active?
         */
        get: function () {
            return this._isActive;
        },
        /**
         * Indicates if this element is currently active (toggled on) or not
         * (toggled off).
         *
         * @param value Is active?
         */
        set: function (value) {
            this.setActive(value);
        },
        enumerable: true,
        configurable: true
    });
    Sprite.prototype.setActive = function (value) {
        value = toBoolean(value);
        if (this._isActive !== value) {
            this._isActive = value;
            if (value && this.states.hasKey("active")) {
                this.setState("active");
                if (this.isHover && this.states.hasKey("hoverActive")) {
                    this.setState("hoverActive");
                }
            }
            else {
                this.applyCurrentState();
            }
            this.dispatchImmediately("toggled");
        }
    };
    Object.defineProperty(Sprite.prototype, "disabled", {
        /**
         * @return Disabled?
         */
        get: function () {
            //if(this._internalDisabled){
            //	return true;
            //}
            var current = this.getPropertyValue("disabled");
            if (hasValue(current)) {
                return current;
            }
            else {
                if (this.virtualParent) {
                    return this.virtualParent.disabled;
                }
                if (this._parent) {
                    return this._parent.disabled;
                }
            }
            return false;
        },
        /**
         * Controls if element is disabled.
         *
         * A disabled element is hidden, and is removed from any processing, layout
         * calculations, and generally treated as if it does not exist.
         *
         * The element itself is not destroyed, though. Setting this back to `false`,
         * will "resurrect" the element.
         *
         * @param value  Disabled?
         */
        set: function (value) {
            this.setDisabled(value);
        },
        enumerable: true,
        configurable: true
    });
    Sprite.prototype.setDisabled = function (value) {
        value = toBoolean(value);
        var current = this.getPropertyValue("disabled");
        if (current != value) {
            this.setPropertyValue("disabled", value, true);
            if (value) {
                this.parent = this._parent;
                this.removeFromInvalids();
                this.group.attr({ "display": "none" });
                this.dispatch("disabled");
            }
            else {
                if (this._parent) {
                    var group = this._parent.element;
                    if (!group.hasChild(this.group)) {
                        group.add(this.group);
                    }
                }
                if (this instanceof Container_Container) {
                    this.deepInvalidate();
                    if (this._background) {
                        this._background.invalidate();
                    }
                }
                else {
                    this.invalidate();
                }
                if (!this.__disabled) {
                    this.removeSVGAttribute("display");
                }
                this.dispatch("enabled");
            }
            this.dispatch("transformed");
            system.requestFrame();
            return true;
        }
        return false;
    };
    Object.defineProperty(Sprite.prototype, "__disabled", {
        /**
         * @ignore
         * @return Disabled?
         */
        get: function () {
            return this._internalDisabled;
        },
        /**
         * Internal disable method.
         *
         * Do not use it for disabling elements. Use `disabled` accessor instead.
         *
         * @ignore Exclude from docs
         * @param value Disabled?
         */
        set: function (value) {
            if (this._internalDisabled != value) {
                this._internalDisabled = value;
                this._updateDisabled = true;
                this.invalidatePosition(); // better use this instead of invalidate()
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "numberFormatter", {
        /**
         * @return A [[NumberFormatter]] instance to be used
         */
        get: function () {
            if (this._numberFormatter) {
                return this._numberFormatter;
            }
            else if (this.virtualParent) {
                return this.virtualParent.numberFormatter;
            }
            else if (this._parent) {
                return this._parent.numberFormatter;
            }
            this._numberFormatter = new NumberFormatter_NumberFormatter();
            this._numberFormatter.language = this.language;
            return this.numberFormatter;
        },
        /**
         * ==========================================================================
         * FORMATTERS AND OTHER EXTERNAL HELPERS
         * ==========================================================================
         * @hidden
         */
        /**
         * A [[NumberFormatter]] instance.
         *
         * This is used to format numbers.
         *
         * ```TypeScript
         * chart.numberFormatter.numberFormat = "#,###.#####";
         * ```
         * ```JavaScript
         * chart.numberFormatter.numberFormat = "#,###.#####";
         * ```
         * ```JSON
         * {
         *   // ...
         *   "numberFormatter": {
         *     "numberFormat": "#,###.#####"
         *   }
         * }
         * ```
         *
         * You can set a separate instance of formatter for each
         * individual element. However that would be unnecessary overhead as
         * all elements would automatically inherit formatter from their parents,
         * all the way up to the chart itself.
         *
         *
         * @see {@link NumberFormatter} for more info on formatting numbers
         * @param value  An instance of NumberFormatter
         */
        set: function (value) {
            this._numberFormatter = value;
            this._numberFormatter.language = this.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "dateFormatter", {
        /**
         * @return An instance of DateFormatter
         */
        get: function () {
            if (this._dateFormatter) {
                return this._dateFormatter;
            }
            else if (this.virtualParent) {
                return this.virtualParent.dateFormatter;
            }
            else if (this._parent) {
                return this._parent.dateFormatter;
            }
            this._dateFormatter = new DateFormatter_DateFormatter();
            this._dateFormatter.language = this.language;
            return this.dateFormatter;
        },
        /**
         * A [[DateFormatter]] instance.
         *
         * This is used to format dates, e.g. on a date axes, balloons, etc.
         *
         * ```TypeScript
         * chart.dateFormatter.dateFormat = "yyyy-MM-dd";
         * ```
         * ```JavaScript
         * chart.dateFormatter.dateFormat = "yyyy-MM-dd";
         * ```
         * ```JSON
         * {
         *   // ...
         *   "dateFormatter": {
         *     "dateFormat": "yyyy-MM-dd"
         *   }
         * }
         * ```
         *
         * You can set a separate instance of formatter for each
         * individual element. However that would be unnecessary overhead as
         * all elements would automatically inherit formatter from their parents,
         * all the way up to the chart itself.
         *
         * @see {@link DateFormatter} for more info on dates formatting
         * @param value  An instance of DateFormatter
         */
        set: function (value) {
            this._dateFormatter = value;
            this._dateFormatter.language = this.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "durationFormatter", {
        /**
         * @return An instance of DurationFormatter
         */
        get: function () {
            if (this._durationFormatter) {
                return this._durationFormatter;
            }
            else if (this.virtualParent) {
                return this.virtualParent.durationFormatter;
            }
            else if (this._parent) {
                return this._parent.durationFormatter;
            }
            this._durationFormatter = new DurationFormatter_DurationFormatter();
            this._durationFormatter.language = this.language;
            return this.durationFormatter;
        },
        /**
         * A [[DurationFormatter]] instance.
         *
         * This is used to format numbers as durations, e.g. on a value axes.
         *
         * You can set a separate instance of formatter for each
         * individual element. However that would be unnecessary overhead as
         * all elements would automatically inherit formatter from their parents,
         * all the way up to the chart itself.
         *
         * @see {@link DurationFormatter} for more info on durations
         * @param value  An instance of DurationFormatter
         */
        set: function (value) {
            this._durationFormatter = value;
            this._durationFormatter.language = this.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "language", {
        /**
         * @return An instance of Language
         */
        get: function () {
            var language = this._language.get();
            if (language) {
                return language;
            }
            else if (this.virtualParent) {
                return this.virtualParent.language;
            }
            else if (this._parent) {
                return this._parent.language;
            }
            language = new Language_Language();
            this.language = language;
            return language;
        },
        /**
         * A [[Language]] instance to use for translations.
         *
         * Normally it is enough to set language for the top-most element - chart.
         *
         * All other element child elements will automatically re-use that language
         * object.
         *
         * @param value  An instance of Language
         */
        set: function (value) {
            var _this = this;
            if (this._language.get() !== value) {
                this._language.set(value, value.events.on("localechanged", function (ev) {
                    if (_this._numberFormatter) {
                        _this._numberFormatter.language = _this.language;
                    }
                    if (_this._dateFormatter) {
                        _this._dateFormatter.language = _this.language;
                    }
                    if (_this._durationFormatter) {
                        _this._durationFormatter.language = _this.language;
                    }
                    if (_this._exporting.get()) {
                        var exporting = _this._exporting.get();
                        exporting.numberFormatter.language = _this.language;
                        exporting.dateFormatter.language = _this.language;
                        exporting.durationFormatter.language = _this.language;
                        exporting.language = _this.language;
                    }
                    if (_this instanceof Container_Container) {
                        _this.deepInvalidate();
                    }
                }));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * ==========================================================================
     * DATA-RELATED STUFF
     * ==========================================================================
     * @hidden
     */
    /**
     * Parses the string for meta tags `{tag}` and replaces them with a real
     * value. Supports straight up tags referring to the field in data, i.e.
     * `{value}` or tags with additional formatting info. E.g.:
     *
     * ```Text
     * {myfield.formatDate("yyyy-MM-dd")}
     * {myfield.formatDate()}
     * {myfield.formatNumber("#,####.00")}
     * {myfield.formatNumber()}
     * {myField.formatDuration("mm:ss")}
     * ```
     *
     * Etc.
     *
     * This method Will automatically detect and use proper formatter for the
     * value.
     *
     * The source value will be looked up in various places: (in order)
     * * Sprite's own `dataItem`
     * * Sprite's properties
     * * Parent's `dataItem`
     * * Parent's properties
     *
     * @ignore Exclude from docs
     * @param string            A string to format
     * @param dataItem          DataItem
     * @return Formatted string
     */
    Sprite.prototype.populateString = function (string, dataItem) {
        if (hasValue(string)) {
            string = castString(string);
            string = getTextFormatter().escape(string);
            var tags = string.match(/\{([^}]+)\}/g);
            var i = void 0;
            if (tags) {
                for (i = 0; i < tags.length; i++) {
                    var tag = tags[i].replace(/\{([^}]+)\}/, "$1");
                    var value = this.getTagValue(tag, "", dataItem);
                    if (!hasValue(value)) {
                        value = "";
                    }
                    string = string.split(tags[i]).join(value);
                }
            }
            string = getTextFormatter().unescape(string);
        }
        else {
            string = "";
        }
        if (!this._adapterO) {
            return string;
        }
        else {
            return this._adapterO.apply("populateString", string);
        }
    };
    /**
     * Gets the value from data item and formats it according to specified format.
     *
     * If `format` is specified, it will use its contents to choose formatter for
     * the value. Otherwise it will select formatter accordingly to actual value
     * type.
     *
     * @ignore Exclude from docs
     * @todo Ability to force certain formatter on known numeric and date values
     * @see {@link NumberFormatter}
     * @see {@link DateFormatter}
     * @see {@link DurationFormatter}
     * @param tagName           Tag name to replace
     * @param format            Format to use
     * @param dataItem          DataItem
     * @return Formatted value
     */
    Sprite.prototype.getTagValue = function (tagName, format, dataItem) {
        var value;
        if (!hasValue(dataItem)) {
            dataItem = this.dataItem;
        }
        // Parse parts
        var parts = [];
        var reg = /([^.]+)\(([^)]*)\)|([^.]+)/g;
        ;
        var matches;
        while (true) {
            matches = reg.exec(tagName);
            if (matches === null) {
                break;
            }
            if (matches[3]) {
                // Simple property
                parts.push({
                    prop: matches[3]
                });
            }
            else {
                // Method
                // Parse parameters
                var params = [];
                if (trim(matches[2]) != "") {
                    var reg2 = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g;
                    var matches2 = void 0;
                    while (true) {
                        matches2 = reg2.exec(matches[2]);
                        if (matches2 === null) {
                            break;
                        }
                        params.push(matches2[1] || matches2[2] || matches2[3]);
                    }
                }
                parts.push({
                    method: matches[1],
                    params: params
                });
            }
        }
        // Check if we can retrieve the value from data item
        if (dataItem) {
            // Check values
            value = this.getTagValueFromObject(parts, dataItem.values);
            // Check properties
            if (!hasValue(value) || isObject(value)) { // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and wont't get to the dateX date.
                value = this.getTagValueFromObject(parts, dataItem);
            }
            // Check data context
            var dataContext = dataItem.dataContext;
            if (!hasValue(value) && dataContext) {
                value = this.getTagValueFromObject(parts, dataItem.dataContext);
                // scond data context level sometimes exist (tree map)
                if (!hasValue(value) && dataContext.dataContext) {
                    value = this.getTagValueFromObject(parts, dataContext.dataContext);
                }
            }
            // Check component's data item
            if (!hasValue(value) && dataItem.component && dataItem.component.dataItem !== dataItem) {
                value = dataItem.component.getTagValue(tagName, format);
            }
        }
        // Check sprite's properties
        if (!hasValue(value)) {
            value = this.getTagValueFromObject(parts, this.populateStringFrom || this);
        }
        // Finally, check the parent
        if (!hasValue(value) && this._parent) {
            value = this._parent.getTagValue(tagName, format);
        }
        return value;
    };
    /**
     * Tries to retrieve values from properties of any object, then applies
     * proper formatting to it.
     *
     * @ignore Exclude from docs
     * @todo Description (improve)
     * @param parts   Properties ant methods to access
     * @param object  Source object
     * @param format  A specific format to apply
     * @return Formatted value
     */
    Sprite.prototype.getTagValueFromObject = function (parts, object, format) {
        var current = object;
        var formatApplied = false;
        for (var i = 0, len = parts.length; i < len; i++) {
            var part = parts[i];
            if (part.prop) {
                // Regular property
                current = current[part.prop];
                if (!hasValue(current)) {
                    // Not set, return undefined
                    return;
                }
            }
            else {
                // Method
                switch (part.method) {
                    case "formatNumber":
                        var numberValue = anyToNumber(current);
                        if (hasValue(numberValue)) {
                            current = this.numberFormatter.format(numberValue, format || part.params[0] || undefined);
                            formatApplied = true;
                        }
                        break;
                    case "formatDate":
                        var dateValue = void 0;
                        if (isString(current)) {
                            dateValue = this.dateFormatter.parse(current);
                        }
                        else {
                            dateValue = anyToDate(current);
                        }
                        if (!isDate(dateValue) || Type_isNaN(dateValue.getTime())) {
                            // Was not able to get date out of value, quitting and letting
                            // calling method try another value
                            return;
                        }
                        if (hasValue(dateValue)) {
                            current = this.dateFormatter.format(dateValue, format || part.params[0] || undefined);
                            formatApplied = true;
                        }
                        break;
                    case "formatDuration":
                        var durationValue = anyToNumber(current);
                        if (hasValue(durationValue)) {
                            current = this.durationFormatter.format(durationValue, format || part.params[0] || undefined, part.params[1] || undefined);
                            formatApplied = true;
                        }
                        break;
                    case "urlEncode":
                    case "encodeURIComponent":
                        current = encodeURIComponent(current);
                        break;
                    default:
                        if (current[part.method]) {
                            current[part.method].apply(this, part.params);
                        }
                        break;
                }
            }
        }
        // Apply default format if it wasn't applied explicitly
        if (!formatApplied) {
            var formatParts = [{
                    method: "",
                    params: format
                }];
            if (!hasValue(format)) {
                // Format is not set
                // Determine from the type of the value
                if (isNumber(current)) {
                    formatParts[0].method = "formatNumber";
                    formatParts[0].params = "";
                }
                else if (isDate(current)) {
                    formatParts[0].method = "formatDate";
                    formatParts[0].params = "";
                }
            }
            else {
                // Format set
                // Try to determine formatter based on the format
                var formatterType = getFormat(format);
                // format
                if (formatterType === NUMBER) {
                    formatParts[0].method = "formatNumber";
                }
                else if (formatterType === DATE) {
                    formatParts[0].method = "formatDate";
                }
                else if (formatterType === DURATION) {
                    formatParts[0].method = "formatDuration";
                }
            }
            // Apply format
            if (formatParts[0].method) {
                current = this.getTagValueFromObject(formatParts, current);
            }
        }
        return current;
    };
    Object.defineProperty(Sprite.prototype, "dataItem", {
        /**
         * @return [[DataItem]]
         */
        get: function () {
            if (!this._dataItem) {
                if (this.virtualParent) {
                    return this.virtualParent.dataItem;
                }
                if (this._parent) {
                    return this._parent.dataItem;
                }
            }
            return this._dataItem;
        },
        /**
         * A [[DataItem]] to use as element's data source.
         *
         * @todo Review type
         * @param dataItem  DataItem
         */
        set: function (dataItem) {
            //an not use this["_dataItem"] here, as we return parent data item if this sprite doesn't have one.
            // @todo:think about it
            this.setDataItem(dataItem);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets currently used [[DataItem]].
     *
     * If the element has also `configField` set, it will also look for any
     * config in DataItem's data context to apply to this element.
     *
     * @param dataItem DataItem
     */
    Sprite.prototype.setDataItem = function (dataItem) {
        var _this = this;
        if (this._dataItem != dataItem) {
            this._dataItem = dataItem;
            if (dataItem) {
                if (this.configField) {
                    var dataContext_1 = dataItem.dataContext;
                    if (dataContext_1) {
                        this.config = dataContext_1[this.configField];
                        if (!this.config && dataContext_1.dataContext) {
                            this.config = dataContext_1.dataContext[this.configField];
                        }
                    }
                }
                var dataContext_2 = dataItem.dataContext;
                if (dataContext_2) {
                    var dataContext2_1 = dataContext_2.dataContext;
                    Object_each(this.propertyFields, function (propertyName, fieldValue) {
                        if (hasValue(dataContext_2[fieldValue])) {
                            var anyThis = _this;
                            anyThis[propertyName] = dataContext_2[fieldValue];
                        }
                        else {
                            if (dataContext2_1) {
                                var value = dataContext2_1[fieldValue];
                                if (hasValue(value)) {
                                    var anyThis = _this;
                                    anyThis[propertyName] = value;
                                }
                            }
                        }
                    });
                }
            }
            this.invalidate();
        }
    };
    /**
     * ==========================================================================
     * PROPERTY UTILITIES
     * ==========================================================================
     * @hidden
     */
    /**
     * Returns element's property value.
     *
     * Will check if there are any bindings with [[DataItem]].
     *
     * Will also apply any adapters bound to `propertyName`.
     *
     * @param propertyName  Property name
     * @return Property value
     */
    Sprite.prototype.getPropertyValue = function (propertyName) {
        var propValue = this.properties[propertyName];
        // Apply adapter
        if (!this._isTemplate) {
            if (this._adapterO) {
                propValue = this._adapterO.apply(propertyName, propValue);
            }
        }
        return propValue;
    };
    Sprite.prototype.setColorProperty = function (property, value, invalidate) {
        var currentValue = this.properties[property];
        if (value instanceof Color_Color && currentValue instanceof Color_Color && value.toString() == currentValue.toString()) {
            return false;
        }
        else {
            return this.setPropertyValue(property, value, invalidate);
        }
    };
    Sprite.prototype.setPercentProperty = function (property, value, invalidate, transform, precision, floor) {
        value = toNumberOrPercent(value);
        if (isNumber(value)) {
            value = Math_round(value, precision, floor);
            return this.setPropertyValue(property, value, invalidate, transform);
        }
        else {
            var currentValue = this.properties[property];
            if (value instanceof Percent && currentValue instanceof Percent && value.value == currentValue.value) {
                return false;
            }
            else {
                return this.setPropertyValue(property, value, invalidate, transform);
            }
        }
    };
    /**
     * Sets elements's property value. Will also propagate the same property value
     * on all element's clones.
     *
     * @param property    Property
     * @param value       Value
     * @param invalidate  Should the sprite be invalidated, cause it's re-rendering
     * @param transform   Re-apply positioning of the element
     * @return Did the value change? It will return `true` if the new value and the old value of the property are not the same
     * @todo Review propagation to clones. Right now we simply check if clone is disposed before setting the same property on it. It's better to remove from clone list altogether.
     */
    Sprite.prototype.setPropertyValue = function (property, value, invalidate, transform) {
        if (this.properties[property] !== value && !this.isDisposed()) {
            this.properties[property] = value;
            if (this.events.isEnabled("propertychanged")) {
                var event_1 = {
                    type: "propertychanged",
                    target: this,
                    property: property
                };
                this.events.dispatchImmediately("propertychanged", event_1);
            }
            if (invalidate) {
                this.invalidate();
            }
            if (transform) {
                this.invalidatePosition();
            }
            if (this.applyOnClones) {
                var clones = this.clones.values;
                var length_2 = clones.length;
                for (var i = 0; i < length_2; ++i) {
                    var clone = clones[i];
                    if (!clone.isDisposed()) {
                        //(<Sprite>clone).setPropertyValue(<any>property, value, invalidate, transform);
                        clone[property] = value;
                    }
                }
            }
            return true;
        }
        return false;
    };
    Sprite.prototype.bind = function (property, source, bindToProperty, modifier) {
        var _this = this;
        if (bindToProperty === void 0) { bindToProperty = property; }
        if (hasValue(this._bindings[property])) {
            this._bindings[property].dispose();
        }
        // set current value
        this[property] = source[bindToProperty];
        //source.addEventListener(AMEvent.PROPERTY_CHANGED, this.handleBindings, false, this);
        this._bindings[property] = source.events.on("propertychanged", function (event) {
            if (event.property === bindToProperty) {
                var value = source[bindToProperty];
                if (modifier) {
                    value = modifier(value);
                }
                // TODO clonesById
                _this[property] = value;
            }
        });
    };
    /**
     * Sets up and obeserver function to monitor changes in particular property
     * or properties.
     *
     * @ignore Exclude from docs
     * @param property  Element's property name
     * @param listener  Handler function
     * @param context   Context for handler function
     * @returns Event Disposer
     */
    Sprite.prototype.observe = function (property, listener, context, shouldClone) {
        var _this = this;
        return new Disposer_MultiDisposer(map(toArray(property), function (prop) {
            return _this.events.on("propertychanged", function (e) {
                if (e.property === prop) {
                    listener.call(context, e);
                }
            }, context, shouldClone);
        }));
    };
    /**
     * ==========================================================================
     * ACCESSIBILITY-RELATED PROPERTIES
     * ==========================================================================
     * @hidden
     */
    /**
     * Applies accessibility to the SVG element.
     *
     * Adds `<title>` and `<description>` elements as well as `aria-labelledby`
     * and `role` properties.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.applyAccessibility = function () {
        // Check if we need to add label and description
        var title = this.readerTitle, description = this.readerDescription, role = this.role, hidden = this.readerHidden, checked = this.readerChecked, controls = this.readerControls, live = this.readerLive, orientation = this.readerOrientation, valueNow = this.readerValueNow, valueText = this.readerValueText;
        // Init label/describe ids
        var labelledByIds = [], describedByIds = [];
        var labelledBy = this.readerLabelledBy;
        if (labelledBy) {
            labelledByIds.push(labelledBy);
        }
        var describedBy = this.readerDescribedBy;
        if (describedBy) {
            describedByIds.push(describedBy);
        }
        // Consolidate title and description if system tooltip is disabled
        if (!this.showSystemTooltip && title) {
            if (description) {
                description = title + " -- " + description;
            }
            else {
                description = title;
            }
            title = undefined;
        }
        // If we have only label, we use `aria-label` attribute.
        // If there are both label and description, we'll go with separate tags and
        // use `aria-labelledby`
        if (title && !description && !this.showSystemTooltip) {
            // Only label is set, use attribute
            this.setSVGAttribute({
                "aria-label": title
            });
            // Remove previous elements
            this.removeSVGAttribute("aria-description");
            if (this._titleElement) {
                this.group.removeElement(this._titleElement);
                this._titleElement = undefined;
            }
            if (this._descriptionElement) {
                this.group.removeElement(this._descriptionElement);
                this._descriptionElement = undefined;
            }
        }
        else {
            if (title) {
                var titleElement = this.titleElement;
                var titleId = this.uid + "-title";
                if (titleElement.node.textContent != title) {
                    titleElement.node.textContent = title;
                    titleElement.attr({ id: titleId });
                }
                labelledByIds.push(titleId);
            }
            else if (this._titleElement) {
                this.group.removeElement(this._titleElement);
                this._titleElement = undefined;
            }
            var descriptionId = this.uid + "-description";
            if (description) {
                var descriptionElement = this.descriptionElement;
                if (descriptionElement.node.textContent != description) {
                    descriptionElement.node.textContent = description;
                    descriptionElement.attr({ id: descriptionId });
                }
                describedByIds.push(descriptionId);
            }
            else if (this._descriptionElement) {
                this.group.removeElement(this._descriptionElement);
                this._descriptionElement = undefined;
                remove(describedByIds, descriptionId);
            }
        }
        // Add label and described properties
        if (labelledByIds.length) {
            this.setSVGAttribute({ "aria-labelledby": labelledByIds.join(" ") });
        }
        else {
            this.removeSVGAttribute("aria-labelledby");
        }
        if (describedByIds.length) {
            this.setSVGAttribute({ "aria-describedby": describedByIds.join(" ") });
        }
        else {
            this.removeSVGAttribute("aria-describedby");
        }
        // Apply role
        if (role) {
            this.setSVGAttribute({ "role": role });
        }
        else {
            this.removeSVGAttribute("role");
        }
        // Apply aria-hidden
        if (hidden) {
            this.setSVGAttribute({ "aria-hidden": "true" });
        }
        else {
            this.removeSVGAttribute("aria-hidden");
        }
        // Apply aria-checked
        if (checked) {
            this.setSVGAttribute({ "aria-checked": "true" });
        }
        else if (checked === false) {
            this.setSVGAttribute({ "aria-checked": "false" });
        }
        else {
            this.removeSVGAttribute("aria-checked");
        }
        // Apply aria-controls
        if (controls) {
            this.setSVGAttribute({ "aria-controls": controls });
        }
        else {
            this.removeSVGAttribute("aria-controls");
        }
        // Apply aria-live
        if (live) {
            this.setSVGAttribute({ "aria-live": live });
        }
        else {
            this.removeSVGAttribute("aria-live");
        }
        // Apply aria-orientation
        if (orientation) {
            this.setSVGAttribute({ "aria-orientation": orientation });
        }
        else {
            this.removeSVGAttribute("aria-orientation");
        }
        // Apply aria-valuenow
        if (valueNow) {
            this.setSVGAttribute({ "aria-valuenow": valueNow });
        }
        else {
            this.removeSVGAttribute("aria-valuenow");
        }
        // Apply aria-valuetext
        if (valueText) {
            this.setSVGAttribute({ "aria-valuetext": valueText });
        }
        else {
            this.removeSVGAttribute("aria-valuetext");
        }
    };
    Object.defineProperty(Sprite.prototype, "readerTitle", {
        /**
         * @return Title
         */
        get: function () {
            var title = this.getPropertyValue("readerTitle");
            if (hasValue(title) && this.dataItem) {
                return this.populateString(title);
            }
            return title;
        },
        /**
         * Screen reader title of the element.
         *
         * @param value Title
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("readerTitle", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "readerDescription", {
        /**
         * @return Description
         */
        get: function () {
            return this.getPropertyValue("readerDescription");
        },
        /**
         * Screen reader description of the element.
         *
         * @param value Description
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("readerDescription", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "role", {
        /**
         * @return Role
         */
        get: function () {
            return this.getPropertyValue("role");
        },
        /**
         * A WAI-ARIA role for the element.
         *
         * @see {@link https://www.w3.org/TR/wai-aria-1.1/#role_definitions} for more information on WAI-ARIA roles
         * @param value  Role
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("role", value)) {
                this.applyAccessibility();
                if (value == "slider") {
                    this.setSVGAttribute({ "aria-valuemin": "0" });
                    this.setSVGAttribute({ "aria-valuemax": "100" });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "readerHidden", {
        /**
         * @return Hidden?
         */
        get: function () {
            return this.getPropertyValue("readerHidden");
        },
        /**
         * Controls if element should be hidden from screen readers.
         *
         * @see {@link https://www.w3.org/TR/wai-aria-1.1/#aria-hidden} for more information
         * @param value  Hidden?
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.setPropertyValue("readerHidden", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "readerChecked", {
        /**
         * @ignore Exclude from docs
         * @return Checked?
         */
        get: function () {
            return this.getPropertyValue("readerChecked");
        },
        /**
         * Controls if element is currently marked as "checked".
         *
         * @ignore Exclude from docs
         * @see {@link https://www.w3.org/TR/wai-aria-1.1/#aria-checked} for more information
         * @param value Checked?
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.setPropertyValue("readerChecked", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "readerControls", {
        /**
         * @ignore Exclude from docs
         * @return Setting value
         */
        get: function () {
            return this.getPropertyValue("readerControls");
        },
        /**
         * A `uid` of an element this element controls.
         *
         * @ignore Exclude from docs
         * @see {@link https://www.w3.org/TR/wai-aria-1.1/#aria-controls} for more information
         * @param value Setting value
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("readerControls", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "readerLive", {
        /**
         * @ignore Exclude from docs
         * @return Setting value
         */
        get: function () {
            return this.getPropertyValue("readerLive");
        },
        /**
         * Controls accessibility setting "aria-live" for the element.
         *
         * @ignore Exclude from docs
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions} for more information
         * @param value Setting value
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("readerLive", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "readerLabelledBy", {
        /**
         * @ignore Exclude from docs
         * @return Target element
         */
        get: function () {
            return this.getPropertyValue("readerLabelledBy");
        },
        /**
         * A `uid` of an element that describes this element.
         *
         * @ignore Exclude from docs
         * @see {@link https://www.w3.org/TR/wai-aria-1.1/#aria-labelledby} for more information
         * @param value Target element
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("readerLabelledBy", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "readerDescribedBy", {
        /**
         * @ignore Exclude from docs
         * @return Target element
         */
        get: function () {
            return this.getPropertyValue("readerDescribedBy");
        },
        /**
         * A `uid` of an element that describes this element.
         *
         * @ignore Exclude from docs
         * @see {@link https://www.w3.org/TR/wai-aria-1.1/#aria-describedby} for more information
         * @param value Target element
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("readerDescribedBy", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "readerOrientation", {
        /**
         * @return Orientation
         */
        get: function () {
            return this.getPropertyValue("readerOrientation");
        },
        /**
         * Orientation of the element.
         *
         * @since 4.7.16
         * @param value Orientation
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("readerOrientation", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "readerValueNow", {
        /**
         * @return Current value
         */
        get: function () {
            return this.getPropertyValue("readerValueNow");
        },
        /**
         * Current value of the element.
         *
         * @since 4.7.16
         * @param value Current value
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("readerValueNow", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "readerValueText", {
        /**
         * @return Current value (text)
         */
        get: function () {
            return this.getPropertyValue("readerValueText");
        },
        /**
         * Text representation of the current value of the element.
         *
         * @since 4.7.16
         * @param value Current value (text)
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("readerValueText", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "keyboardOptions", {
        /**
         * ==========================================================================
         * USER INTERACTIONS
         * ==========================================================================
         * @hidden
         */
        /**
         * Returns elements keyboard options.
         *
         * @return Keyboard options
         */
        get: function () {
            if (!this.interactions.keyboardOptions) {
                if (this.virtualParent) {
                    return this.virtualParent.keyboardOptions;
                }
                if (this._parent) {
                    return this._parent.keyboardOptions;
                }
            }
            return this.interactions.keyboardOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "mouseOptions", {
        /**
         * Mouse options.
         *
         * Enables controlling options related to the mouse, for example sensitivity
         * of its mouse wheel.
         *
         * E.g. the below will reduce chart's wheel-zoom speed to half its default
         * speed:
         *
         * ```TypeScript
         * chart.plotContainer.mouseOptions.sensitivity = 0.5;
         * ```
         * ```JavaScript
         * chart.plotContainer.mouseOptions.sensitivity = 0.5;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "plotContainer": {
         *     "mouseOptions": {
         *       "sensitivity": 0.5
         *     }
         *   }
         * }
         * ```
         *
         * @return Mouse options
         */
        get: function () {
            if (!this.interactions.mouseOptions) {
                if (this.virtualParent) {
                    return this.virtualParent.mouseOptions;
                }
                if (this._parent) {
                    return this._parent.mouseOptions;
                }
            }
            return this.interactions.mouseOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "interactions", {
        /**
         * Returns (creates if necessary) an [[InteractionObject]] associated with
         * this element.
         *
         * [[InteractionObject]] is used to attach all kinds of user-interactions to
         * the element, e.g. click/touch, dragging, hovering, and similar events.
         *
         * @return Interaction object
         */
        get: function () {
            if (!this._interaction) {
                var interaction = getInteraction().getInteraction(this.dom);
                this._interaction = interaction;
                this._interaction.clickable = this.clickable;
                this._interaction.hoverable = this.hoverable;
                this._interaction.trackable = this.trackable;
                this._interaction.draggable = this.draggable;
                this._interaction.swipeable = this.swipeable;
                this._interaction.resizable = this.resizable;
                this._interaction.wheelable = this.wheelable;
                this._interaction.contextMenuDisabled = this.contextMenuDisabled;
                this._interaction.inert = this.inert;
                this._interaction.sprite = this;
                this._disposers.push(this._interaction);
            }
            return this._interaction;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns true if interactions object was created. Mostly used just to avoid creating interactions object if not needed.
     * @return Is Sprite interactive?
     */
    Sprite.prototype.isInteractive = function () {
        if (this._interaction) {
            return true;
        }
        else {
            return false;
        }
    };
    Object.defineProperty(Sprite.prototype, "focusable", {
        /**
         * @return Can element be focused?
         */
        get: function () {
            return this.getPropertyValue("focusable");
        },
        /**
         * ==========================================================================
         * ELEMENT FOCUS-RELATED STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * Controls if the element can gain focus.
         *
         * Focusable element will be selectable via TAB key.
         *
         * Please note, clicking it with a mouse or touching will not add focus to
         * it.
         *
         * Focused element will show a system-specific highlight, which might ruin
         * the overal look. This is why we don't focus element on click/touch.
         *
         * A default setting varies for different elements. By default all elements
         * are not focusable, except certain items like buttons, legend items, etc.
         *
         * @default undefined (auto)
         * @param value  Can element be focused?
         */
        set: function (value) {
            var _this = this;
            value = toBoolean(value);
            if (this.setPropertyValue("focusable", value)) {
                if (!value && !this.isInteractive()) {
                }
                else {
                    this.interactions.focusable = value;
                    if (value) {
                        this.setSVGAttribute({ "focusable": value });
                        if (!this._tabindex) {
                            this.tabindex = 0;
                        }
                    }
                    else {
                        this.removeSVGAttribute("focusable");
                        this.tabindex = undefined;
                    }
                    // Set focus events that would apply "focus" state
                    // setEventDisposer will also remove listeners if value == false
                    this.interactions.setEventDisposer("sprite-focusable", value, function () { return new Disposer_MultiDisposer([
                        _this.events.on("blur", _this.handleBlur, _this, false),
                        _this.events.on("focus", _this.handleFocus, _this, false)
                    ]); });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Applies filters (if set) when element gains focus.
     *
     * @ignore Exclude from docs
     * @param ev Original event
     */
    Sprite.prototype.handleFocus = function (ev) {
        if (this.focusable) {
            if (this.topParent) {
                this.topParent.hasFocused = true;
            }
            if (this.focusFilter) {
                // Any `filters` manipulation will trigger `applyFilters()` so we don't
                // need to call it here
                this.filters.push(this.focusFilter);
            }
            if (this.hoverOnFocus) {
                // Trigger a hover event as well
                this.isHover = true;
                this.handleOver();
            }
        }
    };
    /**
     * Removes focus filter (if set) when elementloses focus.
     *
     * @ignore Exclude from docs
     * @param ev Original event
     */
    Sprite.prototype.handleBlur = function (ev) {
        if (this.focusable) {
            if (this.topParent) {
                this.topParent.hasFocused = false;
            }
            if (this.focusFilter) {
                // Any `filters` manipulation will trigger `applyFilters()` so we don't
                // need to call it here
                this.filters.removeValue(this.focusFilter);
            }
            if (this.hoverOnFocus) {
                // Trigger a out event as well
                this.isHover = false;
                this.handleOut();
            }
        }
    };
    Object.defineProperty(Sprite.prototype, "focusFilter", {
        /**
         * A reference to a [[Filter]] to apply to element when it gains focus.
         *
         * Normally, browsers will draw a default ugly square around focused element,
         * which totally makes sense because its purpose is to help identify active
         * element for visually impaired people.
         *
         * However, if you would rather apply a filter, so you can modify how focused
         * element looks like, use `focusFilter`.
         *
         * Simply set it to an anstance of [[FocusFilter]], or any other filter
         * object.
         *
         * ```TypeScript
         * chart.focusFilter = new am4core.FocusFilter();
         * ```
         * ```JavaScript
         * chart.focusFilter = new am4core.FocusFilter();
         * ```
         * ```JSON
         * {
         *   // ...
         *   "focusFilter": {
         *     "type": "FocusFilter"
         *   },
         *   // ...
         * }
         * ```
         *
         * @see {@link Filter}
         * @see {@link https://www.amcharts.com/docs/v4/concepts/accessibility/} more about accessibility
         * @see {@link https://www.amcharts.com/docs/v4/tutorials/changing-appearance-of-focused-items/} cusomizing focus appearance
         * @ignore Exclude from docs
         * @return Focused element filter
         */
        get: function () {
            /*if (!this._focusFilter) {
                this._focusFilter = new FocusFilter();
                this._disposers.push(this._focusFilter);
            }*/
            //return this._focusFilter;
            var focusFilter = this._focusFilter;
            if (focusFilter) {
                return focusFilter;
            }
            if (this.virtualParent) {
                return this.virtualParent.focusFilter;
            }
            else if (this._parent) {
                return this._parent.focusFilter;
            }
            //this._focusFilter = new FocusFilter();
            //this._disposers.push(this._focusFilter);
        },
        /**
         * @see {@link Filter}
         * @ignore Exclude from docs
         * @todo This is still experimental, don't use it
         */
        set: function (value) {
            this._focusFilter = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "hoverOnFocus", {
        /**
         * @return Trigger hover on focus?
         */
        get: function () {
            return this.getPropertyValue("hoverOnFocus");
        },
        /**
         * If set to `true`, this element will also trigger `"over"` event with all
         * the related consequences, like "hover" state being applied and tooltip
         * being shown.
         *
         * Useful as an accessibility feature to display rollover tooltips on items
         * selected via keyboard.
         *
         * @param value  Trigger hover on focus?
         * @default false
         */
        set: function (value) {
            if (value !== this.hoverOnFocus) {
                this.setPropertyValue("hoverOnFocus", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "tabindex", {
        /**
         * Returns current TAB index for focusable item.
         *
         * @return TAB index
         */
        get: function () {
            var index = this._tabindex;
            if (index != null) {
                return index;
            }
            else if (this.virtualParent) {
                return this.virtualParent.tabindex;
            }
            else if (this._parent) {
                return this._parent.tabindex;
            }
        },
        /**
         * Sets TAB index.
         *
         * Tab index maintains the order in which focusable elements gain focus when
         * TAB key is pressed.
         *
         * Please note, tab index is not local to the chart. It affects the whole
         * of the page, including non-SVG elements. Maintain extreme causion when
         * setting tab indexes, as it affects the user experience for the whole
         * web page.
         *
         * @param value TAB index
         */
        set: function (value) {
            value = toNumber(value);
            if (this.setPropertyValue("tabindex", value) && isNumber(value)) {
                this.interactions.tabindex = value;
                this.setSVGAttribute({ "tabindex": value });
                this._tabindex = value;
                if (value > -1) {
                    this.focusable = true;
                }
                else {
                    this.focusable = undefined;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "inertiaOptions", {
        /**
         * ==========================================================================
         * DRAGGING AND RELATED STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * Returns element's options to be used for inertia. This setting is
         * inheritable, meaning that if not set directly, it will search in all its
         * ascendants until very top.
         *
         * Inertia is used only if element's `inert` is set to `true`.
         *
         * "Inert" element, when dragged and released, will carry the momentum of the
         * movement, and will continue moving in the same drag direction, gradually
         * reducing in speed until finally stops.
         *
         * Check [[IInertiaOptions]] for how you tweak inertia animations.
         *
         * @return Inertia options
         */
        get: function () {
            if (!this.interactions.inertiaOptions) {
                if (this._parent) {
                    return this._parent.inertiaOptions;
                }
            }
            return this.interactions.inertiaOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "draggable", {
        /**
         * @return `true` if element can be dragged
         */
        get: function () {
            return this.getPropertyValue("draggable");
        },
        /**
         * Controls if the element is draggable.
         *
         * @param value  `true` if element can be dragged
         */
        set: function (value) {
            var _this = this;
            value = toBoolean(value);
            if (this.setPropertyValue("draggable", value)) {
                if (!value && !this.isInteractive()) {
                }
                else {
                    this.applyCursorStyle();
                    this.interactions.draggable = value;
                    //interaction.processDraggable(this);
                    // Add events
                    // @todo Maybe attach to InteractionObject's multidisposer so that
                    // sprites events get disposed together with them?
                    // this.interactions.disposers.getItem("movable")
                    // setEventDisposer will also remove listeners if value == false
                    this.interactions.setEventDisposer("sprite-draggable", value, function () { return new Disposer_MultiDisposer([
                        _this.events.on("down", _this.handleDown, _this, false),
                        _this.events.on("dragstart", _this.handleDragStart, _this, false),
                        _this.events.on("drag", _this.handleDragMove, _this, false),
                        _this.events.on("dragstop", _this.handleDragStop, _this, false)
                    ]); });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Executes when dragged element is being started to drag.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.handleDragStart = function (ev) {
        if (!this.interactions.isTouchProtected || !ev.touch) {
            this.interactions.originalPosition = {
                x: this.pixelX,
                y: this.pixelY
            };
            this._isDragged = true;
            this.hideTooltip(0);
        }
    };
    /**
     * Tell this element to start being dragged. This is useful if you want to
     * drag items by interactions performed not directly on the target element.
     *
     * Parameter `pointer` is highly recommended. By passing in the Pointer you
     * will ensure that movement is tracked for the pointer that you want. If not
     * supplied, the system will try to determine the most logical pointer.
     *
     * However this may fail if you have more than one pointer active, which
     * might happen if you have several objects being dragged on a touch device.
     *
     * @ignore Exclude from docs
     * @param pointer Pointer to use for movement
     */
    Sprite.prototype.dragStart = function (pointer) {
        //this.dragStop(pointer);
        //this.draggable = true;
        this._isDragged = true;
        getInteraction().dragStart(this.interactions, pointer);
    };
    /**
     * Executes when dragged element is being dropped.
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype.handleDragStop = function (ev) {
        if (!this.interactions.isTouchProtected || !ev.touch) {
            this._isDragged = false;
            this.showTooltip();
            this.interactions.originalPosition = undefined;
        }
    };
    /**
     * Stops manually initiated dragging of the element.
     *
     * @ignore Exclude from docs
     * @param pointer Pointer to use as a reference
     */
    Sprite.prototype.dragStop = function (pointer, cancelled) {
        //this.draggable = false;
        this._isDragged = false;
        getInteraction().dragStop(this.interactions, pointer, cancelled);
        //this.handleDragStop();
    };
    /**
     * Executes when {Sprite} is being dragged.
     *
     * @ignore Exclude from docs
     * @param ev Event object
     * @todo Implement parent position offset calculation
     */
    Sprite.prototype.handleDragMove = function (ev) {
        if (!this.interactions.isTouchProtected || !ev.touch) {
            var point = this.interactions.originalPosition;
            if (point && this._isDragged) {
                var globalScale = this._parent.globalScale * this.svgContainer.cssScale;
                this.moveTo({ x: point.x + ev.shift.x / globalScale, y: point.y + ev.shift.y / globalScale }, undefined, undefined, true);
            }
            this.dispatchImmediately("dragged", ev);
        }
    };
    Object.defineProperty(Sprite.prototype, "inert", {
        /**
         * @return `true` if element should use inertia when animated
         */
        get: function () {
            return this.getPropertyValue("inert");
        },
        /**
         * Controls if the element should use inertia when interacted with.
         *
         * "Inert" element, when dragged and released, will carry the momentum of the
         * movement, and will continue moving in the same drag direction, gradually
         * reducing in speed until finally stops.
         *
         * @default false
         * @param value `true` if element should use inertia when animated
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.setPropertyValue("inert", value)) {
                if (!value && !this.isInteractive()) {
                    // void
                }
                else {
                    this.interactions.inert = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "hoverOptions", {
        /**
         * ==========================================================================
         * HOVERING
         * ==========================================================================
         * @hidden
         */
        /**
         * Returns Sprite's hover options.
         *
         * @see {@link IHoverOptions} for available options.
         * @return Options
         */
        get: function () {
            if (!this.interactions.hoverOptions) {
                if (this.virtualParent) {
                    return this.virtualParent.hoverOptions;
                }
                if (this._parent) {
                    return this._parent.hoverOptions;
                }
            }
            return this.interactions.hoverOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "hoverable", {
        /**
         * @return `true` if element is hoverable
         */
        get: function () {
            return this.getPropertyValue("hoverable");
        },
        /**
         * Controls if the element is hoverable (hover events are registered).
         *
         * Use `over` and `out` events, to watch for those respective actions.
         *
         * @default false
         * @param value `true` if element can be hovered
         */
        set: function (value) {
            var _this = this;
            value = toBoolean(value);
            if (this.setPropertyValue("hoverable", value)) {
                if (!value && !this.isInteractive()) {
                    // void
                }
                else {
                    this.applyCursorStyle();
                    this.interactions.hoverable = value;
                    // setEventDisposer will also remove listeners if value == false
                    this.interactions.setEventDisposer("sprite-hoverable", value, function () { return new Disposer_MultiDisposer([
                        _this.events.on("over", _this.handleOver, _this, false),
                        _this.events.on("out", _this.handleOut, _this, false),
                    ]); });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handles tasks when element becomes hovered:
     * * Shows [[Tooltip]] if applicable
     * * Applies "hover" state
     *
     * @ignore Exclude from docs
     * @param ev Event object
     */
    Sprite.prototype.handleOver = function (ev) {
        if (this._outTimeout) {
            this._outTimeout.dispose();
        }
        if (this.isHover) {
            if (this.states.hasKey("hover")) {
                //this.setState("hover");
                // This will check `isHover` and will set "hover" state
                if (!this.isHidden) {
                    this.applyCurrentState();
                }
            }
            var point = void 0;
            if (ev && ev.pointer) {
                point = documentPointToSvg(ev.pointer.point, this.svgContainer.SVGContainer, this.svgContainer.cssScale);
            }
            if (this.showTooltipOn == "hover") {
                this.showTooltip(point);
            }
        }
        else {
            if (this.showTooltipOn == "hover") {
                this.hideTooltip();
            }
            if (!this.isHidden && this.states.hasKey("hover")) {
                this.applyCurrentState();
            }
        }
    };
    /**
     * Handles tasks when element loses hover:
     *
     * * Hides [[Tooltip]]
     * * Applies default state
     *
     * @ignore Exclude from docs
     * @param ev [description]
     */
    Sprite.prototype.handleOut = function (ev) {
        var _this = this;
        if (this.tooltip && this.tooltip.targetSprite == this && this.tooltip.keepTargetHover) {
            this._outTimeout = this.setTimeout(function () {
                if (!_this.tooltip.isHover) {
                    if (_this.tooltip.targetSprite == _this) {
                        _this.hideTooltip();
                    }
                    _this._outTimeout = _this.setTimeout(_this.handleOutReal.bind(_this), _this.rollOutDelay);
                }
            }, 10);
            return;
        }
        if (this.showTooltipOn == "hover") {
            this.hideTooltip();
        }
        this._outTimeout = this.setTimeout(this.handleOutReal.bind(this), this.rollOutDelay);
    };
    /**
     * [handleOutReal description]
     *
     * @ignore
     * @todo description
     */
    Sprite.prototype.handleOutReal = function () {
        if (!this.isHidden && !this.isHiding && this.states.hasKey("hover")) {
            this.applyCurrentState();
        }
    };
    Object.defineProperty(Sprite.prototype, "hitOptions", {
        /**
         * ==========================================================================
         * CLICKING/TAPPING AND TOGGLING STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * Returns Sprite's click (hit) options.
         *
         * Click (hit) options control things like double-click, timeouts, etc.
         *
         * @see {@link IHitOptions} for available options.
         * @return Options
         */
        get: function () {
            if (!this.interactions.hitOptions) {
                if (this.virtualParent) {
                    return this.virtualParent.hitOptions;
                }
                if (this._parent) {
                    return this._parent.hitOptions;
                }
            }
            return this.interactions.hitOptions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Prepares element's after `down` event.
     *
     * @ignore Exclude from docs
     * @param ev Event
     */
    Sprite.prototype.handleDown = function (ev) {
        if (this.interactions.downPointers.length === 1) {
            this.interactions.originalPosition = {
                x: this.pixelX,
                y: this.pixelY
            };
            this.interactions.originalAngle = this.rotation;
            this.interactions.originalScale = this.scale;
            if (this.states.hasKey("down")) {
                this.setState("down");
            }
        }
    };
    /**
     * Prepares element's after `up` event.
     *
     * @ignore Exclude from docs
     * @param ev Event
     */
    Sprite.prototype.handleUp = function (ev) {
        var _this = this;
        /*if (!this.isDown) {
            this.interactions.originalPosition = null;
            this.interactions.originalAngle = null;
            this.interactions.originalScale = null;
        }*/
        this._isResized = false;
        if (this.states.hasKey("down")) {
            this.applyCurrentState();
        }
        if (this.showTooltipOn == "hit") {
            this.updateTooltipPosition(ev.pointer.point);
            this._disposers.push(registry.events.once("exitframe", function () {
                _this.showTooltip();
            }));
            this._disposers.push(getInteraction().body.events.once("down", function (ev) {
                _this.hideTooltip();
            }));
        }
    };
    Object.defineProperty(Sprite.prototype, "clickable", {
        /**
         * @return {boolean}
         */
        get: function () {
            return this.getPropertyValue("clickable");
        },
        /**
         * Indicates if the element is clickable.
         *
         * Some type of the elements, like buttons are clickable by default.
         *
         * Most of the elements are not clickable by default.
         *
         * Use `hit`, `doublehit`, `up`, `down`, `toggled` events to watch for
         * respective click/touch actions.
         *
         * @param value `true` if element can be clicked
         */
        set: function (value) {
            var _this = this;
            value = toBoolean(value);
            if (this.setPropertyValue("clickable", value)) {
                if (!value && !this.isInteractive()) {
                    // void
                }
                else {
                    this.applyCursorStyle();
                    this.interactions.clickable = value;
                    // setEventDisposer will also remove listeners if value == false
                    this.interactions.setEventDisposer("sprite-clickable", value, function () { return new Disposer_MultiDisposer([
                        _this.events.on("down", _this.handleDown, _this, false),
                        _this.events.on("up", _this.handleUp, _this, false)
                    ]); });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "togglable", {
        /**
         * @return Is togglable?
         */
        get: function () {
            return this.getPropertyValue("togglable");
        },
        /**
         * Indicates if element can be toggled on and off by subsequent clicks/taps.
         *
         * Togglable element will alternate its `isActive` property between `true`
         * and `false` with each click.
         *
         * @param value Is togglable?
         */
        set: function (value) {
            var _this = this;
            value = toBoolean(value);
            if (this.setPropertyValue("togglable", value)) {
                if (!value && !this.isInteractive()) {
                    // void
                }
                else {
                    // setEventDisposer will also remove listeners if value == false
                    this.interactions.setEventDisposer("sprite-togglable", value, function () { return _this.events.on("hit", _this.handleToggle, _this, false); });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handles toggling of the element.
     *
     * @ignore Exclude from docs
     * @param ev Event
     */
    Sprite.prototype.handleToggle = function (ev) {
        this.isActive = !this.isActive;
    };
    Object.defineProperty(Sprite.prototype, "contextMenuDisabled", {
        /**
         * @return Context menu disabled?
         */
        get: function () {
            return this.getPropertyValue("contextMenuDisabled");
        },
        /**
         * Should element prevent context menu to be displayed, e.g. when
         * right-clicked?
         *
         * @default false
         * @param value Context menu disabled?
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.setPropertyValue("contextMenuDisabled", value)) {
                this.interactions.contextMenuDisabled = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "url", {
        /**
         * @return URL
         */
        get: function () {
            return this.getPropertyValue("url");
        },
        /**
         * Click-through URL for this element.
         *
         * If set, clicking/tapping this element will open the new URL in a target
         * window/tab as set by `urlTarget`.
         *
         * Please note that URL will be parsed by data placeholders in curly
         * brackets, to be populated from data. E.g.:
         *
         * ```TypeScript
         * series.columns.template.url = "https://www.google.com/search?q={category.urlEncode()}";
         * ```
         * ```JavaScript
         * series.columns.template.url = "https://www.google.com/search?q={category.urlEncode()}";
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": [{
         *     // ...
         *     "columns": {
         *       "url": "https://www.google.com/search?q={category.urlEncode()}"
         *     }
         *   }]
         * }
         * ```
         *
         * @param value URL
         */
        set: function (value) {
            if (this.setPropertyValue("url", value)) {
                if (this._urlDisposer) {
                    this._urlDisposer.dispose();
                }
                // If URL is not empty, set up events
                if (isNotEmpty(value)) {
                    this._urlDisposer = this.events.on("hit", this.urlHandler, this, false);
                    // Set other required parameters
                    this.clickable = true;
                    this.cursorOverStyle = MouseCursorStyle.pointer;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "baseId", {
        /**
         * [baseId description]
         *
         * @ignore
         * @return [description]
         */
        get: function () {
            if (!this._baseId && this._parent) {
                this.baseId = this._parent.baseId;
            }
            return this._baseId;
        },
        /**
         * [baseId description]
         *
         * @ignore
         * @param  value  [description]
         */
        set: function (value) {
            this.setBaseId(value);
        },
        enumerable: true,
        configurable: true
    });
    Sprite.prototype.setBaseId = function (value) {
        if (value != this._baseId) {
            if (this.invalid) {
                this.invalid = false;
                registry.removeFromInvalidSprites(this);
                this.invalidate();
            }
            this._baseId = value;
        }
    };
    Object.defineProperty(Sprite.prototype, "baseSprite", {
        /**
         * Returns the mail chart object that this element belongs to.
         *
         * In most cases it will mean the chart object.
         *
         * Can be used to retrieve chart object in various events and adapters.
         *
         * ```TypeScript
         * chart.seriesContainer.events.on("hit", function(ev) {
         *   console.log(ev.target.baseSprite);
         * });
         * ```
         * ```JavaScript
         * chart.seriesContainer.events.on("hit", function(ev) {
         *   console.log(ev.target.baseSprite);
         * });
         * ```
         * ```JSON
         * {
         *   // ...
         *   "seriesContainer": {
         *     "events": {
         *       "hit": function(ev) {
         *         console.log(ev.target.baseSprite);
         *       }
         *     }
         *   }
         * }
         * ```
         *
         * @readonly
         * @return  Base chart object
         */
        get: function () {
            if (this.isBaseSprite) {
                return this;
            }
            else if (this._parent) {
                return this._parent.baseSprite;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "urlTarget", {
        /**
         * @return URL target
         */
        get: function () {
            return this.getPropertyValue("urlTarget");
        },
        /**
         * Target to use for URL clicks:
         *
         * * _blank
         * * _self (default)
         * * _parent
         * * _top
         * * Name of the window/frame
         *
         * Ignored if `url` is not set.
         *
         * @param value URL target
         */
        set: function (value) {
            this.setPropertyValue("urlTarget", value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handles URL transition on element click.
     *
     * @ignore Exclude from docs
     * @param ev An event object
     */
    Sprite.prototype.urlHandler = function (ev) {
        // Is URL set?
        if (isNotEmpty(this.url)) {
            // Proceed to the URL
            var url = this.populateString(this.url);
            if (this.urlTarget === "_self") {
                window.location.href = url;
            }
            else {
                window.open(url, this.urlTarget);
            }
        }
    };
    Object.defineProperty(Sprite.prototype, "swipeOptions", {
        /**
         * ==========================================================================
         * SWIPING GESTURE TRACKING
         * ==========================================================================
         * @hidden
         */
        /**
         * Returns element's swipe gesture options.
         *
         * @return Swipe gesture options
         */
        get: function () {
            if (!this.interactions.swipeOptions) {
                if (this.virtualParent) {
                    return this.virtualParent.swipeOptions;
                }
                if (this._parent) {
                    return this._parent.swipeOptions;
                }
            }
            return this.interactions.swipeOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "swipeable", {
        /**
         * @return Element swipable?
         */
        get: function () {
            return this.getPropertyValue("swipeable");
        },
        /**
         * Controls if element is swipeable.
         *
         * Swipable element will invoke `swipe`, `swipeleft` and `swiperight` events,
         * when quick horizontal drag action is performed with either mouse or touch.
         *
         * Please note that combining swipe and drag is possible, however will incur
         * a slight but noticeable delay in drag start.
         *
         * @param value  Element swipable?
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.setPropertyValue("swipeable", value)) {
                this.applyCursorStyle();
                if (!value && !this.isInteractive()) {
                    // void
                }
                else {
                    this.interactions.swipeable = value;
                }
                //interaction.processSwipeable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "trackable", {
        /**
         * @return Track cursor movement over element?
         */
        get: function () {
            return this.getPropertyValue("trackable");
        },
        /**
         * ==========================================================================
         * POINTER TRACKING
         * ==========================================================================
         * @hidden
         */
        /**
         * Indicates if the element is trackable (mouse position over it is reported to
         * event listeners).
         *
         * Will invoke `track` events whenever pointer (cursor) changes position
         * while over element.
         *
         * Please note, touch devices will also invoke `track` events when touch
         * point is moved while holding down on a trackable element.
         *
         * @param value Track cursor movement over element?
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.setPropertyValue("trackable", value)) {
                if (!value && !this.isInteractive()) {
                    // void
                }
                else {
                    this.applyCursorStyle();
                    this.interactions.trackable = value;
                }
                //interaction.processTrackable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "wheelable", {
        /**
         * @return Mouse wheel events enabled?
         */
        get: function () {
            return this.getPropertyValue("wheelable");
        },
        /**
         * ==========================================================================
         * MOUSE-WHEEL RELATED
         * ==========================================================================
         * @hidden
         */
        /**
         * Indicates if the element can be interacted with mouse wheel.
         *
         * Will invoke `wheel`, `wheelup`, `wheeldown`, `wheelleft`, and `wheelright`
         * events when using mouse wheel over the element.
         *
         * @param value Mouse wheel events enabled?
         */
        set: function (value) {
            if (this.setPropertyValue("wheelable", value)) {
                if (!value && !this.isInteractive()) {
                    // void
                }
                else {
                    this.applyCursorStyle();
                    this.interactions.wheelable = value;
                }
                //interaction.processWheelable(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "resizable", {
        /**
         * @return Element resizable?
         */
        get: function () {
            return this.getPropertyValue("resizable");
        },
        /**
         * ==========================================================================
         * RESIZE
         * ==========================================================================
         * @hidden
         */
        /**
         * Indicates if this element is resizable.
         *
         * Enabling resize will turn on various interactions on the element. Their
         * actual functionality will depend on other properties.
         *
         * If the element also `draggable`, resize will only happen with two points
         * of contact on a touch device.
         *
         * If the element is not draggable, resize can be performed with just one
         * point of contact, touch or mouse.
         *
         * Will invoke `resize` event every time the size of the element changes.
         *
         * @param value  Element resizable?
         */
        set: function (value) {
            var _this = this;
            value = toBoolean(value);
            if (this.setPropertyValue("resizable", value)) {
                if (!value && !this.isInteractive()) {
                    // void
                }
                else {
                    this.applyCursorStyle();
                    this.interactions.resizable = value;
                    // setEventDisposer will also remove listeners if value == false
                    this.interactions.setEventDisposer("sprite-resizable", value, function () { return new Disposer_MultiDisposer([
                        _this.events.on("down", _this.handleDown, _this, false),
                        _this.events.on("resize", _this.handleResize, _this, false)
                    ]); });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handles resize intermediate step.
     *
     * By default this method resizes actual element. Each element, can override
     * this method to implement their own resize logic.
     *
     * @ignore Exclude from docs
     * @param ev Event object
     */
    Sprite.prototype.handleResize = function (ev) {
        if (!this.interactions.isTouchProtected || !ev.touch) {
            this._isResized = true;
            this.scale = this.interactions.originalScale * ev.scale;
            this.validatePosition();
            /*center: (io.draggable
            ? $math.getMidPoint(point1, point2)
            : {
                "x": io.originalPosition.x,
                "y": io.originalPosition.y
            })*/
            //this.moveTo(this.originalPosition.x + ev.shift.x, this.originalPosition.y + ev.shift.y);
            if (this.draggable || this.dragWhileResize) {
                this._isDragged = false;
                var svgPoint1 = documentPointToSvg(ev.point1, this.htmlContainer, this.svgContainer.cssScale);
                var svgPoint2 = documentPointToSvg(ev.point2, this.htmlContainer, this.svgContainer.cssScale);
                var svgMidPoint = getMidPoint(svgPoint1, svgPoint2);
                var parentPoint1 = documentPointToSprite(ev.startPoint1, this._parent);
                var parentPoint2 = documentPointToSprite(ev.startPoint2, this._parent);
                var originalPosition = this.interactions.originalPosition;
                var originalScale = this.interactions.originalScale;
                if (originalPosition) {
                    var spritePoint1 = { x: (parentPoint1.x - originalPosition.x) / originalScale, y: (parentPoint1.y - originalPosition.y) / originalScale };
                    var spritePoint2 = { x: (parentPoint2.x - originalPosition.x) / originalScale, y: (parentPoint2.y - originalPosition.y) / originalScale };
                    var spriteMidPoint = getMidPoint(spritePoint1, spritePoint2);
                    var parentPoint = svgPointToSprite(svgMidPoint, this._parent);
                    this.moveTo({ x: parentPoint.x - spriteMidPoint.x * this.scale, y: parentPoint.y - spriteMidPoint.y * this.scale }, undefined, undefined, true);
                }
            }
        }
    };
    Object.defineProperty(Sprite.prototype, "cursorOptions", {
        /**
         * ==========================================================================
         * MOUSE-RELATED
         * ==========================================================================
         * @hidden
         */
        /**
         * Returns element's cursor options.
         *
         * Cursor options usually define cursor style for various states of the
         * hovered element.
         *
         * Elements inherit `cursorOptions` from their parents if they don't have
         * them set explicitly.
         *
         * @see {@link ICursorOptions} for a list of available options
         * @return Cursor options
         */
        get: function () {
            if (!this.interactions.cursorOptions) {
                if (this.virtualParent) {
                    return this.virtualParent.cursorOptions;
                }
                if (this._parent) {
                    return this._parent.cursorOptions;
                }
            }
            return this.interactions.cursorOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "cursorOverStyle", {
        /**
         * A shortcut to setting mouse cursor on hover.
         *
         * Example:
         *
         * ```TypeScript
         * series.slices.template.cursorOverStyle = am4core.MouseCursorStyle.pointer;
         * ```
         * ```JavaScript
         * series.slices.template.cursorOverStyle = am4core.MouseCursorStyle.pointer;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": {
         *     // ...
         *     "slices": {
         *       "cursorOverStyle": "pointer"
         *     }
         *   }
         * }
         * ```
         *
         * @param style An array of styles to apply onhover
         */
        set: function (style) {
            if (!this.cursorOptions.overStyle) {
                this.interactions.cursorOptions = {
                    defaultStyle: this.cursorOptions.defaultStyle
                };
            }
            this.cursorOptions.overStyle = style;
            getInteraction().applyCursorOverStyle(this.interactions);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "cursorDownStyle", {
        /**
         * A shortcut to setting mouse cursor when button is pressed down.
         *
         * Example:
         *
         * ```TypeScript
         * series.slices.template.cursorDownStyle = am4core.MouseCursorStyle.grabbing;
         * ```
         * ```JavaScript
         * series.slices.template.cursorDownStyle = am4core.MouseCursorStyle.grabbing;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": {
         *     // ...
         *     "slices": {
         *       "cursorDownStyle": "grabbing"
         *     }
         *   }
         * }
         * ```
         *
         * @param style An array of styles to apply onhover
         */
        set: function (style) {
            this.cursorOptions.downStyle = style;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Applies default cursor styles for interactable elements.
     *
     * @ignore Exclude from docs
     * @todo Determine if this is necessary. Maybe let's not apply any cursor styles by default
     */
    Sprite.prototype.applyCursorStyle = function () {
        // Draggable styles
        /*if (this.draggable) {

            if (!$type.hasValue(this.cursorOptions.overStyle)) {
                this.cursorOptions.overStyle = MouseCursorStyle.grab;
            }

            if (!$type.hasValue(this.cursorOptions.downStyle)) {
                this.cursorOptions.downStyle = MouseCursorStyle.grabbing;
            }
        }*/
    };
    Object.defineProperty(Sprite.prototype, "interactionsEnabled", {
        /**
         * @return Is interaction enabled for this element?
         */
        get: function () {
            var value = this.getPropertyValue("interactionsEnabled");
            if (value === false) {
                return false;
            }
            if (this.virtualParent) {
                return this.virtualParent.interactionsEnabled;
            }
            if (this._parent) {
                return this._parent.interactionsEnabled;
            }
            return true;
        },
        /**
         * Setting this to `false` will effectively disable all interactivity on the
         * element.
         *
         * @param value  Is interaction enabled for this element?
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.setPropertyValue("interactionsEnabled", value)) {
                var pointerEvents = null; // must be null, not "null"!
                if (!value) {
                    pointerEvents = "none";
                }
                else {
                    // this is for IE
                    this.group.node.style.pointerEvents = "";
                }
                this.group.node.style.pointerEvents = pointerEvents;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "exporting", {
        /**
         * @return Export instance
         */
        get: function () {
            return this.getExporting();
        },
        /**
         * ==========================================================================
         * EXPORT-RELATED STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * An [[Export]] instance.
         *
         * Used to access API of the chart export functionality.
         *
         * If `exporting` is not set, the element inherits [[Export]] instance from
         * its parents.
         *
         * Upon request, if no parent has such instance, a new one is created, using
         * default settings, what in most cases is just enough.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/exporting/} for more info about exporting
         * @param exp  Export
         */
        set: function (exp) {
            this._exporting.set(exp, exp);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This is here as a method so that inheriting classes could override it.
     *
     * @return Export instance
     */
    Sprite.prototype.getExporting = function () {
        var _export = this._exporting.get();
        if (_export) {
            return _export;
        }
        else {
            if (this.isStandaloneInstance || !this._parent) {
                _export = new Export_Export(this.svgContainer.SVGContainer);
                _export.sprite = this;
                _export.language = this.language;
                _export.numberFormatter = this.numberFormatter;
                _export.dateFormatter = this.dateFormatter;
                _export.durationFormatter = this.durationFormatter;
                this._exporting.set(_export, _export);
            }
            else {
                return this._parent.exporting;
            }
        }
        return _export;
    };
    Object.defineProperty(Sprite.prototype, "exportable", {
        /**
         * @return Export?
         */
        get: function () {
            return this._exportable;
            /*const svgContainer = this.svgContainer;
            return !svgContainer || $array.indexOf(svgContainer.nonExportableSprites, this) == -1;*/
        },
        /**
         * If set to `false` this element will be omitted when exporting the chart
         * to an image.
         *
         * @default true
         * @param value  Export?
         */
        set: function (value) {
            var svgContainer = this.svgContainer;
            this._exportable = value;
            if (svgContainer) {
                if (value) {
                    remove(svgContainer.nonExportableSprites, this);
                }
                else if (indexOf(svgContainer.nonExportableSprites, this) == -1) {
                    svgContainer.nonExportableSprites.push(this);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * ==========================================================================
     * MODAL/POPUP RELATED STUFF
     * ==========================================================================
     * @hidden
     */
    /**
     * Private method to be used for "classPrefix" adapter for modals/popups.
     *
     * @param value  Prefix
     */
    Sprite.prototype.modalPrefix = function (value) {
        value = Options_options.classNamePrefix + value;
        return value;
    };
    Object.defineProperty(Sprite.prototype, "modal", {
        /**
         * Returns a [[Modal]] instance, associated with this chart.
         * (elements top parent)
         *
         * Accessing modal does not make it appear. To make a modal appear, use
         * `showModal()` method.
         *
         * @see {@link Modal} for more information about using Modal windows
         * @return Modal instance
         */
        get: function () {
            var svgContainer = this.svgContainer;
            if (svgContainer) {
                var modal = svgContainer.modal;
                if (!modal.adapter.has("classPrefix", this.modalPrefix)) {
                    modal.adapter.add("classPrefix", this.modalPrefix);
                }
                return modal;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens a modal window with specific content (`text` parameter) and,
     * optionally, `title`.
     *
     * The `text` parameter can contain HTML content.
     *
     * @see {@link Modal} for more information about using Modal windows
     * @param text   Modal contents
     * @param title  Title for the modal window
     */
    Sprite.prototype.openModal = function (text, title) {
        var svgContainer = this.svgContainer;
        if (svgContainer) {
            return svgContainer.openModal(text, title);
        }
    };
    /**
     * Hides modal window if there is one currently open.
     */
    Sprite.prototype.closeModal = function () {
        var svgContainer = this.svgContainer;
        if (svgContainer) {
            svgContainer.closeModal();
        }
    };
    Object.defineProperty(Sprite.prototype, "popups", {
        /**
         * A list of popups for this chart.
         *
         * @return Popups
         */
        get: function () {
            var svgContainer = this.svgContainer;
            if (svgContainer) {
                var popups = svgContainer.popups;
                popups.template.sprite = this;
                if (!popups.template.adapter.has("classPrefix", this.modalPrefix)) {
                    popups.template.adapter.add("classPrefix", this.modalPrefix);
                }
                return popups;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates, opens, and returns a new [[Popup]] window.
     *
     * `text` can be any valid HTML.
     *
     * `title` is currently not supported.
     *
     * @param text   Popup contents
     * @param title  Popup title
     * @return Popup instance
     */
    Sprite.prototype.openPopup = function (text, title) {
        var svgContainer = this.svgContainer;
        if (svgContainer) {
            return svgContainer.openPopup(text, title);
        }
    };
    /**
     * Closes all currently open popup windows
     */
    Sprite.prototype.closeAllPopups = function () {
        var svgContainer = this.svgContainer;
        if (svgContainer) {
            svgContainer.closeAllPopups();
        }
    };
    Object.defineProperty(Sprite.prototype, "x", {
        /**
         * @return X coordinate
         */
        get: function () {
            return this.getPropertyValue("x");
        },
        /**
         * ==========================================================================
         * POSITIONAL PROPERTIES AND RELATED STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * Element's absolute or relative X coordinate.
         *
         * If setting both X and Y, please consider using `moveTo()` method instead,
         * as it will be faster to set both coordinates at once.
         *
         * @param value X coordinate
         */
        set: function (value) {
            if (!this.isDragged) {
                this.setPercentProperty("x", value, false, true, this._positionPrecision, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelX", {
        /**
         * Returns element's current absolute X coordinate in pixels.
         *
         * @readonly
         * @return X coordinate (px)
         */
        get: function () {
            var value = fitToRange(this.getPixelX(this.x), this.minX, this.maxX);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("pixelX", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativeX", {
        /**
         * Returns element's current relative X coordinate in [[Percent]].
         *
         * @return X coordinate ([[Percent]])
         */
        get: function () {
            if (!this._adapterO) {
                return this.getRelativeX(this.x);
            }
            else {
                return this._adapterO.apply("relativeX", this.getRelativeX(this.x));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "minX", {
        /**
         * @ignore Exclude from docs
         * @return Min X (px)
         */
        get: function () {
            return this.getPropertyValue("minX");
        },
        /**
         * The smallest allowable absolute X coordinate for this element.
         *
         * This is used to contain element movement within certain boundaries.
         *
         * @ignore Exclude from docs
         * @param value Min X (px)
         */
        set: function (value) {
            if (isNumber(value)) {
                value = Math_round(value, this._positionPrecision, true);
                this.setPropertyValue("minX", value, false, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "maxX", {
        /**
         * @ignore Exclude from docs
         * @return Max X (px)
         */
        get: function () {
            return this.getPropertyValue("maxX");
        },
        /**
         * The biggest allowable absolute X coordinate for this element.
         *
         * This is used to contain element movement within certain boundaries.
         *
         * @ignore Exclude from docs
         * @param value Max X (px)
         */
        set: function (value) {
            if (isNumber(value)) {
                value = Math_round(value, this._positionPrecision, true);
                this.setPropertyValue("maxX", value, false, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "y", {
        /**
         * @return Y coordinate
         */
        get: function () {
            return this.getPropertyValue("y");
        },
        /**
         * Element's absolute or relative Y coordinate.
         *
         * If setting both X and Y, please consider using `moveTo()` method instead,
         * as it will be faster to set both coordinates at once.
         *
         * @param value  Y coordinate
         */
        set: function (value) {
            if (!this.isDragged) {
                this.setPercentProperty("y", value, false, true, this._positionPrecision, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelY", {
        /**
         * Returns element's current absolute Y coordinate in pixels.
         *
         * @readonly
         * @return Y coordinate (px)
         */
        get: function () {
            var value = fitToRange(this.getPixelY(this.y), this.minY, this.maxY);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("pixelY", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativeY", {
        /**
         * Returns element's current relative Y coordinate in [[Percent]].
         *
         * @readonly
         * @return Y coordinate ([[Percent]])
         */
        get: function () {
            if (!this._adapterO) {
                return this.getRelativeX(this.y);
            }
            else {
                return this._adapterO.apply("relativeY", this.getRelativeX(this.y));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "minY", {
        /**
         * @ignore Exclude from docs
         * @return Min Y (px)
         */
        get: function () {
            return this.getPropertyValue("minY");
        },
        /**
         * The smallest allowable absolute Y coordinate for this element.
         *
         * This is used to contain element movement within certain boundaries.
         *
         * @ignore Exclude from docs
         * @param value Min Y (px)
         */
        set: function (value) {
            if (isNumber(value)) {
                value = Math_round(value, this._positionPrecision, true);
                this.setPropertyValue("minY", value, false, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "maxY", {
        /**
         * @ignore Exclude from docs
         * @return Max Y (px)
         */
        get: function () {
            return this.getPropertyValue("maxY");
        },
        /**
         * The biggest allowable absolute Y coordinate for this element.
         *
         * This is used to contain element movement within certain boundaries.
         *
         * @ignore Exclude from docs
         * @param value  Max Y (px)
         */
        set: function (value) {
            if (isNumber(value)) {
                value = Math_round(value, this._positionPrecision, true);
                this.setPropertyValue("maxY", value, false, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "dx", {
        /**
         * @return Horizontal offset (px)
         */
        get: function () {
            return this.getPropertyValue("dx");
        },
        /**
         * A horizontal offset for the element in pixels.
         *
         * Can be negative value for offset to the left.
         *
         * @param value  Horizontal offset (px)
         */
        set: function (value) {
            if (isNumber(value)) {
                value = Math_round(value, this._positionPrecision, true);
                this.setPropertyValue("dx", value, false, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "dy", {
        /**
         * @return Vertical offset (px)
         */
        get: function () {
            return this.getPropertyValue("dy");
        },
        /**
         * A vertical offset for the element in pixels.
         *
         * Can be negative value for offset upwards.
         *
         * @param value  Vertical offset (px)
         */
        set: function (value) {
            if (isNumber(value)) {
                value = Math_round(value, this._positionPrecision, true);
                this.setPropertyValue("dy", value, false, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "rotation", {
        /**
         * @return Rotation (0-360)
         */
        get: function () {
            return this.getPropertyValue("rotation");
        },
        /**
         * Rotation of the element in degrees. (0-360)
         *
         * Note: For convenience purposes, negative values (for counter-clockwise
         * rotation) and values exceeding 360 can also be used.
         *
         * @param value  Rotation (0-360)
         */
        set: function (value) {
            value = toNumber(value);
            if (!isNumber(value)) {
                value = 0;
            }
            this.setPropertyValue("rotation", value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "align", {
        /**
         * @return Horizontal align
         */
        get: function () {
            return this.getPropertyValue("align");
        },
        /**
         * Controls horizontal alignment of the element.
         *
         * This is used by parent [[Container]] when layouting its children.
         *
         * @param value  Horizontal align
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("align", value)) {
                if (this._parent) {
                    this._parent.invalidateLayout();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "valign", {
        /**
         * @return Vertical align
         */
        get: function () {
            return this.getPropertyValue("valign");
        },
        /**
         * Controls vertical alignment of the element.
         *
         * This is used by parent [[Container]] when layouting its children.
         *
         * @param value  Vertical align
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("valign", value)) {
                if (this._parent) {
                    this._parent.invalidateLayout();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "horizontalCenter", {
        /**
         * @return Horizontal center
         */
        get: function () {
            return this.getPropertyValue("horizontalCenter");
        },
        /**
         * Controls which part of the element to treat as a horizontal center.
         *
         * The setting will be used when positioning, resizing and rotating the
         * element.
         *
         * @param value  Horizontal center
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("horizontalCenter", value)) {
                this.updateCenter();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "verticalCenter", {
        /**
         * @return Vertical center
         */
        get: function () {
            return this.getPropertyValue("verticalCenter");
        },
        /**
         * Controls which part of the element to treat as a vertical center.
         *
         * The setting will be used when positioning, resizing and rotating the
         * element.
         *
         * @param value  Vertical center
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("verticalCenter", value)) {
                this.updateCenter();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "maxWidth", {
        /**
         * @return Maximum width (px)
         */
        get: function () {
            var maxWidth = this.getPropertyValue("maxWidth");
            if (!isNumber(maxWidth)) {
                if (this._parent) {
                    var parentWidth = this._parent.maxWidth;
                    if (this._parent.layout != "absolute" && this.align != "none" && this.align != undefined) {
                        parentWidth = parentWidth - this.pixelMarginLeft - this.pixelMarginRight;
                    }
                    return parentWidth;
                }
            }
            return maxWidth;
        },
        /**
         * ==========================================================================
         * DIMENSIONAL PROPERTIES AND RELATED STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * Maximum allowed width for the element in pixels.
         *
         * @param value  Maximum width (px)
         */
        set: function (value) {
            this.setMaxWidth(value);
        },
        enumerable: true,
        configurable: true
    });
    Sprite.prototype.setMaxWidth = function (value) {
        var prevWidth = this.maxWidth;
        var prevHeight = this.maxHeight;
        if (this.setPropertyValue("maxWidth", value)) {
            if (isNumber(this.relativeWidth)) {
                this.invalidate();
            }
            var event_2 = {
                type: "maxsizechanged",
                target: this,
                previousWidth: prevWidth,
                previousHeight: prevHeight
            };
            this.dispatchImmediately("maxsizechanged", event_2);
        }
    };
    Object.defineProperty(Sprite.prototype, "maxHeight", {
        /**
         * @return Maximum height (px)
         */
        get: function () {
            var maxHeight = this.getPropertyValue("maxHeight");
            if (!isNumber(maxHeight)) {
                if (this._parent) {
                    var parentHeight = this._parent.maxHeight;
                    if (this._parent.layout != "absolute" && this.valign != "none" && this.valign != undefined) {
                        parentHeight = parentHeight - this.pixelMarginTop - this.pixelMarginBottom;
                    }
                    return parentHeight;
                }
            }
            return maxHeight;
        },
        /**
         * Maximum allowed height for the element in pixels.
         *
         * @param value  Maximum height (px)
         */
        set: function (value) {
            this.setMaxHeight(value);
        },
        enumerable: true,
        configurable: true
    });
    Sprite.prototype.setMaxHeight = function (value) {
        var prevWidth = this.maxWidth;
        var prevHeight = this.maxHeight;
        if (this.setPropertyValue("maxHeight", value)) {
            if (isNumber(this.relativeHeight)) {
                this.invalidate();
            }
            var event_3 = {
                type: "maxsizechanged",
                target: this,
                previousWidth: prevWidth,
                previousHeight: prevHeight
            };
            this.dispatchImmediately("maxsizechanged", event_3);
        }
    };
    Object.defineProperty(Sprite.prototype, "minWidth", {
        /**
         * @return Minimum width (px)
         */
        get: function () {
            return this.getPropertyValue("minWidth");
        },
        /**
         * Minimum width of the element in pixels.
         *
         * Set to `undefined` to remove the limit.
         *
         * @param value  Minimum width (px)
         */
        set: function (value) {
            this.setPropertyValue("minWidth", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "minHeight", {
        /**
         * @return Minimum height (px)
         */
        get: function () {
            return this.getPropertyValue("minHeight");
        },
        /**
         * Minimum height for the element in pixels.
         *
         * Set to `undefined` to remove the limit.
         *
         * @param value  Minimum height (px)
         */
        set: function (value) {
            this.setPropertyValue("minHeight", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "width", {
        /**
         * @return Width (absolute or relative)
         */
        get: function () {
            return this.getPropertyValue("width");
        },
        /**
         * Element's absolute or relative width.
         *
         * The width can either be absolute, set in numeric pixels, or relative, set
         * in [[Percent]].
         *
         * Relative width will be calculated using closest measured ancestor
         * [[Container]].
         *
         * @param value  Width (numeric in pixels or relative)
         */
        set: function (value) {
            var changed = this.setPercentProperty("width", value, true, false, this._positionPrecision, true);
            if (changed) {
                this.percentWidth = undefined;
                this.relativeWidth = undefined;
                if (value instanceof Percent) {
                    this.percentWidth = value.percent;
                    if (isNumber(this._pixelWidth)) {
                        this.maxWidth = undefined;
                    }
                    this._pixelWidth = undefined;
                }
                else {
                    this._pixelWidth = Number(value);
                    //this._measuredWidth = this._pixelWidth;
                    this.maxWidth = this._pixelWidth;
                }
                this.invalidatePosition();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "height", {
        /**
         * @return height (absolute or relative)
         */
        get: function () {
            return this.getPropertyValue("height");
        },
        /**
         * Element's absolute or relative height.
         *
         * The height can either be absolute, set in numeric pixels, or relative, set
         * in [[Percent]].
         *
         * Relative height will be calculated using closest measured ancestor
         * [[Container]].
         *
         * @param value  Height (numeric in pixels or relative)
         */
        set: function (value) {
            var changed = this.setPercentProperty("height", value, true, false, this._positionPrecision, true);
            if (changed) {
                this.percentHeight = undefined;
                this._relativeHeight = undefined;
                if (value instanceof Percent) {
                    this.percentHeight = value.percent;
                    if (isNumber(this._pixelHeight)) {
                        this.maxHeight = undefined;
                    }
                    this._pixelHeight = undefined;
                }
                else {
                    this._pixelHeight = Number(value);
                    //this._measuredHeight = this._pixelHeight;
                    this.maxHeight = this._pixelHeight; // yes, we reset maxWidth
                }
                this.invalidatePosition();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelWidth", {
        /**
         * Returns element's width in pixels, if width was set. For actual width use measuredWidth property.
         *
         * @readonly
         * @return Width (px)
         */
        get: function () {
            var width;
            if (isNumber(this.percentWidth)) {
                width = this.maxWidth;
            }
            else if (isNumber(this._pixelWidth)) {
                width = this._pixelWidth;
            }
            else {
                width = 0;
            }
            var minWidth = this.minWidth;
            if (minWidth != null && width < minWidth) {
                width = minWidth;
            }
            var value = Math_round(width, this._positionPrecision, true);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("pixelWidth", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelHeight", {
        /**
         * Returns element's height in pixels. For actual height use measuredHeight property.
         *
         * @readonly
         * @return Height (px)
         */
        get: function () {
            var height;
            if (isNumber(this.percentHeight)) {
                height = this.maxHeight;
            }
            else if (isNumber(this._pixelHeight)) {
                height = this._pixelHeight;
            }
            else {
                height = 0; //this._measuredHeightSelf;
            }
            var minHeight = this.minHeight;
            if (minHeight != null && height < minHeight) {
                height = minHeight;
            }
            var value = Math_round(height, this._positionPrecision, true);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("pixelHeight", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativeWidth", {
        /**
         * @return Relative width
         * @ignore
         */
        get: function () {
            var relativeWidth = this._relativeWidth;
            if (isNumber(relativeWidth)) {
                if (!this._adapterO) {
                    return relativeWidth;
                }
                else {
                    return this._adapterO.apply("relativeWidth", relativeWidth);
                }
            }
        },
        /**
         * Element's relative width in [[Percent]].
         * @ignore
         *
         * @param value  Relative width
         */
        set: function (value) {
            if (this._relativeWidth != value) {
                this._relativeWidth = value;
                //			this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativeHeight", {
        /**
         * @return Relative height
         * @ignore
         */
        get: function () {
            var relativeHeight = this._relativeHeight;
            if (isNumber(relativeHeight)) {
                if (!this._adapterO) {
                    return relativeHeight;
                }
                else {
                    return this._adapterO.apply("relativeHeight", relativeHeight);
                }
            }
        },
        /**
         * Element's relative height in [[Percent]].
         *
         * @param value  Relative height
         * @ignore
         */
        set: function (value) {
            if (this._relativeHeight != value) {
                this._relativeHeight = value;
                //			this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "measuredWidth", {
        /**
         * Returns element's measured width in pixels.
         *
         * A measured width is actual width of contents plus `paddingRight` and* `paddingLeft`, relative to sprite parent, meaning that
         * rotation and scale is taken into account.
         *
         * @readonly
         * @return Width (px)
         */
        get: function () {
            if (this.disabled || this.__disabled) {
                return 0;
            }
            if (!this._adapterO) {
                return this._measuredWidth;
            }
            else {
                return this._adapterO.apply("measuredWidth", this._measuredWidth);
            }
            // it's not good to fit to min/max range as then rotations and scale won't be taken into account
            //return this.adapter.apply("measuredWidth", $math.fitToRange(this._measuredWidth, this.minWidth, this.maxWidth));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "measuredHeight", {
        /**
         * Returns elements's measured height in pixels.
         *
         * A measured height is actual height of contents plus `paddingTop` and `paddingBottom`, relative to sprite parent, meaning that
         * rotation and scale taken into account.
         *
         * @readonly
         * @return Height (px)
         */
        get: function () {
            if (this.disabled || this.__disabled) {
                return 0;
            }
            // it's not good to fit to min/max range as then rotations and scale won't be taken into account
            //return this.adapter.apply("measuredHeight", $math.fitToRange(this._measuredHeight, this.minHeight, this.maxHeight));
            if (!this._adapterO) {
                return this._measuredHeight;
            }
            else {
                return this._adapterO.apply("measuredHeight", this._measuredHeight);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "outerWidth", {
        /**
         * Returns element's measured width plus its left and right margins in
         * pixels.
         *
         * @readonly
         * @return Outer width (px)
         */
        get: function () {
            var value = this.pixelWidth + this.pixelMarginRight + this.pixelMarginLeft;
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("outerWidth", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "outerHeight", {
        /**
         * Returns element's measured height plus its top and bottom margins in
         * pixels.
         *
         * @readonly
         * @return Outer height (px)
         */
        get: function () {
            var value = this.pixelHeight + this.pixelMarginTop + this.pixelMarginBottom;
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("outerHeight", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "innerWidth", {
        /**
         * Returns element's measured inner width in pixels.
         *
         * Inner width is actual available space for content, e.g. element's width
         * minus horizontal padding.
         *
         * @readonly
         * @return Inner width (px)
         */
        get: function () {
            var value = Math.max(0, this.pixelWidth - this.pixelPaddingRight - this.pixelPaddingLeft);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("innerWidth", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "innerHeight", {
        /**
         * Returns element's measured inner height in pixels.
         *
         * Inner height is actual available space for content, e.g. element's height
         * minus vertical padding.
         *
         * @readonly
         * @return Inner height (px)
         */
        get: function () {
            var value = Math.max(0, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("innerHeight", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "globalScale", {
        /**
         * Returns element's current "global" scale.
         *
         * Scale values accumulate over hierarchy of elements.
         *
         * E.g. if a [[Container]] has `scale = 2` and it's child has a `scale = 2`,
         * the child's `globalScale` will be 4. (a multitude of `2 x 2`)
         *
         * @readonly
         * @return Global scale
         */
        get: function () {
            var scale = this.scale;
            if (this._parent) {
                scale = scale * this._parent.globalScale;
            }
            if (!this._adapterO) {
                return scale;
            }
            else {
                return this._adapterO.apply("globalScale", scale);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "scale", {
        /**
         * @return Scale (0-1)
         */
        get: function () {
            return this.getPropertyValue("scale");
        },
        /**
         * Scale of the element.
         *
         * The scale is set from 0 (element reduced to nothing) to 1 (default size).
         * * 2 will mean element is increased twice.
         * * 0.5 - reduced by 50%.
         *
         * Etc.
         *
         * @param value  Scale (0-1)
         */
        set: function (value) {
            value = toNumber(value);
            if (value < 0) {
                value = 0;
            }
            if (value != this.getPropertyValue("scale")) {
                this.setPropertyValue("scale", value, false, true);
                this.handleGlobalScale();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets all four margins for the element at once.
     *
     * Margins are set in pixels.
     *
     * @param top     Top margin
     * @param right   Right margin
     * @param bottom  Bottom margin
     * @param left    Left margin
     * @return Current element
     */
    Sprite.prototype.margin = function (top, right, bottom, left) {
        this.marginTop = top;
        this.marginRight = right;
        this.marginBottom = bottom;
        this.marginLeft = left;
        return this;
    };
    Object.defineProperty(Sprite.prototype, "marginLeft", {
        /**
         * @return Margin value
         */
        get: function () {
            return this.getPropertyValue("marginLeft");
        },
        /**
         * Left margin - absolute (px) or relative ([[Percent]]).
         *
         * @param value  Margin value
         */
        set: function (value) {
            this.setPercentProperty("marginLeft", value, true, true, this._positionPrecision, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "marginRight", {
        /**
         * @return Margin value
         */
        get: function () {
            return this.getPropertyValue("marginRight");
        },
        /**
         * Right margin - absolute (px) or relative ([[Percent]]).
         *
         * @param value  Margin value
         */
        set: function (value) {
            this.setPercentProperty("marginRight", value, true, true, this._positionPrecision, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "marginTop", {
        /**
         * @return Margin value
         */
        get: function () {
            return this.getPropertyValue("marginTop");
        },
        /**
         * Top margin - absolute (px) or relative ([[Percent]]).
         *
         * @param value  Margin value
         */
        set: function (value) {
            this.setPercentProperty("marginTop", value, true, true, this._positionPrecision, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "marginBottom", {
        /**
         * @return Margin value
         */
        get: function () {
            return this.getPropertyValue("marginBottom");
        },
        /**
         * Bottom margin - absolute (px) or relative ([[Percent]]).
         *
         * @param value  Margin value
         */
        set: function (value) {
            this.setPercentProperty("marginBottom", value, true, true, this._positionPrecision, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelMarginRight", {
        /**
         * Returns current right margin in pixels.
         *
         * @readonly
         * @return Right margin (px)
         */
        get: function () {
            var value = this.getPixelX(this.marginRight);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("pixelMarginRight", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativeMarginRight", {
        /**
         * Returns current relative right margin.
         *
         * @readonly
         * @return Relative right margin
         */
        get: function () {
            // @todo Maybe use [[Percent]]?
            var value = this.getRelativeX(this.marginRight);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("relativeMarginRight", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelMarginLeft", {
        /**
         * Returns current left margin in pixels.
         *
         * @readonly
         * @return Left margin (px)
         */
        get: function () {
            var value = this.getPixelX(this.marginLeft);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("pixelMarginLeft", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativeMarginLeft", {
        /**
         * Returns current relative left margin.
         *
         * @readonly
         * @return Relative left margin
         */
        get: function () {
            //@todo Maybe use [[Percent]]?
            var value = this.getRelativeX(this.marginLeft);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("relativeMarginLeft", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelMarginTop", {
        /**
         * Returns current top margin in pixels.
         *
         * @readonly
         * @return Top margin (px)
         */
        get: function () {
            var value = this.getPixelY(this.marginTop);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("pixelMarginTop", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativeMarginTop", {
        /**
         * Returns current relative top margin.
         *
         * @readonly
         * @return Relative top margin
         */
        get: function () {
            // @todo Maybe use [[Percent]]?
            var value = this.getRelativeY(this.marginTop);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("relativeMarginTop", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelMarginBottom", {
        /**
         * Returns current bottom margin in pixels.
         *
         * @readonly
         * @return Bottom margin (px)
         */
        get: function () {
            var value = this.getPixelY(this.marginBottom);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("pixelMarginBottom", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativeMarginBottom", {
        /**
         * Returns current relative bottom margin.
         *
         * @readonly
         * @return Relative bottom margin
         */
        get: function () {
            // @todo Maybe use [[Percent]]?
            var value = this.getRelativeY(this.marginBottom);
            if (!this._adapterO) {
                return value;
            }
            else {
                return this._adapterO.apply("relativeMarginBottom", value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets padding for the element in pixels.
     *
     * @param top     Top padding (px)
     * @param right   Right padding (px)
     * @param bottom  Bottom padding (px)
     * @param left    Left padding (px)
     * @return Element
     */
    Sprite.prototype.padding = function (top, right, bottom, left) {
        this.paddingTop = top;
        this.paddingRight = right;
        this.paddingBottom = bottom;
        this.paddingLeft = left;
        return this;
    };
    Object.defineProperty(Sprite.prototype, "paddingLeft", {
        /**
         * @return Padding value
         */
        get: function () {
            return this.getPropertyValue("paddingLeft");
        },
        /**
         * Left padding - absolute (px) or relative ([[Percent]]).
         *
         * @param value  Padding value
         */
        set: function (value) {
            this.setPercentProperty("paddingLeft", value, true, true, this._positionPrecision, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "paddingRight", {
        /**
         * @return Padding value
         */
        get: function () {
            return this.getPropertyValue("paddingRight");
        },
        /**
         * Right padding - absolute (px) or relative ([[Percent]]).
         *
         * @param value  Padding value
         */
        set: function (value) {
            this.setPercentProperty("paddingRight", value, true, true, this._positionPrecision, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "paddingTop", {
        /**
         * @return Padding value
         */
        get: function () {
            return this.getPropertyValue("paddingTop");
        },
        /**
         * Top padding - absolute (px) or relative ([[Percent]]).
         *
         * @param value  Padding value
         */
        set: function (value) {
            this.setPercentProperty("paddingTop", value, true, true, this._positionPrecision, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "paddingBottom", {
        /**
         * @return Padding value
         */
        get: function () {
            return this.getPropertyValue("paddingBottom");
        },
        /**
         * Bottom padding - absolute (px) or relative ([[Percent]]).
         *
         * @param value  Padding value
         */
        set: function (value) {
            this.setPercentProperty("paddingBottom", value, true, true, this._positionPrecision, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelPaddingRight", {
        /**
         * Returns current right padding in pixels.
         *
         * @readonly
         * @return Right padding (px)
         */
        get: function () {
            return this.getPixelX(this.paddingRight);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativePaddingRight", {
        /**
         * Returns current relative right padding.
         *
         * @readonly
         * @return Relative right padding
         */
        get: function () {
            // @todo Maybe use [[Percent]]?
            return this.getRelativeX(this.paddingRight);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelPaddingLeft", {
        /**
         * Returns current left padding in pixels.
         *
         * @readonly
         * @return Left padding (px)
         */
        get: function () {
            return this.getPixelX(this.paddingLeft);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativePaddingLeft", {
        /**
         * Returns current relative left padding.
         *
         * @readonly
         * @return Relative left padding
         */
        get: function () {
            // @todo Maybe use [[Percent]]?
            return this.getRelativeX(this.paddingLeft);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelPaddingTop", {
        /**
         * Returns current top padding in pixels.
         *
         * @readonly
         * @return Top padding (px)
         */
        get: function () {
            return this.getPixelY(this.paddingTop);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativePaddingTop", {
        /**
         * Returns current relative top padding.
         *
         * @readonly
         * @return Relative top padding
         */
        get: function () {
            // @todo Maybe use [[Percent]]?
            return this.getRelativeY(this.paddingTop);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelPaddingBottom", {
        /**
         * Returns current bottom padding in pixels.
         *
         * @readonly
         * @return Bottom padding (px)
         */
        get: function () {
            return this.getPixelY(this.paddingBottom);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "relativePaddingBottom", {
        /**
         * Returns current relative bottom padding.
         *
         * @readonly
         * @return Relative bottom padding
         */
        get: function () {
            // @todo Maybe use [[Percent]]?
            return this.getRelativeY(this.paddingBottom);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "path", {
        /**
         * @return Path of a Sprite element
         */
        get: function () {
            return this.getPropertyValue("path");
        },
        /**
         * ==========================================================================
         * APPEARANCE-RELATED PROPERTIES AND RELATED STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * Path of Sprite element
         */
        set: function (value) {
            this.setPath(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    Sprite.prototype.setPath = function (value) {
        if (this.setPropertyValue("path", value)) {
            if (this._adapterO) {
                value = this._adapterO.apply("path", value);
            }
            if (!this._isPath) {
                if (!this.element || (this.element.node && !(this.element.node instanceof SVGPathElement))) {
                    this.element = this.paper.add("path");
                }
                this._isPath = true;
            }
            if (hasValue(value)) {
                this.element.attr({ "d": value });
            }
            else {
                this.element.removeAttr("d");
            }
            this.invalidatePosition();
            // otherwise is 0x0
            if (!this.inited) {
                this.events.once("inited", this.validatePosition, this, false);
            }
            return true;
        }
        return false;
    };
    Object.defineProperty(Sprite.prototype, "fillModifier", {
        /**
         * @return Fill color modifier
         */
        get: function () {
            return this.getPropertyValue("fillModifier");
        },
        /**
         * [[ColorModifier]] that can be used to modify color and pattern of the
         * element's fill, e.g. create gradients.
         *
         * @param value  Fill color modifiier
         */
        set: function (value) {
            if (this.setPropertyValue("fillModifier", value)) {
                this.setFill(this.fill);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "strokeModifier", {
        /**
         * @return Stroke color modifier
         */
        get: function () {
            return this.getPropertyValue("strokeModifier");
        },
        /**
         * [[ColorModifier]] that can be used to modify color and pattern of the
         * element's stroke (outline), e.g. create gradients.
         *
         * @param value  Stroke color modifier
         */
        set: function (value) {
            this.setPropertyValue("strokeModifier", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "fillOpacity", {
        /**
         * @return Opacity (0-9)
         */
        get: function () {
            return this.getPropertyValue("fillOpacity");
        },
        /**
         * Element's fill opacity.
         *
         * Opacity ranges from 0 (fully transparent) to 1 (fully opaque).
         *
         * @param value  Opacity (0-1)
         */
        set: function (value) {
            value = toNumberRange(value, 0, 1);
            if (this.setPropertyValue("fillOpacity", value)) {
                this.setSVGAttribute({ "fill-opacity": value });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "fill", {
        /**
         * @return Fill
         */
        get: function () {
            return this.getPropertyValue("fill");
        },
        /**
         * Element's fill color or pattern.
         *
         * @param value  Fill
         */
        set: function (value) {
            this.setFill(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets actual `fill` property on the SVG element, including applicable color
     * modifiers.
     *
     * @ignore Exclude from docs
     * @param value  Fill
     */
    Sprite.prototype.setFill = function (value) {
        if (!isObject(value)) {
            value = toColor(value);
        }
        if (this.setColorProperty("fill", value) || this.fillModifier) {
            // this can not go into next if, as value is turned to Gradient
            if (value instanceof Color_Color) {
                if (this.fillModifier) {
                    value = this.fillModifier.modify(value);
                }
            }
            this.realFill = value;
            // todo: review this place when some Color type will be added
            if (value instanceof Color_Color) {
                this.setSVGAttribute({ "fill": value.toString() });
            }
            else if (!hasValue(value)) {
                this.removeSVGAttribute("fill");
            }
            else if (value instanceof Pattern_Pattern || value instanceof LinearGradient_LinearGradient || value instanceof RadialGradient_RadialGradient) {
                var fill = value;
                fill.paper = this.paper;
                this.setSVGAttribute({ "fill": "url(\"" + getBaseURI() + fill.id + "\")" });
            }
        }
    };
    Object.defineProperty(Sprite.prototype, "opacity", {
        /**
         * @return Opacity (0-1)
         */
        get: function () {
            return this.getPropertyValue("opacity");
        },
        /**
         * Element's opacity.
         *
         * Opacity setting can range from 0 (fully transparent) to 1 (fully opaque).
         *
         * ATTENTION: It is highly not recommended to use `opacity` directly on the
         * element. The charts use `opacity` to hide/show elements, so your setting
         * might be lost if element is hidden and then later shown.
         *
         * Instead use methods `hide()` and `show()` to completely toggle off and on
         * the element.
         *
         * Or, use properties `fillOpacity` and `strokeOpacity`, if you need to make
         * the element semi-transparent.
         *
         * @param value Opacity (0-1)
         */
        set: function (value) {
            value = toNumberRange(value, 0, 1);
            if (this.setPropertyValue("opacity", value)) {
                this.setSVGAttribute({ "opacity": value });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "stroke", {
        /**
         * @return Stroke setting
         */
        get: function () {
            return this.getPropertyValue("stroke");
        },
        /**
         * Element's stroke (outline) color or pattern.
         *
         * @param value  Stroke setting
         */
        set: function (value) {
            this.setStroke(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets actual `stroke` property on the SVG element, including applicable
     * color modifiers.
     *
     * @ignore Exclude from docs
     * @param value Stroke setting
     */
    Sprite.prototype.setStroke = function (value) {
        if (!isObject(value)) {
            value = toColor(value);
        }
        if (this.setColorProperty("stroke", value) || this.strokeModifier) {
            // this can not go into next if, as value is turned to Gradient
            if (value instanceof Color_Color) {
                if (this.strokeModifier) {
                    value = this.strokeModifier.modify(value);
                }
            }
            this.realStroke = value;
            if (value instanceof Color_Color) {
                if (value.hex == "none") {
                    this.removeSVGAttribute("stroke");
                }
                else {
                    this.setSVGAttribute({ "stroke": value.toString() });
                }
            }
            else if (!hasValue(value)) {
                this.removeSVGAttribute("stroke");
            }
            else if (value instanceof Pattern_Pattern || value instanceof LinearGradient_LinearGradient || value instanceof RadialGradient_RadialGradient) {
                var stroke = value;
                stroke.paper = this.paper;
                this.setSVGAttribute({ "stroke": "url(\"" + getBaseURI() + stroke.id + "\")" });
            }
        }
    };
    Object.defineProperty(Sprite.prototype, "strokeOpacity", {
        /**
         * @return Opacity (0-1)
         */
        get: function () {
            return this.getPropertyValue("strokeOpacity");
        },
        /**
         * Stroke (outline) opacity.
         *
         * The values may range from 0 (fully transparent) to 1 (fully opaque).
         *
         * @param value  Opacity (0-1)
         */
        set: function (value) {
            value = toNumberRange(value, 0, 1);
            if (this.setPropertyValue("strokeOpacity", value)) {
                this.setSVGAttribute({ "stroke-opacity": value });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "nonScalingStroke", {
        /**
         * @return Do not scale stroke (outline)
         */
        get: function () {
            return this.getPropertyValue("nonScalingStroke");
        },
        /**
         * Controls if the element's stroke (outline) should remain keep constant
         * thicnkess and do not scale when the whole element is resized.
         *
         * @param value  Do not scale stroke (outline)
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.setPropertyValue("nonScalingStroke", value)) {
                this.strokeWidth = this.strokeWidth;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "nonScaling", {
        /**
         * @return Is element scaleable?
         */
        get: function () {
            return this.getPropertyValue("nonScaling");
        },
        /**
         * Controls if element should keep constant size and not scale even if there is
         * space available, or it does not fit.
         *
         * @param value  Is element scaleable?
         */
        set: function (value) {
            // @todo Description (review)
            value = toBoolean(value);
            this.setPropertyValue("nonScaling", value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "strokeWidth", {
        /**
         * @return Thickness (px)
         */
        get: function () {
            return this.getPropertyValue("strokeWidth");
        },
        /**
         * Stroke (outline) thickness in pixels.
         *
         * @param value  Thickness (px)
         */
        set: function (value) {
            value = toNumber(value);
            this.setPropertyValue("strokeWidth", value, true);
            if (this.nonScalingStroke) {
                if (!isNumber(value)) {
                    value = 1;
                }
                value = value / this.globalScale;
            }
            this.setSVGAttribute({ "stroke-width": value });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "strokeDasharray", {
        /**
         * @return `stroke-dasharray`
         */
        get: function () {
            return this.getPropertyValue("strokeDasharray");
        },
        /**
         * A `stroke-dasharray` for the stroke (outline).
         *
         * "Dasharray" allows setting rules to make lines dashed, dotted, etc.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more info on `stroke-dasharray`
         * @param value  `stroke-dasharray`
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("strokeDasharray", value)) {
                this.setSVGAttribute({ "stroke-dasharray": value });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "strokeDashoffset", {
        /**
         * @return `stroke-dashoffset`
         */
        get: function () {
            return this.getPropertyValue("strokeDashoffset");
        },
        /**
         * A `stroke-dashoffset` for the stroke (outline).
         *
         * "Dashoffset" allows setting the start position of the dashes if
         * `strokeDasharray` is used.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dashoffset} for more info on `stroke-dashoffset`
         * @param value  `stroke-dashoffset`
         */
        set: function (value) {
            value = toNumber(value);
            if (this.setPropertyValue("strokeDashoffset", value)) {
                this.setSVGAttribute({ "stroke-dashoffset": value });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "strokeLinecap", {
        /**
         * @return `stroke-linecap`
         */
        get: function () {
            return this.getPropertyValue("strokeLinecap");
        },
        /**
         * A `stroke-linecap` to indicate how line ends are drawn.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes#Stroke} for more info on `stroke-linecap`
         * @param value  `stroke-linecap`
         */
        set: function (value) {
            if (this.setPropertyValue("strokeLinecap", value)) {
                this.setSVGAttribute({ "stroke-linecap": value });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "strokeLinejoin", {
        /**
         * @return `stroke-linejoin`
         */
        get: function () {
            return this.getPropertyValue("strokeLinejoin");
        },
        /**
         * A `stroke-linejoin` to indicate how line ends are drawn.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes#Stroke} for more info on `stroke-linejoin`
         * @param value  `stroke-linejoin`
         */
        set: function (value) {
            if (this.setPropertyValue("strokeLinejoin", value)) {
                this.setSVGAttribute({ "stroke-linejoin": value });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "shapeRendering", {
        /**
         * @return 'shape-rendering' value
         */
        get: function () {
            return this.getPropertyValue("shapeRendering");
        },
        /**
         * An SVG-specific `shape-rendering` value.
         *
         * `shape-rendering` controls how vector graphics are drawn and rendered.
         *
         * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering} for more information about `shape-rendering`
         * @default "auto"
         * @param value  'shape-rendering' value
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("shapeRendering", value)) {
                this.setSVGAttribute({ "shape-rendering": value });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "pixelPerfect", {
        /**
         * @return Use pixel perfect?
         */
        get: function () {
            return this.getPropertyValue("pixelPerfect");
        },
        /**
         * Controls if SVG vectors should be drawn with "pixel" precision, producing
         * perfectly crisp lines on retina displays.
         *
         * Setting this to `true` might improve visual quality, but may have a
         * negative effect on performance.
         *
         * Different elements use different default setting for `pixelPerfect`.
         *
         * We recommend leaving this at their default settings, unless there's a
         * specific need.
         *
         * @param value  Use pixel perfect?
         */
        set: function (value) {
            value = toBoolean(value);
            if (value) {
                this._positionPrecision = 0;
            }
            else {
                this._positionPrecision = 3;
            }
            this.setPropertyValue("pixelPerfect", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "rtl", {
        /**
         * @return RTL?
         */
        get: function () {
            if (hasValue(this._rtl)) {
                return this._rtl;
            }
            else if (this._topParent) {
                return this._topParent.rtl;
            }
            //this.rtl = false;
            return false;
        },
        /**
         * An RTL (right-to-left) setting.
         *
         * RTL may affect alignment, text, and other visual properties.
         *
         * If you set this on a top-level chart object, it will be used for all
         * child elements, e.g. labels, unless they have their own `rtl` setting
         * set directly on them.
         *
         * @param value  `true` for to use RTL
         */
        set: function (value) {
            value = toBoolean(value);
            if (this.isBaseSprite) {
                this.topParent.rtl = value;
            }
            this._rtl = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * ==========================================================================
     * VISIBILITY AND ORDER PROPERTIES AND RELATED STUFF
     * ==========================================================================
     * @hidden
     */
    /**
     * Reveals hidden element.
     *
     * Has no effect if element is already visible.
     *
     * If `duration` is not specified, it will use default.
     *
     * @param duration  Fade in duration (ms)
     * @return Animation object if such object was created
     */
    Sprite.prototype.show = function (duration) {
        return this.showReal(duration);
    };
    /**
     * Performs actual operations to reveal this element.
     *
     * @ignore Exclude from docs
     * @param duration Fade in duration (ms)
     * @return Fade in duration (ms)
     */
    Sprite.prototype.showReal = function (duration) {
        var _this = this;
        if (this.preventShow) {
            return;
        }
        var transition;
        var properties = this.defaultState.properties;
        if (!this.disabled && (this.isHidden || !this.visible || this.isHiding || (properties.opacity != null && this.opacity < properties.opacity && !this.isShowing)) && !this.isDisposed()) {
            // helps to avoid flicker, as show might change opacity or visibility but item might be at invalid state/position
            if (this.invalid) {
                this.validate();
            }
            if (this.positionInvalid) {
                this.validatePosition();
            }
            if (!isNumber(duration)) {
                duration = this.defaultState.transitionDuration;
            }
            if (this._hideAnimation) {
                this._hideAnimation.kill();
                this._hideAnimation = undefined;
            }
            // Cancel hide handler just in case it was there
            if (this._showHideDisposer) {
                this.removeDispose(this._showHideDisposer);
            }
            this._isHidden = false;
            this.isHiding = false;
            this.isShowing = true;
            // Apply current state
            transition = this.applyCurrentState(duration);
            if (transition && !transition.isFinished()) {
                this._showHideDisposer = transition.events.on("animationended", function () {
                    _this.isShowing = false;
                });
                this._disposers.push(this._showHideDisposer);
            }
            else {
                this.isShowing = false;
            }
            // Make it visible
            var visible = this.defaultState.properties.visible;
            if (!hasValue(visible)) {
                visible = true;
            }
            this.visible = visible;
            // Unhide from screen readers
            this.readerHidden = false;
            // Dispatch "show" event
            this.dispatchImmediately("shown");
        }
        return transition;
    };
    /**
     * Initiates hiding of Sprite.
     * When called it will fade out the the Sprite to transparency, then make it
     * invisible.
     * @param duration Duration in millisecons
     */
    /**
     * Hides the element, by applying `hidden` state.
     *
     * Has no effect if element is already hidden.
     *
     * If `duration` is not specified, it will use default.
     *
     * While element is fading out, its `isHiding` property will resolve to
     * `true`.
     *
     * When element is hidden, its `visible` property will resolve to `false`.
     *
     * @param duration  Fade out duration (ms)
     * @return hide Animation object if such object was created
     */
    Sprite.prototype.hide = function (duration) {
        return this.hideReal(duration);
    };
    /**
     * Hides actual SVG elements and handles hiding animations.
     *
     * @param duration  Fade out duration (ms)
     * @return Fade out duration (ms)
     * @ignore
     */
    Sprite.prototype.hideReal = function (duration) {
        var _this = this;
        var transition;
        if (!this.isHiding && this.visible && !this.isDisposed()) {
            // added to solve 51375
            if (this.tooltip && this.tooltip.currentSprite == this) {
                this.hideTooltip(0);
            }
            if (this._hideAnimation) {
                this._hideAnimation.kill();
                this._hideAnimation = undefined;
            }
            this.isShowing = false;
            // Cancel hide handler just in case it was there
            if (this._showHideDisposer) {
                this.removeDispose(this._showHideDisposer);
            }
            // Get state
            var hiddenState = this.hiddenState;
            // Transition to "hidden" state, provided Sprite has one set
            if (hiddenState) {
                // Yes, we have a "hidden" state
                // `setState` will return an `Animation` object which we can set
                // events on
                transition = this.setState(hiddenState, duration, undefined);
                if (transition && !transition.isFinished()) {
                    this._hideAnimation = transition;
                    this._showHideDisposer = transition.events.on("animationended", function () {
                        _this.isHiding = false;
                        _this._isHidden = true;
                    }, this);
                    this._disposers.push(this._showHideDisposer);
                    // Thrown everything into `_disposers` just in case Sprite gets
                    // destroyed in the meantime
                    this._disposers.push(transition);
                }
                else {
                    this.isHiding = false;
                    this._isHidden = true;
                }
            }
            else {
                // No hidden state, let's just set `visible` and call it a day
                this.visible = false;
                this.isHiding = false;
                this._isHidden = true;
            }
            // Hide from screen readers
            this.readerHidden = true;
            // Dispach "hidden" event
            this.dispatchImmediately("hidden");
            this.invalidate(); // hide it at once to avoid flickers // validate() causes SO
        }
        if (!isNumber(duration)) {
            duration = this.hiddenState.transitionDuration;
        }
        return transition;
    };
    Object.defineProperty(Sprite.prototype, "visible", {
        /**
         * Returns current visibility of the element.
         *
         * @return Visible?
         */
        get: function () {
            return this.getVisibility();
        },
        /**
         * Sets visibility of the element.
         *
         * @param value Visible?
         */
        set: function (value) {
            value = toBoolean(value);
            this.setVisibility(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns visibility value
     * @ignore
     */
    Sprite.prototype.getVisibility = function () {
        var value = this.getPropertyValue("visible");
        if (!hasValue(value)) {
            value = true;
        }
        return value;
    };
    /**
     * Sets `visibility` property:
     *
     * * `true` - visible
     * * `false` - hidden
     *
     * @param value  true - visible, false - hidden
     * @return Current visibility
     */
    Sprite.prototype.setVisibility = function (value) {
        if (this.setPropertyValue("visible", value)) {
            if (value) {
                this.group.removeAttr("visibility");
            }
            else {
                this.group.attr({ "visibility": "hidden" });
            }
            //this.invalidatePosition();
            if (this.events.isEnabled("visibilitychanged")) {
                var event_4 = {
                    type: "visibilitychanged",
                    target: this,
                    visible: value
                };
                this.events.dispatchImmediately("visibilitychanged", event_4);
            }
        }
    };
    Object.defineProperty(Sprite.prototype, "zIndex", {
        /**
         * @return zIndex
         */
        get: function () {
            return this.getPropertyValue("zIndex");
        },
        /**
         * A "zIndex" of the element.
         *
         * "zIndex" determines the order of how elements are placed over each other.
         *
         * Higher "zIndex" will mean the element will be draw on top of elements
         * with lower "zIndexes".
         *
         * @param value  zIndex
         */
        set: function (value) {
            value = toNumber(value);
            if (this.setPropertyValue("zIndex", value)) {
                this.dispatch("zIndexChanged");
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Moves the element to the very top in element order, so that it appears
     * in front of other elements.
     */
    Sprite.prototype.toFront = function () {
        var parent = this._parent;
        if (parent && parent.children.indexOf(this) != parent.children.length - 1) {
            parent.children.moveValue(this, parent.children.length - 1);
            this.dispatch("zIndexChanged");
        }
    };
    /**
     * Moves the element to the very bottom in the element order, so that it
     * appears behind other elements.
     */
    Sprite.prototype.toBack = function () {
        var parent = this._parent;
        if (parent && parent.children.indexOf(this) != 0) {
            parent.children.moveValue(this, 0);
            this.dispatch("zIndexChanged");
        }
    };
    Object.defineProperty(Sprite.prototype, "userClassName", {
        /**
         * @return Class name
         */
        get: function () {
            return this.getPropertyValue("userClassName");
        },
        /**
         * A custom class name to set on the element.
         *
         * If set, the value will be added to element's `class` attribute.
         *
         * @since 4.9.11
         * @param  value  Class name
         */
        set: function (value) {
            if (this.setPropertyValue("userClassName", value)) {
                if (!value && this.userClassName) {
                    this.group.removeClass(this.userClassName);
                }
                this.setClassName();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "tooltip", {
        /**
         * @return Tooltip
         */
        get: function () {
            if (this._tooltip) {
                return this._tooltip;
            }
            else if (this.virtualParent) {
                return this.virtualParent.tooltip;
            }
            else if (this._parent) {
                return this._parent.tooltip;
            }
        },
        /**
         * ==========================================================================
         * TOOLTIP-RELATED PROPERTIES STUFF
         * ==========================================================================
         * @hidden
         */
        /**
         * A [[Tooltip]] object to be used when displayed rollover information for
         * the element.
         *
         * @param tooltip  Tooltip
         */
        set: function (tooltip) {
            if (this._tooltip) {
                //this._tooltip.dispose();
                this.removeDispose(this._tooltip);
            }
            this._tooltip = tooltip;
            if (tooltip) {
                tooltip.parent = this.tooltipContainer;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "tooltipDataItem", {
        /**
         * @return Tooltip data item
         */
        get: function () {
            var tooltipDataItem = this._tooltipDataItem;
            if (tooltipDataItem) {
                return tooltipDataItem;
            }
            else {
                return this.dataItem;
            }
        },
        /**
         * A [[DataItem]] to use when populating content for the element's
         * [[Tooltip]].
         *
         * @see {@link Tooltip}
         * @see {@link DataItem}
         * @param value  Tooltip data item
         */
        set: function (value) {
            // important: do not dispose tooltip dataItem, as it is some actual data item from data!
            this._tooltipDataItem = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "tooltipColorSource", {
        /**
         * @return Tooltip color source
         */
        get: function () {
            return this._tooltipColorSource;
        },
        /**
         * A [[Sprite]] or sprite template to use when getting colors for tooltip. If a template is set,
         * tooltip will look for a clone in tooltipDataItem.sprites. If no clone is found, then template colors will be used.
         *
         * @see {@link Tooltip}
         * @see {@link Sprite}
         * @param sprite Sprite
         */
        set: function (sprite) {
            this._tooltipColorSource = sprite;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows the element's [[Tooltip]].
     *
     * A tooltip will be populated using text templates in either `tooltipHTML` or
     * `tooltipText` as well as data in `tooltipDataItem`.
     *
     * @see {@link Tooltip}
     * @param optional point (sprite-related) to which tooltip must point.
     * @return returns true if the tooltip was shown and false if it wasn't (no text was found)
     */
    Sprite.prototype.showTooltip = function (point) {
        if (this.showTooltipOn == "always" && !this._tooltip && this.tooltip) {
            this._tooltip = this.tooltip.clone();
        }
        if (!point && this.tooltipPosition == "pointer" && this.isHover) {
            point = documentPointToSvg(getInteraction().lastPointer.point, this.svgContainer.SVGContainer, this.svgContainer.cssScale);
        }
        // do not show if hidden
        var sprite = this;
        while (sprite != undefined) {
            if (!sprite.visible || sprite.disabled || sprite.__disabled) {
                if (this._tooltip && this._tooltip.visible) {
                    this._tooltip.hide(0);
                }
                return;
            }
            sprite = sprite.parent;
        }
        if (hasValue(this.tooltipText) || hasValue(this.tooltipHTML)) {
            var tooltip = this.tooltip;
            var tooltipDataItem = this.tooltipDataItem;
            if (tooltip) {
                tooltip.targetSprite = this;
                var colorSource_1 = this;
                var tooltipColorSource_1 = this.tooltipColorSource;
                if ((tooltip.getStrokeFromObject || tooltip.getFillFromObject) && tooltipColorSource_1) {
                    if (tooltipColorSource_1.isTemplate) {
                        if (tooltipDataItem) {
                            eachContinue(tooltipDataItem.sprites, function (sprite) {
                                if (sprite.clonedFrom == tooltipColorSource_1) {
                                    colorSource_1 = sprite;
                                    return false;
                                }
                                return true;
                            });
                        }
                    }
                    else {
                        colorSource_1 = tooltipColorSource_1;
                    }
                }
                if (tooltip.getStrokeFromObject) {
                    var stroke = this.stroke;
                    var source = colorSource_1;
                    while (source.parent != undefined) {
                        stroke = source.stroke;
                        if (stroke == undefined) {
                            source = source.parent;
                        }
                        if (stroke != undefined) {
                            break;
                        }
                    }
                    if (stroke instanceof Color_Color) {
                        tooltip.background.animate({ property: "stroke", to: stroke }, tooltip.animationDuration);
                    }
                    else {
                        tooltip.background.stroke = stroke;
                    }
                }
                // Set data item
                tooltip.dataItem = tooltipDataItem;
                tooltip.label.populateStringFrom = this;
                if (tooltip.getFillFromObject) {
                    var fill = this.fill;
                    var source = colorSource_1;
                    while (source.parent != undefined) {
                        fill = source.fill;
                        if (fill == undefined || (fill instanceof Color_Color && fill.rgb == undefined)) {
                            source = source.parent;
                        }
                        else if (fill != undefined) {
                            break;
                        }
                    }
                    if (fill == undefined) {
                        fill = Color_color("#000000");
                    }
                    if (fill instanceof Color_Color) {
                        if (!tooltip.visible) {
                            tooltip.background.fill = fill;
                        }
                        else {
                            tooltip.background.animate({ property: "fill", to: fill }, tooltip.animationDuration);
                        }
                    }
                    else {
                        tooltip.background.fill = fill;
                    }
                    if (tooltip.autoTextColor && fill instanceof Color_Color) {
                        tooltip.label.fill = fill.alternative;
                    }
                }
                // Apply tooltip text
                var text = "";
                if (this.tooltipHTML) {
                    tooltip.html = this.tooltipHTML;
                    text = this.tooltipHTML;
                }
                if (this.tooltipText) {
                    tooltip.text = this.tooltipText;
                    text = this.tooltipText;
                }
                if (this.updateTooltipPosition(point)) {
                    // Set accessibility option
                    tooltip.readerDescribedBy = this.uidAttr();
                    // make label to render to be able to check currentText
                    if (tooltip.label.invalid) {
                        tooltip.label.validate();
                    }
                    if (text != undefined && text != "" && tooltip.label.currentText != "") {
                        //@todo: think of how to solve this better
                        if (tooltip && !tooltip.parent) {
                            tooltip.parent = this.tooltipContainer;
                        }
                        // Reveal tooltip
                        // showing it in 1 ms helps to avoid strange flickering in IE
                        var duration = tooltip.defaultState.transitionDuration;
                        if (duration <= 0) {
                            duration = 1;
                        }
                        tooltip.show(duration);
                        tooltip.currentSprite = this;
                        return true;
                    }
                    else {
                        this.hideTooltip(0);
                    }
                }
                else {
                    this.hideTooltip(0);
                }
            }
        }
        return false;
    };
    /**
     * @ignore
     */
    Sprite.prototype.updateTooltipPosition = function (point) {
        var _this = this;
        if (this.tooltipPosition == "pointer") {
            if (this._interactionDisposer) {
                this._interactionDisposer.dispose();
            }
            this._interactionDisposer = getInteraction().body.events.on("track", function (ev) {
                return _this.pointTooltipTo(documentPointToSvg(ev.point, _this.svgContainer.SVGContainer, _this.svgContainer.cssScale), true);
            });
            if (point) {
                return this.pointTooltipTo(point, true);
            }
        }
        else {
            // Point to the X/Y of this Sprite
            var globalPoint = spritePointToSvg({
                "x": this.getTooltipX(),
                "y": this.getTooltipY()
            }, this);
            return this.pointTooltipTo(globalPoint);
        }
    };
    /**
     * Sets the point the [[Tooltip]] should point to.
     *
     * @param point      Coordinates to point to
     * @param instantly  Move instantly without animation
     */
    Sprite.prototype.pointTooltipTo = function (point, instantly) {
        var tooltip = this.tooltip;
        if (tooltip && this.topParent) {
            if (tooltip.showInViewport) {
                tooltip.pointTo(point, instantly);
                return true;
            }
            if (isInRectangle(point, { x: 0, y: 0, width: this.topParent.maxWidth, height: this.topParent.maxHeight })) {
                tooltip.pointTo(point, instantly);
                return true;
            }
        }
        return false;
    };
    /**
     * Hides element's [[Tooltip]].
     *
     * @see {@link Tooltip}
     */
    Sprite.prototype.hideTooltip = function (duration) {
        if (this.showTooltipOn == "always") {
            return;
        }
        var tooltip = this.tooltip;
        if (tooltip) {
            if (tooltip.targetSprite == this) {
                tooltip.targetSprite = undefined;
            }
            tooltip.hide(duration);
            if (this._interactionDisposer) {
                this._interactionDisposer.dispose();
                this._interactionDisposer = undefined;
            }
        }
    };
    Object.defineProperty(Sprite.prototype, "tooltipHTML", {
        /**
         * @return Tooltip HTML content template
         */
        get: function () {
            return this.getPropertyValue("tooltipHTML");
        },
        /**
         * An HTML template to be used to populate [[Tooltip]] contents.
         *
         * If element has `tooltipDataItem` or `dataItem` set, this will be parsed
         * for any data values to be replaced with the values from respective data
         * items.
         *
         * @param value Tooltip HTML content template
         */
        set: function (value) {
            value = toText(value);
            this.hoverable = true;
            if (this.setPropertyValue("tooltipHTML", value)) {
                if (this.tooltip) {
                    if (this.tooltip.visible) {
                        this.showTooltip();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "tooltipText", {
        /**
         * @return Tooltip content template
         */
        get: function () {
            return this.getPropertyValue("tooltipText");
        },
        /**
         * A text template to be used to populate Tooltip's contents.
         *
         * If element has `tooltipDataItem` or `dataItem` set, this will be parsed
         * for any data values to be replaced with the values from respective data
         * items.
         *
         * This template will also be parsed for any special formatting tags.
         *
         * @param value Tooltip content template
         * @see {@link TextFormatter}
         */
        set: function (value) {
            value = toText(value);
            if (value) {
                this.hoverable = true;
            }
            if (this.setPropertyValue("tooltipText", value)) {
                if (this.tooltip) {
                    if (this.tooltip.visible) {
                        this.showTooltip();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "tooltipContainer", {
        /**
         * @ignore Exclude from docs
         * @return Container
         */
        get: function () {
            if (this._tooltipContainer) {
                return this._tooltipContainer;
            }
            else if (this._parent) {
                return this._parent.tooltipContainer;
            }
        },
        /**
         * A container reference that should be used to place element's
         * [[Tooltip]] in.
         *
         * Will use parent's container if does not have one set.
         *
         * @ignore Exclude from docs
         * @param value Container
         * @todo Dispose of the old _tooltipContainer ?
         */
        set: function (value) {
            this._tooltipContainer = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "tooltipX", {
        /**
         * @return Tooltip X (px)
         */
        get: function () {
            return this.getTooltipX();
        },
        /**
         * X coordinate the [[Tooltip]] should be shown at.
         *
         * @param value  Tooltip X (px)
         */
        set: function (value) {
            if (this.setPercentProperty("tooltipX", value) && this.tooltip) {
                this.tooltip.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "alwaysShowTooltip", {
        /**
         * @return Always show tooltip?
         */
        get: function () {
            return this.getPropertyValue("showTooltipOn") == "always";
        },
        /**
         * DEPRECATION NOTICE: This setting is deprecated in favor of a more flexible
         * setting: `showTooltipOn`. Please use `showTooltipOn = "always"` instead.
         *
         * Indicates if this element should display a tooltip permanently.
         *
         * Useful, if you want to show permanent tooltips on some items.
         *
         * @default false
         * @since 4.5.4
         * @deprecated Use `showTooltipOn = "always"` instead
         * @param  value  Always show tooltip?
         */
        set: function (value) {
            value = toBoolean(value);
            if (value) {
                this.showTooltipOn = "always";
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "showTooltipOn", {
        /**
         * @return When to show tooltip
         */
        get: function () {
            return this.getPropertyValue("showTooltipOn");
        },
        /**
         * Indicates when tooltip needs to be shown on this element:
         *
         * * `"hover"` (default) - Tooltip will be shown when element is hovered on.
         * * `"hit"` - Tooltip will be shown when element is clicked/tapped. Tooltip will be hidden when clicked/tapped anywhere else.
         * * `"always"` - Tooltip will be shown on the element permanently.
         *
         * For example, if you would like to show tooltips on all of the columns of
         * a [[ColumnSeries]]:
         *
         * ```TypeScript
         * series.columns.template.showTooltipOn = "always";
         * ```
         * ```JavaScript
         * series.columns.template.showTooltipOn = "always";
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": [{
         *     // ...
         *     "columns": {
         *       "showTooltipOn": "always"
         *     }
         *   }]
         * }
         * ```
         *
         * It can even be set to display on a selected columns via `propertyFields`:
         *
         * ```TypeScript
         * series.columns.template.propertyFields.showTooltipOn = "tooltip";
         * ```
         * ```JavaScript
         * series.columns.template.propertyFields.showTooltipOn = "tooltip";
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": [{
         *     // ...
         *     "columns": {
         *       "propertyFields": {
         *         "showTooltipOn": "tooltip"
         *       }
         *     }
         *   }]
         * }
         * ```
         *
         * @default "hover"
         * @since 4.7.9
         * @param  value  When to show tooltip
         */
        set: function (value) {
            if (this.setPropertyValue("showTooltipOn", value)) {
                if (value == "hit") {
                    this.clickable = true;
                }
                if (this.tooltip) {
                    if (value == "always") {
                        this.showTooltip();
                    }
                    else {
                        this.handleAlwaysShowTooltip();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "tooltipPosition", {
        /**
         * Position
         */
        get: function () {
            return this.getPropertyValue("tooltipPosition");
        },
        /**
         * Specifies if [[Tooltip]] should follow the mouse or touch pointer or stay
         * at the fixed position.
         *
         * @param value  Position
         */
        set: function (value) {
            this.setPropertyValue("tooltipPosition", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "tooltipY", {
        /**
         * @return Tooltip Y (px)
         */
        get: function () {
            return this.getTooltipY();
        },
        /**
         * Y coordinate the [[Tooltip]] should be shown at.
         *
         * @param value  Tooltip Y (px)
         */
        set: function (value) {
            if (this.setPercentProperty("tooltipY", value) && this.tooltip) {
                this.tooltip.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns Tooltip X coordinate if it's set, or middle of the element.
     *
     * @ignore Exclude from docs
     * @return X (px)
     */
    Sprite.prototype.getTooltipX = function () {
        var x = this.getPropertyValue("tooltipX");
        if (!hasValue(x)) {
            x = Percent_percent(50);
        }
        var value;
        if (isNumber(x)) {
            value = x;
        }
        if (x instanceof Percent) {
            value = this.maxLeftSelf + this._measuredWidthSelf * x.value - this.pixelPaddingLeft - this.ex; // overflow is know only for measured items, so this is not always good
        }
        if (!isNumber(value)) {
            value = 0;
        }
        return value;
    };
    /**
     * Returns Tooltip Y coordinate if it's set, or middle of the element.
     *
     * @ignore Exclude from docs
     * @return Y (px)
     */
    Sprite.prototype.getTooltipY = function () {
        var y = this.getPropertyValue("tooltipY");
        if (!hasValue(y)) {
            y = Percent_percent(50);
        }
        var value;
        if (isNumber(y)) {
            value = y;
        }
        if (y instanceof Percent) {
            value = this.maxTopSelf + this._measuredHeightSelf * y.value - this.pixelPaddingTop - this.ey; // overflow is know only for measured items, so this is not always good
        }
        if (!isNumber(value)) {
            value = 0;
        }
        return value;
    };
    /**
     * Displays a modal or console message with error, and halts any further
     * processing of this item.
     *
     * @ignore Exclude from docs
     * @param e Error
     * @todo Implement from applying further actions to this item
     */
    Sprite.prototype.raiseCriticalError = function (e, closable) {
        if (this.svgContainer) {
            if (!this._adapterO) {
                this.modal.content = e.message;
            }
            else {
                this.modal.content = this._adapterO.apply("criticalError", e).message;
            }
            if (!closable) {
                this.disabled = true;
            }
            else {
                this.modal.closable = true;
            }
            if (!Options_options.suppressErrors) {
                this.modal.open();
            }
        }
        if (Options_options.verbose) {
            console.log(e);
        }
    };
    /**
 * Processes JSON-based config before it is applied to the object.
 *
 * @ignore Exclude from docs
 * @param config  Config
 */
    Sprite.prototype.processConfig = function (config) {
        if (config) {
            // Tooltip color source
            if (hasValue(config.tooltipColorSource) && isString(config.tooltipColorSource) && this.map.hasKey(config.tooltipColorSource)) {
                config.tooltipColorSource = this.map.getKey(config.tooltipColorSource);
            }
            // Cursor styles
            if (hasValue(config.cursorOverStyle) && isString(config.cursorOverStyle)) {
                config.cursorOverStyle = this.getCursorStyle(config.cursorOverStyle);
            }
            if (hasValue(config.cursorDowntyle) && isString(config.cursorDowntyle)) {
                config.cursorDowntyle = this.getCursorStyle(config.cursorDowntyle);
            }
            if (hasValue(config.cursorOptions)) {
                if (hasValue(config.cursorOptions.overStyle) && isString(config.cursorOptions.overStyle)) {
                    config.cursorOptions.overStyle = this.getCursorStyle(config.cursorOptions.overStyle);
                }
                if (hasValue(config.cursorOptions.downStyle) && isString(config.cursorOptions.downStyle)) {
                    config.cursorOptions.downStyle = this.getCursorStyle(config.cursorOptions.downStyle);
                }
            }
        }
        _super.prototype.processConfig.call(this, config);
        this.processDelayedMap();
    };
    /**
     * Converts string name of the cursor into actual [[MouseCursorStyle]].
     *
     * @param style  Cursor type
     * @return Cursor definition
     */
    Sprite.prototype.getCursorStyle = function (style) {
        switch (style) {
            case "grab":
                return MouseCursorStyle.grab;
            case "grabbing":
                return MouseCursorStyle.grabbing;
            case "pointer":
                return MouseCursorStyle.pointer;
            case "horizontalResize":
                return MouseCursorStyle.horizontalResize;
            case "verticalResize":
                return MouseCursorStyle.verticalResize;
            default:
                return MouseCursorStyle.default;
        }
    };
    /**
     * This function is used to sort element's JSON config properties, so that
     * some properties that absolutely need to be processed last, can be put at
     * the end.
     *
     * @ignore Exclude from docs
     * @param a  Element 1
     * @param b  Element 2
     * @return Sorting number
     */
    Sprite.prototype.configOrder = function (a, b) {
        if (a == b) {
            return 0;
        }
        // Must come last
        else if (a == "tooltipColorSource") {
            return 1;
        }
        else if (b == "tooltipColorSource") {
            return -1;
        }
        else {
            return _super.prototype.configOrder.call(this, a, b);
        }
    };
    Object.defineProperty(Sprite.prototype, "isHidden", {
        /**
         * If `sprite.hide()` is called, we set isHidden to true when sprite is hidden.
         * This was added becaus hidden state might have visibility set to true and so
         * there would not be possible to find out if a sprite is technically hidden or not.
         */
        get: function () {
            if (this._isHidden) {
                return this._isHidden;
            }
            else if (this._parent) {
                return this._parent.isHidden;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "showOnInit", {
        /**
         * @return Show on init?
         */
        get: function () {
            return this.getPropertyValue("showOnInit");
        },
        /**
         * If this is set to `true`, Sprite, when inited will be instantly hidden
         * ("hidden" state applied) and then shown ("default" state applied).
         *
         * If your "default" state's `transitionDuration > 0` this will result in
         * initial animation from "hidden" state to "default" state.
         *
         * If you need a Sprite which has `showOnInit = true` not to be shown
         * initially, set `sprite.hidden = true`. Setting `sprite.visible = false`
         * will not prevent the animation and the sprite will be shown.
         *
         * @param value show on init?
         */
        set: function (value) {
            value = toBoolean(value);
            this.setShowOnInit(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    Sprite.prototype.setShowOnInit = function (value) {
        if (this.setPropertyValue("showOnInit", value)) {
            if (!this.isTemplate) {
                if (value && !this.inited && !this.hidden) {
                    this._showOnInitDisposer = new Disposer_MultiDisposer([
                        registry.events.once("enterframe", this.hideInitially, this),
                        this.events.once("beforevalidated", this.hideInitially, this, false),
                        this.events.on("inited", this.appear, this, false)
                    ]);
                    this._disposers.push(this._showOnInitDisposer);
                }
                else {
                    if (this._showOnInitDisposer) {
                        this._showOnInitDisposer.dispose();
                    }
                }
            }
        }
    };
    /**
     * @ignore
     */
    Sprite.prototype.hideInitially = function () {
        if (!this.isDisposed()) {
            this.appeared = false;
            //if (!this.hidden && !this._isHidden) { // not good for series, as on enterframe it doesn't have data items yet.
            if (!this.inited) {
                this.hide(0);
            }
        }
    };
    /**
     * Hides the chart instantly and then shows it. If defaultState.transitionDuration > 0, this will result an animation in which properties of hidden state will animate to properties of visible state.
     */
    Sprite.prototype.appear = function () {
        var _this = this;
        this.appeared = false;
        if (!this.hidden && !this.isHidden) {
            this.hide(0);
        }
        if (!this.hidden) {
            var animation = this.show();
            if (animation && !animation.isFinished()) {
                this.addDisposer(animation.events.on("animationended", function () {
                    _this.appeared = true;
                    _this.dispatch("appeared");
                }));
            }
            else {
                this.appeared = true;
                this.dispatch("appeared");
            }
        }
        else {
            this.appeared = true;
            this.dispatch("appeared");
        }
    };
    Object.defineProperty(Sprite.prototype, "hidden", {
        /**
         * @return Is initially hidden?
         */
        get: function () {
            return this.getPropertyValue("hidden");
        },
        /**
         * If a sprite has `showOnInit = true`, it will animate from "hidden" to
         * "default" state when initialized. To prevent this but keep
         * `showOnInit = true`, you can set `sprite.hidden = true`.
         *
         * @param value initially hidden?
         */
        set: function (value) {
            value = toBoolean(value);
            this.setPropertyValue("hidden", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "bbox", {
        /**
         * Returns bounding box (square) for this element.
         *
         * @ignore Exclude from docs
         */
        get: function () {
            if (this.definedBBox) {
                return this.definedBBox;
            }
            return this._bbox;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "plugins", {
        /**
         * A list of plugins (objects that implement [[IPlugin]] interface) attached
         * to this object.
         *
         * @since 4.2.2
         * @return List of plugins
         */
        get: function () {
            var _this = this;
            if (!this._plugins) {
                this._plugins = new List_List();
                this._disposers.push(this._plugins.events.on("inserted", function (ev) {
                    ev.newValue.target = _this;
                    ev.newValue.init();
                }));
                this._disposers.push(new List_ListDisposer(this._plugins));
            }
            return this._plugins;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called during the System.update method
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype._systemUpdate = function (skippedSprites) {
        this.validate();
    };
    /**
     * Called during the System.update method
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype._systemCheckIfValidate = function () {
        return true;
    };
    /**
     * Called during the System.validatePositions method
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype._systemValidatePositions = function () {
        this.validatePosition();
    };
    /**
     * Called during the System.validateLayouts method
     *
     * @ignore Exclude from docs
     */
    Sprite.prototype._systemValidateLayouts = function () {
    };
    return Sprite;
}(Base_BaseObjectEvents));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Sprite"] = Sprite_Sprite;
//# sourceMappingURL=Sprite.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Rectangle.js
/**
 * Functionality for drawing rectangles.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to draw a rectangle.
 *
 * @see {@link IRectangleEvents} for a list of available events
 * @see {@link IRectangleAdapters} for a list of available Adapters
 */
var Rectangle_Rectangle = /** @class */ (function (_super) {
    __extends(Rectangle, _super);
    /**
     * Constructor
     * * Creates a `<rect>` element
     * * Creates default state
     */
    function Rectangle() {
        var _this = _super.call(this) || this;
        _this.className = "Rectangle";
        _this.element = _this.paper.add("rect");
        //this.pixelPerfect = false;
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    Rectangle.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var precision = this._positionPrecision;
        if (this.pixelPerfect) {
            precision = 0;
        }
        var w = Math_round(this.innerWidth, precision);
        var h = Math_round(this.innerHeight, precision);
        this.element.attr({
            "width": w,
            "height": h
        });
    };
    /**
     * Measures the element.
     *
     * @ignore Exclude from docs
     */
    Rectangle.prototype.measureElement = function () {
    };
    Object.defineProperty(Rectangle.prototype, "bbox", {
        /**
         * Returns bounding box (square) for this element.
         *
         * @ignore Exclude from docs
         */
        get: function () {
            if (this.definedBBox) {
                return this.definedBBox;
            }
            if (this.isMeasured) {
                return {
                    x: 0,
                    y: 0,
                    width: this.innerWidth,
                    height: this.innerHeight
                };
            }
            else {
                return { x: 0, y: 0, width: 0, height: 0 };
            }
        },
        enumerable: true,
        configurable: true
    });
    return Rectangle;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Rectangle"] = Rectangle_Rectangle;
//# sourceMappingURL=Rectangle.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/Container.js
/**
 * Container module
 * @todo Needs description
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */
















;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Container can contain multiple sprites and arrange them in various layouts.
 *
 * @see {@link IContainerEvents} for a list of available events
 * @see {@link IContainerAdapters} for a list of available Adapters
 * @important
 */
var Container_Container = /** @class */ (function (_super) {
    __extends(Container, _super);
    /**
     * Constructor
     */
    function Container() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Container children. (sorted by layout)
         *
         * @ignore Exclude from docs
         */
        _this._childrenByLayout = [];
        /**
         * Container's disposers for its child elements.
         *
         * @ignore Exclude from docs
         */
        _this._childrenDisposers = new Dictionary_Dictionary();
        /**
         * Indicates if this container contains any focused elements, including
         * itself.
         */
        _this.hasFocused = false;
        /**
         * An array of references to elements the state should be set, when it is set
         * on this element.
         */
        _this.setStateOnSprites = [];
        /*
         * @ignore
         */
        _this.layoutInvalid = false;
        _this._absoluteWidth = 0;
        _this._absoluteHeight = 0;
        /**
         * An array of child Sprites that should be ready before this object can
         * fire a "ready" event.
         */
        _this._shouldBeReady = [];
        /**
         * Enables touch tap protection.
         */
        _this._tapToActivate = false;
        /**
         * If `tapToActivate` is used, this setting will determine how long the chart
         * will stay in "active" mode.
         *
         * @default 3000
         * @since 4.4.0
         */
        _this.tapTimeout = 3000;
        _this.className = "Container";
        _this._element = _this.paper.addGroup("g");
        _this.group.add(_this.element);
        _this.setPropertyValue("pixelPerfect", false);
        _this.setPropertyValue("layout", "absolute");
        _this.setPropertyValue("fixedWidthGrid", false);
        _this.setPropertyValue("verticalCenter", "none");
        _this.setPropertyValue("horizontalCenter", "none");
        _this._positionPrecision = 4;
        _this._disposers.push(new Dictionary_DictionaryDisposer(_this._childrenDisposers));
        _this.children.events.on("inserted", _this.handleChildAdded, _this);
        _this.children.events.on("removed", _this.handleChildRemoved, _this);
        _this.applyTheme();
        return _this;
    }
    /**
     * Handles adding of a new child into `children`. Adding new children might
     * affect the whole layout so it needs to be revalidated.
     *
     * @ignore Exclude from docs
     * @param event Event object
     * @todo Throw an exception on adding a disposed object. Of course it's better NOT TO add disposed objects, so that what we should focus on.
     */
    Container.prototype.handleChildAdded = function (event) {
        this.processChild(event.newValue);
    };
    /**
     * @ignore
     */
    Container.prototype.processChild = function (child) {
        // try solves the problem when somedy adds child directly to children
        try {
            this._childrenDisposers.insertKey(child.uid, new Disposer_MultiDisposer([
                // it's not enough to listen to POSITION_CHANGED only, as some extra redrawals will happen.
                child.events.on("transformed", this.handleChildTransform, this),
                child.events.on("zIndexChanged", this.sortAndAdd, this)
            ]));
        }
        catch (err) {
            // void
        }
        if (this.element) {
            var group = this.element;
            group.add(child.group);
        }
        child.parent = this;
        child.paper = this.paper;
        this.dispatchImmediately("childadded", { type: "childadded", newValue: child });
        this.invalidate();
    };
    /**
     * @ignore
     */
    Container.prototype.sortAndAdd = function () {
        this.sortChildren();
        this.addChildren();
    };
    /**
     * Handles child removal. Changing size of the child may change the
     * whole layout of the Container, hence layout needs to be invalidated.
     *
     * @ignore Exclude from docs
     * @param event Event object
     */
    Container.prototype.handleChildRemoved = function (event) {
        var child = event.oldValue;
        // TODO figure out why the key sometimes doesn't exist
        this._childrenDisposers.removeKey(child.uid);
        if (this.element) {
            var group = this.element;
            group.removeElement(child.group);
        }
        if (child.isMeasured) {
            this.invalidateLayout();
        }
        this.dispatchImmediately("childremoved", { type: "childremoved", oldValue: child });
    };
    /**
     * Handles child transformation. Changing size of the child may change the
     * whole layout of the Container, hence layout needs to be invalidated.
     *
     * @ignore Exclude from docs
     * @param event Event object
     */
    Container.prototype.handleChildTransform = function (event) {
        var child = event.target;
        if (child.isMeasured) { // && this.layout != "none" && this.layout != "absolute") {
            this.invalidateLayout();
        }
    };
    /**
     * Invalidates Container's layout, causing it to be re-evaluated again.
     *
     * @ignore Exclude from docs
     */
    Container.prototype.invalidateLayout = function () {
        if (this.layoutInvalid || this.disabled || this.isTemplate || this.layout == "none" || this.__disabled) {
            return;
        }
        this.layoutInvalid = true;
        registry.addToInvalidLayouts(this);
        system.requestFrame();
    };
    /**
     * Invalidates element.
     *
     * Object will be redrawn during the next update cycle.
     *
     * Please note that in most cases elements will auto-invalidate when needed. If
     * everything works, DO NOT use this method. Use it only if some changes do
     * not take otherwise.
     */
    Container.prototype.invalidate = function () {
        _super.prototype.invalidate.call(this);
        this.invalidateLayout();
    };
    /**
     * Invalidates the whole element, including layout AND all its child
     * elements.
     *
     * As this will essentially force all elements to redraw, use only if
     * absolutely necessary.
     */
    Container.prototype.deepInvalidate = function () {
        _super.prototype.invalidate.call(this);
        //this.sortChildren();
        each(this._childrenByLayout, function (child) {
            if (child instanceof Container) {
                child.deepInvalidate();
            }
            else {
                child.invalidate();
            }
        });
        this.invalidateLayout();
    };
    Object.defineProperty(Container.prototype, "children", {
        /**
         * Returns a list of the child [[Sprite]] elements contained in this
         * Container.
         *
         * @return List of child elements (Sprites)
         */
        get: function () {
            // @todo Review if we can add all children to disposers
            if (!this._children) {
                this._children = new List_List();
                //this._disposers.push(new ListDisposer(this._children));
            }
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "minWidth", {
        /**
         * @return Width (px)
         */
        get: function () {
            return this.getPropertyValue("minWidth");
        },
        /**
         * Minimum width (px) for the Container. A container will not
         * auto-shrink beyond this value, even if child elements are smaller.
         *
         * @param value  Width (px)
         */
        set: function (value) {
            if (this.setPropertyValue("minWidth", value)) {
                this.invalidateLayout();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "minHeight", {
        /**
         * @return Height (px)
         */
        get: function () {
            return this.getPropertyValue("minHeight");
        },
        /**
         * Minimum height (px) for the Container. A container will not
         * auto-shrink beyond this value, even if child elements are smaller.
         *
         * @param value  Height (px)
         */
        set: function (value) {
            if (this.setPropertyValue("minHeight", value)) {
                this.invalidateLayout();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Overrides the original `removeElement` so that Container's actual element
     * is not removed. We do not need to remove element of a Container.
     *
     * We do this because remove element each time will fail the `getBBox`.
     *
     * @ignore Exclude from docs
     */
    Container.prototype.removeElement = function () {
    };
    /**
     * Sorts Container's children: the ones with variable width and height are
     * put at the end of the list (depending on layout type), so that fixed-width
     * ones can be drawn first.
     *
     * @ignore Exclude from docs
     */
    Container.prototype.sortChildren = function () {
        var _this = this;
        this._childrenByLayout = [];
        if (this.layout == "none" || this.layout == "absolute" || !this.layout) {
            //$iter.each(this.children.iterator(), (child) => {
            //	this._childrenByLayout.push(child);
            //});
            this._childrenByLayout = this.children.values;
        }
        else {
            // Assemble fixed-size and relative lists
            var fixed_1 = [];
            var relative_1 = [];
            Iterator_each(this.children.iterator(), function (child) {
                if (_this.layout == "horizontal" || _this.layout == "grid") {
                    if (!isNumber(child.percentWidth)) {
                        fixed_1.push(child);
                    }
                    else {
                        relative_1.push(child);
                    }
                }
                else if (_this.layout == "vertical") {
                    if (!isNumber(child.percentHeight)) {
                        fixed_1.push(child);
                    }
                    else {
                        relative_1.push(child);
                    }
                }
                else {
                    fixed_1.push(child);
                }
            });
            // Concat everything into list
            this._childrenByLayout = fixed_1.concat(relative_1);
        }
        this.calculateRelativeSize();
    };
    /**
     * Calculates relative sizes for all Container's children.
     *
     * @ignore Exclude from docs
     * @todo Make it protected?
     */
    Container.prototype.calculateRelativeSize = function () {
        var _this = this;
        var totalRelativeWidth = 0;
        var totalRelativeHeight = 0;
        each(this._childrenByLayout, function (child) {
            // if child is not measured, we do not care about it at all.
            if (child.isMeasured) {
                if (isNumber(child.percentWidth)) {
                    totalRelativeWidth += child.percentWidth;
                }
                if (isNumber(child.percentHeight)) {
                    totalRelativeHeight += child.percentHeight;
                }
            }
        });
        each(this._childrenByLayout, function (child) {
            if (child.isMeasured) {
                if (_this.layout == "horizontal") {
                    if (isNumber(child.percentWidth)) {
                        child.relativeWidth = child.percentWidth / totalRelativeWidth;
                    }
                    if (isNumber(child.percentHeight)) {
                        child.relativeHeight = child.percentHeight / 100;
                    }
                }
                if (_this.layout == "vertical") {
                    if (isNumber(child.percentHeight)) {
                        child.relativeHeight = child.percentHeight / totalRelativeHeight;
                    }
                    if (isNumber(child.percentWidth)) {
                        child.relativeWidth = child.percentWidth / 100;
                    }
                }
                if (_this.layout == "grid") {
                    if (isNumber(child.percentHeight)) {
                        child.relativeHeight = child.percentHeight / 100;
                    }
                    if (isNumber(child.percentWidth)) {
                        child.relativeWidth = child.percentWidth / 100;
                    }
                }
            }
            if (_this.layout == "absolute" || !child.isMeasured) {
                if (isNumber(child.percentWidth)) {
                    child.relativeWidth = child.percentWidth / 100;
                }
                if (isNumber(child.percentHeight)) {
                    child.relativeHeight = child.percentHeight / 100;
                }
            }
        });
    };
    /**
     * Adds all children to Container's SVG element.
     *
     * @ignore Exclude from docs
     */
    Container.prototype.addChildren = function () {
        /*
          Need this check because a child might be assigned to parent even before element is created, for example a theme
          access scrollbar.thumb
        */
        if (this.element) {
            var zindexed = copy(this.children.values); // not children by layout!
            var sortArray = zindexed.map(function (data, idx) {
                return { idx: idx, data: data };
            });
            sortArray.sort(function (a, b) {
                var ai = (a.data.zIndex || 0);
                var bi = (b.data.zIndex || 0);
                if (ai < bi) {
                    return -1;
                }
                if (ai > bi) {
                    return 1;
                }
                return a.idx - b.idx;
            });
            zindexed = sortArray.map(function (val) {
                return val.data;
            });
            var group_1 = this.element;
            // check, maybe the order is good already
            var isCorrect = true;
            if (group_1.node && group_1.node.childNodes) {
                for (var i = 0, len = group_1.node.childNodes.length; i < len; i++) {
                    if (group_1.node.childNodes[i] != zindexed[i].group.node) {
                        isCorrect = false;
                        break;
                    }
                }
            }
            if (!isCorrect) {
                each(zindexed, function (child) {
                    if (child.group) {
                        group_1.add(child.group);
                    }
                });
                if (this._background) {
                    this.group.addToBack(this._background.group);
                }
                this.invalidateLayout();
            }
        }
    };
    /**
     * Creates a new element of specific type and assigns as a child to the
     * Container.
     *
     * @param Class type for the new element
     * @return New element
     */
    Container.prototype.createChild = function (classType) {
        var sprite = new classType();
        sprite.parent = this;
        return sprite;
    };
    /**
     * Removes all Container's children without actually destroying them.
     *
     * To destroy children use `disposeChildren()` instead.
     */
    Container.prototype.removeChildren = function () {
        // remove all children
        // TODO use iteration instead
        while (this.children.length > 0) {
            var child = this.children.getIndex(0);
            child.parent = undefined;
            this.children.removeValue(child);
        }
    };
    /**
     * Removes and destroys all Container's children.
     *
     * To remove children from Container without destroying them, use
     * `removeChildren()`.
     */
    Container.prototype.disposeChildren = function () {
        // TODO use iteration instead
        while (this.children.length > 0) {
            var child = this.children.getIndex(0);
            child.dispose();
            this.children.removeValue(child);
        }
    };
    Object.defineProperty(Container.prototype, "background", {
        /**
         * @return Background element
         */
        get: function () {
            if (!this._background) {
                this._background = this.createBackground();
                this.processBackground();
            }
            return this._background;
        },
        /**
         * An element to use as container background.
         *
         * @param background  Background element
         */
        set: function (background) {
            if (this._background && this.background != background) {
                this.removeDispose(this._background);
            }
            if (background) {
                this._background = background;
                this._disposers.push(background);
                this.processBackground();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handles the situation where parent element is resized.
     *
     * @ignore Exclude from docs
     */
    Container.prototype.handleGlobalScale = function () {
        _super.prototype.handleGlobalScale.call(this);
        this.children.each(function (child) {
            child.handleGlobalScale();
        });
    };
    /**
     * Creates and returns a [[Rectangle]] to use as a background for Container.
     *
     * @ignore Exclude from docs
     * @return Background Rectangle element
     */
    Container.prototype.createBackground = function () {
        return new Rectangle_Rectangle();
    };
    /**
     * Decorates background element with required properties.
     *
     * @ignore Exclude from docs
     */
    Container.prototype.processBackground = function () {
        var background = this._background;
        if (background) {
            background.isMeasured = false;
            this._background.fill = new InterfaceColorSet_InterfaceColorSet().getFor("background");
            background.parent = this;
            background.isMeasured = false;
            this.children.removeValue(background);
            this._disposers.push(background);
            this.group.addToBack(this._background.group);
        }
    };
    /**
     * Measures the size of container and informs its children of how much size
     * they can occupy, by setting their relative `maxWidth` and `maxHeight`
     * properties.
     *
     * @ignore Exclude from docs
     */
    Container.prototype.validateLayout = function () {
        var _this = this;
        registry.removeFromInvalidLayouts(this);
        this.layoutInvalid = false;
        // prevents from drawing if topparent is 0x0
        /*
        let topParent = this.topParent;
        if (topParent) {
            if (!topParent.maxWidth || !topParent.maxHeight) {
                this._disposers.push(topParent.events.once("maxsizechanged", this.invalidateLayout, this));
            }
        }*/
        this._availableWidth = this.innerWidth;
        this._availableHeight = this.innerHeight;
        var measuredWidth = 0;
        var measuredHeight = 0;
        var allValid = true;
        if (this.children) {
            this.sortChildren();
            // we itterate through list of children, sorted by layout priority. sprites which width non-relative width/height will go first, so we will reduce available width before proceeding to sprites with relative width/height
            each(this._childrenByLayout, function (child) {
                var maxWidth;
                var maxHeight;
                if (isNumber(child.relativeWidth)) {
                    maxWidth = Math_round(_this._availableWidth * child.relativeWidth, 2);
                    if (_this.layout == "horizontal") { // || this.layout == "absolute") {
                        maxWidth -= child.pixelMarginRight + child.pixelMarginLeft;
                    }
                }
                else {
                    if (_this.layout == "horizontal") {
                        if (child.invalid) {
                            child.validate();
                        }
                    }
                }
                if (isNumber(child.relativeHeight)) {
                    maxHeight = Math_round(_this._availableHeight * child.relativeHeight, 2);
                    if (_this.layout == "vertical") { //  || this.layout == "absolute") {
                        maxHeight -= child.pixelMarginTop + child.pixelMarginBottom;
                    }
                }
                else {
                    if (_this.layout == "vertical") {
                        if (child.invalid) {
                            child.validate();
                        }
                    }
                }
                // if child is valid
                if (child.invalid == false) {
                    if (isNumber(child.relativeWidth)) {
                        child.maxWidth = maxWidth;
                    }
                    if (isNumber(child.relativeHeight)) {
                        child.maxHeight = maxHeight;
                    }
                    if (child.isMeasured) {
                        // reduce available width if this is horizontal layout
                        if (_this.layout == "horizontal") {
                            if (!isNumber(child.percentWidth)) {
                                if (child.measuredWidth > 0) {
                                    _this._availableWidth -= child.measuredWidth + child.pixelMarginLeft + child.pixelMarginRight;
                                }
                            }
                        }
                        // reduce available height if this is vertical layout
                        if (_this.layout == "vertical") {
                            if (!isNumber(child.percentHeight)) {
                                if (child.measuredHeight > 0) {
                                    _this._availableHeight -= child.measuredHeight + child.pixelMarginTop + child.pixelMarginBottom;
                                }
                            }
                        }
                        var childMeasuredWidth = child.measuredWidth;
                        var childMeasuredHeight = child.measuredHeight;
                        if (child.align != "none") {
                            childMeasuredWidth += child.pixelMarginLeft + child.pixelMarginRight;
                        }
                        if (child.valign != "none") {
                            childMeasuredHeight += child.pixelMarginTop + child.pixelMarginBottom;
                        }
                        measuredWidth = Math.max(measuredWidth, childMeasuredWidth);
                        measuredHeight = Math.max(measuredHeight, childMeasuredHeight);
                    }
                }
                // if child is not valid
                else {
                    // tell child what maximum width/ height it can occupy
                    if (child.isMeasured) {
                        if (isNumber(child.relativeWidth)) {
                            if (child.maxWidth != maxWidth) { // need to check this because of allValid
                                child.maxWidth = maxWidth;
                                allValid = false;
                            }
                        }
                        if (isNumber(child.relativeHeight)) {
                            if (child.maxHeight != maxHeight) { // need to check this because of allValid
                                child.maxHeight = maxHeight;
                                allValid = false;
                            }
                        }
                    }
                }
            });
        }
        this._absoluteWidth = measuredWidth;
        this._absoluteHeight = measuredHeight;
        // arrange after measuring, only if all children are valid already
        if (allValid) {
            this.arrange();
        }
    };
    /**
     * Arranges children according to layout specs and available space / child
     * sizes.
     *
     * @ignore Exclude from docs
     */
    Container.prototype.arrange = function () {
        var _this = this;
        var children = this.children;
        /*
           in this method we not only arrange children but also find out the size of the container
           it might seem it would be easier to get container size using sprite's measure method,
           however it would return only actual size of the bbox. However as each child meight have
           margins set, we need to check each child - we do it here.

           This method doesn't do anything with DOM, so it's not expensive
        */
        var measuredWidth = 0;
        var measuredHeight = 0;
        //let innerWidth: number = this.innerWidth; //$math.max(this.innerWidth, this._measuredWidth - paddingLeft - paddingRight);
        //let innerHeight: number = this.innerHeight; //$math.max(this.innerHeight, this._measuredHeight - paddingTop - paddingBottom);
        // above is wrong, as if a w/h is not specified, it is 0 and alignment doesn't work at all.
        var innerWidth = Math_max(this.innerWidth, this._absoluteWidth);
        var innerHeight = Math_max(this.innerHeight, this._absoluteHeight);
        var left; // = 0;
        var right; // = innerWidth;
        var top; // = 0;
        var bottom; // = innerHeight;
        var paddingLeft = this.pixelPaddingLeft;
        var paddingRight = this.pixelPaddingRight;
        var paddingTop = this.pixelPaddingTop;
        var paddingBottom = this.pixelPaddingBottom;
        var nextX = 0;
        var nextY = 0;
        var row = 0;
        var column = 0;
        var columnWidth = [];
        var rowHeight = [];
        var maxCellWidth;
        var minCellWidth;
        var columnCount;
        var maxWidth = this.maxWidth;
        var maxHeight = this.maxHeight;
        var minWidth = this.minWidth;
        var minHeight = this.minHeight;
        var childrenCopy = copy(children.values);
        if (this.reverseOrder) {
            childrenCopy.reverse();
        }
        // GRID PRECALCULATIONS
        if (this.layout == "grid") {
            minCellWidth = maxWidth;
            maxCellWidth = 1;
            for (var i = 0, len = childrenCopy.length; i < len; i++) {
                var child = childrenCopy[i];
                if (child.isMeasured && !child.disabled && !child.__disabled) {
                    var childMeasuredWidth = child.measuredWidth;
                    if (childMeasuredWidth < minCellWidth) {
                        minCellWidth = childMeasuredWidth;
                    }
                    if (childMeasuredWidth > maxCellWidth) {
                        maxCellWidth = childMeasuredWidth;
                    }
                }
            }
            minCellWidth = fitToRange(minCellWidth, 1, maxWidth);
            maxCellWidth = fitToRange(maxCellWidth, 1, maxWidth);
            if (this.fixedWidthGrid) {
                columnCount = maxWidth / maxCellWidth;
            }
            else {
                columnCount = maxWidth / minCellWidth; // predicted number of columns, yes it is usually much more than real number, but we fix that later
            }
            columnCount = Math_max(1, Math.floor(columnCount));
            columnCount = Math_min(this.maxColumns, columnCount);
            columnWidth = this.getColumnWidth(childrenCopy, columnCount, maxCellWidth);
        }
        var contentLeft;
        var contentRight;
        var contentTop;
        var contentBottom;
        // we itterate through array of children
        // TODO use iterator instead
        for (var i = 0, len = childrenCopy.length; i < len; i++) {
            var child = childrenCopy[i];
            if (child.isMeasured && !child.disabled && !child.__disabled) {
                var x = undefined; //child.pixelX; // must reset
                var y = undefined; //child.pixelY; // must reset
                var childMarginLeft = child.pixelMarginLeft;
                var childMarginRight = child.pixelMarginRight;
                var childMarginTop = child.pixelMarginTop;
                var childMarginBottom = child.pixelMarginBottom;
                var childWidth = child.measuredWidth;
                var childHeight = child.measuredHeight;
                var childLeft = void 0;
                var childRight = void 0;
                var childTop = void 0;
                var childBottom = void 0;
                switch (this.layout) {
                    case "none":
                        break;
                    // absolute layout
                    case "absolute":
                        // horizontal alignment
                        switch (child.align) {
                            case "left":
                                x = childMarginLeft - child.maxLeft;
                                break;
                            case "center":
                                x = (innerWidth - childWidth) / 2 - child.maxLeft;
                                break;
                            case "right":
                                x = innerWidth - childMarginRight - child.maxRight;
                                break;
                            default:
                                if (!(child.x instanceof Percent)) {
                                    x = child.pixelX;
                                }
                                break;
                        }
                        // vertical alignment
                        switch (child.valign) {
                            case "top":
                                y = childMarginTop - child.maxTop;
                                break;
                            case "middle":
                                y = (innerHeight - childHeight) / 2 - child.maxTop;
                                break;
                            case "bottom":
                                y = innerHeight - childMarginBottom - child.maxBottom;
                                break;
                            default:
                                if (!(child.y instanceof Percent)) {
                                    y = child.pixelY;
                                }
                                break;
                        }
                        break;
                    // vertical layout
                    case "vertical":
                        //if ($type.isNumber(child.relativeHeight)) {
                        //	childHeight = child.maxHeight;
                        //}
                        switch (child.align) {
                            case "left":
                                x = childMarginLeft - child.maxLeft;
                                break;
                            case "center":
                                x = (innerWidth - childWidth) / 2 - child.maxLeft;
                                break;
                            case "right":
                                x = innerWidth - childMarginRight - child.maxRight;
                                break;
                            default:
                                x = child.pixelX;
                                break;
                        }
                        y = nextY + childMarginTop - child.maxTop;
                        nextY = y + child.maxBottom + childMarginBottom;
                        break;
                    // horizontal layout
                    case "horizontal":
                        //if ($type.isNumber(child.relativeHeight)) {
                        //	childHeight = child.maxHeight;
                        //}
                        switch (child.valign) {
                            case "top":
                                y = childMarginTop - child.maxTop;
                                break;
                            case "middle":
                                y = (innerHeight - childHeight) / 2 - child.maxTop;
                                break;
                            case "bottom":
                                y = innerHeight - childMarginBottom - child.maxBottom;
                                break;
                            default:
                                y = child.pixelY;
                                break;
                        }
                        x = nextX + childMarginLeft - child.maxLeft;
                        nextX = x + child.maxRight + childMarginRight;
                        break;
                    case "grid":
                        x = nextX + childMarginLeft - child.maxLeft;
                        switch (child.valign) {
                            case "top":
                                y = nextY + childMarginTop - child.maxTop;
                                break;
                            case "middle":
                                y = nextY + (innerHeight - childHeight) / 2 - child.maxTop;
                                break;
                            case "bottom":
                                y = nextY + innerHeight - childMarginBottom - child.maxBottom;
                                break;
                            default:
                                y = nextY - child.maxTop;
                                break;
                        }
                        nextX += columnWidth[column];
                        rowHeight[row] = Math_max(rowHeight[row], childHeight);
                        column++;
                        var nextColumnWidth = columnWidth[column];
                        if (!isNumber(nextColumnWidth)) {
                            nextColumnWidth = maxCellWidth;
                        }
                        if (nextX > Math_min(this.innerWidth, maxWidth) - nextColumnWidth + 1 && column < columnCount) {
                            columnCount = column;
                            nextX = 0;
                            nextY = 0;
                            row = 0;
                            column = 0;
                            columnWidth = this.getColumnWidth(childrenCopy, columnCount, maxCellWidth);
                            rowHeight = [];
                            i = -1;
                            continue;
                        }
                        if (column >= columnCount) {
                            column = 0;
                            nextY += rowHeight[row];
                            row++;
                            nextX = 0;
                        }
                        break;
                }
                if (this.layout !== "none") {
                    child.moveTo({ x: x, y: y }); // must use moveTo, otherwise x/y set in percent won't work
                    childLeft = x + child.maxLeft - childMarginLeft;
                    childRight = x + child.maxRight + childMarginRight;
                    childTop = y + child.maxTop - childMarginTop;
                    childBottom = y + child.maxBottom + childMarginBottom;
                    if (childRight > right || !isNumber(right)) {
                        right = childRight;
                    }
                    if (childLeft < left || !isNumber(left)) {
                        left = childLeft;
                    }
                    if (childTop < top || !isNumber(top)) {
                        top = childTop;
                    }
                    if (childBottom > bottom || !isNumber(bottom)) {
                        bottom = childBottom;
                    }
                    if (childRight > contentRight || !isNumber(contentRight)) {
                        contentRight = childRight;
                    }
                    if (childLeft < contentLeft || !isNumber(contentLeft)) {
                        contentLeft = childLeft;
                    }
                    if (childTop < contentTop || !isNumber(contentTop)) {
                        contentTop = childTop;
                    }
                    if (childBottom > contentBottom || !isNumber(contentBottom)) {
                        contentBottom = contentBottom;
                    }
                }
            }
            else {
                child.validatePosition();
            }
        }
        if (this.layout == "none") {
            var noneBBox = this.bbox;
            left = noneBBox.x;
            right = noneBBox.x + noneBBox.width;
            top = noneBBox.y;
            bottom = noneBBox.y + noneBBox.height;
        }
        if (!isNumber(left)) {
            left = 0;
            contentLeft = 0;
        }
        if (!isNumber(right)) {
            right = this._availableWidth;
            contentRight = right;
        }
        if (!isNumber(top)) {
            top = 0;
            contentTop = 0;
        }
        if (!isNumber(bottom)) {
            bottom = this._availableHeight;
            contentBottom = bottom;
        }
        if (!isNumber(contentTop)) {
            contentTop = 0;
        }
        if (!isNumber(contentBottom)) {
            contentBottom = contentTop;
        }
        if (!isNumber(contentLeft)) {
            contentLeft = 0;
        }
        if (!isNumber(contentRight)) {
            contentRight = contentLeft;
        }
        measuredWidth = right - left;
        measuredHeight = bottom - top;
        if (isNumber(this.relativeWidth)) {
            measuredWidth = maxWidth - paddingLeft - paddingRight;
            left = 0;
            right = measuredWidth;
        }
        if (isNumber(this.relativeHeight)) {
            measuredHeight = maxHeight - paddingTop - paddingBottom;
            top = 0;
            bottom = measuredHeight;
        }
        if (isNumber(this._pixelWidth)) {
            left = 0;
            measuredWidth = this._pixelWidth - paddingLeft - paddingRight;
        }
        if (isNumber(minWidth) && measuredWidth < minWidth) {
            left = 0;
            measuredWidth = this.minWidth - paddingLeft - paddingRight;
        }
        if (isNumber(this._pixelHeight)) {
            top = 0;
            measuredHeight = this._pixelHeight - paddingTop - paddingBottom;
        }
        if (isNumber(minHeight) && measuredHeight < minHeight) {
            top = 0;
            measuredHeight = minHeight - paddingTop - paddingBottom;
        }
        var measuredContentWidth = contentRight - contentLeft;
        var measuredContentHeight = contentBottom - contentTop;
        /// handle content alignment
        if (this.layout != "none" && (this.contentAlign || this.contentValign) && children.length > 0) {
            var dx_1;
            var dy_1;
            var mwa = measuredWidth;
            var mha = measuredHeight;
            if (mwa < measuredContentWidth) {
                mwa = measuredContentWidth;
            }
            if (mha < measuredContentHeight) {
                mha = measuredContentHeight;
            }
            if (this.contentAlign == "center") {
                dx_1 = (mwa - measuredContentWidth) / 2;
            }
            if (this.contentAlign == "right") {
                dx_1 = mwa - measuredContentWidth;
            }
            if (this.contentValign == "middle") {
                dy_1 = (mha - measuredContentHeight) / 2;
            }
            if (this.contentValign == "bottom") {
                dy_1 = mha - measuredContentHeight;
            }
            if (isNumber(dx_1)) {
                Iterator_each(children.iterator(), function (child) {
                    var childLeft = child.maxLeft;
                    var ddx = dx_1;
                    if (_this.layout == "horizontal") {
                        child.x = child.pixelX + ddx;
                    }
                    // individual grid elements can not be aligned vertically, that's why it's different from horizontal
                    if (_this.layout == "grid") {
                        child.x = child.pixelX + ddx;
                    }
                    if (_this.layout == "vertical") {
                        ddx += child.pixelMarginLeft;
                        if (child.align == "none") {
                            child.x = ddx - childLeft;
                        }
                    }
                    if (_this.layout == "absolute") {
                        ddx += child.pixelMarginLeft;
                        if (child.align == "none") {
                            child.x = ddx - childLeft;
                        }
                    }
                });
            }
            if (isNumber(dy_1)) {
                Iterator_each(children.iterator(), function (child) {
                    var childTop = child.maxTop;
                    var ddy = dy_1;
                    if (_this.layout == "horizontal") {
                        ddy += child.pixelMarginTop;
                        if (child.valign == "none") {
                            child.y = ddy - childTop;
                        }
                    }
                    // individual grid elements can not be aligned vertically, that's why it's different from horizontal
                    if (_this.layout == "grid") {
                        ddy += child.pixelMarginTop;
                        child.y = ddy - childTop;
                    }
                    if (_this.layout == "vertical") {
                        child.y = child.pixelY + ddy;
                    }
                    if (_this.layout == "absolute") {
                        ddy += child.pixelMarginTop;
                        if (child.valign == "none") {
                            child.y = ddy - childTop;
                        }
                    }
                });
            }
        }
        var oldBBox = this.bbox;
        // this will mess up maxw/maxh set by container layout, we need a separate min/maxwidth for users
        // this prevents invalidating layout in such cases as scrolling category axis, when labels go outside bounds and results transformed event
        // todo: need to check if this doesn't cause other problems.
        //if (this.maxWidth > 0) {
        //measuredWidth = $math.min(measuredWidth, this.maxWidth);
        //measuredWidth = $math.max(measuredWidth, this.minWidth);
        //}
        //if (this.maxHeight > 0) {
        //measuredHeight = $math.min(measuredHeight, this.maxHeight);
        //measuredHeight = $math.max(measuredHeight, this.minHeight);
        //}
        measuredWidth = Math_max(measuredWidth, minWidth);
        measuredHeight = Math_max(measuredHeight, minHeight);
        this.contentWidth = measuredWidth;
        this.contentHeight = measuredHeight;
        // new
        measuredWidth = Math_min(measuredWidth, maxWidth);
        measuredHeight = Math_min(measuredHeight, maxHeight);
        this._bbox = { x: left, y: top, width: measuredWidth, height: measuredHeight };
        var prevLeft = this.maxLeft;
        var prevTop = this.maxTop;
        var prevBotttom = this.maxBottom;
        var prevRight = this.maxRight;
        this.measure();
        if (prevLeft != this.maxLeft || prevRight != this.maxRight || prevTop != this.maxTop || prevBotttom != this.maxBottom) {
            if (this.events.isEnabled("transformed")) {
                var event_1 = {
                    type: "transformed",
                    target: this
                };
                if (oldBBox) {
                    event_1.dummyData = oldBBox.width + " " + measuredWidth + "  " + oldBBox.height + " " + measuredHeight;
                }
                this.events.dispatchImmediately("transformed", event_1);
            }
        }
        this.dispatchImmediately("layoutvalidated");
    };
    /**
     * Positions element according its center settings.
     *
     * @todo Description (review)
     * @ignore Exclude from docs
     */
    Container.prototype.updateCenter = function () {
        _super.prototype.updateCenter.call(this);
        this.updateBackground();
    };
    /**
     * Update the background to fit into specific dimensions.
     *
     * @ignore Exclude from docs
     * @todo Make it protected?
     */
    Container.prototype.updateBackground = function () {
        var background = this._background; // accessing protected, as getter creates instance if it doesn't exist
        if (background) {
            background.x = this.maxLeft;
            background.y = this.maxTop;
            background.width = this.maxRight - this.maxLeft;
            background.height = this.maxBottom - this.maxTop;
        }
    };
    /**
     * Returns widths of all columns in a horizontal Container layout.
     *
     * @ignore Exclude from docs
     * @param columnCount   Number of columns
     * @param maxCellWidth  Maximum width of one grid cell
     * @return An array of column widths
     */
    Container.prototype.getColumnWidth = function (children, columnCount, maxCellWidth) {
        var _this = this;
        var columnWidth = [];
        var column = 0;
        each(children, function (child) {
            if (child.isMeasured && !child.disabled && !child.__disabled) {
                if (_this.fixedWidthGrid) {
                    columnWidth[column] = maxCellWidth;
                }
                else {
                    columnWidth[column] = Math_max(columnWidth[column], child.measuredWidth + child.pixelMarginRight + child.pixelMarginLeft);
                }
                column++;
                if (column == columnCount) {
                    column = 0;
                }
            }
        });
        return columnWidth;
    };
    Object.defineProperty(Container.prototype, "layout", {
        /**
         * @return Layout
         */
        get: function () {
            return this.getPropertyValue("layout");
        },
        /**
         * Container layout.
         *
         * Options: "absolute" (default), "vertical", "horizontal", "grid", "none". "none" is quite the same as "absolute" - the objects will
         * be positioned at their x, y coordinates, the difference is that with "absolute" you can still use align/valign for children and with "none" you can not.
         * Use "none" as much as you can as it's most cpu-saving layout.
         *
         * @default "absolute"
         * @param value Layout
         */
        set: function (value) {
            if (this.setPropertyValue("layout", value)) {
                this.invalidateLayout();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "contentValign", {
        /**
         * @return Vertical alignment
         */
        get: function () {
            return this.getPropertyValue("contentValign");
        },
        /**
         * Vertical alignment of the elements for the vertical Container.
         *
         * This is used when Container is larger than the height of all its children.
         *
         * @param value vertical alignment
         */
        set: function (value) {
            this.setPropertyValue("contentValign", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "contentAlign", {
        /**
         * @return Horizontal alignment
         */
        get: function () {
            return this.getPropertyValue("contentAlign");
        },
        /**
         * Horizontal alignment of the elements for the horizontal Container.
         *
         * This is used when Container is larger than the height of all its children.
         *
         * @param value  Horizontal alignment
         */
        set: function (value) {
            this.setPropertyValue("contentAlign", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "fixedWidthGrid", {
        /**
         * @return Should use fixed width grid?
         */
        get: function () {
            return this.getPropertyValue("fixedWidthGrid");
        },
        /**
         * Controls if the grid of the Container should use fixed width. Fixed width
         * grid will divide available space to all its columns/rows equally, without
         * adapting to actual child sizes or size requirements.
         *
         * @default false
         * @param value  Should use fixed width grid?
         */
        set: function (value) {
            this.setPropertyValue("fixedWidthGrid", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "maxColumns", {
        /**
         * @return Should use fixed width grid?
         */
        get: function () {
            return this.getPropertyValue("maxColumns");
        },
        /**
         * Maximum number of columns (when using `"grid"` layout).
         *
         * @param value  Should use fixed width grid?
         */
        set: function (value) {
            this.setPropertyValue("maxColumns", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "reverseOrder", {
        /**
         * @return Reverse children?
         */
        get: function () {
            return this.getPropertyValue("reverseOrder");
        },
        /**
         * If set to `true`, the children of the container will be drawn in reverse
         * order.
         *
         * @default false
         * @param value  Reverse children?
         */
        set: function (value) {
            this.setPropertyValue("reverseOrder", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "setStateOnChildren", {
        /**
         * @return Set state on children
         */
        get: function () {
            return this.getPropertyValue("setStateOnChildren");
        },
        /**
         * Specifies if, when state is applied on this container, the same state
         * should be applied to container's children as well as `background`.
         *
         * @default false
         * @param value  Set state on children
         */
        set: function (value) {
            this.setPropertyValue("setStateOnChildren", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if point is within bounds of a container.
     *
     * @param point  A coordinate to check
     * @return `true` if it fits within container
     */
    Container.prototype.fitsToBounds = function (point) {
        var x = point.x;
        var y = point.y;
        var deviation = 0.5; // sometimes coordinates are rounded to numbers like .999 so we add deviation here
        if (x >= -deviation && x <= this.pixelWidth + deviation && y >= -deviation && y <= this.pixelHeight + deviation) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Copies all properties from different Container, including background
     * clone.
     *
     * @param source  Source Container to copy from
     */
    Container.prototype.copyFrom = function (source) {
        var _this = this;
        _super.prototype.copyFrom.call(this, source);
        this.layout = source.layout;
        this.setStateOnChildren = source.setStateOnChildren;
        if (source._background) {
            this.background = source._background.clone();
            this.background.copyFrom(source._background); // won't work without this
        }
        Iterator_each(source.children.iterator(), function (child) {
            if (child.shouldClone) {
                var clonedChild = child.clone();
                clonedChild.parent = _this;
            }
        });
    };
    Object.defineProperty(Container.prototype, "preloader", {
        /**
         * @return Preloader instance
         */
        get: function () {
            var preloader = this._preloader;
            if (preloader) {
                return preloader;
            }
            else if (this.parent) {
                return this.parent.preloader;
            }
        },
        /**
         * A [[Preloader]] instance to be used when Container is busy.
         *
         * @param preloader  Preloader instance
         */
        set: function (preloader) {
            if (this._preloader) {
                this.removeDispose(this._preloader);
            }
            this._preloader = preloader;
            if (preloader) {
                preloader.parent = this.tooltipContainer;
                this._disposers.push(preloader);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets [[Paper]] instance to use to draw elements.
     * @ignore
     * @param paper Paper
     * @return true if paper was changed, false, if it's the same
     */
    Container.prototype.setPaper = function (paper) {
        var _this = this;
        var changed = _super.prototype.setPaper.call(this, paper);
        if (changed) {
            if (this._background) {
                this._background.paper = paper;
                this._background.topParent = this.topParent;
            }
            this.children.each(function (child) {
                child.setPaper(paper);
                child.topParent = _this.topParent;
            });
        }
        return changed;
    };
    /**
     * Removes Container from the system-wide list of invalid Containers.
     *
     * @ignore Exclude from docs
     */
    Container.prototype.removeFromInvalids = function () {
        _super.prototype.removeFromInvalids.call(this);
        registry.removeFromInvalidLayouts(this);
    };
    /**
     * Sets a [[DataItem]] to be used as data for the Container.
     *
     * @todo Description
     * @param dataItem DataItem
     */
    Container.prototype.setDataItem = function (dataItem) {
        // this place is potentially dangerous, as if we set datItem for some dummy container, all children dataItems will be overriden
        // the main reason for doing this is that we need a setDataItem code to be called for each sprite, otherwise property fields won't be
        // applied. Also, getting dataItem from parent all the time is more expensive than saving value.
        if (this._dataItem != dataItem) {
            Iterator_each(this.children.iterator(), function (child) {
                child.dataItem = dataItem;
            });
            if (this._background) {
                this._background.dataItem = dataItem;
            }
        }
        _super.prototype.setDataItem.call(this, dataItem);
    };
    /**
     * Measures the element.
     *
     * @ignore Exclude from docs
     */
    Container.prototype.measureElement = function () {
        if (this.disabled || this.isTemplate || this.layout == "none" || this.__disabled) {
            // void
        }
        else {
            this.validateLayout();
        }
    };
    Object.defineProperty(Container.prototype, "fontFamily", {
        /**
         * @return Font family
         */
        get: function () {
            return this.getPropertyValue("fontFamily");
        },
        /**
         * Font family to be used for the text.
         *
         * Parts of the text may override this setting using in-line formatting.
         *
         * @param value Font family value
         */
        set: function (value) {
            if (this.setPropertyValue("fontFamily", value, true)) {
                this.setSVGAttribute({ "font-family": value });
                this.invalidateLabels();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "fontSize", {
        /**
         * @return Font size
         */
        get: function () {
            return this.getPropertyValue("fontSize");
        },
        /**
         * Font size to be used for the text. The size can either be numeric, in
         * pixels, or other measurements.
         *
         * Parts of the text may override this setting using in-line formatting.
         *
         * @param value Font size value
         */
        set: function (value) {
            if (this.setPropertyValue("fontSize", value, true)) {
                this.setSVGAttribute({ "font-size": value });
                this.invalidateLabels();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * When fontSize of fontFamily changes we need to hard-invalidate all Labels of this container to position them properly.
     */
    Container.prototype.invalidateLabels = function () {
        this.children.each(function (child) {
            // can't import Label because of Circular dependencies
            if (child["hardInvalidate"]) {
                child["hardInvalidate"]();
                // this fixes firefox and viewport issue
                child.events.once("validated", child.handleValidate, child, false);
            }
            else if (child instanceof Container) {
                child.invalidateLabels();
            }
        });
    };
    Object.defineProperty(Container.prototype, "fontWeight", {
        /**
         * @return Font weight
         */
        get: function () {
            return this.getPropertyValue("fontWeight");
        },
        /**
         * Font weight to use for text.
         *
         * Parts of the text may override this setting using in-line formatting.
         *
         * @param value Font weight
         */
        set: function (value) {
            this.setPropertyValue("fontWeight", value);
            this.setSVGAttribute({ "font-weight": value });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Container.prototype, "textDecoration", {
        /**
         * @return Decoration
         */
        get: function () {
            return this.getPropertyValue("textDecoration");
        },
        /**
         * A text decoration to use for text.
         *
         * Parts of the text may override this setting using in-line formatting.
         *
         * @param value  Decoration
         */
        set: function (value) {
            this.setPropertyValue("textDecoration", value);
            this.setSVGAttribute({ "text-decoration": value });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes (destroys) the element and all its children.
     */
    Container.prototype.dispose = function () {
        if (this._background) {
            this._background.dispose();
        }
        this._shouldBeReady = [];
        this.disposeChildren();
        _super.prototype.dispose.call(this);
    };
    /**
     * Applies a [[SpriteState]] on this element.
     *
     * The first parameter can either be a name of the state or a [[SpriteState]]
     * instance.
     *
     * When run, this method will apply SVG properties defined in a
     * [[SpriteState]], but only those that are relevant to this particular
     * element, that is are listed in its respective `properties` array.
     *
     * @see {@link SpriteState}
     * @param value               A state - name key or instance
     * @param transitionDuration  Duration of the transition between current and new state
     * @param easing              An easing function
     */
    Container.prototype.setState = function (value, transitionDuration, easing) {
        var stateName = value;
        if (value instanceof SpriteState_SpriteState) {
            stateName = value.name;
        }
        if (this.setStateOnChildren) {
            Iterator_each(this.children.iterator(), function (child) {
                child.setState(stateName, transitionDuration, easing);
                // not good to set it in child setState
                if (stateName != "active") {
                    child.isActive = false;
                }
            });
        }
        if (this._background) {
            this._background.setState(stateName);
        }
        if (this.setStateOnSprites.length) {
            each(this.setStateOnSprites, function (item) {
                item.setState(stateName, transitionDuration, easing);
            });
        }
        return _super.prototype.setState.call(this, value, transitionDuration, easing);
    };
    // otherwise isActive won't work properly with background
    Container.prototype.setActive = function (value) {
        _super.prototype.setActive.call(this, value);
        if (this._background) {
            this._background.isActive = value;
        }
    };
    /**
     * Dispatches ready event. Dispatches when all children are ready.
     */
    Container.prototype.dispatchReady = function () {
        var _this = this;
        if (!this.isReady() && !this.isDisposed()) {
            var allReady_1 = true;
            Iterator_eachContinue(this.children.iterator(), function (sprite) {
                if (!sprite.__disabled && !sprite.disabled && !sprite.isReady()) {
                    allReady_1 = false;
                    return false;
                }
                else {
                    return true;
                }
            });
            eachContinue(this._shouldBeReady, function (sprite) {
                if (!sprite.__disabled && !sprite.disabled && !sprite.isReady()) {
                    allReady_1 = false;
                    return false;
                }
                else {
                    return true;
                }
            });
            if (allReady_1) {
                _super.prototype.dispatchReady.call(this);
            }
            else {
                registry.events.once("exitframe", function () {
                    _this.dispatchReady();
                    system.requestFrame();
                }, undefined, false);
            }
        }
    };
    /**
     * Called during the System.update method
     *
     * @ignore Exclude from docs
     */
    Container.prototype._systemUpdate = function (skippedSprites) {
        this.children.each(function (child) {
            if (child.invalid) {
                if (!child._systemCheckIfValidate()) {
                    skippedSprites.push(child);
                }
                else if (child.dataItem && child.dataItem.component && child.dataItem.component.dataInvalid) {
                    skippedSprites.push(child);
                }
                else {
                    child.validate();
                }
            }
        });
        _super.prototype._systemUpdate.call(this, skippedSprites);
    };
    /**
     * Called during the System.validatePositions method
     *
     * @ignore Exclude from docs
     */
    Container.prototype._systemValidatePositions = function () {
        this.children.each(function (sprite) {
            if (sprite.positionInvalid) {
                sprite.validatePosition();
            }
        });
        _super.prototype._systemValidatePositions.call(this);
    };
    /**
     * Called during the System.validateLayouts method
     *
     * @ignore Exclude from docs
     */
    Container.prototype._systemValidateLayouts = function () {
        if (this.layoutInvalid && !this.isDisposed()) {
            this.validateLayout();
        }
    };
    Object.defineProperty(Container.prototype, "tapToActivate", {
        /**
         * @return Enable touch protection?
         */
        get: function () {
            return this._tapToActivate;
        },
        /**
         * If set to `true` the chart's regular touch functionality will be suspended
         * so that the whole page it is located in remains scrollable, even when
         * swiping over the chart's body.
         *
         * User will need to tap the chart in order to activate its regular touch
         * functionality.
         *
         * The chart will remain "active" as long as user keeps interacting with the
         * chart. After `tapTimeout` milliseconds the chart will return to its
         * "protected" mode.
         *
         * @default false
         * @since 4.4.0
         * @param  value  Enable touch protection?
         * @see {@link https://www.amcharts.com/docs/v4/concepts/touch/} For more information.
         */
        set: function (value) {
            if (this._tapToActivate != value) {
                this.setTapToActivate(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Container.prototype.setTapToActivate = function (value) {
        var _this = this;
        this._tapToActivate = value;
        this.interactions.isTouchProtected = value;
        // setEventDisposer will also remove listeners if value == false
        if (value) {
            this.interactions.setEventDisposer("container-tapToActivate", value, function () { return new Disposer_MultiDisposer([
                _this.events.on("hit", _this.handleTapToActivate, _this, false),
                _this.events.on("down", _this.initTapTimeout, _this, false),
                _this.events.on("track", _this.initTapTimeout, _this, false),
                //this.events.on("drag", this.initTapTimeout, this, false),
                getInteraction().body.events.on("down", function (ev) {
                    if (!getInteraction().isLocalElement(ev.pointer, _this.paper.svg, _this.uid)) {
                        _this.handleTapToActivateDeactivation();
                    }
                }, _this, false)
            ]); });
        }
        getInteraction();
    };
    /**
     * @todo Ignore on non-touch events
     */
    Container.prototype.handleTapToActivate = function () {
        this.interactions.isTouchProtected = false;
        this.initTapTimeout();
    };
    Container.prototype.handleTapToActivateDeactivation = function () {
        this.interactions.isTouchProtected = true;
    };
    Container.prototype.initTapTimeout = function () {
        var _this = this;
        if (this._tapToActivateTimeout) {
            this._tapToActivateTimeout.dispose();
        }
        if (this.tapToActivate && !this.interactions.isTouchProtected && this.tapTimeout) {
            this._tapToActivateTimeout = this.setTimeout(function () {
                _this.handleTapToActivateDeactivation();
            }, this.tapTimeout);
        }
    };
    /**
     * @ignore
     * @return Has license?
     */
    Container.prototype.hasLicense = function () {
        if (Options_options.commercialLicense) {
            return true;
        }
        for (var i = 0; i < Options_options.licenses.length; i++) {
            if (Options_options.licenses[i].match(/^CH.{5,}/i)) {
                return true;
            }
        }
        return false;
    };
    return Container;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Container"] = Container_Container;
//# sourceMappingURL=Container.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Log.js


/**
 * Outputs string to console if `verbose` is `true`.
 */
function log() {
    var messages = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        messages[_i] = arguments[_i];
    }
    if (Options_options.verbose) {
        if (console) {
            console.log.apply(console, __spread(messages));
        }
    }
}
/**
 * Outputs a warning to the console.
 */
function warn() {
    var messages = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        messages[_i] = arguments[_i];
    }
    if (console) {
        console.warn.apply(console, __spread(messages));
    }
}
//# sourceMappingURL=Log.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/System.js
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * The main class that handles system-wide tasks, like caching, heartbeats, etc.
 * @important
 */
var System_System = /** @class */ (function () {
    /**
     * Performs initialization of the System object.
     *
     * Called when the first [[Sprite]] object is created.
     *
     * @ignore Exclude from docs
     */
    function System() {
        /**
         * A flag indicating if the system is on pause.
         */
        this._isPaused = false;
        /**
         * Holds the list of currently playing animations.
         *
         * @ignore Exclude from docs
         */
        this.animations = [];
        /**
         * Unique ID of the object.
         */
        this.uid = registry.getUniqueId();
        /**
         * @todo Description
         * @todo Needed?
         * @ignore Exclude from docs
         */
        this.dummyCounter = 0;
        this._frameRequested = false;
        this.updateStepDuration = 45;
        this.time = Date.now();
    }
    /**
     * Reports time elapsed since timer was reset.
     *
     * @ignore Exclude from docs
     * @todo Needed?
     * @param msg    Message to report in console
     * @param reset  Reset time counter
     */
    System.prototype.reportTime = function (msg, reset) {
        if (this.dummyCounter < 6) {
            //console.log(Date.now() - this.time, msg, this.dummyCounter2);
        }
        if (reset) {
            this.time = Date.now();
        }
    };
    /**
     * Performs "heartbeat" operations `frameRate` number of times per second.
     *
     * When the chart element is invalidated, it is not immediately redrawn.
     *
     * Instead it waits for the next `update()` cycle to be re-validated.
     *
     * @ignore Exclude from docs
     * @todo Maybe should be private?
     */
    System.prototype.update = function () {
        var _this = this;
        if (this._isPaused) {
            return;
        }
        this._frameRequested = false;
        var time = Date.now();
        registry.dispatchImmediately("enterframe");
        //this.validateLayouts();
        //this.validatePositions();
        /*
                for (let key in registry.invalidLayouts) {
                    this.validateLayouts(key);
                }
                for (let key in registry.invalidPositions) {
                    this.validatePositions(key);
                }
        */
        var skippedComponents = [];
        // data objects first - do all calculations
        // only data is parsed in chunks, thats why we do for loop instead of a while like with other invalid items.
        // important to go backwards, as items are removed!
        // TODO use iterator instead
        for (var key in registry.invalidDatas) {
            if (hasKey(registry.invalidDatas, key)) {
                var invalidData = registry.invalidDatas[key];
                while (invalidData.length > 0) {
                    var component = invalidData[0];
                    var dataProvider = component.dataProvider;
                    if (!component.isDisposed()) {
                        if (dataProvider && dataProvider.dataInvalid) {
                            try {
                                dataProvider.validateData();
                                if (dataProvider.dataValidationProgress < 1) {
                                    break;
                                }
                            }
                            catch (e) {
                                remove(invalidData, dataProvider);
                                dataProvider.raiseCriticalError(e);
                            }
                        }
                        else {
                            try {
                                component.validateData();
                                if (component.dataValidationProgress < 1) {
                                    break;
                                }
                            }
                            catch (e) {
                                remove(invalidData, component);
                                component.raiseCriticalError(e);
                            }
                        }
                    }
                    else {
                        remove(invalidData, component);
                    }
                }
                if (Date.now() - time > this.updateStepDuration) {
                    break;
                }
            }
        }
        while (registry.invalidRawDatas.length > 0) {
            var component = registry.invalidRawDatas[0];
            if (!component.isDisposed()) {
                try {
                    component.validateRawData();
                }
                catch (e) {
                    remove(registry.invalidRawDatas, component);
                    component.raiseCriticalError(e);
                }
            }
            else {
                remove(registry.invalidRawDatas, component);
            }
        }
        // TODO use iterator instead
        while (registry.invalidDataItems.length > 0) {
            var component = registry.invalidDataItems[0];
            var dataProvider = component.dataProvider;
            // this is needed to avoid partial value validation when data is parsed in chunks
            if (component.isDisposed() || component.dataInvalid || (dataProvider && dataProvider.dataInvalid)) {
                // void
            }
            else {
                try {
                    component.validateDataItems();
                }
                catch (e) {
                    remove(registry.invalidDataItems, component);
                    component.raiseCriticalError(e);
                }
            }
            // this might seem too much, as validateValues removes from invalidDataItems aswell, but just to be sure (in case validateData is overriden and no super is called)
            remove(registry.invalidDataItems, component);
        }
        // TODO use iterator instead
        while (registry.invalidDataRange.length > 0) {
            var component = registry.invalidDataRange[0];
            var dataProvider = component.dataProvider;
            if (component.isDisposed() || component.dataInvalid || (dataProvider && dataProvider.dataInvalid)) {
                // void
            }
            else {
                try {
                    component.validateDataRange();
                    if (!component.skipRangeEvent) {
                        component.dispatchImmediately("datarangechanged");
                    }
                    component.skipRangeEvent = false;
                }
                catch (e) {
                    remove(registry.invalidDataRange, component);
                    component.raiseCriticalError(e);
                }
            }
            // this might seem too much, as validateDataRange removes from invalidDataRange aswell, but just to be sure (in case validateData is overriden and no super is called)
            remove(registry.invalidDataRange, component);
        }
        var skippedSprites = [];
        // display objects later
        // TODO use iterator instead
        Object_each(registry.invalidLayouts, function (key) {
            _this.validateLayouts(key);
        });
        Object_each(registry.invalidPositions, function (key) {
            _this.validatePositions(key);
        });
        var hasSkipped = false;
        time = Date.now();
        Object_each(registry.invalidSprites, function (key, invalidSprites) {
            var count = 0;
            while (invalidSprites.length > 0) {
                _this.validateLayouts(key);
                _this.validatePositions(key);
                count++;
                if (count == 5) {
                    if (Date.now() - time > _this.updateStepDuration) {
                        break;
                    }
                    count = 0;
                }
                var sprite = invalidSprites[invalidSprites.length - 1];
                // we need to check this, as validateLayout might validate sprite
                if (sprite && !sprite.isDisposed()) {
                    if (!sprite._systemCheckIfValidate()) {
                        // void
                        skippedSprites.push(sprite);
                    }
                    else {
                        if (!_this.checkIfValidate2(sprite)) {
                            // void
                            skippedSprites.push(sprite);
                        }
                        else {
                            try {
                                sprite._systemUpdate(skippedSprites);
                            }
                            catch (e) {
                                sprite.invalid = false;
                                remove(invalidSprites, sprite);
                                sprite.raiseCriticalError(e);
                            }
                        }
                    }
                    // this might seem too much, but it's ok
                    sprite.invalid = false;
                }
                remove(invalidSprites, sprite);
            }
            registry.invalidSprites[key] = registry.invalidSprites[key].concat(skippedSprites);
        });
        Object_each(registry.invalidSprites, function (key, value) {
            if (value.length > 0) {
                hasSkipped = true;
            }
        });
        Object_each(registry.invalidDatas, function (key, value) {
            if (value.length > 0) {
                hasSkipped = true;
            }
        });
        // TODO make this more efficient
        // TODO don't copy the array
        each(copy(this.animations), function (x) {
            x.update();
        });
        //if(!hasSkipped){
        Object_each(registry.invalidLayouts, function (key) {
            _this.validateLayouts(key);
        });
        Object_each(registry.invalidPositions, function (key) {
            _this.validatePositions(key);
        });
        //}
        triggerIdle();
        Object_each(registry.invalidLayouts, function (key) {
            _this.validateLayouts(key);
        });
        Object_each(registry.invalidPositions, function (key) {
            _this.validatePositions(key);
        });
        registry.dispatchImmediately("exitframe");
        if (hasSkipped || this.animations.length > 0 || skippedComponents.length > 0) {
            this.requestFrame();
        }
        if (this.updateStepDuration < 200) {
            var all0_1 = true;
            Object_each(registry.invalidDatas, function (key, value) {
                if (value.length > 0) {
                    all0_1 = false;
                }
            });
            Object_each(registry.invalidSprites, function (key, value) {
                if (value.length > 0) {
                    all0_1 = false;
                }
            });
            if (all0_1) {
                this.updateStepDuration = 200;
            }
        }
    };
    System.prototype.checkIfValidate2 = function (sprite) {
        if (sprite.dataItem && sprite.dataItem.component && sprite.dataItem.component.dataInvalid && !sprite.dataItem.component.isTemplate) {
            return false;
        }
        else {
            return true;
        }
    };
    /**
     * Requests new animation frame
     */
    System.prototype.requestFrame = function () {
        var _this = this;
        if (!this._frameRequested) {
            raf(function () {
                _this.update();
            });
            this._frameRequested = true;
        }
    };
    /**
     * Call this method if you update data or config of a chart that is in
     * hidden container, after revealing the container, so that labels and
     * possibly other elements can correctly arrange themselves.
     *
     * @since 4.7.10
     * @param  container  Target container
     */
    System.prototype.softInvalidate = function (container) {
        var _this = this;
        container.children.each(function (child) {
            if (child instanceof Container_Container) {
                _this.softInvalidate(child);
            }
            if (child.measureFailed) {
                if (is(child, "Label")) {
                    child.hardInvalidate();
                }
                else {
                    child.invalidate();
                }
                child.measureFailed = false;
            }
        });
    };
    /**
     * Triggers position re-validation on all [[Sprite]] elements that have
     * invalid(ated) positions.
     *
     * @ignore Exclude from docs
     * @todo Maybe should be private?
     */
    System.prototype.validatePositions = function (id) {
        // invalid positions
        // TODO use iterator instead
        var invalidPositions = registry.invalidPositions[id];
        while (invalidPositions.length > 0) {
            var sprite = invalidPositions[invalidPositions.length - 1];
            if (!sprite.isDisposed()) {
                try {
                    sprite._systemValidatePositions();
                }
                catch (e) {
                    sprite.positionInvalid = false;
                    remove(invalidPositions, sprite);
                    sprite.raiseCriticalError(e);
                }
            }
            else {
                remove(invalidPositions, sprite);
            }
        }
    };
    /**
     * Triggers position re-validation on all [[Container]] elements that have
     * invalid(ated) layouts.
     *
     * @ignore Exclude from docs
     * @todo Maybe should be private?
     */
    System.prototype.validateLayouts = function (id) {
        // invalid positions
        // TODO use iterator instead
        var invalidLayouts = registry.invalidLayouts[id];
        while (invalidLayouts.length > 0) {
            var container = invalidLayouts[invalidLayouts.length - 1];
            if (!container.isDisposed()) {
                try {
                    container.children.each(function (sprite) {
                        sprite._systemValidateLayouts();
                    });
                    container.validateLayout();
                }
                catch (e) {
                    container.layoutInvalid = false;
                    remove(invalidLayouts, container);
                    container.raiseCriticalError(e);
                }
            }
            else {
                remove(invalidLayouts, container);
            }
        }
    };
    /**
     * Outputs string to console if `verbose` is `true`.
     *
     * @param value Message to output to console
     */
    System.prototype.log = function (value) {
        log(value);
    };
    Object.defineProperty(System.prototype, "isPaused", {
        /**
         * @return Is system on pause?
         */
        get: function () {
            return this._isPaused;
        },
        /**
         * Pauses all the processes of all the amCharts objects on the page
         *
         * @return is paused?
         */
        set: function (value) {
            this._isPaused = value;
            if (!value) {
                this._frameRequested = false;
                this.requestFrame();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * amCharts Version.
     *
     * This follows npm's semver specification.
     *
     * @see {@link https://docs.npmjs.com/misc/semver}
     */
    System.VERSION = "4.9.21";
    return System;
}());

/**
 * A singleton global instance of [[System]].
 *
 * All code should use this, rather than instantiating their
 * own System objects.
 */
var system = new System_System();
//# sourceMappingURL=System.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/data/DataParser.js
/**
 * Data parser module.
 */
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Base class for the data parsers.
 */
var DataParser_DataParser = /** @class */ (function () {
    function DataParser() {
    }
    /**
     * A "placeholder" function for real parsers to override.
     *
     * @ignore Exclude from docs
     * @param data  Source data
     * @return Parsed data (empty)
     */
    DataParser.prototype.parse = function (data) {
        return [];
    };
    ;
    Object.defineProperty(DataParser.prototype, "parsableNumbers", {
        /**
         * Checks if there are any numeric fields that need to be converted to
         * numbers.
         *
         * @return Numeric fields?
         */
        get: function () {
            return this.options.numberFields && (this.options.numberFields.length > 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts a value to 'number' if it is in `numberFields`.
     *
     * @param field  Field name
     * @param value  Value
     * @return Parsed or original value
     */
    DataParser.prototype.maybeToNumber = function (field, value) {
        if (this.options.numberFields.indexOf(field) !== -1) {
            return anyToNumber(value);
        }
        return value;
    };
    Object.defineProperty(DataParser.prototype, "parsableDates", {
        /**
         * Checks if there are any date fields that need to be converted to `Date`
         * objects.
         *
         * @return Date fields?
         */
        get: function () {
            return this.options.dateFields && (this.options.dateFields.length > 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts a value to `Date` if it is in `dateFields`.
     *
     * @param field  Field name
     * @param value  Value
     * @return Parsed or original value
     */
    DataParser.prototype.maybeToDate = function (field, value) {
        if (this.options.dateFields.indexOf(field) !== -1) {
            return this.options.dateFormatter.parse(value, this.dateFormat);
        }
        return value;
    };
    /**
     * Replaces empty value with something else.
     *
     * @param value  Source value
     * @return Source value or replacement
     */
    DataParser.prototype.maybeToEmpty = function (value) {
        if ((!hasValue(value) || value == "") && hasValue(this.options.emptyAs)) {
            return this.options.emptyAs;
        }
        return value;
    };
    Object.defineProperty(DataParser.prototype, "dateFormatter", {
        /**
         * [[DateFormatter]] object for date parsing.
         *
         * If there was not [[DateFormatter]] supplied in parser options, a new one
         * is created.
         *
         * @return Date formatter
         * @see {@link DateFormatter}
         */
        get: function () {
            if (!this.options.dateFormatter) {
                this.options.dateFormatter = new DateFormatter_DateFormatter;
                if (this.options.dateFormat) {
                    this.options.dateFormat = this.options.dateFormat;
                }
            }
            return this.options.dateFormatter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataParser.prototype, "dateFormat", {
        /**
         * A date format to use when parsing dates.
         *
         * @return Date format
         * @see {@link DateFormatter}
         */
        get: function () {
            return this.options.dateFormat || this.dateFormatter.inputDateFormat;
        },
        enumerable: true,
        configurable: true
    });
    return DataParser;
}());

//# sourceMappingURL=DataParser.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/data/CSVParser.js
/**
 * CSV parser.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * Define possible separators.
 */
var separators = [",", ";", "\t"];
/**
 * A parser for CSV format.
 *
 * @important
 */
var CSVParser_CSVParser = /** @class */ (function (_super) {
    __extends(CSVParser, _super);
    function CSVParser() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Content-type suitable for CSV format.
         */
        _this.contentType = "text/csv";
        /**
         * Parser options.
         *
         * @see {@link ICSVOptions} for description of each option
         */
        _this.options = {
            delimiter: "",
            reverse: false,
            skipRows: 0,
            skipEmpty: true,
            useColumnNames: false
        };
        return _this;
    }
    /**
     * Tests if the format is CSV.
     *
     * @param data  Source data
     * @return Is it CSV?
     */
    CSVParser.isCSV = function (data) {
        return CSVParser.getDelimiterFromData(data) ? true : false;
    };
    /**
     * Tries to determine a column separator.
     *
     * @param data  Source data
     * @return Separator
     */
    CSVParser.getDelimiterFromData = function (data) {
        // We're going to take first few lines of the CSV with different
        // possible separators and check if it results in same number of columns.
        // If it does, we're going to assume it's a CSV
        var lines = data.split("\n");
        var len = lines.length;
        var separator;
        each(separators, function (sep) {
            var columns = 0, lineColums = 0;
            // TODO replace with iterators
            for (var i = 0; i < len; ++i) {
                // Get number of columns in a line
                columns = lines[i].split(sep).length;
                if (columns > 1) {
                    // More than one column - possible candidate
                    if (lineColums === 0) {
                        // First line
                        lineColums = columns;
                    }
                    else if (columns != lineColums) {
                        // Incorrect number of columns, give up on this separator
                        lineColums = 0;
                        break;
                    }
                }
                else {
                    // Not this separator
                    // Not point in continuing
                    lineColums = 0;
                    break;
                }
            }
            // Check if we have a winner
            if (lineColums) {
                separator = sep;
            }
        });
        return separator;
    };
    /**
     * Parses and returns data.
     *
     * @param data  Unparsed data
     * @return Parsed data
     */
    CSVParser.prototype.parse = function (csv) {
        // Check if we have delimiter set
        if (!this.options.delimiter) {
            this.options.delimiter = CSVParser.getDelimiterFromData(csv);
        }
        // Get CSV data as array
        var data = this.CSVToArray(csv, this.options.delimiter);
        // Do we need to cast some fields to numbers?
        var empty = hasValue(this.options.emptyAs);
        var numbers = this.parsableNumbers;
        var dates = this.parsableDates;
        // Init resuling array
        var res = [], cols = [], col, i;
        // Skip rows
        for (i = 0; i < this.options.skipRows; i++) {
            data.shift();
        }
        // First row holds column names?
        if (this.options.useColumnNames) {
            cols = data.shift();
            // Normalize column names
            for (var x = 0; x < cols.length; x++) {
                // trim
                col = hasValue(cols[x]) ? cols[x].replace(/^\s+|\s+$/gm, "") : "";
                // Check for empty
                if ("" === col) {
                    col = "col" + x;
                }
                cols[x] = col;
            }
        }
        // Iterate through the result set
        var row;
        while (true) {
            row = this.options.reverse ? data.pop() : data.shift();
            if (!row) {
                break;
            }
            if (this.options.skipEmpty && row.length === 1 && row[0] === "") {
                continue;
            }
            var dataPoint = {};
            for (i = 0; i < row.length; i++) {
                col = undefined === cols[i] ? "col" + i : cols[i];
                dataPoint[col] = row[i] === "" ? this.options.emptyAs : row[i];
                // Convert
                if (empty) {
                    dataPoint[col] = this.maybeToEmpty(dataPoint[col]);
                }
                if (numbers) {
                    dataPoint[col] = this.maybeToNumber(col, dataPoint[col]);
                }
                if (dates) {
                    dataPoint[col] = this.maybeToDate(col, dataPoint[col]);
                }
            }
            res.push(dataPoint);
        }
        return res;
    };
    /**
     * Converts CSV into array.
     *
     * The functionality of this function is taken from here:
     * http://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm
     *
     * @param data       Source data
     * @param delimiter  Column delimiter
     * @return Parsed array
     */
    CSVParser.prototype.CSVToArray = function (data, delimiter) {
        // Check to see if the delimiter is defined. If not,
        // then default to comma.
        delimiter = (delimiter || ',');
        // Create a regular expression to parse the CSV values.
        var objPattern = new RegExp((
        // Delimiters.
        "(\\" + delimiter + "|\\r?\\n|\\r|^)" +
            // Quoted fields.
            "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +
            // Standard fields.
            "([^\"\\" + delimiter + "\\r\\n]*))"), "gi");
        // Create an array to hold our data. Give the array
        // a default empty first row.
        var arrData = [
            []
        ];
        // Create an array to hold our individual pattern
        // matching groups.
        var arrMatches = null;
        // Keep looping over the regular expression matches
        // until we can no longer find a match.
        while (true) {
            arrMatches = objPattern.exec(data);
            if (!arrMatches) {
                break;
            }
            // Get the delimiter that was found.
            var strMatchedDelimiter = arrMatches[1];
            // Check to see if the given delimiter has a length
            // (is not the start of string) and if it matches
            // field delimiter. If id does not, then we know
            // that this delimiter is a row delimiter.
            if (strMatchedDelimiter.length &&
                (strMatchedDelimiter !== delimiter)) {
                // Since we have reached a new row of data,
                // add an empty row to our data array.
                arrData.push([]);
            }
            // Now that we have our delimiter out of the way,
            // let's check to see which kind of value we
            // captured (quoted or unquoted).
            var strMatchedValue = void 0;
            if (arrMatches[2]) {
                // We found a quoted value. When we capture
                // this value, unescape any double quotes.
                strMatchedValue = arrMatches[2].replace(new RegExp("\"\"", "g"), "\"");
            }
            else {
                // We found a non-quoted value.
                strMatchedValue = arrMatches[3];
            }
            // Now that we have our value string, let's add
            // it to the data array.
            arrData[arrData.length - 1].push(strMatchedValue);
        }
        // Return the parsed data.
        return (arrData);
    };
    return CSVParser;
}(DataParser_DataParser));

//# sourceMappingURL=CSVParser.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/data/JSONParser.js
/**
 * JSON parser.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * A parser for JSON.
 *
 * @important
 */
var JSONParser_JSONParser = /** @class */ (function (_super) {
    __extends(JSONParser, _super);
    function JSONParser() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Content-type suitable for JSON format.
         */
        _this.contentType = "application/json";
        /**
         * Parser options.
         *
         * @see {@link IJSONOptions} for description of each option
         */
        _this.options = {};
        return _this;
    }
    /**
     * Tests if the data is valid JSON.
     *
     * @param data  Source data
     * @return Is it JSON?
     */
    JSONParser.isJSON = function (data) {
        try {
            // Try parsing JSON
            JSON.parse(data);
            // If we got to this point it means it's a valid JSON
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * Parses and returns data.
     *
     * @param data  Unparsed data
     * @return Parsed data
     */
    JSONParser.prototype.parse = function (data) {
        var _this = this;
        // Init return
        var res;
        // Try parsing
        try {
            if (hasValue(JSON)) {
                res = JSON.parse(data);
            }
        }
        catch (e) {
            return undefined;
        }
        // Do we need to cast some fields to numbers or dates?
        var empty = hasValue(this.options.emptyAs);
        var numbers = this.parsableNumbers;
        var dates = this.parsableDates;
        if (Array.isArray(res) && (numbers || dates || empty)) {
            var _loop_1 = function (i, len) {
                var row = res[i];
                Object_each(row, function (key, value) {
                    if (empty) {
                        row[key] = _this.maybeToEmpty(row[key]);
                    }
                    if (numbers) {
                        row[key] = _this.maybeToNumber(key, row[key]);
                    }
                    if (dates) {
                        row[key] = _this.maybeToDate(key, row[key]);
                    }
                });
            };
            // Iterate through the data and check if it needs to be converted
            for (var i = 0, len = res.length; i < len; i++) {
                _loop_1(i, len);
            }
        }
        // Convert to array
        //return Array.isArray(res) ? res : [res];
        return res;
    };
    return JSONParser;
}(DataParser_DataParser));

//# sourceMappingURL=JSONParser.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/data/DataLoader.js
/**
 * Data Loader is responsible for loading and parsing external data
 */





;
/**
 * Data Loader is responsible for loading and parsing external data.
 *
 * There is just one instance of DataLoader per system. Unless you have a
 * speicific reason, do not instantiate additional instances.
 *
 * The global instance of Data Loader is accessible via:
 *
 * ```TypeScript
 * am4core.dataLoader;
 * ```
 * ```JavaScript
 * am4core.dataLoader;
 * ```
 *
 * A loading of specific data source is done via [[DataSource]].
 *
     Please refer to [[DataSource]] for information how to use it.
 *
 * @see {@link IDataLoaderAdapters} for a list of available Adapters
 */
var DataLoader_DataLoader = /** @class */ (function () {
    function DataLoader() {
        /**
         * Adapter.
         */
        this.adapter = new Adapter_Adapter(this);
    }
    /**
     * Loads a supplied [[DataSource]] or an array of data sources, then calls
     * their respective `parse` methods.
     *
     * @param source  A single data source or an array of multiple of data sources
     */
    DataLoader.prototype.load = function (source) {
        var sources = Array.isArray(source) ? source : [source];
        // Add each Source to the list to be loaded simultaneously
        var promises = map(sources, function (x) {
            // Dispatch events
            x.dispatchImmediately("started");
            x.dispatchImmediately("loadstarted");
            return load(x.url, x, x.requestOptions);
        });
        // Run all promises in parallel
        Promise.all(promises).then(function (res) {
            // Process each loaded source
            each(res, function (result) {
                // Get Source
                var source = result.target;
                // Dispatch events
                source.dispatchImmediately("loadended");
                if (result.error) {
                    if (source.events.isEnabled("error")) {
                        source.events.dispatchImmediately("error", {
                            type: "error",
                            code: result.xhr.status,
                            message: source.language.translate("Unable to load file: %1", null, source.url),
                            target: source
                        });
                    }
                }
                else {
                    // Initiate parsing of the loaded data
                    source.processData(result.response, result.type);
                }
                source.dispatchImmediately("ended");
            });
        }).catch(function (res) {
            if (res.target) {
                res.target.dispatchImmediately("loadended");
                if (res.target.events.isEnabled("error")) {
                    res.target.events.dispatchImmediately("error", {
                        type: "error",
                        code: res.xhr.status,
                        message: res.target.language.translate("Unable to load file: %1", null, res.target.url),
                        target: res.target
                    });
                }
                res.target.dispatchImmediately("ended");
            }
        });
    };
    /**
     * Instantiates a [[DataParser]] object based on the data type.
     * Built-in parser types are as follows:
     *
     * * "csv" or "text/csv"
     * * "json" or "application/json"
     *
     * @param contentType  A format type
     * @return A parser object
     */
    DataLoader.prototype.getParserByType = function (contentType) {
        // Let some plugin decide
        var parser = this.adapter.apply("getParserByType", {
            parser: null,
            type: contentType
        }).parser;
        if (parser) {
            return parser;
        }
        if (contentType == "csv" || contentType == "text/csv" || contentType == "application/vnd.ms-excel") {
            return new CSVParser_CSVParser();
        }
        if (contentType == "json" || contentType == "application/json") {
            return new JSONParser_JSONParser();
        }
        return;
    };
    /**
     * Tries to determine a parser out of content type and/or actual data.
     *
     * @param data         Data
     * @param contentType  Content-type
     * @return Parser instance
     */
    DataLoader.prototype.getParserByData = function (data, contentType) {
        // Let some plugin decide
        var parser = this.adapter.apply("getParserByData", {
            parser: null,
            data: data,
            type: contentType
        }).parser;
        // Check if we have parser from outside code
        if (!parser) {
            // No, let's try to figure it out
            parser = this.getParserByType(contentType);
            if (parser) {
                // We're able to figure out parser by content-type
                return parser;
            }
            else if (JSONParser_JSONParser.isJSON(data)) {
                return this.getParserByType("json");
            }
            else if (CSVParser_CSVParser.isCSV(data)) {
                return this.getParserByType("csv");
            }
        }
        return parser;
    };
    return DataLoader;
}());

/**
 * Create instance of Data Loader
 */
var dataLoader = new DataLoader_DataLoader();
//# sourceMappingURL=DataLoader.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/data/DataSource.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */










;
;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Represents a single data source - external file with all of its settings,
 * such as format, data parsing, etc.
 *
 * ```TypeScript
 * chart.dataSource.url = "http://www.myweb.com/data.json";
 * chart.dataSource.parser = am4core.JSONParser;
 * ```
 * ```JavaScript
 * chart.dataSource.url = "http://www.myweb.com/data.json";
 * chart.dataSource.parser = am4core.JSONParser;
 * ```
 * ```JSON
 * {
 *   // ...
 *   "dataSource": {
 *     "url": "http://www.myweb.com/data.json",
 *     "parser": "JSONParser"
 *   },
 *   // ...
 * }
 * ```
 *
 * @see {@link IDataSourceEvents} for a list of available events
 * @see {@link IDataSourceAdapters} for a list of available Adapters
 */
var DataSource_DataSource = /** @class */ (function (_super) {
    __extends(DataSource, _super);
    /**
     * Constructor
     */
    function DataSource(url, parser) {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Adapter.
         */
        _this.adapter = new Adapter_Adapter(_this);
        /**
         * Custom options for HTTP(S) request.
         */
        _this._requestOptions = {};
        /**
         * If set to `true`, any subsequent data loads will be considered incremental
         * (containing only new data points that are supposed to be added to existing
         * data).
         *
         * NOTE: this setting works only with element's `data` property. It won't
         * work with any other externally-loadable data property.
         *
         * @default false
         */
        _this._incremental = false;
        /**
         * A collection of key/value pairs to attach to a data source URL when making
         * an incremental request.
         */
        _this._incrementalParams = {};
        /**
         * This setting is used only when `incremental = true`. If set to `true`,
         * it will try to retain the same number of data items across each load.
         *
         * E.g. if incremental load yeilded 5 new records, then 5 items from the
         * beginning of data will be removed so that we end up with the same number
         * of data items.
         *
         * @default false
         */
        _this._keepCount = false;
        /**
         * If set to `true`, each subsequent load will be treated as an update to
         * currently loaded data, meaning that it will try to update values on
         * existing data items, not overwrite the whole data.
         *
         * This will work faster than complete update, and also will animate the
         * values to their new positions.
         *
         * Data sources across loads must contain the same number of data items.
         *
         * Loader will not truncate the data set if loaded data has fewer data items,
         * and if it is longer, the excess data items will be ignored.
         *
         * @default false
         * @since 4.5.5
         */
        _this._updateCurrentData = false;
        /**
         * Will show loading indicator when loading files.
         */
        _this.showPreloader = true;
        _this.className = "DataSource";
        // Set defaults
        if (url) {
            _this.url = url;
        }
        // Set parser
        if (parser) {
            if (typeof parser == "string") {
                _this.parser = dataLoader.getParserByType(parser);
            }
            else {
                _this.parser = parser;
            }
        }
        return _this;
    }
    /**
     * Processes the loaded data.
     *
     * @ignore Exclude from docs
     * @param data         Raw (unparsed) data
     * @param contentType  Content type of the loaded data (optional)
     */
    DataSource.prototype.processData = function (data, contentType) {
        // Parsing started
        this.dispatchImmediately("parsestarted");
        // Check if parser is set
        if (!this.parser) {
            // Try to resolve from data
            this.parser = dataLoader.getParserByData(data, contentType);
            if (!this.parser) {
                // We have a problem - nobody knows what to do with the data
                // Raise error
                if (this.events.isEnabled("parseerror")) {
                    var event_1 = {
                        type: "parseerror",
                        message: this.language.translate("No parser available for file: %1", null, this.url),
                        target: this
                    };
                    this.events.dispatchImmediately("parseerror", event_1);
                }
                this.dispatchImmediately("parseended");
                return;
            }
        }
        // Apply options adapters
        this.parser.options = this.adapter.apply("parserOptions", this.parser.options);
        this.parser.options.dateFields = this.adapter.apply("dateFields", this.parser.options.dateFields || []);
        this.parser.options.numberFields = this.adapter.apply("numberFields", this.parser.options.numberFields || []);
        // Check if we need to pass in date formatter
        if (this.parser.options.dateFields && !this.parser.options.dateFormatter) {
            this.parser.options.dateFormatter = this.dateFormatter;
        }
        // Parse
        this.data = this.adapter.apply("parsedData", this.parser.parse(this.adapter.apply("unparsedData", data)));
        // Check for parsing errors
        if (!hasValue(this.data) && this.events.isEnabled("parseerror")) {
            var event_2 = {
                type: "parseerror",
                message: this.language.translate("Error parsing file: %1", null, this.url),
                target: this
            };
            this.events.dispatchImmediately("parseerror", event_2);
        }
        // Wrap up
        this.dispatchImmediately("parseended");
        if (hasValue(this.data)) {
            this.dispatchImmediately("done", {
                "data": this.data
            });
        }
        // The component is responsible for updating its own data vtriggered via
        // events.
        // Update last data load
        this.lastLoad = new Date();
    };
    Object.defineProperty(DataSource.prototype, "url", {
        /**
         * @return URL
         */
        get: function () {
            // Get URL
            var url = this.disableCache
                ? this.timestampUrl(this._url)
                : this._url;
            // Add incremental params
            if (this.incremental && this.component.data.length) {
                url = this.addUrlParams(url, this.incrementalParams);
            }
            return this.adapter.apply("url", url);
        },
        /**
         * URL of the data source.
         *
         * @param value  URL
         */
        set: function (value) {
            this._url = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "requestOptions", {
        /**
         * @return Options
         */
        get: function () {
            return this.adapter.apply("requestOptions", this._requestOptions);
        },
        /**
         * Custom options for HTTP(S) request.
         *
         * At this moment the only option supported is: `requestHeaders`, which holds
         * an array of objects for custom request headers, e.g.:
         *
         * ```TypeScript
         * chart.dataSource.requestOptions.requestHeaders = [{
         *   "key": "x-access-token",
         *   "value": "123456789"
         * }];
         * ``````JavaScript
         * chart.dataSource.requestOptions.requestHeaders = [{
         *   "key": "x-access-token",
         *   "value": "123456789"
         * }];
         * ```
         * ```JSON
         * {
         *   // ...
         *   "dataSource": {
         *     // ...
         *     "requestOptions": {
         *       "requestHeaders": [{
         *         "key": "x-access-token",
         *         "value": "123456789"
         *       }]
         *     }
         *   }
         * }
         * ```
         *
         * NOTE: setting this options on an-already loaded DataSource will not
         * trigger a reload.
         *
         * @param value  Options
         */
        set: function (value) {
            this._requestOptions = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "parser", {
        /**
         * @return Data parser
         */
        get: function () {
            if (!this._parser) {
                this._parser = new JSONParser_JSONParser();
            }
            return this.adapter.apply("parser", this._parser);
        },
        /**
         * A parser to be used to parse data.
         *
         * ```TypeScript
         * chart.dataSource.url = "http://www.myweb.com/data.json";
         * chart.dataSource.parser = am4core.JSONParser;
         * ```
         * ```JavaScript
         * chart.dataSource.url = "http://www.myweb.com/data.json";
         * chart.dataSource.parser = am4core.JSONParser;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "dataSource": {
         *     "url": "http://www.myweb.com/data.json",
         *     "parser": "JSONParser"
         *   },
         *   // ...
         * }
         * ```
         *
         * @default JSONParser
         * @param value  Data parser
         */
        set: function (value) {
            this._parser = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "reloadFrequency", {
        /**
         * @return Reload frequency (ms)
         */
        get: function () {
            return this.adapter.apply("reloadTimeout", this._reloadFrequency);
        },
        /**
         * Data source reload frequency.
         *
         * If set, it will reload the same URL every X milliseconds.
         *
         * @param value Reload frequency (ms)
         */
        set: function (value) {
            var _this = this;
            if (this._reloadFrequency != value) {
                this._reloadFrequency = value;
                // Should we schedule a reload?
                if (value) {
                    if (!hasValue(this._reloadDisposer)) {
                        this._reloadDisposer = this.events.on("ended", function (ev) {
                            _this._reloadTimeout = setTimeout(function () {
                                _this.load();
                            }, _this.reloadFrequency);
                        });
                    }
                }
                else if (hasValue(this._reloadDisposer)) {
                    this._reloadDisposer.dispose();
                    this._reloadDisposer = undefined;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "incremental", {
        /**
         * @return Incremental load?
         */
        get: function () {
            return this.adapter.apply("incremental", this._incremental);
        },
        /**
         * Should subsequent reloads be treated as incremental?
         *
         * Incremental loads will assume that they contain only new data items
         * since the last load.
         *
         * If `incremental = false` the loader will replace all of the target's
         * data with each load.
         *
         * This setting does not have any effect trhe first time data is loaded.
         *
         * NOTE: this setting works only with element's `data` property. It won't
         * work with any other externally-loadable data property.
         *
         * @default false
         * @param Incremental load?
         */
        set: function (value) {
            this._incremental = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "incrementalParams", {
        /**
         * @return Incremental request parameters
         */
        get: function () {
            return this.adapter.apply("incrementalParams", this._incrementalParams);
        },
        /**
         * An object consisting of key/value pairs to apply to an URL when data
         * source is making an incremental request.
         *
         * @param value  Incremental request parameters
         */
        set: function (value) {
            this._incrementalParams = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "keepCount", {
        /**
         * @return keepCount load?
         */
        get: function () {
            return this.adapter.apply("keepCount", this._keepCount);
        },
        /**
         * This setting is used only when `incremental = true`. If set to `true`,
         * it will try to retain the same number of data items across each load.
         *
         * E.g. if incremental load yeilded 5 new records, then 5 items from the
         * beginning of data will be removed so that we end up with the same number
         * of data items.
         *
         * @default false
         * @param Keep record count?
         */
        set: function (value) {
            this._keepCount = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "updateCurrentData", {
        /**
         * @return Update current data?
         */
        get: function () {
            return this.adapter.apply("updateCurrentData", this._updateCurrentData);
        },
        /**
         * If set to `true`, each subsequent load will be treated as an update to
         * currently loaded data, meaning that it will try to update values on
         * existing data items, not overwrite the whole data.
         *
         * This will work faster than complete update, and also will animate the
         * values to their new positions.
         *
         * Data sources across loads must contain the same number of data items.
         *
         * Loader will not truncate the data set if loaded data has fewer data items,
         * and if it is longer, the excess data items will be ignored.
         *
         * NOTE: this setting is ignored if `incremental = true`.
         *
         * @default false
         * @since 2.5.5
         * @param Update current data?
         */
        set: function (value) {
            this._updateCurrentData = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "language", {
        /**
         * @return A [[Language]] instance to be used
         */
        get: function () {
            if (this._language) {
                return this._language;
            }
            else if (this.component) {
                this._language = this.component.language;
                return this._language;
            }
            this.language = new Language_Language();
            return this.language;
        },
        /**
         * Language instance to use.
         *
         * Will inherit and use chart's language, if not set.
         *
         * @param value An instance of Language
         */
        set: function (value) {
            this._language = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataSource.prototype, "dateFormatter", {
        /**
         * @return A [[DateFormatter]] instance to be used
         */
        get: function () {
            if (this._dateFormatter) {
                return this._dateFormatter;
            }
            else if (this.component) {
                this._dateFormatter = this.component.dateFormatter;
                return this._dateFormatter;
            }
            this.dateFormatter = new DateFormatter_DateFormatter();
            return this.dateFormatter;
        },
        /**
         * A [[DateFormatter]] to use when parsing dates from string formats.
         *
         * Will inherit and use chart's DateFormatter if not ser.
         *
         * @param value An instance of [[DateFormatter]]
         */
        set: function (value) {
            this._dateFormatter = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds current timestamp to the URL.
     *
     * @param url  Source URL
     * @return Timestamped URL
     */
    DataSource.prototype.timestampUrl = function (url) {
        var tstamp = new Date().getTime().toString();
        var params = {};
        params[tstamp] = "";
        return this.addUrlParams(url, params);
    };
    /**
     * Disposes of this object.
     */
    DataSource.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this._reloadTimeout) {
            clearTimeout(this._reloadTimeout);
        }
        if (hasValue(this._reloadDisposer)) {
            this._reloadDisposer.dispose();
            this._reloadDisposer = undefined;
        }
    };
    /**
     * Initiate the load.
     *
     * All loading in JavaScript is asynchronous. This function will trigger the
     * load and will exit immediately.
     *
     * Use DataSource's events to watch for loaded data and errors.
     */
    DataSource.prototype.load = function () {
        if (this.url) {
            if (this._reloadTimeout) {
                clearTimeout(this._reloadTimeout);
            }
            dataLoader.load(this);
        }
    };
    /**
     * Adds parameters to `url` as query strings. Will take care of proper
     * separators.
     *
     * @param url     Source URL
     * @param params  Parameters
     * @return New URL
     */
    DataSource.prototype.addUrlParams = function (url, params) {
        var join = url.match(/\?/) ? "&" : "?";
        var add = [];
        Object_each(params, function (key, value) {
            if (value != "") {
                add.push(key + "=" + encodeURIComponent(value));
            }
            else {
                add.push(key);
            }
        });
        if (add.length) {
            return url + join + add.join("&");
        }
        return url;
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    DataSource.prototype.processConfig = function (config) {
        registry.registeredClasses["json"] = JSONParser_JSONParser;
        registry.registeredClasses["JSONParser"] = JSONParser_JSONParser;
        registry.registeredClasses["csv"] = CSVParser_CSVParser;
        registry.registeredClasses["CSVParser"] = CSVParser_CSVParser;
        _super.prototype.processConfig.call(this, config);
    };
    return DataSource;
}(Base_BaseObjectEvents));

//# sourceMappingURL=DataSource.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Responsive.js
/**
 * Responsive functionality module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */








/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Responsive is responsible for overriding certain properties when conditions
 * are met.
 *
 * This class is used to dynamically apply and change certain chart properties
 * based on the current values of properties.
 *
 * Mainly, this is used with [[Sprite]]'s dimensional properties, like
 * `pixelWidth` and `pixelHeight`. However, it can be used to dynamically
 * change any property, based on any other property's value.
 *
 * A default responsive rules are disabled.
 *
 * To enable, set `enabled = false`. E.g.:
 *
 * ```TypeScript
 * chart.responsive.enabled = true;
 * ```
 * ```JavaScript
 * chart.responsive.enabled = true;
 * ```
 *
 * @see {@link IResponsiveEvents} for a list of available events
 * @see {@link IResponsiveAdapters} for a list of available Adapters
 * @todo Add default rules
 * @todo Watch for rule modification
 * @important
 */
var Responsive_Responsive = /** @class */ (function (_super) {
    __extends(Responsive, _super);
    /**
     * Constructor
     */
    function Responsive() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Holds a list of responsive rules organized by object type.
         */
        _this._rules = new List_List();
        /**
         * Holds the list of the default responsive rules.
         * @deprecated
         */
        //protected _defaultRules = new List<IResponsiveRule>();
        /**
         * Holds the list of currently applied rules.
         */
        _this._appliedRules = {};
        /**
         * Used to keep track of objects that have rules applied at the moment.
         */
        _this._appliedTargets = [];
        /**
         * Use default rules in addition to the user-defined ones?
         */
        _this._useDefault = true;
        /**
         * Adapter.
         */
        _this.adapter = new Adapter_Adapter(_this);
        /**
         * Indicates of responsive rules application is enabled.
         */
        _this._enabled = false;
        /**
         * Holds disposers for all events added by this class.
         */
        _this._responsiveDisposers = [];
        /**
         * Collection of objects and state ids that do not have any properties set.
         */
        _this._noStates = [];
        _this.className = "Responsive";
        // Set up rules list events
        _this.rules.events.on("inserted", function () { _this.checkRules(); }, true);
        _this.rules.events.on("removed", function () { _this.checkRules(); }, true);
        _this._disposers.push(_this.rules.events);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(Responsive.prototype, "component", {
        /**
         * @return Target object
         */
        get: function () {
            return this._component;
        },
        /**
         * A target object that responsive rules will need to be applied to.
         *
         * @param value  Target object
         */
        set: function (value) {
            var _this = this;
            // Check if it's the same
            if (value == this._component) {
                return;
            }
            // Check if we already have a set up component and remove its events
            this.disposeResponsiveHandlers();
            // Set
            this._component = value;
            // Set up resize monitoring events
            this._responsiveDisposers.push(getValue(this.component).events.on("sizechanged", function () { _this.checkRules(); }, this));
            this._responsiveDisposers.push(getValue(this.component).events.on("datavalidated", function () {
                if (_this._component.isReady()) {
                    _this.checkRules(true);
                }
            }, this));
            // Enable resoponsive
            this.enabled = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Responsive.prototype, "enabled", {
        /**
         * @return Apply responsive rules?
         */
        get: function () {
            return this.adapter.apply("enabled", this._enabled);
        },
        /**
         * Should responsive rules be checked against and applied?
         *
         * @default false
         * @param value  Apply responsive rules?
         */
        set: function (value) {
            if (this._enabled != value) {
                this._enabled = value;
                // Run `applyRules` so that any currently applied rules can be reset
                this.applyRules();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Responsive.prototype, "useDefault", {
        /**
         * @return Use default rules?
         */
        get: function () {
            return this.adapter.apply("useDefault", this._useDefault);
        },
        /**
         * Should default responsive rules be applied in addition to user-defined
         * ones.
         *
         * User-defined rules will take precedence over default rules whenever they
         * produce conflicting settings.
         *
         * @default true
         * @param value  Use default rules?
         */
        set: function (value) {
            if (this._useDefault != value) {
                this._useDefault = value;
                // Run `applyRules` so that any currently applied rules can be reset
                this.applyRules();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Responsive.prototype, "rules", {
        /**
         * @return User-defined rules
         */
        get: function () {
            return this.adapter.apply("rules", this._rules);
        },
        /**
         * User-defined responsive rules.
         *
         * User-defined rules will take precedence over default rules whenever they
         * produce conflicting settings.
         *
         * Use `allRules` to get all applicable rules including default and
         * user-defined ones.
         *
         * @param value  User-defined rules
         */
        set: function (value) {
            this._rules = value;
            this._enabled = true;
            this.applyRules();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Responsive.prototype, "defaultRules", {
        /**
         * Default responsive rules.
         *
         * @readonly
         * @return List of responsive rules
         */
        get: function () {
            return this.adapter.apply("defaultRules", defaultRules);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Responsive.prototype, "allRules", {
        /**
         * Returns all rules: default rules (if not disabled) combined with
         * user-defined ones.
         *
         * @readonly
         * @return List of all applicable rules
         */
        get: function () {
            // Create empty list
            var rules = new List_List();
            // Add default rules if not disabled
            // A code, requesting `allRules` must ensure loading of default rules
            // by calling `loadDefaultRules()`
            if (this.useDefault) {
                rules.copyFrom(this.defaultRules);
            }
            // Add user-defined ones
            rules.copyFrom(this.rules);
            return this.adapter.apply("allRules", rules);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if rule by the particular id currently applied.
     *
     * @param ruleId  Rule ID
     * @return Is currently applied?
     */
    Responsive.prototype.isApplied = function (ruleId) {
        var rule = this._appliedRules[ruleId];
        return hasValue(rule) ? rule : false;
    };
    /**
     * Checks which responsive rules currently satisfy their conditions and
     * should be applied, or unapplied.
     *
     * @ignore Exclude from docs
     */
    Responsive.prototype.checkRules = function (force) {
        var _this = this;
        if (force === void 0) { force = false; }
        // Check if there are any rules
        var rules = this.allRules;
        if (!rules || rules.length == 0) {
            return;
        }
        // Init a list of rules to be applied
        var rulesChanged = false;
        var component = getValue(this.component);
        // Check which rules match
        Iterator_each(rules.iterator(), function (rule) {
            // Check if rule has an id
            if (!rule.id) {
                rule.id = registry.getUniqueId();
            }
            // Init indicator if this rule should be applied
            var apply = rule.relevant(component);
            // Let's check if this rule needs to be applied
            if ((apply && !_this.isApplied(rule.id)) || (!apply && _this.isApplied(rule.id))) {
                rulesChanged = true;
            }
            _this._appliedRules[rule.id] = apply;
        });
        if (force) {
            rulesChanged = true;
        }
        // Check if we need to re-apply the rules
        if (rulesChanged) {
            if (!this.component.isReady()) {
                // The chart is not yet ready (built)
                // We will hide the chart and delay application of rules
                // until "ready" event kicks in
                //component.hide(0);
                component.hidden = true;
                component.events.once("ready", function (ev) {
                    ev.target.show(0);
                    _this.applyRules();
                });
                return;
            }
            this.dispatchImmediately("ruleschanged");
            this.applyRules();
        }
    };
    /**
     * Applies current rules to the object.
     *
     * @ignore Exclude from docs
     * @param target Target object
     * @todo Better type check
     */
    Responsive.prototype.applyRules = function (target) {
        var _this = this;
        // If no target supplied, we assume the top-level element
        var newTarget = (hasValue(target)
            ? target
            : getValue(this.component));
        // Check each rule
        var defaultStateApplied = false;
        if (this.enabled) {
            var isApplied_1 = false;
            Iterator_each(this.allRules.iterator(), function (rule) {
                // Get relevant state
                var state = _this.getState(rule, newTarget);
                // If there's a state, it means it needs to be applied
                if (state) {
                    // Check if default state was already applied to this element.
                    // We don't want to go resetting default states to ALL element,
                    // if they don't have responsive states.
                    if (!defaultStateApplied) {
                        // Nope, reset states (instantly).
                        if (indexOf(_this._appliedTargets, newTarget.uid) !== -1) {
                            // But only if this element has any rules applied, otherwise no
                            // point in setting current state
                            newTarget.setState(_this.getDefaultState(newTarget));
                        }
                        defaultStateApplied = true;
                    }
                    // Is this rule currently applied?
                    if (_this.isApplied(getValue(rule.id))) {
                        // Yes. Apply the responsive state
                        state.transitionDuration = 0;
                        _this.setTargetState(newTarget, state);
                        _this.dispatchImmediately("ruleapplied", {
                            rule: rule
                        });
                        isApplied_1 = true;
                    }
                }
            });
            if (isApplied_1) {
                replace(this._appliedTargets, newTarget.uid);
            }
            else {
                remove(this._appliedTargets, newTarget.uid);
            }
        }
        // Apply rules to the children
        if (newTarget.children) {
            Iterator_each(newTarget.children.iterator(), function (child) {
                _this.applyRules(child);
            });
        }
    };
    /**
     * Returns a relative state for the rule/target, or `undefined` if no state is
     * needed.
     *
     * @param rule    [description]
     * @param target  [description]
     * @return [description]
     */
    Responsive.prototype.getState = function (rule, target) {
        var stateId = "responsive-" + rule.id;
        var tmpId = target.uid + "_" + stateId;
        if (indexOf(this._noStates, tmpId) !== -1) {
            return;
        }
        else if (!target.states.hasKey(stateId)) {
            var state = rule.state(target, stateId);
            if (!state) {
                this._noStates.push(tmpId);
            }
            return state;
        }
        else {
            return target.states.getKey(stateId);
        }
    };
    /**
     * Creates and returns default responsive rule for the target.
     *
     * This rule will be used to "reset" to non-responsive values.
     * @param   target  Target Sprite
     * @return          State
     */
    Responsive.prototype.getDefaultState = function (target) {
        if (target.states.hasKey("responsive-default")) {
            return target.states.getKey("responsive-default");
        }
        return target.states.create("responsive-default");
    };
    /**
     * Sets state on the target element and updates default state with the
     * overwritten values if needed.
     *
     * @param  target  Target
     * @param  state   State
     */
    Responsive.prototype.setTargetState = function (target, state) {
        var _this = this;
        // Update default state
        var defaultState = this.getDefaultState(target);
        Object_each(state.properties, function (key, val) {
            if (!hasValue(defaultState.properties[key])) {
                defaultState.properties[key] = _this.getValue(target, key);
            }
        });
        target.setState(state);
    };
    /**
     * Gets a value from an element.
     *
     * @ignore Exclude from docs
     * @param target    Target object
     * @param property  Property
     * @return Property value
     */
    Responsive.prototype.getValue = function (target, property) {
        // This is a bit hacky, first we check if the property exist.
        // If it doesn't we try accessing target's property directly
        var value = target.getPropertyValue(property);
        if (!hasValue(value) && hasValue(target[property])) {
            value = target[property];
        }
        return value;
    };
    /**
     * Disposes the object.
     */
    Responsive.prototype.dispose = function () {
        this.disposeResponsiveHandlers();
        _super.prototype.dispose.call(this);
    };
    /**
     * Disposes all event handlers.
     */
    Responsive.prototype.disposeResponsiveHandlers = function () {
        var disposer = this._responsiveDisposers.pop();
        while (disposer) {
            disposer.dispose();
            disposer = this._responsiveDisposers.pop();
        }
    };
    return Responsive;
}(Base_BaseObjectEvents));

/**
 * [defaultRules description]
 *
 * @todo description
 */
var defaultRules = new List_List();
defaultRules.events.on("inserted", function (ev) {
    ev.newValue.id = registry.getUniqueId();
});
/**
 *
 * @todo description
 */
var ResponsiveBreakpoints = /** @class */ (function () {
    function ResponsiveBreakpoints() {
    }
    // Breakpoint functions (for use in `relevant` clause of the responsive rules)
    ResponsiveBreakpoints.widthXXS = function (container) {
        return container.pixelWidth <= ResponsiveBreakpoints.XXS;
    };
    ResponsiveBreakpoints.widthXS = function (container) {
        return container.pixelWidth <= ResponsiveBreakpoints.XS;
    };
    ResponsiveBreakpoints.widthS = function (container) {
        return container.pixelWidth <= ResponsiveBreakpoints.S;
    };
    ResponsiveBreakpoints.widthM = function (container) {
        return container.pixelWidth <= ResponsiveBreakpoints.M;
    };
    ResponsiveBreakpoints.widthL = function (container) {
        return container.pixelWidth <= ResponsiveBreakpoints.L;
    };
    ResponsiveBreakpoints.widthXL = function (container) {
        return container.pixelWidth <= ResponsiveBreakpoints.XL;
    };
    ResponsiveBreakpoints.widthXXL = function (container) {
        return container.pixelWidth <= ResponsiveBreakpoints.XXL;
    };
    ResponsiveBreakpoints.heightXXS = function (container) {
        return container.pixelHeight <= ResponsiveBreakpoints.XXS;
    };
    ResponsiveBreakpoints.heightXS = function (container) {
        return container.pixelHeight <= ResponsiveBreakpoints.XS;
    };
    ResponsiveBreakpoints.heightS = function (container) {
        return container.pixelHeight <= ResponsiveBreakpoints.S;
    };
    ResponsiveBreakpoints.heightM = function (container) {
        return container.pixelHeight <= ResponsiveBreakpoints.M;
    };
    ResponsiveBreakpoints.heightL = function (container) {
        return container.pixelHeight <= ResponsiveBreakpoints.L;
    };
    ResponsiveBreakpoints.heightXL = function (container) {
        return container.pixelHeight <= ResponsiveBreakpoints.XL;
    };
    ResponsiveBreakpoints.heightXXL = function (container) {
        return container.pixelHeight <= ResponsiveBreakpoints.XXL;
    };
    ResponsiveBreakpoints.isXXS = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.XXS) && (container.pixelHeight <= ResponsiveBreakpoints.XXS);
    };
    ResponsiveBreakpoints.isXS = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.XS) && (container.pixelHeight <= ResponsiveBreakpoints.XS);
    };
    ResponsiveBreakpoints.isS = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.S) && (container.pixelHeight <= ResponsiveBreakpoints.S);
    };
    ResponsiveBreakpoints.isM = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.M) && (container.pixelHeight <= ResponsiveBreakpoints.M);
    };
    ResponsiveBreakpoints.isL = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.L) && (container.pixelHeight <= ResponsiveBreakpoints.L);
    };
    ResponsiveBreakpoints.isXL = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.XL) && (container.pixelHeight <= ResponsiveBreakpoints.XL);
    };
    ResponsiveBreakpoints.isXXL = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.XXL) && (container.pixelHeight <= ResponsiveBreakpoints.XXL);
    };
    ResponsiveBreakpoints.maybeXXS = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.XXS) || (container.pixelHeight <= ResponsiveBreakpoints.XXS);
    };
    ResponsiveBreakpoints.maybeXS = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.XS) || (container.pixelHeight <= ResponsiveBreakpoints.XS);
    };
    ResponsiveBreakpoints.maybeS = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.S) || (container.pixelHeight <= ResponsiveBreakpoints.S);
    };
    ResponsiveBreakpoints.maybeM = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.M) || (container.pixelHeight <= ResponsiveBreakpoints.M);
    };
    ResponsiveBreakpoints.maybeL = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.L) || (container.pixelHeight <= ResponsiveBreakpoints.L);
    };
    ResponsiveBreakpoints.maybeXL = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.XL) || (container.pixelHeight <= ResponsiveBreakpoints.XL);
    };
    ResponsiveBreakpoints.maybeXXL = function (container) {
        return (container.pixelWidth <= ResponsiveBreakpoints.XXL) || (container.pixelHeight <= ResponsiveBreakpoints.XXL);
    };
    // Named pixel breakpoints
    ResponsiveBreakpoints.XXS = 100;
    ResponsiveBreakpoints.XS = 200;
    ResponsiveBreakpoints.S = 300;
    ResponsiveBreakpoints.M = 400;
    ResponsiveBreakpoints.L = 600;
    ResponsiveBreakpoints.XL = 800;
    ResponsiveBreakpoints.XXL = 1000;
    return ResponsiveBreakpoints;
}());

//# sourceMappingURL=Responsive.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/DataItem.js
/**
 * Defines functionality for "Data Item"
 *
 * A Data Item can be any object that can hold data. For example [[LineSeries]]
 * holds a number of values, that comprise a line graph. Each of those values
 * (data points) is a {DataItem}.
 *
 * Furthermore the [[LineSeries]] itself can be represented as a entry in the
 * legend. Since legend needs access to Line Series' value, a DataItem is
 * created for the series.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





//import * as $object from "./utils/Object";

/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * DataItem represents single element in data, for example a data point in a
 * Serial Chart Series, e.g. a column.
 *
 * DataItem defines relationship between structured data, required for specific
 * chart type or task, and raw source data.
 *
 * It also implements required calculations, updates related visual elements,
 * etc.
 *
 * @todo Description
 * @important
 */
var DataItem_DataItem = /** @class */ (function (_super) {
    __extends(DataItem, _super);
    /**
     * Constructor
     * @todo Adding events to disposers produces errors in some cases, which means that chart is using disposed Data Items which is not right
     */
    function DataItem() {
        var _this = _super.call(this) || this;
        /**
         * This Data Item is currently disabled.
         *
         * @ignore Exclude from docs
         */
        _this._disabled = false;
        /**
         * Indicates whether Data Item has any properties set.
         *
         * If it does not have any, the code can use this property to check whether
         * they need to apply costly operation of re-applying properties, whenever
         * Data Item-related element is redrawn, e.g. series.
         */
        _this.hasProperties = false;
        /**
         * An object containing calculated values.
         */
        _this.values = {};
        /**
         * An object container current working values.
         */
        //public readonly workingValues: { [index: string]: { [index: string]: number } } = {};
        /**
         * An object containing categories.
         */
        _this.categories = {};
        /**
         * An object containing dates.
         */
        _this.dates = {};
        /**
         * An object containing locations for the Data Item.
         *
         * A location is a position within date or category, or, in some other cases,
         * where there is no single point but rather some period.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/series/#Data_item_locations} for info how data item locations work
         */
        _this.locations = {};
        /**
         * Current working locations.
         */
        _this.workingLocations = {};
        /**
         * An object containing Data Item specific appearance properties in key-value
         * pairs.
         *
         * Sometimes a single Data Item needs to apply different properties than the
         * rest of the data [[Series]] it is part of. E.g. a single column,
         * represented by a Data Item needs to be filled with a different color than
         * the reset of the [[ColumnSeries]] it belongs to.
         *
         * That's where Data Item's `properties` come into play.
         *
         * Please note that you should set Data Item-specific properties using
         * `setProperty()` method, rather than access `properties` object directly.
         */
        _this.properties = {};
        /**
         * A list of [[Sprite]] elements that are associated with this Data Item.
         *
         * E.g. an [[Axis]] Data Item has several separate elements associated with
         * it, like [[AxisTick]], [[AxisLabel]], and [[Grid]].
         *
         * Data Item keeps track of all of them, so it can toggle all related visual
         * elements when it itself is toggled.
         */
        _this.sprites = [];
        /**
         * Identifies if this object is a "template" and should not be treated as
         * real object that is drawn or actually used in the chart.
         */
        _this.isTemplate = false;
        /**
         * The current index within the dataItems
         *
         * @ignore Exclude from docs
         */
        _this._index = null;
        /**
         * Is Data Item currently visible?
         *
         * @ignore Exclude from docs
         */
        _this._visible = true;
        /**
         * Is Data Item currently hidden?
         *
         * @ignore Exclude from docs
         */
        _this._hidden = false;
        /**
         * Should this Data Item be used when calculating data ranges and scales?
         *
         * @ignore Exclude from docs
         */
        _this._ignoreMinMax = false;
        /**
         * Some of the Data Item's data fields may contain an array of children. This
         * property contains an object indicating which fields hold an array, so that
         * they can be processed properly.
         *
         * @ignore Exclude from docs
         */
        _this.hasChildren = {};
        /**
         * Indicates whether Data Item is currently animiting from visible to hidden
         * state.
         */
        _this.isHiding = false;
        /**
         *
         * @ignore Exclude from docs
         */
        _this._valueAnimations = {};
        /**
         *
         * @ignore Exclude from docs
         */
        _this._locationAnimations = {};
        _this.className = "DataItem";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(DataItem.prototype, "adapter", {
        /**
         * Holds Adapter.
         */
        get: function () {
            if (!this._adapterO) {
                this._adapterO = new Adapter_Adapter(this);
            }
            return this._adapterO;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataItem.prototype, "index", {
        /**
         * Data Item's position index in Component's data.
         *
         * @return Index
         */
        get: function () {
            if (this.component) {
                if (this._index != null) {
                    return this._index;
                }
                else {
                    return -1;
                }
            }
            else {
                return -1;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataItem.prototype, "animations", {
        /**
         * A list of [[Animations]] objects currently mutating Data Item's values.
         *
         * @return [description]
         */
        get: function () {
            if (!this._animations) {
                this._animations = [];
                this._disposers.push(new Animation_AnimationDisposer(this._animations));
            }
            return this._animations;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataItem.prototype, "visible", {
        /**
         * Returns `true` if this Data Item is currently visible.
         *
         * @return Visible?
         */
        get: function () {
            if (this._hidden) {
                return false;
            }
            return this._visible;
        },
        /**
         * Sets visibility of the Data Item.
         *
         * @param value Visible?
         */
        set: function (value) {
            if (value) {
                this.hidden = false;
            }
            if (this._visible != value) {
                this.setVisibility(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataItem.prototype, "hidden", {
        /**
         * Returns `true` if this Data Item is currently hidden.
         *
         * @return Hidden?
         */
        get: function () {
            return this._hidden;
        },
        /**
         * Sets hidden flag for data item. Mostly used to initially hide data item.
         *
         * @param value Hidden?
         */
        set: function (value) {
            if (this._hidden != value) {
                this._hidden = value;
                if (value) {
                    this.setVisibility(false);
                }
                else {
                    this.setVisibility(true, true);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataItem.prototype, "__disabled", {
        /**
         * Is this Data Item currently disabled?
         *
         * @ignore Exclude from docs
         * @param {boolean}
         */
        get: function () {
            return this._disabled;
        },
        /**
         * Disables all Sprites associated with this Data Item.
         *
         * @ignore Exclude from docs
         * @param {boolean}
         */
        set: function (value) {
            //	if (this._disabled != value) { // not good
            this._disabled = value;
            each(this.sprites, function (sprite) {
                sprite.__disabled = value;
            });
            //	}
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets visibility of the Data Item.
     *
     * @param value Data Item
     */
    DataItem.prototype.setVisibility = function (value, noChangeValues) {
        each(this.sprites, function (sprite) {
            if (value) {
                sprite.visible = sprite.defaultState.properties.visible;
            }
            else {
                if (sprite.hiddenState) {
                    sprite.visible = sprite.hiddenState.properties.visible;
                }
                else {
                    sprite.visible = false;
                }
            }
        });
        this._visible = value;
        if (this._eventDispatcher && !this.__disabled) {
            if (this.events.isEnabled("visibilitychanged")) {
                var event_1 = {
                    type: "visibilitychanged",
                    target: this,
                    visible: value
                };
                this.events.dispatchImmediately("visibilitychanged", event_1);
            }
        }
    };
    /**
     * Shows the Data Item and related visual elements.
     *
     * @param duration  Animation duration (ms)
     * @param delay     Delay animation (ms)
     * @param fields    A list of fields to set values of
     */
    DataItem.prototype.show = function (duration, delay, fields) {
        var _this = this;
        if (!this.hidden) {
            this.setVisibility(true, true);
            this.isHiding = false;
            if (this._hideDisposer) {
                this.removeDispose(this._hideDisposer);
            }
            var animation_1;
            if (fields) {
                each(fields, function (field) {
                    animation_1 = _this.setWorkingValue(field, _this.values[field].value, duration, delay);
                });
            }
            each(this.sprites, function (sprite) {
                var animation = sprite.show(duration);
                if (animation != null && !animation.isFinished()) {
                    _this._disposers.push(animation);
                    if (delay != null && delay > 0) {
                        animation.delay(delay);
                    }
                }
            });
            return animation_1;
        }
    };
    /**
     * Destroys this object and all related data.
     */
    DataItem.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        each(this.sprites, function (sprite) {
            sprite.dispose();
        });
        this.sprites = [];
    };
    /**
     * Hides the Data Item and related visual elements.
     *
     * @param duration  Animation duration (ms)
     * @param delay     Delay animation (ms)
     * @param toValue   A value to set to `fields` when hiding
     * @param fields    A list of data fields to set value to `toValue`
     */
    DataItem.prototype.hide = function (duration, delay, toValue, fields) {
        var _this = this;
        this.isHiding = true;
        each(this.sprites, function (sprite) {
            var animation = sprite.hide(duration);
            if (animation != null && !animation.isFinished()) {
                _this._disposers.push(animation);
                if (delay != null && delay > 0) {
                    animation.delay(delay);
                }
            }
        });
        if (isNumber(toValue) && fields) {
            var animation_2;
            each(fields, function (field) {
                var anim = _this.setWorkingValue(field, toValue, duration, delay);
                if (anim) {
                    animation_2 = anim;
                }
            });
            if (animation_2 && !animation_2.isFinished()) {
                this._hideDisposer = animation_2.events.on("animationended", function () {
                    _this.setVisibility(false, true);
                    _this.isHiding = false;
                });
                this._disposers.push(this._hideDisposer);
                return animation_2;
            }
            else {
                this.isHiding = false;
                this.setVisibility(false, true);
            }
        }
        else {
            this.isHiding = false;
            this.setVisibility(false);
        }
    };
    /**
     * Returns a duration (ms) the Data Item should take to animate from one
     * value to another.
     *
     * If the duration is not specified via parameter, this method will try to
     * request a default duration from the related `Component`.
     *
     * @param duration  Default duration (ms)
     * @return Duration (ms)
     */
    DataItem.prototype.getDuration = function (duration) {
        if (!isNumber(duration)) {
            var component = this.component;
            if (component) {
                duration = component.interpolationDuration;
            }
        }
        if (duration != null) {
            if (!this._adapterO) {
                return duration;
            }
            else {
                return this._adapterO.apply("duration", duration);
            }
        }
    };
    /**
     * Returns a numeric value for specific data field.
     *
     * If `calculated` is not set, it will return a raw value, as it is in
     * source data.
     *
     * If `calculated` is set, it will return a pre-calculated specific value.
     *
     * @param name        Data field name
     * @param calculated  A calculated value name
     * @return Value
     */
    DataItem.prototype.getValue = function (name, calculated) {
        if (name && this.component) {
            if (!calculated) {
                calculated = this.component.dataFields[name + "Show"];
                if (!calculated) {
                    calculated = "value";
                }
            }
            var value = this.values[name][calculated];
            if (this._adapterO && this._adapterO.isEnabled("value")) {
                return this._adapterO.apply("value", {
                    value: value,
                    field: name
                }).value;
            }
            else {
                return value;
            }
        }
    };
    /**
     * Returns a current working value for a specific data field.
     *
     * The actual value may differ from the one returned by `getValue()`. The
     * latter returns static values from the data source.
     *
     * `getWorkingValue()` returns current value, which is usually different if
     * Data Item is animating from one state to another.
     *
     * @param name        Data field name
     * @return Value
     */
    DataItem.prototype.getWorkingValue = function (name) {
        if (name && this.component) {
            var realName = this.component.dataFields[name + "Show"];
            if (!realName) {
                realName = "workingValue";
            }
            if (this._adapterO) {
                return this._adapterO.apply("workingValue", {
                    workingValue: this.values[name][realName],
                    field: name
                }).workingValue;
            }
            else {
                return this.values[name][realName];
            }
        }
    };
    /**
     * @ignore
     * @return Value
     */
    DataItem.prototype.getActualWorkingValue = function (name) {
        return this.values[name].workingValue;
    };
    /**
     * Sets a numeric value for specific data field.
     *
     * @param name        Data field name
     * @param value       Value
     * @param calculated  Calculated data field name
     * @param duration    Duration (ms) to animate to new value to
     * @param delay       Delay animation (ms)
     */
    DataItem.prototype.setValue = function (name, value, duration, delay) {
        var currentValue = this.values[name].value;
        var newDuration = this.getDuration(duration);
        value = toNumber(value);
        if (currentValue !== value) {
            this.values[name].value = value;
            if (this._eventDispatcher && !this.__disabled) {
                if (this.events.isEnabled("valuechanged")) {
                    var event_2 = {
                        type: "valuechanged",
                        target: this,
                        property: name
                    };
                    this.events.dispatchImmediately("valuechanged", event_2);
                }
            }
            if (this.component) {
                this.component.handleDataItemValueChange(this, name);
            }
        }
        this.setWorkingValue(name, value, newDuration, delay);
    };
    DataItem.prototype.setCalculatedValue = function (name, value, calculated) {
        var currentValue = this.values[name][calculated];
        if (currentValue !== value && isNumber(value)) {
            this.values[name][calculated] = value;
            if (this._eventDispatcher && !this.__disabled) {
                if (this.events.isEnabled("calculatedvaluechanged")) {
                    var event_3 = {
                        type: "calculatedvaluechanged",
                        target: this,
                        property: name
                    };
                    this.events.dispatchImmediately("calculatedvaluechanged", event_3);
                }
            }
            if (this.component) {
                this.component.handleDataItemCalculatedValueChange(this, name);
            }
        }
    };
    /**
     * Set current working numeric value for a specific data field.
     *
     * @param name        Data field name
     * @param value       Value
     * @param calculated  Calculated data field name
     * @param duration    Duration (ms) to animate to new value to
     * @param delay       Delay animation (ms)
     * @return An [[Animation]] object used for transition to new values
     */
    DataItem.prototype.setWorkingValue = function (name, value, duration, delay) {
        if (isNumber(this.values[name].value)) {
            var newDuration = this.getDuration(duration);
            var workingValue = this.values[name].workingValue;
            if (newDuration != null && newDuration > 0 && isNumber(workingValue) && this.component) { // sometimes NaN is passed, so only change this to != null if all cases of NaN are handled, otherwise animation won't stop
                if (workingValue != value) {
                    var animation = this.animate({ childObject: this.values[name], property: "workingValue", from: workingValue, to: value, dummyData: name }, newDuration, this.component.interpolationEasing);
                    if (delay != null) {
                        animation.delay(delay);
                    }
                    animation.events.on("animationstarted", this.handleInterpolationProgress, this);
                    animation.events.on("animationprogress", this.handleInterpolationProgress, this);
                    animation.events.on("animationended", this.handleInterpolationProgress, this);
                    this._valueAnimations[name] = animation;
                    return animation;
                }
                else {
                    var valueAnimation = this._valueAnimations[name];
                    if (valueAnimation) {
                        valueAnimation.stop();
                    }
                    this.values[name].workingValue = value;
                }
            }
            else {
                var valueAnimation = this._valueAnimations[name];
                if (valueAnimation) {
                    valueAnimation.stop();
                }
                this.values[name].workingValue = value;
                if (this._eventDispatcher && !this.__disabled) {
                    if (this.events.isEnabled("workingvaluechanged")) {
                        var event_4 = {
                            type: "workingvaluechanged",
                            target: this,
                            property: name
                        };
                        this.events.dispatchImmediately("workingvaluechanged", event_4);
                    }
                }
                if (this.component) {
                    this.component.handleDataItemWorkingValueChange(this, name);
                }
            }
        }
    };
    /**
     * Sets a relative location for a data field.
     *
     * A location is always relative on a 0 to 1 scale, with 0 being beginning,
     * 0.5 middle and 1 end.
     *
     * @todo Rewiew description
     * @param name      Data field name
     * @param value     Location (0-1)
     * @param duration  Duration (ms) to animate to new value to
     * @param delay     Delay animation (ms)
     */
    DataItem.prototype.setLocation = function (name, value, duration, delay) {
        var currentLocation = this.locations[name];
        if (currentLocation !== value) {
            this.locations[name] = value;
            if (this._eventDispatcher && !this.__disabled) {
                if (this.events.isEnabled("locationchanged")) {
                    var event_5 = {
                        type: "locationchanged",
                        target: this,
                        property: name
                    };
                    this.events.dispatchImmediately("locationchanged", event_5);
                }
            }
            if (this.component) {
                this.component.handleDataItemValueChange(this, name); // correct
            }
            this.setWorkingLocation(name, value, duration, delay);
        }
    };
    /**
     * Sets a current working location for a data field.
     *
     * @todo Rewiew description
     * @param name      Data field name
     * @param value     Location (0-1)
     * @param duration  Duration (ms) to animate to new value to
     * @param delay     Delay animation (ms)
     */
    DataItem.prototype.setWorkingLocation = function (name, value, duration, delay) {
        var newDuration = this.getDuration(duration);
        var workingLocation = this.workingLocations[name];
        if (newDuration != null && newDuration > 0 && isNumber(workingLocation) && this.component) { // sometimes NaN is passed, so only change this to != null if all cases of NaN are handled, otherwise animation won't stop
            if (workingLocation != value) {
                var animation = this.animate({ childObject: this.workingLocations, property: name, from: workingLocation, to: value, dummyData: name }, newDuration, this.component.interpolationEasing);
                if (delay != null) {
                    animation.delay(delay);
                }
                animation.events.on("animationstarted", this.handleInterpolationProgress, this);
                animation.events.on("animationprogress", this.handleInterpolationProgress, this);
                animation.events.on("animationended", this.handleInterpolationProgress, this);
                this._locationAnimations[name] = animation;
                return animation;
            }
            else {
                var locationAnimation = this._locationAnimations[name];
                if (locationAnimation) {
                    locationAnimation.stop();
                }
                this.workingLocations[name] = value;
            }
        }
        else {
            var locationAnimation = this._locationAnimations[name];
            if (locationAnimation) {
                locationAnimation.stop();
            }
            this.workingLocations[name] = value;
            if (this._eventDispatcher && !this.__disabled) {
                if (this.events.isEnabled("workinglocationchanged")) {
                    var event_6 = {
                        type: "workinglocationchanged",
                        target: this,
                        property: name
                    };
                    this.events.dispatchImmediately("workinglocationchanged", event_6);
                }
            }
            if (this.component) {
                this.component.handleDataItemWorkingLocationChange(this, name);
            }
        }
    };
    /**
     * Sets Date value to a data field.
     *
     * @param name      Data field name
     * @param date      Date object
     * @param duration  Duration (ms) to animate to new value to
     */
    DataItem.prototype.setDate = function (name, date, duration) {
        if (!isDate(date) && this.component) {
            date = this.component.dateFormatter.parse(date);
        }
        var currentDate = this.dates[name];
        if (currentDate !== date) {
            this.dates[name] = date;
            this.setValue(name, date.getTime(), duration);
        }
    };
    /**
     * Returns a Date value of the data field.
     *
     * @param name  Data field name
     * @return Date object
     */
    DataItem.prototype.getDate = function (name) {
        if (this._adapterO) {
            return this._adapterO.apply("date", {
                date: this.dates[name],
                field: name
            }).date;
        }
        else {
            return this.dates[name];
        }
    };
    /**
     * Sets a Data Item-specific visual properties to apply to related elements.
     *
     * @param name   Property name
     * @param value  Property value
     */
    DataItem.prototype.setProperty = function (name, value) {
        if (this.properties[name] !== value) {
            this.hasProperties = true;
            this.properties[name] = value;
            if (this._eventDispatcher && !this.__disabled) {
                if (this.events.isEnabled("propertychanged")) {
                    var event_7 = {
                        type: "propertychanged",
                        target: this,
                        property: name,
                        value: value
                    };
                    this.events.dispatchImmediately("propertychanged", event_7);
                }
            }
            if (this.component) {
                this.component.handleDataItemPropertyChange(this, name);
            }
        }
    };
    /**
     * Sets a related category for this Data Item.
     *
     * @todo Review description
     * @param name   Data field name
     * @param value  Category
     */
    DataItem.prototype.setCategory = function (name, value) {
        if (!isString(value)) {
            value = castString(value);
        }
        if (this.categories[name] !== value) {
            this.categories[name] = value;
        }
    };
    /**
     * Clones the Data Item, including all related data.
     *
     * @return New Data Item clone
     */
    //public clone(cloneId?: string): this {
    //	let dataItem: this = super.clone(cloneId);
    //	dataItem.copyFrom(this);
    //	return dataItem;
    //}
    /**
     * Copies all properties and related data from different data item.
     *
     * @param object Source data item
     */
    DataItem.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (source.dataContext) {
            this.dataContext = Utils_copy(source.dataContext, {});
        }
        Utils_copyProperties(source.locations, this.locations);
        /*
        $utils.copyProperties(source.properties, this.properties);
        $utils.copyProperties(source.categories, this.categories);
        $utils.copyProperties(source.values, this.values);
        $utils.copyProperties(source.dates, this.dates);

        $object.each(source.values, (name, value) => {
            this.values[name] = $object.copy(value);
        });*/
        if (source._adapterO) {
            this.adapter.copyFrom(source._adapterO);
        }
        //this.events.copyFrom(source.events); // because copied in Base
        this.component = source.component;
    };
    Object.defineProperty(DataItem.prototype, "opacity", {
        /**
         * Sets opacity for all Data Item's related elements (Sprites).
         *
         * @param value Opacity (0-1)
         */
        set: function (value) {
            each(this.sprites, function (sprite) {
                sprite.opacity = value;
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataItem.prototype, "ignoreMinMax", {
        /**
         * Exclude from min/max calculations?
         * @return Exclude from min/max calculations?
         */
        get: function () {
            return this._ignoreMinMax;
        },
        /**
         * Sets whether this data point should not be included in the scale and
         * minimum/maximum calculations.
         *
         * E.g. some we may want to exclude a particular data point from influencing
         * [[ValueAxis]] scale.
         *
         * @param value  Exclude from min/max calculations?
         */
        set: function (value) {
            this._ignoreMinMax = value;
            if (this._eventDispatcher && !this.__disabled) {
                if (this.events.isEnabled("propertychanged")) {
                    var event_8 = {
                        type: "propertychanged",
                        target: this,
                        property: "ignoreMinMax",
                        value: value
                    };
                    this.events.dispatchImmediately("propertychanged", event_8);
                }
            }
            if (this.component) {
                this.component.handleDataItemPropertyChange(this, "ignoreMinMax");
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates and starts an [[Animation]] to interpolate (morph) Data Item's
     * properties and/or values.
     *
     * @see {@link Animation}
     * @param animationOptions  Animation options
     * @param duration          Animation duration (ms)
     * @param easing            Easing function
     * @return Animation
     */
    DataItem.prototype.animate = function (animationOptions, duration, easing) {
        return new Animation_Animation(this, animationOptions, duration, easing).start();
    };
    /**
     * Handles intermediate steps when Data Item is interpolating (morphing) from
     * one value to another.
     *
     * @ignore Exclude from docs
     * @param event Event object
     */
    DataItem.prototype.handleInterpolationProgress = function (event) {
        var animation = event.target;
        // it's always only one options, no need cycle
        var animationOptions = animation.animationOptions[0];
        if (animationOptions) {
            if (this._eventDispatcher && !this.__disabled) {
                if (this.events.isEnabled("workingvaluechanged")) {
                    var event_9 = {
                        type: "workingvaluechanged",
                        target: this,
                        property: animationOptions.dummyData
                    };
                    this.events.dispatchImmediately("workingvaluechanged", event_9);
                }
            }
            if (this.component) {
                this.component.handleDataItemWorkingValueChange(this, animationOptions.dummyData);
            }
        }
    };
    /**
     * Checks whether Data Item has values set for all of the data fields,
     * supplied via argument.
     *
     * @ignore Exclude from docs
     * @param fields  Field list to check
     * @return Has values for all fields?
     */
    DataItem.prototype.hasValue = function (fields) {
        // todo: what about categories?
        for (var i = 0, len = fields.length; i < len; i++) {
            var values = this.values[fields[i]];
            if (!values || !hasValue(values.value)) {
                return false;
            }
        }
        return true;
    };
    Object.defineProperty(DataItem.prototype, "depth", {
        /**
         * Depth of the Data Item.
         *
         * In nested data structures, like TreeMap, this indicates the level this
         * data point is at, in relation to the parent Data Item.
         *
         * @return Depth
         */
        get: function () {
            if (!this.parent) {
                return 0;
            }
            else {
                return this.parent.depth + 1;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DataItem.prototype, "dataContext", {
        /**
         * Sets to a reference to an original object from Component's data.
         *
         * @return [description]
         */
        get: function () {
            return this._dataContext;
        },
        /**
         * A reference to an original object in Component's data, that this Data Item
         * is derived from.
         *
         * @param value Original data object
         */
        set: function (value) {
            this._dataContext = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * adds a sprite to dataItem.sprites array
     * @ignore
     */
    DataItem.prototype.addSprite = function (sprite) {
        if (sprite.dataItem && sprite.dataItem != this) {
            remove(sprite.dataItem.sprites, sprite);
        }
        if (!this.visible) {
            sprite.hide(0);
        }
        if (this.isHiding) {
            sprite.hide();
        }
        this.sprites.push(sprite);
        sprite.dataItem = this;
    };
    return DataItem;
}(Base_BaseObjectEvents));

//# sourceMappingURL=DataItem.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/Component.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

















/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A Component represents an independent functional element or control, that
 * can have it's own behavior, children, data, etc.
 *
 * A few examples of a Component: [[Legend]], [[Series]], [[Scrollbar]].
 *
 * @see {@link IComponentEvents} for a list of available events
 * @see {@link IComponentAdapters} for a list of available Adapters
 * @important
 */
var Component_Component = /** @class */ (function (_super) {
    __extends(Component, _super);
    /**
     * Constructor
     */
    function Component() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Holds data field names.
         *
         * Data fields define connection beween [[DataItem]] and actual properties
         * in raw data.
         */
        _this.dataFields = {};
        /**
         * A list of [[DataSource]] definitions of external data source.
         *
         * @ignore Exclude from docs
         */
        _this._dataSources = {};
        /**
         * This is used when only new data is invalidated (if added using `addData`
         * method).
         *
         * @ignore Exclude from docs
         */
        _this._parseDataFrom = 0;
        /**
         * Holds the disposers for the dataItems and dataUsers
         *
         * @ignore Exclude from docs
         */
        _this._dataDisposers = [];
        /**
         * Currently selected "data set".
         *
         * If it's set to `""`, main data set (unaggregated data) is used.
         */
        _this._currentDataSetId = "";
        /**
         * [_start description]
         *
         * @ignore Exclude from docs
         */
        _this._start = 0;
        /**
         * [_end description]
         *
         * @ignore Exclude from docs
         */
        _this._end = 1;
        /**
         * If set to `true`, changing data range in element will not trigger
         * `daterangechanged` event.
         */
        _this.skipRangeEvent = false;
        /**
         * Whenever selected scope changes (chart is zoomed or panned), for example
         * by interaction from a Scrollbar, or API, a chart needs to reposition
         * its contents.
         *
         * `rangeChangeDuration` influences how this is performed.
         *
         * If set to zero (0), the change will happen instantenously.
         *
         * If set to non-zero value, the chart will gradually animate into new
         * position for the set amount of milliseconds.
         *
         * @default 0
         * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations
         */
        _this.rangeChangeDuration = 0;
        /**
         * An easing function to use for range change animation.
         *
         * @see {@link Ease}
         * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations
         */
        _this.rangeChangeEasing = cubicOut;
        /**
         * A duration (ms) of each data parsing step. A Component parses its data in
         * chunks in order to avoid completely freezing the machine when large data
         * sets are used. This setting will control how many milliseconds should pass
         * when parsing data until parser stops for a brief moment to let other
         * processes catch up.
         */
        _this.parsingStepDuration = 50;
        /**
         * [dataInvalid description]
         *
         * @ignore Exclude from docs
         * @todo Description
         */
        _this.dataInvalid = false;
        /**
         *
         * @ignore Exclude from docs
         */
        _this.rawDataInvalid = false;
        /**
         * [dataRangeInvalid description]
         *
         * @ignore Exclude from docs
         * @todo Description
         */
        _this.dataRangeInvalid = false;
        /**
         * [dataItemsInvalid description]
         *
         * @ignore Exclude from docs
         * @todo Description
         */
        _this.dataItemsInvalid = false;
        /**
         * If set to a non-zero number the element will "animate" data values of its
         * children.
         *
         * This will happen on first load and whenever data values change.
         *
         * Enabling interpolation will mean that elements will transit smoothly into
         * new values rather than updating instantly.
         *
         * @default 0
         * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations
         */
        _this.interpolationDuration = 0;
        /**
         * An easing function to use for interpolating values when transiting from
         * one source value to another.
         *
         * @default cubicOut
         * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations
         * @see {@link Ease}
         */
        _this.interpolationEasing = cubicOut;
        /**
         * Indicates whether transition between data item's values should start and
         * play out all at once, or with a small delay (as defined by
         * `sequencedInterpolationDelay`) for each subsequent data item.
         *
         * @default true
         * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations
         */
        _this.sequencedInterpolation = true;
        /**
         * A delay (ms) to wait between animating each subsequent data item's
         * interpolation animation.
         *
         * Relative only if `sequencedInterpolation = true`.
         *
         * @default 0
         * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations
         */
        _this.sequencedInterpolationDelay = 0;
        /**
         * A progress (0-1) for the data validation process.
         *
         * @ignore Exclude from docs
         */
        _this.dataValidationProgress = 0;
        _this._addAllDataItems = true;
        _this._usesData = true;
        _this.className = "Component";
        _this.minZoomCount = 1;
        _this.maxZoomCount = 0;
        _this._dataItems = new SortedList_OrderedListTemplate(_this.createDataItem());
        _this._dataItems.events.on("inserted", _this.handleDataItemAdded, _this, false);
        _this._dataItems.events.on("removed", _this.handleDataItemRemoved, _this, false);
        _this._disposers.push(new List_ListDisposer(_this._dataItems));
        _this._disposers.push(_this._dataItems.template);
        _this.invalidateData();
        // TODO what about remove ?
        _this.dataUsers.events.on("inserted", _this.handleDataUserAdded, _this, false);
        // Set up disposers
        _this._disposers.push(new Disposer_MultiDisposer(_this._dataDisposers));
        _this._start = 0;
        _this._end = 1;
        _this.maxZoomDeclination = 1;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    Component.prototype.createDataItem = function () {
        return new DataItem_DataItem();
    };
    /**
     * [handleDataUserAdded description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param event Event object
     */
    Component.prototype.handleDataUserAdded = function (event) {
        var dataUser = event.newValue;
        dataUser.dataProvider = this;
    };
    /**
     * [handleDataItemValueChange description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    Component.prototype.handleDataItemValueChange = function (dataItem, name) {
        if (!this.dataItemsInvalid) {
            this.invalidateDataItems();
        }
    };
    /**
     * [handleDataItemWorkingValueChange description]
     *
     * @ignore Exclude from docs
     */
    Component.prototype.handleDataItemWorkingValueChange = function (dataItem, name) {
    };
    /**
     * [handleDataItemWorkingLocationChange description]
     *
     * @ignore Exclude from docs
     */
    Component.prototype.handleDataItemWorkingLocationChange = function (dataItem, name) {
    };
    /**
     * [handleDataItemCalculatedValueChange description]
     *
     * @ignore Exclude from docs
     */
    Component.prototype.handleDataItemCalculatedValueChange = function (dataItem, name) {
    };
    /**
     * [handleDataItemPropertyChange description]
     *
     * @ignore Exclude from docs
     */
    Component.prototype.handleDataItemPropertyChange = function (dataItem, name) {
    };
    /**
     * Populates a [[DataItem]] width data from data source.
     *
     * Loops through all the fields and if such a field is found in raw data
     * object, a corresponding value on passed in `dataItem` is set.
     *
     * @ignore Exclude from docs
     * @param item
     */
    Component.prototype.processDataItem = function (dataItem, dataContext) {
        var _this = this;
        if (dataItem) {
            if (!dataContext) {
                dataContext = {};
            }
            // store reference to original data item
            dataItem.dataContext = dataContext;
            var hasSomeValues_1 = false;
            Object_each(this.dataFields, function (key, fieldValue) {
                var fieldName = key;
                var value = dataContext[fieldValue];
                // Apply adapters to a retrieved value
                if (_this._adapterO) {
                    if (_this._adapterO.isEnabled("dataContextValue")) {
                        value = _this._adapterO.apply("dataContextValue", {
                            field: fieldName,
                            value: value,
                            dataItem: dataItem
                        }).value;
                    }
                }
                if (hasValue(value)) {
                    hasSomeValues_1 = true;
                    if (dataItem.hasChildren[fieldName]) {
                        var template = _this.createDataItem();
                        template.copyFrom(_this.mainDataSet.template);
                        var children = new SortedList_OrderedListTemplate(template);
                        children.events.on("inserted", _this.handleDataItemAdded, _this, false);
                        children.events.on("removed", _this.handleDataItemRemoved, _this, false);
                        _this._dataDisposers.push(new List_ListDisposer(children));
                        var count = value.length;
                        for (var i = 0; i < count; i++) {
                            var rawDataItem = value[i];
                            var childDataItem = children.create();
                            childDataItem.parent = dataItem;
                            _this.processDataItem(childDataItem, rawDataItem);
                        }
                        var anyDataItem = dataItem;
                        anyDataItem[fieldName] = children;
                    }
                    else {
                        // data is converted to numbers/dates in each dataItem
                        dataItem[fieldName] = value;
                    }
                }
            });
            Object_each(this.propertyFields, function (key, fieldValue) {
                var f = key;
                var value = dataContext[fieldValue];
                if (hasValue(value)) {
                    hasSomeValues_1 = true;
                    dataItem.setProperty(f, value);
                }
            });
            // @todo we might need some flag which would tell whether we should create empty data items or not.
            if (!this._addAllDataItems && !hasSomeValues_1) {
                this.mainDataSet.remove(dataItem);
            }
        }
    };
    /**
     *
     * When validating raw data, instead of processing data item, we update it
     *
     * @ignore Exclude from docs
     * @param item
     */
    Component.prototype.updateDataItem = function (dataItem) {
        var _this = this;
        if (dataItem) {
            var dataContext_1 = dataItem.dataContext;
            Object_each(this.dataFields, function (key, fieldValue) {
                var fieldName = key;
                var value = dataContext_1[fieldValue];
                // Apply adapters to a retrieved value
                if (_this._adapterO) {
                    value = _this._adapterO.apply("dataContextValue", {
                        field: fieldName,
                        value: value,
                        dataItem: dataItem
                    }).value;
                }
                if (hasValue(value)) {
                    if (dataItem.hasChildren[fieldName]) {
                        var anyDataItem = dataItem;
                        var children = (anyDataItem[fieldName]);
                        children.each(function (child) {
                            _this.updateDataItem(child);
                        });
                    }
                    else {
                        // data is converted to numbers/dates in each dataItem					
                        dataItem[fieldName] = value;
                    }
                }
            });
            Object_each(this.propertyFields, function (key, fieldValue) {
                var f = key;
                var value = dataContext_1[fieldValue];
                if (hasValue(value)) {
                    dataItem.setProperty(f, value);
                }
            });
        }
    };
    /**
     * [validateDataElements description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    Component.prototype.validateDataElements = function () {
        var count = this.endIndex;
        for (var i = this.startIndex; i < count; i++) {
            var dataItem = this.dataItems.getIndex(i);
            // TODO is this correct
            if (dataItem) {
                this.validateDataElement(dataItem);
            }
        }
    };
    /**
     * Validates this element and its related elements.
     *
     * @ignore Exclude from docs
     */
    Component.prototype.validate = function () {
        this.validateDataElements();
        _super.prototype.validate.call(this);
    };
    /**
     * [validateDataElement description]
     *
     * @ignore Exclude from docs
     * @param dataItem [description]
     */
    Component.prototype.validateDataElement = function (dataItem) {
    };
    /**
     * Adds one or several (array) of data items to the existing data.
     *
     * @param rawDataItem One or many raw data item objects
     */
    Component.prototype.addData = function (rawDataItem, removeCount, skipRaw) {
        var _this = this;
        // need to check if data is invalid, as addData might be called multiple times
        if (!this.dataInvalid && this.inited) {
            this._parseDataFrom = this.data.length; // save length of parsed data
        }
        if (!skipRaw) {
            if (rawDataItem instanceof Array) {
                // can't use concat because new array is returned
                each(rawDataItem, function (dataItem) {
                    _this.data.push(dataItem);
                });
            }
            else {
                this.data.push(rawDataItem); // add to raw data array
            }
        }
        if (this.inited) {
            this.removeData(removeCount, skipRaw);
        }
        else {
            if (isNumber(removeCount)) {
                while (removeCount > 0) {
                    this.data.shift();
                    removeCount--;
                }
            }
        }
        this.invalidateData();
    };
    /**
     * Removes elements from the beginning of data
     *
     * @param count number of elements to remove
     */
    Component.prototype.removeData = function (count, skipRaw) {
        if (isNumber(count) && count > 0) {
            while (count > 0) {
                var dataItem = this.mainDataSet.getIndex(0);
                if (dataItem) {
                    this.mainDataSet.remove(dataItem);
                }
                this.dataUsers.each(function (dataUser) {
                    if (!dataUser.data || dataUser.data.length == 0) {
                        var dataItem_1 = dataUser.mainDataSet.getIndex(0);
                        if (dataItem_1) {
                            dataUser.mainDataSet.remove(dataItem_1);
                        }
                    }
                });
                if (!skipRaw) {
                    this.data.shift();
                }
                if (this._parseDataFrom > 0) {
                    this._parseDataFrom--;
                }
                count--;
            }
            // changed from invalidateData since 4.7.19 to solve #51551
            this.invalidateDataItems();
        }
    };
    /**
     * Triggers a data (re)parsing.
     *
     * @ignore Exclude from docs
     */
    Component.prototype.invalidateData = function () {
        if (this.disabled || this.isTemplate) {
            return;
        }
        //if(!this.dataInvalid){
        registry.addToInvalidComponents(this);
        system.requestFrame();
        this.dataInvalid = true;
        Iterator_each(this.dataUsers.iterator(), function (x) {
            x.invalidateDataItems();
        });
        //}
    };
    /**
     * [invalidateDataUsers description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    Component.prototype.invalidateDataUsers = function () {
        Iterator_each(this.dataUsers.iterator(), function (x) {
            x.invalidate();
        });
    };
    /**
     * Invalidates data values. When data array is not changed, but values within
     * it changes, we invalidate data so that component would process changes.
     *
     * @ignore Exclude from docs
     */
    Component.prototype.invalidateDataItems = function () {
        if (this.disabled || this.isTemplate) {
            return;
        }
        //if(!this.dataItemsInvalid){
        move(registry.invalidDataItems, this);
        system.requestFrame();
        this.dataItemsInvalid = true;
        Iterator_each(this.dataUsers.iterator(), function (x) {
            x.invalidateDataItems();
        });
        //}
    };
    /**
     * Invalidates data range. This is done when data which must be shown
     * changes (chart is zoomed for example).
     *
     * @ignore Exclude from docs
     */
    Component.prototype.invalidateDataRange = function () {
        if (this.disabled || this.isTemplate) {
            return;
        }
        //if(!this.dataRangeInvalid){
        this.dataRangeInvalid = true;
        move(registry.invalidDataRange, this);
        system.requestFrame();
        //}
    };
    /**
     * Processes data range.
     *
     * @todo Description
     * @ignore Exclude from docs
     */
    Component.prototype.validateDataRange = function () {
        remove(registry.invalidDataRange, this);
        this.dataRangeInvalid = false;
        if (this.startIndex != this._prevStartIndex || this.endIndex != this._prevEndIndex) {
            this.rangeChangeUpdate();
            this.appendDataItems();
            this.invalidate();
            this.dispatchImmediately("datarangechanged");
        }
    };
    /**
     * [sliceData description]
     *
     * @todo Description
     * @ignore Exclude from docs
     */
    Component.prototype.sliceData = function () {
        this._workingStartIndex = this.startIndex;
        this._workingEndIndex = this.endIndex;
    };
    /**
     * [rangeChangeUpdate description]
     *
     * @todo Description
     * @ignore Exclude from docs
     */
    Component.prototype.rangeChangeUpdate = function () {
        this.sliceData();
        this._prevStartIndex = this.startIndex;
        this._prevEndIndex = this.endIndex;
    };
    /**
     * [appendDataItems description]
     *
     * @todo Description
     * @ignore Exclude from docs
     */
    Component.prototype.appendDataItems = function () {
        // TODO use an iterator instead
        var count = this.endIndex;
        for (var i = this.startIndex; i < count; i++) {
            // data item
            var dataItem = this.dataItems.getIndex(i);
            if (dataItem) {
                dataItem.__disabled = false;
            }
        }
        for (var i = 0; i < this.startIndex; i++) {
            var dataItem = this.dataItems.getIndex(i);
            dataItem.__disabled = true;
        }
        for (var i = this.endIndex; i < this.dataItems.length; i++) {
            var dataItem = this.dataItems.getIndex(i);
            dataItem.__disabled = true;
        }
    };
    /**
     * If you want to have a smooth transition from one data values to another, you change your raw data and then you must call this method.
     * then instead of redrawing everything, the chart will check raw data and smoothly transit from previous to new data
     */
    Component.prototype.invalidateRawData = function () {
        if (this.disabled || this.isTemplate) {
            return;
        }
        //if(!this.rawDataInvalid){
        move(registry.invalidRawDatas, this);
        system.requestFrame();
        this.rawDataInvalid = true;
        Iterator_each(this.dataUsers.iterator(), function (x) {
            x.invalidateRawData();
        });
        //}
    };
    /**
     * @ignore
     */
    Component.prototype.validateRawData = function () {
        var _this = this;
        remove(registry.invalidRawDatas, this);
        Iterator_each(this.mainDataSet.iterator(), function (dataItem) {
            if (dataItem) {
                _this.updateDataItem(dataItem);
            }
        });
    };
    /**
     * Destroys this object and all related data.
     */
    Component.prototype.dispose = function () {
        var _this = this;
        this.mainDataSet.template.clones.clear();
        Object_each(this._dataSources, function (key, source) {
            _this.removeDispose(source);
        });
        _super.prototype.dispose.call(this);
    };
    /**
     * @ignore
     */
    Component.prototype.disposeData = function () {
        this.mainDataSet.template.clones.clear();
        each(this._dataDisposers, function (x) {
            x.dispose();
        });
        // and for all components
        Iterator_each(this.dataUsers.iterator(), function (dataUser) {
            dataUser.disposeData();
        });
        this._dataDisposers.length = 0;
        this._startIndex = undefined;
        this._endIndex = undefined;
        // dispose old
        this.mainDataSet.clear();
        this.mainDataSet.template.clones.clear();
        if (this._dataSets) {
            this._dataSets.clear();
        }
    };
    Component.prototype.getDataItem = function (dataContext) {
        return this.mainDataSet.create();
    };
    /**
     * Validates (processes) data.
     *
     * @ignore Exclude from docs
     */
    Component.prototype.validateData = function () {
        this.dispatchImmediately("beforedatavalidated");
        this.dataInvalid = false;
        registry.removeFromInvalidComponents(this);
        if (this.__disabled) {
            return;
        }
        this.dataValidationProgress = 0;
        // need this to slice new data
        this._prevStartIndex = undefined;
        this._prevEndIndex = undefined;
        // todo: this needs some overthinking, maybe some extra settings like zoomOotonDataupdate like in v3 or so. some charts like pie chart probably should act like this always
        this._startIndex = undefined;
        this._endIndex = undefined;
        if (this.dataFields.data && this.dataItem) {
            var dataContext = this.dataItem.dataContext;
            this._data = dataContext[this.dataFields.data];
        }
        // data items array is reset only if all data is validated, if _parseDataFrom is not 0, we append new data only
        // check heatmap demo if uncommented
        // fixed both issues by adding && this.data.length > 0
        // check adding series example if changed
        if (this._parseDataFrom === 0 && this.data.length > 0) {
            this.disposeData();
        }
        if (this.data.length > 0) {
            var preloader = this.preloader;
            // and for all components
            Iterator_each(this.dataUsers.iterator(), function (dataUser) {
                // todo: this needs some overthinking, maybe some extra settings like zoomOUtonDataupdate like in v3 or so. some charts like pie chart probably should act like this always
                dataUser._startIndex = undefined;
                dataUser._endIndex = undefined;
            });
            var counter = 0;
            var startTime = Date.now();
            // parse data
            var i = this._parseDataFrom;
            var n = this.data.length;
            var _loop_1 = function () {
                var rawDataItem = this_1.data[i];
                if (this_1._usesData) {
                    var dataItem = this_1.getDataItem(rawDataItem);
                    this_1.processDataItem(dataItem, rawDataItem);
                }
                this_1.dataUsers.each(function (dataUser) {
                    if (dataUser.data.length == 0) { // checking if data is not set directly
                        var dataUserDataItem = dataUser.getDataItem(rawDataItem);
                        dataUser.processDataItem(dataUserDataItem, rawDataItem);
                    }
                });
                counter++;
                // show preloader if this takes too many time
                if (counter == 100) { // no need to check it on each data item
                    counter = 0;
                    var elapsed = Date.now() - startTime;
                    if (elapsed > this_1.parsingStepDuration) {
                        if (i < this_1.data.length - 10) {
                            this_1._parseDataFrom = i + 1;
                            // update preloader
                            if (preloader) {
                                if (i / this_1.data.length > 0.5 && !preloader.visible) {
                                    // do not start showing
                                }
                                else {
                                    preloader.progress = i / this_1.data.length;
                                }
                            }
                            this_1.dataValidationProgress = i / this_1.data.length;
                            i = this_1.data.length; // stops cycle
                            this_1.invalidateData();
                            return { value: void 0 };
                        }
                    }
                }
            };
            var this_1 = this;
            for (i; i < n; i++) {
                var state_1 = _loop_1();
                if (typeof state_1 === "object")
                    return state_1.value;
            }
            if (preloader) {
                preloader.progress = 1;
            }
            this.dataUsers.each(function (dataUser) {
                if (dataUser.hidden) {
                    dataUser.hide(0);
                }
            });
        }
        this.dataValidationProgress = 1;
        this._parseDataFrom = 0; // reset this index, it is set to dataItems.length if addData() method was used.
        this.invalidateDataItems();
        if (!this._internalDefaultsApplied) {
            this.applyInternalDefaults();
        }
        this.dispatch("datavalidated"); // can't zoom chart if dispatched immediately
    };
    /**
     * Validates (processes) data items.
     *
     * @ignore Exclude from docs
     */
    Component.prototype.validateDataItems = function () {
        remove(registry.invalidDataItems, this);
        this.dataItemsInvalid = false;
        this.invalidateDataRange();
        this.invalidate();
        this.dispatch("dataitemsvalidated");
    };
    Object.defineProperty(Component.prototype, "data", {
        /**
         * Returns element's source (raw) data.
         *
         * @return Data
         */
        get: function () {
            if (!this._data) {
                this._data = [];
            }
            if (!this._adapterO) {
                return this._data;
            }
            else {
                return this._adapterO.apply("data", this._data);
            }
        },
        /**
         * Sets source (raw) data for the element. The "data" is always an `Array`
         * of objects.
         *
         * IMPORTANT: The order of data items in `data` array is important as it
         * might affect chart look and behavior. [More details](https://www.amcharts.com/docs/v4/concepts/data/#Order_of_data_items).
         *
         * @param value Data
         */
        set: function (value) {
            this.setData(value);
        },
        enumerable: true,
        configurable: true
    });
    Component.prototype.setData = function (value) {
        // array might be the same, but there might be items added
        // todo: check if array changed, toString maybe?
        //if (this._data != value) {
        this._parseDataFrom = 0;
        this.disposeData();
        this._data = value;
        if (value && value.length > 0) {
            this.invalidateData();
        }
        else {
            this.dispatchImmediately("beforedatavalidated");
            this.dispatch("datavalidated");
        }
        //}
    };
    /**
     * Returns (creates if necessary) a [[DataSource]] bound to any specific
     * property.
     *
     * For example if I want to bind `data` to an external JSON file, I'd create
     * a DataSource for it.
     *
     * @param property  Property to bind external data to
     * @return A DataSource for property
     */
    Component.prototype.getDataSource = function (property) {
        var _this = this;
        if (!hasValue(this._dataSources[property])) {
            this._dataSources[property] = new DataSource_DataSource();
            this._dataSources[property].component = this;
            this.setDataSourceEvents(this._dataSources[property], property);
            this._dataSources[property].adapter.add("dateFields", function (val) {
                return _this.dataSourceDateFields(val);
            });
            this._dataSources[property].adapter.add("numberFields", function (val) {
                return _this.dataSourceNumberFields(val);
            });
            this.events.on("inited", function () {
                _this.loadData(property);
            }, this, false);
        }
        return this._dataSources[property];
    };
    Object.defineProperty(Component.prototype, "dataSource", {
        /**
         * @return Data source
         */
        get: function () {
            if (!this._dataSources["data"]) {
                this.getDataSource("data");
            }
            return this._dataSources["data"];
        },
        /**
         *A [[DataSource]] to be used for loading Component's data.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/loading-external-data/} for more on loading external data
         * @param value  Data source
         */
        set: function (value) {
            var _this = this;
            if (this._dataSources["data"]) {
                this.removeDispose(this._dataSources["data"]);
            }
            this._dataSources["data"] = value;
            this._dataSources["data"].component = this;
            this.events.on("inited", function () {
                _this.loadData("data");
            }, this, false);
            this.setDataSourceEvents(value, "data");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initiates loading of the external data via [[DataSource]].
     *
     * @ignore Exclude from docs
     */
    Component.prototype.loadData = function (property) {
        this._dataSources[property].load();
    };
    /**
     * This function is called by the [[DataSource]]'s `dateFields` adapater
     * so that particular chart types can popuplate this setting with their
     * own type-specific data fields so they are parsed properly.
     *
     * @ignore Exclude from docs
     * @param value  Array of date fields
     * @return Array of date fields populated with chart's date fields
     */
    Component.prototype.dataSourceDateFields = function (value) {
        return value;
    };
    /**
     * This function is called by the [[DataSource]]'s `numberFields` adapater
     * so that particular chart types can popuplate this setting with their
     * own type-specific data fields so they are parsed properly.
     *
     * @ignore Exclude from docs
     * @param value  Array of number fields
     * @return Array of number fields populated with chart's number fields
     */
    Component.prototype.dataSourceNumberFields = function (value) {
        return value;
    };
    /**
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param list        [description]
     * @param dataFields  [description]
     * @param targetList  [description]
     * @return [description]
     */
    Component.prototype.populateDataSourceFields = function (list, dataFields, targetList) {
        each(targetList, function (value) {
            if (dataFields[value] && indexOf(list, dataFields[value]) === -1) {
                list.push(dataFields[value]);
            }
        });
        return list;
    };
    /**
     * Sets events on a [[DataSource]].
     *
     * @ignore Exclude from docs
     */
    Component.prototype.setDataSourceEvents = function (ds, property) {
        var _this = this;
        ds.events.on("started", function (ev) {
            var preloader = _this.preloader;
            if (preloader) {
                preloader.progress = 0;
                //preloader.label.text = this.language.translate("Loading");
            }
        }, undefined, false);
        ds.events.on("loadstarted", function (ev) {
            var preloader = _this.preloader;
            if (preloader) {
                preloader.progress = 0.25;
            }
        }, undefined, false);
        ds.events.on("loadended", function (ev) {
            var preloader = _this.preloader;
            if (preloader) {
                preloader.progress = 0.5;
            }
        }, undefined, false);
        ds.events.on("parseended", function (ev) {
            var preloader = _this.preloader;
            if (preloader) {
                preloader.progress = 0.75;
            }
        }, undefined, false);
        ds.events.on("ended", function (ev) {
            var preloader = _this.preloader;
            if (preloader) {
                preloader.progress = 1;
            }
        }, undefined, false);
        ds.events.on("error", function (ev) {
            var preloader = _this.preloader;
            if (preloader) {
                preloader.progress = 1;
            }
            _this.openModal(ev.message);
        }, undefined, false);
        if (property) {
            ds.events.on("done", function (ev) {
                var preloader = _this.preloader;
                if (preloader) {
                    preloader.progress = 1;
                }
                if (property == "data" && !isArray(ev.data)) {
                    ev.data = [ev.data];
                }
                if (ds.incremental && property == "data" && _this.data.length) {
                    _this.addData(ev.data, ds.keepCount ? ev.data.length : 0);
                }
                else if (ds.updateCurrentData && property == "data" && _this.data.length) {
                    // cycle through existing data items
                    each(_this.data, function (item, index) {
                        if (hasValue(ev.data[index])) {
                            Object_each(item, function (key, val) {
                                if (hasValue(ev.data[index][key])) {
                                    item[key] = ev.data[index][key];
                                }
                            });
                        }
                    });
                    _this.invalidateRawData();
                }
                else {
                    _this[property] = ev.data;
                }
            });
        }
    };
    Object.defineProperty(Component.prototype, "responsive", {
        /**
         * @return Responsive rules handler
         */
        get: function () {
            if (!this._responsive) {
                this._responsive = new Responsive_Responsive();
                this._responsive.component = this;
            }
            return this._responsive;
        },
        /**
         * A [[Responsive]] instance to be used when applying conditional
         * property values.
         *
         * NOTE: Responsive features are currently in development and may not work
         * as expected, if at all.
         *
         * @param value  Responsive rules handler
         */
        set: function (value) {
            this._responsive = value;
            this._responsive.component = this;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets current zoom.
     *
     * The range uses relative values from 0 to 1, with 0 marking beginning and 1
     * marking end of the available data range.
     *
     * This method will not have any effect when called on a chart object.
     * Since the chart can have a number of axes and series, each with its own
     * data, the meaning of "range" is very ambiguous.
     *
     * To zoom the chart use `zoom*` methods on its respective axes.
     *
     * @param range          Range
     * @param skipRangeEvent Should rangechanged event not be triggered?
     * @param instantly      Do not animate?
     * @return Actual modidied range (taking `maxZoomFactor` into account)
     */
    Component.prototype.zoom = function (range, skipRangeEvent, instantly, declination) {
        var _this = this;
        if (skipRangeEvent === void 0) { skipRangeEvent = false; }
        if (instantly === void 0) { instantly = false; }
        var start = range.start;
        var end = range.end;
        var priority = range.priority;
        if (range.start == range.end) {
            range.start = range.start - 0.5 / this.maxZoomFactor;
            range.end = range.end + 0.5 / this.maxZoomFactor;
        }
        if (priority == "end" && end == 1 && start != 0) {
            if (start < this.start) {
                priority = "start";
            }
        }
        if (priority == "start" && start == 0) {
            if (end > this.end) {
                priority = "end";
            }
        }
        if (!isNumber(declination)) {
            declination = this.maxZoomDeclination;
        }
        if (!isNumber(start) || !isNumber(end)) {
            return { start: this.start, end: this.end };
        }
        if (this._finalStart != start || this._finalEnd != end) {
            var maxZoomFactor = this.maxZoomFactor / this.minZoomCount;
            var minZoomFactor = this.maxZoomFactor / this.maxZoomCount;
            // most likely we are dragging left scrollbar grip here, so we tend to modify end
            if (priority == "start") {
                if (this.maxZoomCount > 0) {
                    // add to the end
                    if (1 / (end - start) < minZoomFactor) {
                        end = start + 1 / minZoomFactor;
                    }
                }
                // add to the end
                if (1 / (end - start) > maxZoomFactor) {
                    end = start + 1 / maxZoomFactor;
                }
                //unless end is > 0
                if (end > 1 && end - start < 1 / maxZoomFactor) {
                    //end = 1;
                    start = end - 1 / maxZoomFactor;
                }
            }
            // most likely we are dragging right, so we modify left
            else {
                if (this.maxZoomCount > 0) {
                    // add to the end
                    if (1 / (end - start) < minZoomFactor) {
                        start = end - 1 / minZoomFactor;
                    }
                }
                // remove from start
                if (1 / (end - start) > maxZoomFactor) {
                    start = end - 1 / maxZoomFactor;
                }
                if (start < 0 && end - start < 1 / maxZoomFactor) {
                    //start = 0;
                    end = start + 1 / maxZoomFactor;
                }
            }
            if (start < -declination) {
                start = -declination;
            }
            if (1 / (end - start) > maxZoomFactor) {
                end = start + 1 / maxZoomFactor;
            }
            if (end > 1 + declination) {
                end = 1 + declination;
            }
            if (1 / (end - start) > maxZoomFactor) {
                start = end - 1 / maxZoomFactor;
            }
            this._finalEnd = end;
            this._finalStart = start;
            this.skipRangeEvent = skipRangeEvent;
            this.dispatchImmediately("rangechangestarted");
            if (this.rangeChangeDuration > 0 && !instantly) {
                // todo: maybe move this to Animation
                var rangeChangeAnimation = this.rangeChangeAnimation;
                if (rangeChangeAnimation && rangeChangeAnimation.progress < 1) {
                    var options = rangeChangeAnimation.animationOptions;
                    if (options.length > 1) {
                        if (options[0].to == start && options[1].to == end) {
                            return { start: start, end: end };
                        }
                        else {
                            if (!rangeChangeAnimation.isDisposed()) {
                                rangeChangeAnimation.stop();
                            }
                        }
                    }
                }
                if (this.rangeChangeAnimation) {
                    this.rangeChangeAnimation.kill();
                }
                rangeChangeAnimation = this.animate([{ property: "start", to: start }, { property: "end", to: end }], this.rangeChangeDuration, this.rangeChangeEasing);
                this.rangeChangeAnimation = rangeChangeAnimation;
                if (rangeChangeAnimation && !rangeChangeAnimation.isFinished()) {
                    rangeChangeAnimation.events.on("animationended", function () {
                        _this.dispatchImmediately("rangechangeended");
                    });
                }
                else {
                    this.dispatchImmediately("rangechangeended");
                }
            }
            else {
                this.start = start;
                this.end = end;
                this.dispatch("rangechangeended");
            }
        }
        return { start: start, end: end };
    };
    /**
     * Zooms to specific data items using their index in data.
     *
     * This method will not have any effect when called on a chart object.
     * Since the chart can have a number of axes and series, each with its own
     * data, the meaning of "index" is very ambiguous.
     *
     * To zoom the chart use `zoom*` methods on its respective axes.
     *
     * @param startIndex     Index of the starting data item
     * @param endIndex       Index of the ending data item
     * @param skipRangeEvent Should rangechanged event not be triggered?
     * @param instantly      Do not animate?
     */
    Component.prototype.zoomToIndexes = function (startIndex, endIndex, skipRangeEvent, instantly) {
        if (!isNumber(startIndex) || !isNumber(endIndex)) {
            return;
        }
        var start = startIndex / this.dataItems.length;
        var end = endIndex / this.dataItems.length;
        this.zoom({ start: start, end: end }, skipRangeEvent, instantly);
    };
    Object.defineProperty(Component.prototype, "zoomFactor", {
        /**
         * A current zoom factor (0-1). 1 meaning fully zoomed out. (showing all of
         * the available data)
         *
         * @return Zoom factor
         */
        get: function () {
            return fitToRange(1 / (this.end - this.start), 1, this.maxZoomFactor);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "maxZoomFactor", {
        /**
         * @return Maximum zoomFactor
         */
        get: function () {
            return this.getPropertyValue("maxZoomFactor");
        },
        /**
         * Max available `zoomFactor`.
         *
         * The element will not allow zoom to occur beyond this factor.
         *
         * [[DateAxis]] and [[CategoryAxis]] calculate this atutomatically so that
         * category axis could be zoomed to one category and date axis allows to be
         * zoomed up to one base interval.
         *
         * In case you want to restrict category or date axis to be zoomed to more
         * than one category or more than one base interval, use `minZoomCount`
         * property (set it to `> 1`).
         *
         * Default value of [[ValueAxis]]'s `maxZoomFactor` is `1000`.
         *
         * Feel free to modify it to allow bigger zoom or to restrict zooming.
         *
         * @param value  Maximum zoomFactor
         */
        set: function (value) {
            if (this.setPropertyValue("maxZoomFactor", value)) {
                if (value == 1) {
                    this.maxZoomDeclination = 0;
                }
                this.invalidateDataRange();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "maxZoomDeclination", {
        /**
         * @ignore
         * @return Maximum zoom declination
         */
        get: function () {
            return this.getPropertyValue("maxZoomDeclination");
        },
        /**
         * Max zoom declination.
         *
         * @ignore
         * @default 1
         * @param value  Maximum zoom declination
         */
        set: function (value) {
            if (this.setPropertyValue("maxZoomDeclination", value)) {
                this.invalidateDataRange();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "startIndex", {
        /**
         * Current starting index.
         *
         * @return Start index
         */
        get: function () {
            if (!isNumber(this._startIndex)) {
                this._startIndex = 0;
            }
            return this._startIndex;
        },
        /**
         * Sets current starting index.
         *
         * @ignore Exclude from docs
         * @param value Start index
         */
        set: function (value) {
            this._startIndex = fitToRange(Math.round(value), 0, this.dataItems.length);
            //this._workingStartIndex = this._startIndex; // not good, breaks adjusted working start index of line series
            this.start = this.indexToPosition(this._startIndex);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     * @todo:review description
     * returns item's relative position by the index of the item
     * @param index
     */
    Component.prototype.indexToPosition = function (index) {
        return index / this.dataItems.length;
    };
    Object.defineProperty(Component.prototype, "endIndex", {
        /**
         * Current ending index.
         *
         * @return End index
         */
        get: function () {
            var count = this.dataItems.length;
            if (!isNumber(this._endIndex) || this._endIndex > count) {
                this._endIndex = count;
            }
            return this._endIndex;
        },
        /**
         * Sets current ending index.
         *
         * @ignore Exclude from docs
         * @param value End index
         */
        set: function (value) {
            this._endIndex = fitToRange(Math.round(value), 0, this.dataItems.length);
            //this._workingEndIndex = this._endIndex; // not good, breaks adjusted workingend index of line series
            this.end = this.indexToPosition(this._endIndex);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "start", {
        /**
         * @return Start (0-1)
         */
        get: function () {
            if (!this._adapterO) {
                return this._start;
            }
            else {
                return this._adapterO.apply("start", this._start);
            }
        },
        /**
         * Start of the current data range (zoom).
         *
         * These are relative values from 0 (beginning) to 1 (end).
         *
         * @param value Start (0-1)
         */
        set: function (value) {
            // value = $math.round(value, 10); not good
            //if (1 / (this.end - value) > this.maxZoomFactor) {
            //	value = this.end - 1 / this.maxZoomFactor;
            //}
            if (this._start != value) {
                this._start = value;
                var startIndex = Math.max(0, Math.floor(this.dataItems.length * value) || 0);
                this._startIndex = Math.min(startIndex, this.dataItems.length);
                this.invalidateDataRange();
                this.invalidate();
                this.dispatchImmediately("startchanged");
                this.dispatch("startendchanged");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "end", {
        /**
         * @return End (0-1)
         */
        get: function () {
            if (!this._adapterO) {
                return this._end;
            }
            else {
                return this._adapterO.apply("end", this._end);
            }
        },
        /**
         * End of the current data range (zoom).
         *
         * These are relative values from 0 (beginning) to 1 (end).
         *
         * @param value End (0-1)
         */
        set: function (value) {
            // value = $math.round(value, 10); // not good
            //if (1 / (value - this.start) > this.maxZoomFactor) {
            //	value = 1 / this.maxZoomFactor + this.start;
            //}
            if (this._end != value) {
                this._end = value;
                this._endIndex = Math.min(this.dataItems.length, Math.ceil(this.dataItems.length * value) || 0);
                this.invalidateDataRange();
                this.invalidate();
                this.dispatchImmediately("endchanged");
                this.dispatch("startendchanged");
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * [removeFromInvalids description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    Component.prototype.removeFromInvalids = function () {
        _super.prototype.removeFromInvalids.call(this);
        registry.removeFromInvalidComponents(this);
        remove(registry.invalidDataItems, this);
        remove(registry.invalidDataRange, this);
        remove(registry.invalidRawDatas, this);
    };
    Object.defineProperty(Component.prototype, "dataItems", {
        /**
         * Returns a list of source [[DataItem]] objects currently used in the chart.
         *
         * @return List of data items
         */
        get: function () {
            if (this._currentDataSetId != "") {
                var dataItems = this.dataSets.getKey(this._currentDataSetId);
                if (dataItems) {
                    return dataItems;
                }
            }
            return this._dataItems;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "dataSets", {
        /**
         * Holds data items for data sets (usually aggregated data).
         *
         * @ignore
         * @since 4.7.0
         * @return  Data sets
         */
        get: function () {
            if (!this._dataSets) {
                this._dataSets = new Dictionary_Dictionary();
            }
            return this._dataSets;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Makes the chart use particular data set.
     *
     * If `id` is not provided or there is no such data set, main data will be
     * used.
     *
     * @ignore
     * @since 4.7.0
     * @param  id  Data set id
     */
    Component.prototype.setDataSet = function (id) {
        if (this._currentDataSetId != id) {
            var dataSet = this.dataSets.getKey(id);
            if (!dataSet) {
                if (this._currentDataSetId != "") {
                    this.dataItems.each(function (dataItem) {
                        dataItem.__disabled = true;
                    });
                    this._currentDataSetId = "";
                    this.invalidateDataRange();
                    this._prevStartIndex = undefined;
                    this.dataItems.each(function (dataItem) {
                        dataItem.__disabled = false;
                    });
                    return true;
                }
            }
            else {
                this.dataItems.each(function (dataItem) {
                    dataItem.__disabled = true;
                });
                this._currentDataSetId = id;
                this.invalidateDataRange();
                this._prevStartIndex = undefined;
                this.dataItems.each(function (dataItem) {
                    dataItem.__disabled = false;
                });
                return true;
            }
        }
        return false;
    };
    Object.defineProperty(Component.prototype, "currentDataSetId", {
        /**
         * Returns id of the currently used data set, or `undefined` if main data set
         * is in use.
         *
         * @since 4.7.0
         * @return Current data set id
         */
        get: function () {
            return this._currentDataSetId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "mainDataSet", {
        /**
         * Returns reference to "main" data set (unaggregated data as it was supplied
         * in `data`).
         *
         * @since 4.7.0
         * @return Main data set
         */
        get: function () {
            return this._dataItems;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the indexes for the dataItems
     *
     * @ignore Exclude from docs
     */
    Component.prototype._updateDataItemIndexes = function (startIndex) {
        var dataItems = this.mainDataSet.values;
        var length = dataItems.length;
        for (var i = startIndex; i < length; ++i) {
            dataItems[i]._index = i;
        }
    };
    /**
     * Processes newly added [[DataItem]] as well as triggers data re-validation.
     *
     * @ignore Exclude from docs
     * @param event [description]
     */
    Component.prototype.handleDataItemAdded = function (event) {
        event.newValue.component = this;
        this._updateDataItemIndexes(event.index);
        if (!this.dataItemsInvalid) {
            this.invalidateDataItems();
        }
    };
    /**
     * removes [[DataItem]] as well as triggers data re-validation.
     *
     * @ignore Exclude from docs
     * @param event [description]
     */
    Component.prototype.handleDataItemRemoved = function (event) {
        //		event.oldValue.component = undefined; // not good, as some items might be not removed from component lists
        this._updateDataItemIndexes(event.index);
        if (!this.dataItemsInvalid) {
            this.invalidateDataItems();
        }
    };
    /**
     * Binds a data element's field to a specific field in raw data.
     * For example, for the very basic column chart you'd want to bind a `value`
     * field to a field in data, such as `price`.
     *
     * Some more advanced Components, like [[CandlestickSeries]] need several
     * data fields bound to data, such as ones for open, high, low and close
     * values.
     *
     * @todo Example
     * @param field  Field name
     * @param value  Field name in data
     */
    Component.prototype.bindDataField = function (field, value) {
        this.dataFields[field] = value;
        this.invalidateDataRange();
    };
    /**
     * Invalidates processed data.
     *
     * @ignore Exclude from docs
     */
    Component.prototype.invalidateProcessedData = function () {
        this.resetProcessedRange();
        this.invalidateDataRange();
    };
    /**
     * [resetProcessedRange description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    Component.prototype.resetProcessedRange = function () {
        this._prevEndIndex = null;
        this._prevStartIndex = null;
    };
    Object.defineProperty(Component.prototype, "dataUsers", {
        /**
         * Returns all other [[Component]] objects that are using this element's
         * data.
         *
         * @ignore Exclude from docs
         * @todo Description (review)
         * @return [description]
         */
        get: function () {
            var _this = this;
            if (!this._dataUsers) {
                this._dataUsers = new List_List();
                //this._disposers.push(new ListDisposer(this._dataUsers));
                // TODO better way of handling this? e.g. move into another module ?
                this._disposers.push(new Disposer(function () {
                    // TODO clear the list ?
                    Iterator_each(_this._dataUsers.iterator(), function (x) {
                        x.dispose();
                    });
                }));
            }
            return this._dataUsers;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a clone of this element.
     *
     * @return Clone
     */
    Component.prototype.clone = function () {
        var component = _super.prototype.clone.call(this);
        component.dataFields = Utils_copyProperties(this.dataFields, {});
        return component;
    };
    /**
     * Copies all parameters from another [[Component]].
     *
     * @param source Source Component
     */
    Component.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.data = source.data;
        this.sequencedInterpolation = source.sequencedInterpolation;
        this.sequencedInterpolationDelay = source.sequencedInterpolationDelay;
        this.interpolationDuration = source.interpolationDuration;
        this.interpolationEasing = source.interpolationEasing;
    };
    /**
     * Invalidates the whole element, including all its children, causing
     * complete re-parsing of data and redraw.
     *
     * Use sparingly!
     */
    Component.prototype.reinit = function () {
        this._inited = false;
        this.deepInvalidate();
    };
    /**
     * Add an adapter for data.
     *
     * @return Exporting
     */
    Component.prototype.getExporting = function () {
        var _export = _super.prototype.getExporting.call(this);
        if (!_export.adapter.has("data", this._exportData, -1, this)) {
            _export.adapter.add("data", this._exportData, -1, this);
            this.events.on("datavalidated", function (ev) {
                if (_export.menu) {
                    _export.menu.invalidate();
                }
                _export.handleDataUpdated();
            });
        }
        return _export;
    };
    Component.prototype._exportData = function (arg) {
        arg.data = this.data;
        return arg;
    };
    Component.prototype.setDisabled = function (value) {
        var changed = _super.prototype.setDisabled.call(this, value);
        if (changed) {
            this.invalidateData();
        }
        return changed;
    };
    /**
     * @ignore
     */
    Component.prototype.setShowOnInit = function (value) {
        if (value != this.getPropertyValue("showOnInit")) {
            if (value && !this.inited && !this.hidden) {
                this._showOnInitDisposer2 = this.events.once("dataitemsvalidated", this.hideInitially, this, false);
                this._disposers.push(this._showOnInitDisposer2);
            }
            else {
                if (this._showOnInitDisposer2) {
                    this.removeDispose(this._showOnInitDisposer2);
                }
            }
        }
        // important order here
        _super.prototype.setShowOnInit.call(this, value);
    };
    Component.prototype.setBaseId = function (value) {
        if (value != this._baseId) {
            if (this.dataInvalid) {
                this.dataInvalid = false;
                registry.removeFromInvalidComponents(this);
                this._baseId = value;
                this.invalidateData();
            }
        }
        _super.prototype.setBaseId.call(this, value);
    };
    Object.defineProperty(Component.prototype, "minZoomCount", {
        /**
         * @return Min zoom count
         */
        get: function () {
            return this.getPropertyValue("minZoomCount");
        },
        /**
         * Use this for [[CategoryAxis]] or [[DateAxis]].
         *
         * Allows restricting zoom in beyond certain number of categories or base
         * intervals.
         *
         * @default 1
         * @param value  Min zoom count
         */
        set: function (value) {
            this.setPropertyValue("minZoomCount", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "maxZoomCount", {
        /**
         * @return Max zoom count
         */
        get: function () {
            return this.getPropertyValue("maxZoomCount");
        },
        /**
         * Use this for [[CategoryAxis]] or [[DateAxis]].
         *
         * Limits how many categories or base intervals can be shown at the same
         * time.
         *
         * If there are more items in the chart, the chart will auto-zoom.
         *
         * @default 0 (no limit)
         * @since 4.6.2
         * @param value  Max zoom count
         */
        set: function (value) {
            this.setPropertyValue("maxZoomCount", value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called during the System.update method
     *
     * @ignore Exclude from docs
     */
    Component.prototype._systemCheckIfValidate = function () {
        if (this.dataInvalid || (this.dataProvider && this.dataProvider.dataInvalid)) {
            return false;
        }
        else {
            return true;
        }
    };
    /**
     * Adds easing functions to "function" fields.
     *
     * @param field  Field name
     * @return Assign as function?
     */
    Component.prototype.asFunction = function (field) {
        return field == "interpolationEasing" || field == "rangeChangeEasing" || _super.prototype.asIs.call(this, field);
    };
    return Component;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Component"] = Component_Component;
//# sourceMappingURL=Component.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Label.js
/**
 * Text class deals with all text placed on chart.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */










;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Text is used to display highly configurable, data-enabled textual elements.
 *
 * ## Data Binding
 *
 * A Text element can dynamically parse and populate its contents with values
 * from a [[DataItem]].
 *
 * To activate such binding, set element's `dataItem` property.
 *
 * When activated, text contents will be parsed for special tags, e.g.:
 *
 * ```TypeScript
 * label.dataItem = myDataItem;
 * label.text = "The title is: {title}";
 * ```
 * ```JavaScript
 * label.dataItem = myDataItem;
 * label.text = "The title is: {title}";
 * ```
 *
 * The above will automatically replace "{title}" in the string with the
 * actual data value from `myDataItem`.
 *
 * Note, that most often dataItem is set by the Component.
 *
 *
 * @see {@link ILabelEvents} for a list of available events
 * @see {@link ILabelAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding
 * @todo Vertical align
 * @important
 */
var Label_Label = /** @class */ (function (_super) {
    __extends(Label, _super);
    /**
     * Constructor
     */
    function Label() {
        var _this = 
        // Execute super's constructor
        _super.call(this) || this;
        /**
         * Indicates if the whole text does not fit into max dimenstions set for it.
         */
        _this.isOversized = false;
        // Set this class name
        _this.className = "Label";
        _this.fill = new InterfaceColorSet_InterfaceColorSet().getFor("text");
        // not good to set this, as then these will appear on each label and values set on container won't be applied.
        //this.textDecoration = "none";
        //this.fontWeight = "normal";
        // Set defaults
        _this.wrap = false;
        _this.truncate = false;
        _this.fullWords = true;
        _this.ellipsis = "…";
        _this.textAlign = "start";
        _this.textValign = "top";
        _this.layout = "absolute";
        _this.baseLineRatio = -0.27;
        //this.pixelPerfect = true;
        _this._positionPrecision = 1;
        // Add events to watch for maxWidth/maxHeight changes so that we can
        // invalidate this
        _this.events.on("maxsizechanged", function () {
            if (_this.inited) {
                _this.handleMaxSize();
            }
        }, _this, false);
        // this solves strange bug when text just added to svg is 0x0
        _this.events.once("validated", _this.handleValidate, _this, false);
        // Aply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * A placeholder method that is called **after** element finishes drawing
     * itself.
     *
     * @ignore Exclude from docs
     */
    Label.prototype.afterDraw = function () {
        // since we removed validatePosition from sprite, we still need it here to handle rotated text
        _super.prototype.afterDraw.call(this);
        this.validatePosition();
    };
    /**
     * Sets [[Paper]] instance to use to draw elements.
     * @ignore
     * @param paper Paper
     * @return true if paper was changed, false, if it's the same
     */
    Label.prototype.setPaper = function (paper) {
        var changed = _super.prototype.setPaper.call(this, paper);
        if (changed) {
            this.hardInvalidate();
        }
        return changed;
    };
    /**
     * @ignore
     */
    Label.prototype.handleValidate = function () {
        if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {
            registry.events.once("exitframe", this.hardInvalidate, this);
        }
    };
    /**
     * @ignore
     */
    Label.prototype.handleMaxSize = function () {
        if ((this.bbox.width > this.availableWidth)
            || ((this.bbox.width < this.availableWidth) && (this.isOversized || this.truncate))
            || (this.bbox.height > this.availableHeight)
            || ((this.bbox.height < this.availableHeight) && this.isOversized)) {
            this.invalidate();
        }
        else {
            this.alignSVGText();
        }
    };
    /**
     * [arrange description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    Label.prototype.arrange = function () {
    };
    /**
     * Updates current text according to data item and supported features.
     * Returns `true` if current text has changed.
     *
     * @return Text changed?
     */
    Label.prototype.updateCurrentText = function () {
        // Determine output format
        var output, text;
        if (isNotEmpty(this.html) && this.paper.supportsForeignObject()) {
            // We favor HTML text if it's set and browser supports `foreignObject`
            output = "html";
            text = this.html;
        }
        else {
            output = "svg";
            text = this.text;
        }
        // Need to toString source?
        if (isObject(text)) {
            text = text.toString();
        }
        // Need to format text all the time
        if (hasValue(text) && text !== "") {
            text = this.populateString(text, this.dataItem);
        }
        if (output == "html") {
            if (this._adapterO) {
                text = this._adapterO.apply("htmlOutput", text);
            }
        }
        else {
            if (this._adapterO) {
                text = this._adapterO.apply("textOutput", text);
            }
        }
        // Update the text
        var changed = text != this.currentText || output != this._currentFormat;
        this.currentText = text;
        this._currentFormat = output;
        return changed;
    };
    /**
     * Hard invalidate means the text will be redrawn even if it hasn't changed.
     * This is used when we change `fontSize`, `fontFamily`, or for some other
     * reasons.
     */
    Label.prototype.hardInvalidate = function () {
        this._prevStatus = "";
        this.invalidate();
    };
    /**
     * Gets line bbox, uses caching to save cpu
     * @ignore
     */
    Label.prototype.getLineBBox = function (lineInfo) {
        //let cacheKey = lineInfo.text + lineInfo.style;
        //let lineBBox = this.getCache(cacheKey);
        //if (!lineBBox) {
        //lineBBox = lineInfo.element.getBBox();
        //if (lineBBox.width != 0 && lineBBox.height != 0) {
        //	this.setCache(cacheKey, lineBBox, 5000);
        //}
        //}
        var element = lineInfo && lineInfo.element;
        var node = element && element.node;
        // Check for the parent Node to avoid FF from throwing errors
        if (node && node.parentNode) {
            lineInfo.bbox = element.getBBox();
        }
    };
    /**
     * Draws the textual label.
     *
     * @ignore Exclude from docs
     */
    Label.prototype.draw = function () {
        // Draw super
        _super.prototype.draw.call(this);
        var oldW = this.bbox.width;
        var oldH = this.bbox.height;
        var topParent = this.topParent;
        if (topParent) {
            if (!topParent.maxWidth || !topParent.maxHeight) {
                topParent.events.once("maxsizechanged", this.hardInvalidate, this, false);
                return;
            }
        }
        // Calculate max width and height
        var maxWidth = Math_max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);
        var maxHeight = Math_max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0);
        // save
        var status = maxHeight + "," + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis;
        // Update text
        if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {
            return;
        }
        this._measuredWidth = 0;
        this._measuredHeight = 0;
        // Reset
        this.isOversized = false;
        // Determine output format
        var output = this._currentFormat;
        var text = this.currentText;
        // Empty string
        if (!hasValue(text) || text == "") {
            this.element.attr({ display: "none" });
            return;
        }
        // Chop up text into lines
        // We're still processing SVG and HTML in the same way for now
        var lines = text.split("\n");
        // Do we need to go through the trouble of measuring lines
        //let measure: boolean = true;// (lines.length > 1) || this.wrap;
        this._prevStatus = status;
        this.textAlign = this.textAlign;
        // need this to measure
        var display = this.group.getAttr("display");
        if (display == "none") {
            this.group.removeAttr("display");
        }
        if (this.textPathElement) {
            this.textPathElement.removeChildren();
        }
        // SVG or HTML?
        if (output === "svg") {
            /**
             * SVG
             */
            this.element.removeAttr("display");
            // Clear the element
            var group = this.element;
            this.resetBBox();
            // Init state variables
            var currentHeight = 0;
            var currentFormat = "";
            // Process each line
            for (var i = 0; i < lines.length; i++) {
                // Get line
                var line = lines[i];
                // Check if line is empty
                if (line == "") {
                    // It is, let's just update currentHeight and go to the next one
                    // If it's the first line, we'll have to use arbirary line height,
                    // since there's nothing to measure. For subsequent lines we can take
                    // previous line's height
                    var tempElement = this.getSVGLineElement("", 0);
                    tempElement.add(this.getSvgElement(".", getTextFormatter().translateStyleShortcuts(currentFormat)));
                    group.add(tempElement);
                    var offset = Math.ceil(tempElement.getBBox().height);
                    if (offset > 0) {
                        currentHeight += offset;
                    }
                    group.removeElement(tempElement);
                    // Clear cache if necessary
                    var lineInfo_1 = this.getLineInfo(i);
                    if (lineInfo_1) {
                        lineInfo_1.text = "";
                        lineInfo_1.element.textContent = "";
                    }
                    continue;
                }
                // Chunk up the line and process each chunk
                var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);
                var currentLineHeight = 0;
                var firstChunk = true;
                var skipTextChunks = false;
                // Create line element or grab it from cache
                var lineInfo = this.getLineInfo(i);
                if (lineInfo) {
                    // Empty line
                    lineInfo.text = "";
                    lineInfo.element.textContent = "";
                }
                else {
                    // Init new line info
                    lineInfo = {
                        "text": "",
                        "element": this.getSVGLineElement("", 0),
                        "complex": false
                    };
                    // Create the line element
                    //lineInfo.element = this.getSVGLineElement("", 0);
                    //lineElement = this.getSVGLineElement("", 0);
                    group.add(lineInfo.element);
                }
                lineInfo.element.removeAttr("display");
                lineInfo.element.removeChildren(); // memory leak without this
                if (this.textPathElement) {
                    lineInfo.element.add(this.textPathElement);
                }
                /*// @todo not needed anymore
                if (this.rtl) {
                    chunks.reverse();
                }*/
                // Process each chunk
                for (var x = 0; x < chunks.length; x++) {
                    // If there's more than one chunk, means the line is "complex"
                    if (x) {
                        lineInfo.complex = true;
                    }
                    // Get chunk
                    var chunk = chunks[x];
                    // Is this chunk format or text?
                    if (chunk.type === "format") {
                        // Log current format, so that we can apply it to multiple lines if
                        // necessary
                        currentFormat = chunk.text;
                    }
                    else {
                        // It's text block
                        // Need to skip?
                        // We do this when truncating. We can't just simply go ahead and
                        // abandon chunk processing as they might have formatting
                        // instructions in them that are relevant for subsequent lines
                        if (skipTextChunks) {
                            continue;
                        }
                        // Add chunk to the current element
                        //lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));
                        lineInfo.text = chunk.text;
                        lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);
                        var tspan = this.getSvgElement(lineInfo.text, lineInfo.style);
                        if (this.textPathElement) {
                            this.textPathElement.add(tspan);
                        }
                        else {
                            lineInfo.element.add(tspan);
                        }
                        this.getLineBBox(lineInfo);
                        lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width);
                        // Updated current line height
                        if (currentLineHeight < lineInfo.bbox.height) {
                            currentLineHeight = lineInfo.bbox.height;
                        }
                        // Wrapping?
                        if ((this.wrap || this.truncate) && (lineInfo.bbox.width > maxWidth)) {
                            // Set oversized
                            this.isOversized = true;
                            // Take temporary measurements
                            var lineText = lineInfo.element.textContent;
                            var avgCharWidth = (lineInfo.bbox.width / lineText.length); // * .9;
                            // Calculate average number of symbols / width
                            var excessChars = Math_min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);
                            // Are we truncating or auto-wrapping text?
                            if (this.truncate) {
                                /**
                                 * Processing line truncation
                                 * With the addition of each text chunk we measure if current
                                 * line does not exceed maxWidth. If it does, we will stop
                                 * addition of further chunks as well as try to truncate
                                 * current or any number of previous chunks with an added
                                 * ellipsis
                                 */
                                // Indicator whether we need to add ellipsis to the current
                                // element, even if it fits. This is needed to indicate
                                // whether we have already removed some subsequent chunks in
                                // which case we need to add ellipsis.
                                var addEllipsis = false;
                                // Process each child in the temporary line, until the whole
                                // line fits, preferably with an ellipsis
                                // TODO use iterator instead
                                var node_1 = lineInfo.element.node;
                                if (node_1 && node_1.childNodes) {
                                    for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {
                                        // Get current element
                                        var node_2 = lineInfo.element.node.childNodes[e];
                                        // Add ellipsis only if previous chunk was removed in full
                                        // and this chunk already fits
                                        //if (addEllipsis && (bbox.width <= maxWidth)) {
                                        if (addEllipsis && (lineInfo.bbox.width <= maxWidth)) {
                                            // Add ellipsis
                                            node_2.textContent += " " + this.ellipsis;
                                            // Measure again (we need to make sure ellipsis fits)
                                            lineInfo.bbox = lineInfo.element.getBBox();
                                            lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);
                                            // If it fits, we're done here
                                            // If it doesn't we continue rolling
                                            if (lineInfo.bbox.width <= maxWidth) {
                                                break;
                                            }
                                        }
                                        addEllipsis = false;
                                        // Get element text
                                        var elementText = node_2.textContent;
                                        // Calculate average number of symbols / width
                                        lineText = lineInfo.element.textContent;
                                        excessChars = Math_min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);
                                        // Do this until we fit
                                        while ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {
                                            // Calculate max available chars
                                            var maxChars = Math_max(lineText.length - excessChars - this.ellipsis.length, 1);
                                            // Is there anything left?
                                            if (maxChars <= 1) {
                                                // Nope, let's jump to the previous item
                                                // Set excess characters to zero so that this loop does
                                                // not repeat when it over
                                                excessChars = 0;
                                                // Add ellipsis to previous item
                                                // Subsequent iterations will check if the ellipsis fits
                                                if (e > 0) {
                                                    // Indicating to add ellipsis to previous item
                                                    addEllipsis = true;
                                                    // Removing this node
                                                    lineInfo.element.node.removeChild(node_2);
                                                }
                                            }
                                            // Truncate the text
                                            elementText = truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);
                                            if ((elementText.length > maxChars) && this.fullWords) {
                                                // Still too long?
                                                // Let's try truncating breaking words anyway
                                                elementText = truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);
                                            }
                                            // Set truncated text
                                            node_2.textContent = elementText;
                                            // Measure again
                                            lineInfo.bbox = lineInfo.element.getBBox();
                                            lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);
                                            // Increase excess characters count, just in case it still
                                            // doesn't fit and we have to go at it again
                                            excessChars = Math.ceil(excessChars * 1.1);
                                        }
                                        // Do not process further chunks
                                        skipTextChunks = true;
                                    }
                                }
                            }
                            else {
                                /**
                                 * Processign auto-wrap
                                 * In this case we're going to be adding text chunks until
                                 * they don't fit into current line. Once that happens we will
                                 * inject the rest of the chunks to the next line
                                 */
                                // Get last node added and measure it
                                var node_3 = lineInfo.element.node;
                                if (node_3) {
                                    var lastNode = lineInfo.element.node.lastChild;
                                    // Init split lines
                                    var splitLines = void 0;
                                    while ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {
                                        // Calculate max available chars
                                        var maxChars = Math_max(chunk.text.length - excessChars, 1);
                                        // Don't split the words mid-word if it's not the first chunk
                                        // in the line
                                        if (firstChunk) {
                                            // Split mid-word if necessary
                                            splitLines = splitTextByCharCount(chunk.text, maxChars, true, this.rtl);
                                        }
                                        else {
                                            // Don't split mid-word
                                            splitLines = splitTextByCharCount(chunk.text, maxChars, true, this.rtl);
                                            // Check if the first word is too long
                                            if ((splitLines[0].length > maxChars) || maxChars === 1) {
                                                // Yes - move the whole chunk to the next line
                                                // Remove the element we just added
                                                lineInfo.element.node.removeChild(lastNode);
                                                // Break out of the while on next cycle
                                                excessChars = 0;
                                            }
                                        }
                                        // Use the first line to update last item
                                        if (excessChars > 0) {
                                            lastNode.textContent = getTextFormatter().cleanUp(trim(splitLines.shift()));
                                        }
                                        // Measure again, just in case
                                        lineInfo.bbox = lineInfo.element.getBBox();
                                        lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);
                                        // Increase excess characters count, just in case it still
                                        // doesn't fit and we have to go at it again
                                        excessChars = Math.ceil(excessChars * 1.1);
                                    }
                                    // Construct the rest of the line
                                    if (splitLines.length > 0) {
                                        var restOfLine = "";
                                        // Add leftovers from splitting the current chunk
                                        if (hasValue(splitLines)) {
                                            if (this.rtl) {
                                                restOfLine += splitLines.join("") + currentFormat;
                                            }
                                            else {
                                                restOfLine += currentFormat + splitLines.join("").replace(/([\[\]]{1})/g, "$1$1");
                                            }
                                        }
                                        // Add the rest of the chunks
                                        for (var c = x + 1; c < chunks.length; c++) {
                                            if (chunks[c].type == "value") {
                                                // We're escaping single square brackets that were
                                                // cleaned up by chunk() back to double square brackets
                                                // so that they are not being treated as format on
                                                // next pass.
                                                restOfLine += chunks[c].text.replace(/([\[\]]{1})/g, "$1$1");
                                            }
                                            else {
                                                restOfLine += chunks[c].text;
                                            }
                                        }
                                        // Inject the rest of the lines as chunks for subsequent
                                        lines.splice(i + 1, 0, restOfLine);
                                    }
                                    // Skip processing the rest of the chunks
                                    skipTextChunks = true;
                                }
                            }
                        }
                        // Let's update the text's bbox with the line's one
                        if (this.bbox.width < lineInfo.bbox.width) {
                            this.bbox.width = lineInfo.bbox.width;
                        }
                        // commented to avoid bug (seen on sankey link) where text is incorrectly aligned
                        //if (this.bbox.x > lineInfo.bbox.x) {
                        //this.bbox.x = lineInfo.bbox.x;
                        //}
                        this.bbox.height = currentHeight + currentLineHeight;
                        // Position current line
                        if (!this.textPathElement) {
                            lineInfo.element.attr({
                                "x": "0",
                                "y": currentHeight + currentLineHeight,
                                "dy": Math_round((this.baseLineRatio * currentLineHeight), 3).toString()
                            });
                        }
                        else {
                            lineInfo.element.attr({
                                "dy": -this.paddingBottom.toString()
                            });
                        }
                        firstChunk = false;
                    }
                }
                // Trim the last item
                var node = lineInfo.element.node;
                if (node) {
                    var lastNode = node.lastChild;
                    if (lastNode) {
                        lastNode.textContent = this.rtl ?
                            ltrim(lastNode.textContent) :
                            rtrim(lastNode.textContent);
                    }
                }
                // Increment collective height
                currentHeight += currentLineHeight;
                // Save line cache
                this.addLineInfo(lineInfo, i);
            }
            // Check if maybe we need to hide the whole label if it doesn't fit
            this.maybeHideOversized();
            this.measureFailed = false;
            if (this.bbox.width == 0 || this.bbox.height == 0) {
                this.measureFailed = true;
            }
            // Updated measured dims
            this._measuredWidth = Math_round(Math_max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));
            this._measuredHeight = Math_round(Math_max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom));
            // Align the lines
            this.alignSVGText();
            this.bbox.width = this._measuredWidth;
            this.bbox.height = this._measuredHeight;
            if (oldH != this._measuredHeight || oldW != this._measuredWidth) {
                this.dispatch("transformed");
            }
            this.hideUnused(lines.length);
        }
        else {
            /**
             * HTML
             */
            this.element.removeAttr("display");
            this.resetBBox();
            // Clear the element
            var group = this.element;
            group.removeChildren();
            // Create a ForeignObject to use as HTML container
            var fo = this.paper.foreignObject();
            group.add(fo);
            // Set widths on foreignObject so that autosizing measurements work
            // This will bet reset to actual content width/height
            if (this.maxWidth) {
                fo.attr({
                    width: this.maxWidth
                });
            }
            if (this.maxHeight) {
                fo.attr({
                    height: this.maxHeight
                });
            }
            // Create line element
            //let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));
            var lineElement = this.getHTMLLineElement(text);
            fo.node.appendChild(lineElement);
            // Temporarily set to inline-block so we can measure real width and height
            lineElement.style.display = "inline-block";
            var clientWidth = lineElement.clientWidth;
            var clientHeight = lineElement.clientHeight;
            lineElement.style.display = "block";
            this._bbox = {
                x: 0,
                y: 0,
                width: clientWidth,
                height: clientHeight
            };
            // Set exact dimensions of foreignObject so it is sized exactly as
            // the content within
            fo.attr({
                width: clientWidth,
                height: clientHeight
            });
            // Check if maybe we need to hide the whole label if it doesn't fit
            this.maybeHideOversized();
            // Set measurements and update bbox
            this._measuredWidth = Math_max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);
            this._measuredHeight = Math_max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);
            this.bbox.width = this._measuredWidth;
            this.bbox.height = this._measuredHeight;
            // Don't let labels bleed out of the alotted area
            if (this.truncate) {
                lineElement.style.overflow = "hidden";
            }
            if ((clientWidth > maxWidth) || (clientHeight > maxHeight)) {
                this.isOversized = true;
            }
        }
        // Set applicable styles
        this.setStyles();
        this.updateCenter();
        this.updateBackground();
        if (display == "none") {
            this.group.attr({ display: "none" });
        }
        if (this.pathElement) {
            this.paper.appendDef(this.pathElement);
        }
    };
    /**
     * Hides element if it does not fit into available space
     */
    Label.prototype.maybeHideOversized = function () {
        if (this.hideOversized) {
            if ((this.availableWidth < this.bbox.width) || (this.availableHeight < this.bbox.height)) {
                this.element.attr({ display: "none" });
                this.isOversized = true;
            }
            else {
                this.element.removeAttr("display");
                this.isOversized = false;
            }
        }
    };
    /**
     * Aligns the lines horizontally ant vertically, based on properties.
     *
     * @ignore Exclude from docs
     */
    Label.prototype.alignSVGText = function () {
        // Get Group
        var group = this.element;
        var children = group.node.children || group.node.childNodes;
        // Is there anything to align?
        if (!children || (children && children.length == 0)) {
            return;
        }
        var width = this._measuredWidth;
        var height = this._measuredHeight;
        // TODO maybe these aren't needed ?
        used(this.pixelPaddingLeft);
        used(this.pixelPaddingRight);
        used(this.pixelPaddingTop);
        used(this.pixelPaddingBottom);
        // Process each line
        //$iter.each(group.children.backwards().iterator(), (element) => {
        for (var i = children.length - 1; i >= 0; i--) {
            // Align horizontally
            // Since we are using `text-anchor` for horizontal alignment, all we need
            // to do here is move the `x` position
            var node = children[i];
            node.setAttribute("text-anchor", this.textAlign);
            if (this.textPathElement) {
                node.removeAttribute("x");
                node.removeAttribute("y");
            }
            else {
                switch (this.textAlign) {
                    case "middle":
                        node.setAttribute("x", (width / 2).toString() + "px");
                        break;
                    case "end":
                        if (this.rtl) {
                        }
                        else {
                            node.setAttribute("x", width.toString());
                        }
                        break;
                    default:
                        if (this.rtl) {
                            node.setAttribute("x", width.toString());
                        }
                        else {
                            node.removeAttribute("text-anchor");
                        }
                        break;
                }
                var y = toNumber(node.getAttribute("y"));
                switch (this.textValign) {
                    case "middle":
                        node.setAttribute("y", ((y || 0) + (height - this.bbox.height) / 2).toString());
                        break;
                    case "bottom":
                        node.setAttribute("y", ((y || 0) + height - this.bbox.height).toString());
                        break;
                    default:
                        node.setAttribute("y", (y || 0).toString());
                        break;
                }
            }
        }
    };
    /**
     * Produces an SVG line element with formatted text.
     *
     * @ignore Exclude from docs
     * @param text    Text to wrap into line
     * @param y       Current line vertical position
     * @return A DOM element
     * @todo Implement HTML support
     */
    Label.prototype.getSVGLineElement = function (text, y) {
        // Create a <text> node and set text
        var element = this.paper.addGroup("text");
        element.textContent = text;
        // Set parameters
        element.attr({
            "x": "0"
            //"alignment-baseline": "hanging",
            //"baseline-shift": "-20%",
            //"text-anchor": "center"
        });
        // Set `y` position
        if (hasValue(y)) {
            element.attr({
                "y": y.toString()
            });
        }
        // Don't let labels blled out of the alotted area
        if (this.truncate || this.wrap) {
            element.attr({ "overflow": "hidden" });
        }
        // Add RTL?
        if (this.rtl) {
            element.attr({
                "direction": "rtl",
            });
        }
        return element;
    };
    /**
     * Resets cached BBox.
     *
     * @ignore Exclude from docs
     */
    Label.prototype.resetBBox = function () {
        this._bbox = { x: 0, y: 0, width: 0, height: 0 };
    };
    /**
     * Creates and returns an HTML line element (`<div>`).
     *
     * @ignore Exclude from docs
     * @param text  Text to add
     * @return `<div>` element reference
     */
    Label.prototype.getHTMLLineElement = function (text) {
        // Create the <div> element
        var div = document.createElement("div");
        div.innerHTML = text;
        // Set text alignment
        switch (this.textAlign) {
            case "middle":
                div.style.textAlign = "center";
                break;
            case "end":
                div.style.textAlign = "right";
                break;
        }
        // Disable or enable wrapping
        if (this.wrap) {
            div.style.wordWrap = "break-word";
        }
        else {
            div.style.whiteSpace = "nowrap";
        }
        // Don't let labels bleed out of the alotted area
        // Moved to `draw()` because setting "hidden" kills all measuring
        /*if (this.truncate) {
            div.style.overflow = "hidden";
        }*/
        // Set RTL-related styles
        if (this.rtl) {
            div.style.direction = "rtl";
            //div.style.unicodeBidi = "bidi-override";
        }
        // Translate some of the SVG styles into CSS
        if (hasValue(this.fill)) {
            div.style.color = this.fill.toString();
        }
        return div;
    };
    /**
     * Applies specific styles to text to make it not selectable, unless it is
     * explicitly set as `selectable`.
     *
     * @ignore Exclude from docs
     * @todo Set styles via AMElement
     */
    Label.prototype.setStyles = function () {
        var group = this.element;
        if (!this.selectable || this.draggable || this.resizable || this.swipeable) {
            group.addStyle({
                "webkitUserSelect": "none",
                "msUserSelect": "none"
            });
        }
        else if (this.selectable) {
            group.removeStyle("webkitUserSelect");
            group.removeStyle("msUserSelect");
        }
    };
    /**
     * Hides unused lines
     */
    Label.prototype.hideUnused = function (index) {
        this.initLineCache();
        var lines = this.getCache("lineInfo");
        if (lines.length >= index) {
            for (var i = index; i < lines.length; i++) {
                var line = lines[i];
                if (line && line.element) {
                    line.element.attr({ "display": "none" });
                }
            }
        }
    };
    Object.defineProperty(Label.prototype, "text", {
        /**
         * @return SVG text
         */
        get: function () {
            return this.getPropertyValue("text");
        },
        /**
         * An SVG text.
         *
         * Please note that setting `html` will override this setting if browser
         * supports `foreignObject` in SGV, such as most modern browsers excluding
         * IEs.
         *
         * @param value  SVG Text
         */
        set: function (value) {
            //this.setPropertyValue("html", undefined);
            this.setPropertyValue("text", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "path", {
        /**
         * @return Path
         */
        get: function () {
            return this.getPropertyValue("path");
        },
        /**
         * An SVG path string to position text along. If set, the text will follow
         * the curvature of the path.
         *
         * Location along the path can be set using `locationOnPath`.
         *
         * IMPORTANT: Only SVG text can be put on path. If you are using HTML text
         * this setting will be ignored.
         *
         * @since 4.1.2
         * @param  value  Path
         */
        set: function (value) {
            if (this.setPropertyValue("path", value, true)) {
                if (this.pathElement) {
                    this.pathElement.dispose();
                }
                if (this.textPathElement) {
                    this.textPathElement.dispose();
                }
                this.pathElement = this.paper.add("path");
                this.pathElement.attr({ "d": value });
                this.pathElement.attr({ "id": "text-path-" + this.uid });
                this._disposers.push(this.pathElement);
                this.textPathElement = this.paper.addGroup("textPath");
                this.textPathElement.attrNS(XLINK, "xlink:href", "#text-path-" + this.uid);
                // TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed
                this.textPathElement.attr({ "path": value });
                this._disposers.push(this.textPathElement);
                this.hardInvalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "locationOnPath", {
        /**
         * @return Relatvie location on path
         */
        get: function () {
            return this.getPropertyValue("locationOnPath");
        },
        /**
         * Relative label location on `path`. Value range is from 0 (beginning)
         * to 1 (end).
         *
         * Works only if you set `path` setting to an SVG path.
         *
         * @since 4.1.2
         * @default 0
         * @param  value  Relatvie location on path
         */
        set: function (value) {
            this.setPropertyValue("locationOnPath", value);
            if (this.textPathElement) {
                this.textPathElement.attr({ "startOffset": (value * 100) + "%" });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "baseLineRatio", {
        /**
         * @return Base line ratio
         */
        get: function () {
            return this.getPropertyValue("baseLineRatio");
        },
        /**
         * A ratio to calculate text baseline. Ralative distance from the bottom of
         * the label.
         *
         * @since 4.4.2
         * @default -0.27
         * @param  value  Base line ratio
         */
        set: function (value) {
            this.setPropertyValue("baseLineRatio", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "wrap", {
        /**
         * @return Auto-wrap enabled or not
         */
        get: function () {
            return this.getPropertyValue("wrap");
        },
        /**
         * Enables or disables autowrapping of text.
         *
         * @param value  Auto-wrapping enabled
         */
        set: function (value) {
            this.resetBBox();
            this.setPropertyValue("wrap", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "truncate", {
        /**
         * @return Truncate text?
         */
        get: function () {
            return this.getPropertyValue("truncate");
        },
        /**
         * Indicates if text lines need to be truncated if they do not fit, using
         * configurable `ellipsis` string.
         *
         * `truncate` overrides `wrap` if both are set to `true`.
         *
         * NOTE: For HTML text, this setting **won't** trigger a parser and actual
         * line truncation with ellipsis. It will just hide everything that goes
         * outside the label.
         *
         * @param value  trincate text?
         */
        set: function (value) {
            this.resetBBox();
            this.setPropertyValue("truncate", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "fullWords", {
        /**
         * @return Truncate on full words?
         */
        get: function () {
            return this.getPropertyValue("fullWords");
        },
        /**
         * If `truncate` is enabled, should Label try to break only on full words
         * (`true`), or whenever needed, including middle of the word. (`false`)
         *
         * @default true
         * @param value  Truncate on full words?
         */
        set: function (value) {
            this.setPropertyValue("fullWords", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "ellipsis", {
        /**
         * @return Ellipsis string
         */
        get: function () {
            return this.getPropertyValue("ellipsis");
        },
        /**
         * Ellipsis character to use if `truncate` is enabled.
         *
         * @param value Ellipsis string
         * @default "..."
         */
        set: function (value) {
            this.setPropertyValue("ellipsis", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "selectable", {
        /**
         * @return Text selectable?
         */
        get: function () {
            return this.getPropertyValue("selectable");
        },
        /**
         * Forces the text to be selectable. This setting will be ignored if the
         * object has some kind of interaction attached to it, such as it is
         * `draggable`, `swipeable`, `resizable`.
         *
         * @param value  Text selectable?
         * @default false
         */
        set: function (value) {
            this.setPropertyValue("selectable", value, true);
            this.setStyles();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "textAlign", {
        /**
         * @return Alignment
         */
        get: function () {
            return this.getPropertyValue("textAlign");
        },
        /**
         * Horizontal text alignment.
         *
         * Available choices:
         * * "start"
         * * "middle"
         * * "end"
         *
         * @param value  Alignment
         */
        set: function (value) {
            this.setPropertyValue("textAlign", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "textValign", {
        /**
         * @ignore Exclude from docs (not used)
         * @return Alignment
         * @deprecated
         */
        get: function () {
            return this.getPropertyValue("textValign");
        },
        /**
         * Vertical text alignment.
         *
         * @ignore Exclude from docs (not used)
         * @param value  Alignment
         * @deprecated
         */
        set: function (value) {
            this.setPropertyValue("textValign", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "html", {
        /**
         * @return HTML content
         */
        get: function () {
            return this.getPropertyValue("html");
        },
        /**
         * Raw HTML to be used as text.
         *
         * NOTE: HTML text is subject to browser support. It relies on browsers
         * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not
         * support it. On those browsers, the text will fall back to basic SVG text,
         * striping out all HTML markup and styling that goes with it.
         *
         * For more information about `foreignObject` and its browser compatibility
         * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).
         *
         * @param value HTML text
         */
        set: function (value) {
            this.setPropertyValue("html", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "hideOversized", {
        /**
         * @return Hide if text does not fit?
         */
        get: function () {
            return this.getPropertyValue("hideOversized");
        },
        /**
         * Indicates whether the whole text should be hidden if it does not fit into
         * its allotted space.
         *
         * @param value  Hide if text does not fit?
         */
        set: function (value) {
            this.setPropertyValue("hideOversized", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "ignoreFormatting", {
        /**
         * @return Ignore formatting?
         */
        get: function () {
            return this.getPropertyValue("ignoreFormatting");
        },
        /**
         * If set to `true` square-bracket formatting blocks will be treated as
         * regular text.
         *
         * @default false
         * @param value  Ignore formatting?
         */
        set: function (value) {
            this.setPropertyValue("ignoreFormatting", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Override `mesaureElement` so it does not get measure again, because
     * internal `_bbox` is being updated by measuring routines in Text itself.
     */
    Label.prototype.measureElement = function () { };
    /**
     * Returns information about a line element.
     *
     * @ignore Exclude from docs
     * @param index  Line index
     * @return Line info object
     */
    Label.prototype.getLineInfo = function (index) {
        this.initLineCache();
        var lines = this.getCache("lineInfo");
        return lines.length > index ? lines[index] : undefined;
    };
    /**
     * Adds a line to line info cache.
     *
     * @ignore Exclude from docs
     * @param line     Line info object
     * @param index    Insert at specified index
     */
    Label.prototype.addLineInfo = function (line, index) {
        this.initLineCache();
        this.getCache("lineInfo")[index] = line;
    };
    /**
     * Checks if line cache is initialized and initializes it.
     */
    Label.prototype.initLineCache = function () {
        if (!hasValue(this.getCache("lineInfo"))) {
            this.setCache("lineInfo", [], 0);
        }
    };
    /**
     * Sets a [[DataItem]] to use for populating dynamic sections of the text.
     *
     * Check the description for [[Text]] class, for data binding.
     *
     * @param dataItem Data item
     */
    Label.prototype.setDataItem = function (dataItem) {
        if (this._sourceDataItemEvents) {
            this._sourceDataItemEvents.dispose();
        }
        if (dataItem) {
            this._sourceDataItemEvents = new Disposer_MultiDisposer([
                dataItem.events.on("valuechanged", this.invalidate, this, false),
                dataItem.events.on("workingvaluechanged", this.invalidate, this, false),
                dataItem.events.on("calculatedvaluechanged", this.invalidate, this, false),
                dataItem.events.on("propertychanged", this.invalidate, this, false)
            ]);
        }
        _super.prototype.setDataItem.call(this, dataItem);
    };
    Object.defineProperty(Label.prototype, "availableWidth", {
        /**
         * Returns available horizontal space.
         *
         * @ignore Exclude from docs
         * @return Available width (px)
         */
        get: function () {
            return hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Label.prototype, "availableHeight", {
        /**
         * Returns available vertical space.
         *
         * @return Available height (px)
         */
        get: function () {
            return hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;
        },
        enumerable: true,
        configurable: true
    });
    // temp, replacing textFormatter method
    Label.prototype.getSvgElement = function (text, style) {
        var element = this.paper.add("tspan");
        element.textContent = text;
        if (style) {
            element.node.setAttribute("style", style);
        }
        return element;
    };
    /**
     * Invalidates the whole element, including layout AND all its child
     * elements.
     */
    Label.prototype.deepInvalidate = function () {
        _super.prototype.deepInvalidate.call(this);
        this.hardInvalidate();
    };
    Object.defineProperty(Label.prototype, "readerTitle", {
        /**
         * @return Title
         */
        get: function () {
            var title = this.getPropertyValue("readerTitle");
            if (!title) {
                title = this.populateString(plainText(isNotEmpty(this.html)
                    ? this.html
                    : this.text));
            }
            return title;
        },
        /**
         * Screen reader title of the element.
         *
         * @param value Title
         */
        set: function (value) {
            value = toText(value);
            if (this.setPropertyValue("readerTitle", value)) {
                this.applyAccessibility();
            }
        },
        enumerable: true,
        configurable: true
    });
    return Label;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Label"] = Label_Label;
/**
 * Add default responsive rules
 */
/**
 * Hide labels added directly to chart, like titles if chart is short.
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.heightXS,
    state: function (target, stateId) {
        if (target instanceof Label_Label && target.parent && target.parent.isBaseSprite) {
            var state = target.states.create(stateId);
            state.properties.disabled = true;
            return state;
        }
        return null;
    }
});
//# sourceMappingURL=Label.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/RoundedRectangle.js
/**
 * Rounded rectangle module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a rectangle with rounded corners.
 *
 * @see {@link IRoundedRectangleEvents} for a list of available events
 * @see {@link IRoundedRectangleAdapters} for a list of available Adapters
 */
var RoundedRectangle_RoundedRectangle = /** @class */ (function (_super) {
    __extends(RoundedRectangle, _super);
    /**
     * Constructor
     */
    function RoundedRectangle() {
        var _this = _super.call(this) || this;
        _this.className = "RoundedRectangle";
        _this.element = _this.paper.add("path");
        _this.cornerRadius(3, 3, 3, 3);
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    RoundedRectangle.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var w = this.innerWidth;
        var h = this.innerHeight;
        if (isNumber(w) && isNumber(h)) {
            var minSide = Math_min(w, h) / 2;
            var cornerRadiusTopLeft = relativeToValue(this.cornerRadiusTopLeft, minSide);
            var cornerRadiusTopRight = relativeToValue(this.cornerRadiusTopRight, minSide);
            var cornerRadiusBottomRight = relativeToValue(this.cornerRadiusBottomRight, minSide);
            var cornerRadiusBottomLeft = relativeToValue(this.cornerRadiusBottomLeft, minSide);
            var maxcr = Math_min(Math.abs(w / 2), Math.abs(h / 2));
            var crtl = fitToRange(cornerRadiusTopLeft, 0, maxcr);
            var crtr = fitToRange(cornerRadiusTopRight, 0, maxcr);
            var crbr = fitToRange(cornerRadiusBottomRight, 0, maxcr);
            var crbl = fitToRange(cornerRadiusBottomLeft, 0, maxcr);
            var lineT = "M" + crtl + ",0 L" + (w - crtr) + ",0";
            var lineB = " L" + crbl + "," + h;
            var lineL = " L0," + crtl;
            var lineR = " L" + w + "," + (h - crbr);
            var arcTR = " a" + crtr + "," + crtr + " 0 0 1 " + crtr + "," + crtr;
            var arcBR = " a" + crbr + "," + crbr + " 0 0 1 -" + crbr + "," + crbr;
            var arcBL = " a" + crbl + "," + crbl + " 0 0 1 -" + crbl + ",-" + crbl;
            var arcTL = " a" + crtl + "," + crtl + " 0 0 1 " + crtl + ",-" + crtl;
            var path = lineT + arcTR + lineR + arcBR + lineB + arcBL + lineL + arcTL + " Z";
            this.path = path;
        }
    };
    /**
     * Sets radius for all four corners at ones.
     *
     * All numbers are in pixels.
     *
     * @param tl  Top-left corner
     * @param tr  Top-right corner
     * @param bl  Bottom-left corner
     * @param br  Bottom-right corner
     */
    RoundedRectangle.prototype.cornerRadius = function (tl, tr, bl, br) {
        this.cornerRadiusTopLeft = tl;
        this.cornerRadiusTopRight = tr;
        this.cornerRadiusBottomLeft = bl;
        this.cornerRadiusBottomRight = br;
    };
    Object.defineProperty(RoundedRectangle.prototype, "cornerRadiusTopLeft", {
        /**
         * @return Radius (px or Percent)
         */
        get: function () {
            return this.getPropertyValue("cornerRadiusTopLeft");
        },
        /**
         * Radius of the top-left corner in pixels.
         *
         * @default 3
         * @param value  Radius (px or Percent)
         */
        set: function (value) {
            this.setPercentProperty("cornerRadiusTopLeft", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RoundedRectangle.prototype, "cornerRadiusTopRight", {
        /**
         * @return Radius (px or Percent)
         */
        get: function () {
            return this.getPropertyValue("cornerRadiusTopRight");
        },
        /**
         * Radius of the top-right corner in pixels.
         *
         * @default 3
         * @param value  Radius (px or Percent)
         */
        set: function (value) {
            this.setPercentProperty("cornerRadiusTopRight", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RoundedRectangle.prototype, "cornerRadiusBottomRight", {
        /**
         * @return Radius (px or Percent)
         */
        get: function () {
            return this.getPropertyValue("cornerRadiusBottomRight");
        },
        /**
         * Radius of the bottom-right corner in pixels.
         *
         * @default 3
         * @param value  Radius (px or Percent)
         */
        set: function (value) {
            this.setPercentProperty("cornerRadiusBottomRight", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RoundedRectangle.prototype, "cornerRadiusBottomLeft", {
        /**
         * @return Radius (px or Percent)
         */
        get: function () {
            return this.getPropertyValue("cornerRadiusBottomLeft");
        },
        /**
         * Radius of the bottom-left corner in pixels.
         *
         * @default 3
         * @param value  Radius (px or Percent)
         */
        set: function (value) {
            this.setPercentProperty("cornerRadiusBottomLeft", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Measures the element.
     *
     * @ignore Exclude from docs
     */
    RoundedRectangle.prototype.measureElement = function () {
    };
    Object.defineProperty(RoundedRectangle.prototype, "bbox", {
        /**
         * Returns bounding box (square) for this element.
         *
         * @ignore Exclude from docs
         */
        get: function () {
            if (this.definedBBox) {
                return this.definedBBox;
            }
            if (this.isMeasured) {
                return {
                    x: 0,
                    y: 0,
                    width: this.innerWidth,
                    height: this.innerHeight
                };
            }
            else {
                return { x: 0, y: 0, width: 0, height: 0 };
            }
        },
        enumerable: true,
        configurable: true
    });
    return RoundedRectangle;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["RoundedRectangle"] = RoundedRectangle_RoundedRectangle;
//# sourceMappingURL=RoundedRectangle.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Button.js
/**
 * Functionality for drawing simple buttons.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Button class is capable of drawing a simple rectangular button with
 * optionally rounded corners and an icon in it.
 *
 * @see {@link IButtonEvents} for a list of available events
 * @see {@link IButtonAdapters} for a list of available Adapters
 */
var Button_Button = /** @class */ (function (_super) {
    __extends(Button, _super);
    /**
     * Constructor
     */
    function Button() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "Button";
        _this.tooltipY = 0;
        // Set defaults
        _this.iconPosition = "left";
        _this.layout = "horizontal";
        _this.contentAlign = "center";
        _this.contentValign = "middle";
        _this.padding(8, 16, 8, 16);
        _this.setStateOnChildren = true;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        // Create background
        var background = _this.background;
        background.fill = interfaceColors.getFor("secondaryButton");
        background.stroke = interfaceColors.getFor("secondaryButtonStroke");
        background.fillOpacity = 1;
        background.strokeOpacity = 1;
        background.cornerRadius(3, 3, 3, 3);
        // Create the label element
        _this.label = new Label_Label();
        _this.label.fill = interfaceColors.getFor("secondaryButtonText");
        ;
        _this.label.shouldClone = false;
        // Create default states
        var hoverState = background.states.create("hover");
        hoverState.properties.fillOpacity = 1;
        hoverState.properties.fill = interfaceColors.getFor("secondaryButtonHover");
        var downState = background.states.create("down");
        downState.transitionDuration = 100;
        downState.properties.fill = interfaceColors.getFor("secondaryButtonDown");
        downState.properties.fillOpacity = 1;
        // Set up accessibility
        // A button should be always focusable
        _this.role = "button";
        _this.focusable = true;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(Button.prototype, "icon", {
        /**
         * @return Icon Sprite
         */
        get: function () {
            return this._icon;
        },
        /**
         * A [[Sprite]] to be used as an icon on button.
         *
         * @param icon Icon Sprite
         */
        set: function (icon) {
            var currentIcon = this._icon;
            if (currentIcon) {
                //this._icon.dispose();
                //this.removeDispose(currentIcon);
                currentIcon.parent = undefined;
            }
            if (icon) {
                this._icon = icon;
                icon.parent = this;
                icon.interactionsEnabled = false;
                icon.shouldClone = false;
                this.iconPosition = this.iconPosition;
                this._disposers.push(icon);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "iconPosition", {
        /**
         * @return Icon position
         */
        get: function () {
            return this.getPropertyValue("iconPosition");
        },
        /**
         * Icon position: "left" or "right".
         *
         * @default "left"
         * @param position  Icon position
         */
        set: function (position) {
            this.setPropertyValue("iconPosition", position);
            if (this.icon) {
                if (position == "left") {
                    this.icon.toBack();
                }
                else {
                    this.icon.toFront();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "label", {
        /**
         * @return Label element
         */
        get: function () {
            return this._label;
        },
        /**
         * [[Label]] element to be used for text.
         *
         * @param label element
         */
        set: function (label) {
            if (this._label) {
                //this._label.dispose();
                this.removeDispose(this._label);
            }
            this._label = label;
            if (label) {
                label.parent = this;
                label.interactionsEnabled = false;
                this._disposers.push(this._label);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a background element for the button.
     *
     * @ignore Exclude from docs
     * @return Background element
     */
    Button.prototype.createBackground = function () {
        return new RoundedRectangle_RoundedRectangle();
    };
    /**
     * Copies properties and other attributes.
     *
     * @param source  Source
     */
    Button.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (source.label) {
            this.label.copyFrom(source.label);
        }
        if (source.icon) {
            this.icon = source.icon.clone();
        }
    };
    return Button;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Button"] = Button_Button;
//# sourceMappingURL=Button.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Circle.js
/**
 * Functionality for drawing circles.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to create a circle
 * @see {@link ICircleEvents} for a list of available events
 * @see {@link ICircleAdapters} for a list of available Adapters
 */
var Circle_Circle = /** @class */ (function (_super) {
    __extends(Circle, _super);
    /**
     * Constructor
     */
    function Circle() {
        var _this = _super.call(this) || this;
        _this.className = "Circle";
        _this.element = _this.paper.add("circle");
        _this.setPercentProperty("radius", Percent_percent(100));
        _this.setPropertyValue("horizontalCenter", "middle");
        _this.setPropertyValue("verticalCenter", "middle");
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the circle.
     */
    Circle.prototype.draw = function () {
        _super.prototype.draw.call(this);
        this.element.attr({ "r": this.pixelRadius });
    };
    Object.defineProperty(Circle.prototype, "radius", {
        /**
         * @return Radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Radius of the circle.
         *
         * Can be either absolute (pixels) or relative ([Percent]).
         *
         * @param value  Radius
         */
        set: function (value) {
            this.setPercentProperty("radius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Circle.prototype, "pixelRadius", {
        /**
         * Radius of the circle in pixels.
         *
         * This is a read-only property. To set radius in pixels, use `radius`
         * property.
         *
         * @readonly
         * @return Radius (px)
         */
        get: function () {
            return relativeToValue(this.radius, Math_min(this.innerWidth / 2, this.innerHeight / 2));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates bounding box.
     *
     * @ignore Exclude from docs
     */
    Circle.prototype.measureElement = function () {
        var pixelRadius = this.pixelRadius;
        this._bbox = {
            x: -pixelRadius,
            y: -pixelRadius,
            width: pixelRadius * 2,
            height: pixelRadius * 2
        };
    };
    return Circle;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Circle"] = Circle_Circle;
//# sourceMappingURL=Circle.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Ellipse.js
/**
 * Ellipse module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws an ellipse
 * @see {@link IEllipseEvents} for a list of available events
 * @see {@link IEllipseAdapters} for a list of available Adapters
 */
var Ellipse_Ellipse = /** @class */ (function (_super) {
    __extends(Ellipse, _super);
    /**
     * Constructor
     */
    function Ellipse() {
        var _this = _super.call(this) || this;
        _this.className = "Ellipse";
        _this.element = _this.paper.add("ellipse");
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the ellipsis.
     */
    Ellipse.prototype.draw = function () {
        _super.prototype.draw.call(this);
        this.element.attr({ "rx": this.radius });
        this.element.attr({ "ry": this.radiusY });
    };
    Object.defineProperty(Ellipse.prototype, "radiusY", {
        /**
         * @return Vertical radius
         */
        get: function () {
            return this.innerHeight / 2;
        },
        /**
         * Vertical radius.
         *
         * It's a relative size to the `radius`.
         *
         * E.g. 0.8 will mean the height of the ellipsis will be 80% of it's
         * horizontal radius.
         *
         * @param value  Vertical radius
         */
        set: function (value) {
            this.height = value * 2;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Ellipse.prototype, "radius", {
        /**
         * @return Horizontal radius
         */
        get: function () {
            return this.innerWidth / 2;
        },
        /**
         * Horizontal radius.
         *
         * @param value  Horizontal radius
         */
        set: function (value) {
            this.width = value * 2;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    return Ellipse;
}(Circle_Circle));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Ellipse"] = Ellipse_Ellipse;
//# sourceMappingURL=Ellipse.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Image.js
/**
 * Functionality for adding images in SVG tree.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to add `<image>` elements to SVG.
 *
 * @see {@link IImageEvents} for a list of available events
 * @see {@link IImageAdapters} for a list of available Adapters
 */
var Image_Image = /** @class */ (function (_super) {
    __extends(Image, _super);
    /**
     * Constructor
     */
    function Image() {
        var _this = _super.call(this) || this;
        _this.className = "Image";
        _this.element = _this.paper.add("image");
        _this.applyTheme();
        _this.width = 50;
        _this.height = 50;
        return _this;
    }
    /**
     * Draws an `<image>` element.
     *
     * @ignore Exclude from docs
     */
    Image.prototype.draw = function () {
        _super.prototype.draw.call(this);
        if (this.href) {
            var width = this.innerWidth;
            var height = this.innerHeight;
            if (isNumber(this.widthRatio)) {
                width = height * this.widthRatio;
                this.width = width;
            }
            if (isNumber(this.heightRatio)) {
                height = width * this.heightRatio;
                this.height = height;
            }
            this.element.attr({
                "width": width,
                "height": height
            });
            this.element.attrNS(XLINK, "xlink:href", this.href);
        }
    };
    Object.defineProperty(Image.prototype, "href", {
        /**
         * @return Image URI
         */
        get: function () {
            return this.getPropertyValue("href");
        },
        /**
         * An image URI.
         *
         * @param value  Image URI
         */
        set: function (value) {
            this.setPropertyValue("href", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "widthRatio", {
        /**
         * @return Ratio
         */
        get: function () {
            return this.getPropertyValue("widthRatio");
        },
        /**
         * Sets image `width` relatively to its `height`.
         *
         * If image's `height = 100` and `widthRatio = 0.5` the actual width will be
         * `50`.
         *
         * @param value  Ratio
         */
        set: function (value) {
            this.setPropertyValue("widthRatio", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "heightRatio", {
        /**
         * @return Ratio
         */
        get: function () {
            return this.getPropertyValue("heightRatio");
        },
        /**
         * Sets image `height` relatively to its `width`.
         *
         * If image's `width = 100` and `heightRatio = 0.5` the actual height will be
         * `50`.
         *
         * @param value  Ratio
         */
        set: function (value) {
            this.setPropertyValue("heightRatio", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "bbox", {
        /**
         * Returns bounding box (square) for this element.
         *
         * @ignore Exclude from docs
         */
        get: function () {
            return {
                x: 0,
                y: 0,
                width: this.pixelWidth,
                height: this.pixelHeight
            };
        },
        enumerable: true,
        configurable: true
    });
    return Image;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Image"] = Image_Image;
//# sourceMappingURL=Image.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Line.js
/**
 * Line drawing functionality.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a line.
 *
 * @see {@link ILineEvents} for a list of available events
 * @see {@link ILineAdapters} for a list of available Adapters
 */
var Line_Line = /** @class */ (function (_super) {
    __extends(Line, _super);
    /**
     * Constructor
     */
    function Line() {
        var _this = _super.call(this) || this;
        _this.className = "Line";
        _this.element = _this.paper.add("line");
        _this.fill = Color_color(); //"none";
        _this.x1 = 0;
        _this.y1 = 0;
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the line.
     *
     * @ignore Exclude from docs
     */
    Line.prototype.draw = function () {
        _super.prototype.draw.call(this);
        if (this.x1 == this.x2 || this.y1 == this.y2) {
            this.pixelPerfect = true;
        }
        else {
            this.pixelPerfect = false;
        }
        this.x1 = this.x1;
        this.x2 = this.x2;
        this.y1 = this.y1;
        this.y2 = this.y2;
    };
    Object.defineProperty(Line.prototype, "x1", {
        /**
         * @return X
         */
        get: function () {
            return this.getPropertyValue("x1");
        },
        /**
         * X coordinate of first end.
         *
         * @param value X
         */
        set: function (value) {
            if (!isNumber(value)) {
                value = 0;
            }
            var delta = 0;
            if (this.pixelPerfect && this.stroke instanceof LinearGradient_LinearGradient) {
                delta = 0.00001;
            }
            this.setPropertyValue("x1", value, true);
            this.element.attr({ "x1": value + delta });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Line.prototype, "x2", {
        /**
         * @return X
         */
        get: function () {
            var value = this.getPropertyValue("x2");
            if (!isNumber(value)) {
                value = this.pixelWidth;
            }
            return value;
        },
        /**
         * X coordinate of second end.
         *
         * @param value X
         */
        set: function (value) {
            if (!isNumber(value)) {
                value = 0;
            }
            this.setPropertyValue("x2", value, true);
            this.element.attr({ "x2": value });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Line.prototype, "y1", {
        /**
         * @return Y
         */
        get: function () {
            return this.getPropertyValue("y1");
        },
        /**
         * Y coordinate of first end.
         *
         * @param value Y
         */
        set: function (value) {
            if (!isNumber(value)) {
                value = 0;
            }
            var delta = 0;
            if (this.pixelPerfect && this.stroke instanceof LinearGradient_LinearGradient) {
                delta = 0.00001;
            }
            this.setPropertyValue("y1", value, true);
            this.element.attr({ "y1": value + delta });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Line.prototype, "y2", {
        /**
         * @return Y
         */
        get: function () {
            var value = this.getPropertyValue("y2");
            if (!isNumber(value)) {
                value = this.pixelHeight;
            }
            return value;
        },
        /**
         * Y coordinate of second end.
         *
         * @param value Y
         */
        set: function (value) {
            if (!isNumber(value)) {
                value = 0;
            }
            this.setPropertyValue("y2", value, true);
            this.element.attr({ "y2": value });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts relative position along the line (0-1) into pixel coordinates.
     *
     * @param position  Position (0-1)
     * @return Coordinates
     */
    Line.prototype.positionToPoint = function (position) {
        var point1 = { x: this.x1, y: this.y1 };
        var point2 = { x: this.x2, y: this.y2 };
        var point = getMidPoint(point1, point2, position);
        var angle = getAngle(point1, point2);
        return { x: point.x, y: point.y, angle: angle };
    };
    return Line;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Line"] = Line_Line;
//# sourceMappingURL=Line.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/PointedShape.js
/**
 * Pointed shape module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a shape with a pointer.
 *
 * @see {@link IPointedShapeEvents} for a list of available events
 * @see {@link IPointedShapeAdapters} for a list of available Adapters
 */
var PointedShape_PointedShape = /** @class */ (function (_super) {
    __extends(PointedShape, _super);
    /**
     * Constructor
     */
    function PointedShape() {
        var _this = _super.call(this) || this;
        _this.className = "PointedShape";
        _this.pointerBaseWidth = 15;
        _this.pointerLength = 10;
        _this.pointerY = 0;
        _this.pointerX = 0;
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    PointedShape.prototype.draw = function () {
        _super.prototype.draw.call(this);
        if (!isNumber(this.pointerX)) {
            this.pointerX = this.pixelWidth / 2;
        }
        if (!isNumber(this.pointerY)) {
            this.pointerY = this.pixelHeight + 10;
        }
    };
    Object.defineProperty(PointedShape.prototype, "pointerBaseWidth", {
        /**
         * @return Width (px)
         */
        get: function () {
            return this.getPropertyValue("pointerBaseWidth");
        },
        /**
         * A width of the pinter's (stem's) thick end (base) in pixels.
         *
         * @default 15
         * @param value  Width (px)
         */
        set: function (value) {
            this.setPropertyValue("pointerBaseWidth", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PointedShape.prototype, "pointerLength", {
        /**
         * @return Length (px)
         */
        get: function () {
            return this.getPropertyValue("pointerLength");
        },
        /**
         * A length of the pinter (stem) in pixels.
         *
         * @default 10
         * @param value  Length (px)
         */
        set: function (value) {
            this.setPropertyValue("pointerLength", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PointedShape.prototype, "pointerX", {
        /**
         * @return X
         */
        get: function () {
            return this.getPropertyValue("pointerX");
        },
        /**
         * X coordinate the shape is pointing to.
         *
         * @param value  X
         */
        set: function (value) {
            this.setPropertyValue("pointerX", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PointedShape.prototype, "pointerY", {
        /**
         * @return Y
         */
        get: function () {
            return this.getPropertyValue("pointerY");
        },
        /**
         * Y coordinate the shape is pointing to.
         *
         * @param value  Y
         */
        set: function (value) {
            this.setPropertyValue("pointerY", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return PointedShape;
}(Sprite_Sprite));

//# sourceMappingURL=PointedShape.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/PointedRectangle.js
/**
 * Pointed rectangle module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a rectangle with a pointer.
 *
 * @see {@link IPointedRectangleEvents} for a list of available events
 * @see {@link IPointedRectangleAdapters} for a list of available Adapters
 */
var PointedRectangle_PointedRectangle = /** @class */ (function (_super) {
    __extends(PointedRectangle, _super);
    /**
     * Constructor
     */
    function PointedRectangle() {
        var _this = _super.call(this) || this;
        _this.className = "PointedRectangle";
        _this.element = _this.paper.add("path");
        _this.cornerRadius = 6;
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    PointedRectangle.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var cr = this.cornerRadius;
        var w = this.innerWidth;
        var h = this.innerHeight;
        if (w > 0 && h > 0) {
            var x = this.pointerX;
            var y = this.pointerY;
            var bwh = this.pointerBaseWidth / 2;
            var maxcr = Math_min(w / 2, h / 2);
            var crtl = fitToRange(cr, 0, maxcr);
            var crtr = fitToRange(cr, 0, maxcr);
            var crbr = fitToRange(cr, 0, maxcr);
            var crbl = fitToRange(cr, 0, maxcr);
            // corner coordinates
            // top left
            var xtl = 0;
            var ytl = 0;
            // top right
            var xtr = w;
            var ytr = 0;
            // bottom right
            var xbr = w;
            var ybr = h;
            // bottom left
            var xbl = 0;
            var ybl = h;
            var lineT = void 0;
            var lineR = void 0;
            var lineB = void 0;
            var lineL = void 0;
            // find stem base side: http://$math.stackexchange.com/questions/274712/calculate-on-which-side-of-straign-line-is-dot-located
            // d=(x−x1)(y2−y1)−(y−y1)(x2−x1)
            var d1 = (x - xtl) * (ybr - ytl) - (y - ytl) * (xbr - xtl);
            var d2 = (x - xbl) * (ytr - ybl) - (y - ybl) * (xtr - xbl);
            // top
            if (d1 > 0 && d2 > 0) {
                var stemX = fitToRange(x, crtl + bwh, w - bwh - crtr);
                y = fitToRange(y, -Infinity, 0);
                lineT = "M" + crtl + ",0 L" + (stemX - bwh) + ",0 L" + x + "," + y + " L" + (stemX + bwh) + ",0 L" + (w - crtr) + ",0";
            }
            else {
                lineT = "M" + crtl + ",0 L" + (w - crtr) + ",0";
            }
            // bottom
            if (d1 < 0 && d2 < 0) {
                var stemX = fitToRange(x, crbl + bwh, w - bwh - crbr);
                y = fitToRange(y, h, Infinity);
                lineB = " L" + (w - crbr) + "," + h + " L" + (stemX + bwh) + "," + h + " L" + x + "," + y + " L" + (stemX - bwh) + "," + h + " L" + crbl + "," + h;
            }
            else {
                lineB = " L" + crbl + "," + h;
            }
            // left
            if (d1 < 0 && d2 > 0) {
                var stemY = fitToRange(y, crtl + bwh, h - crbl - bwh);
                x = fitToRange(x, -Infinity, 0);
                lineL = " L0," + (h - crbl) + " L0," + (stemY + bwh) + " L" + x + "," + y + " L0," + (stemY - bwh) + " L0," + crtl;
            }
            else {
                lineL = " L0," + crtl;
            }
            // right
            if (d1 > 0 && d2 < 0) {
                var stemY = fitToRange(y, crtr + bwh, h - bwh - crbr);
                x = fitToRange(x, w, Infinity);
                lineR = " L" + w + "," + crtr + " L" + w + "," + (stemY - bwh) + " L" + x + "," + y + " L" + w + "," + (stemY + bwh) + " L" + w + "," + (h - crbr);
            }
            else {
                lineR = " L" + w + "," + (h - crbr);
            }
            var arcTR = " a" + crtr + "," + crtr + " 0 0 1 " + crtr + "," + crtr;
            var arcBR = " a" + crbr + "," + crbr + " 0 0 1 -" + crbr + "," + crbr;
            var arcBL = " a" + crbl + "," + crbl + " 0 0 1 -" + crbl + ",-" + crbl;
            var arcTL = " a" + crtl + "," + crtl + " 0 0 1 " + crtl + ",-" + crtl;
            this.path = lineT + arcTR + lineR + arcBR + lineB + arcBL + lineL + arcTL;
        }
    };
    Object.defineProperty(PointedRectangle.prototype, "cornerRadius", {
        /**
         * @return Corner radius (px)
         */
        get: function () {
            return this.getPropertyValue("cornerRadius");
        },
        /**
         * Radius of rectangle's border in pixels.
         *
         * @default 0
         * @param value  Corner radius (px)
         */
        set: function (value) {
            this.setPropertyValue("cornerRadius", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return PointedRectangle;
}(PointedShape_PointedShape));

//# sourceMappingURL=PointedRectangle.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/Path.js
/**
 * A collection of functions that deals with path calculations.
 */




/**
 * ============================================================================
 * PATH FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Returns an SVG path from a number of points.
 *
 * @ignore Exclude from docs
 * @param points  An array of line elbow points
 * @return SVG path
 */
function polyline(points) {
    var path = lineTo(points[0]);
    var prevPoint = { x: 0, y: 0 };
    var minStep = Options_options.minPolylineStep;
    if (!isNumber(minStep)) {
        minStep = 0.5;
    }
    for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (getDistance(point, prevPoint) > minStep) {
            path += lineTo(point);
            prevPoint = point;
        }
    }
    return path;
}
/**
 * Returns a starting point of an SVG path.
 *
 * @ignore Exclude from docs
 * @param point  Starting point
 * @return SVG path
 */
function moveTo(point) {
    return " M" + Math_round(point.x, 4) + "," + Math_round(point.y, 4) + " ";
}
/**
 * Returns a line part of SVG path.
 *
 * @ignore Exclude from docs
 * @param point  SVG path
 * @return SVG path
 */
function lineTo(point) {
    return " L" + Math_round(point.x, 4) + "," + Math_round(point.y, 4) + " ";
}
/**
 * Returns a quadratic curve part of an SVG path.
 *
 * @ignore Exclude from docs
 * @param point         End point of the curve
 * @param controlPoint  Control point
 * @return SVG path
 */
function quadraticCurveTo(point, controlPoint) {
    return " Q" + Math_round(controlPoint.x, 4)
        + "," + Math_round(controlPoint.y, 4) + " " + Math_round(point.x, 4)
        + "," + Math_round(point.y, 4);
}
/**
 * Returns a cubic curve part of an SVG path.
 *
 * @ignore Exclude from docs
 * @param point          End point of the curve
 * @param controlPointA  Control point A
 * @param controlPointB  Control point B
 * @return SVG path
 */
function cubicCurveTo(point, controlPointA, controlPointB) {
    return " C" + Math_round(controlPointA.x, 4)
        + "," + Math_round(controlPointA.y, 4) + " " + Math_round(controlPointB.x, 4)
        + "," + Math_round(controlPointB.y, 4) + " " + Math_round(point.x, 4)
        + "," + Math_round(point.y, 4);
}
/**
 * Returns a terminator for an SVG path.
 *
 * @ignore Exclude from docs
 * @return SVG path
 */
function closePath() {
    return " Z";
}
/**
 * Returns an arc part of an SVG path.
 *
 * @ignore Exclude from docs
 * @todo Better parameter descriptions
 * @param startAngle  Starting angle
 * @param arc         Arc
 * @param radius      Radius
 * @param radiusY     Vertical radius
 * @return SVG path
 */
function arcTo(startAngle, arc, radius, radiusY) {
    if (arc == 0) {
        return "";
    }
    if (!isNumber(radiusY)) {
        radiusY = radius;
    }
    var path = "";
    var c = ",";
    var segments = Math.ceil(Math.abs(arc) / 180);
    var l = 1;
    if (arc < 0) {
        l = 0;
    }
    // previous, as we use a not A
    var pax = 0;
    var pay = 0;
    // center
    var cx = -Math_cos(startAngle) * radius;
    var cy = -Math_sin(startAngle) * radiusY;
    // foir very short angles and big radius, solves artefacts
    if (arc < 0.5 && radius > 3000) {
        var endAngle = startAngle + arc;
        var ax = Math_round(Math_cos(endAngle) * radius, 4);
        var ay = Math_round(Math_sin(endAngle) * radiusY, 4);
        return lineTo({ x: ax, y: ay });
    }
    for (var i = 0; i < segments; i++) {
        var endAngle = startAngle + arc / segments * (i + 1);
        var ax = Math_round(Math_cos(endAngle) * radius + cx - pax, 4);
        var ay = Math_round(Math_sin(endAngle) * radiusY + cy - pay, 4);
        path += " a" + radius + c + radiusY + c + 0 + c + 0 + c + l + c + ax + c + ay;
        pax = ax;
        pay = ay;
    }
    return path;
}
/**
 * Creates an arc path.
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param startAngle         [description]
 * @param arc                [description]
 * @param radius             [description]
 * @param innerRadius        [description]
 * @param radiusY            [description]
 * @param cornerRadius       [description]
 * @param innerCornerRadius  [description]
 * @return SVG path
 */
function Path_arc(startAngle, arc, radius, innerRadius, radiusY, cornerRadius, innerCornerRadius) {
    if (arc == 0) {
        return "";
    }
    if (!isNumber(innerRadius)) {
        innerRadius = 0;
    }
    if (radius == 0 && innerRadius <= 0) {
        return "";
    }
    if (radius < innerRadius) {
        var temp = radius;
        radius = innerRadius;
        innerRadius = temp;
        if (isNumber(radiusY)) {
            radiusY = radiusY / innerRadius * radius;
        }
    }
    arc = Math_min(arc, 360);
    if (arc == 360) {
        cornerRadius = 0;
        innerCornerRadius = 0;
    }
    var endAngle = startAngle + arc;
    var crSin = Math_sin(Math_min(arc, 45) / 2);
    radiusY = isNumber(radiusY) ? radiusY : radius;
    cornerRadius = cornerRadius || 0;
    innerCornerRadius = isNumber(innerCornerRadius) ? innerCornerRadius : cornerRadius;
    var innerRadiusY = (radiusY / radius) * innerRadius;
    var cornerRadiusY = (radiusY / radius) * cornerRadius;
    var innerCornerRadiusY = (radiusY / radius) * innerCornerRadius;
    cornerRadius = fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);
    cornerRadiusY = fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);
    innerCornerRadius = fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);
    innerCornerRadiusY = fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);
    cornerRadius = Math_round(fitToRange(cornerRadius, 0, radius * crSin), 4);
    cornerRadiusY = Math_round(fitToRange(cornerRadiusY, 0, radiusY * crSin), 4);
    innerCornerRadius = Math_round(fitToRange(innerCornerRadius, 0, innerRadius * crSin), 4);
    innerCornerRadiusY = Math_round(fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin), 4);
    var crAngle = Math.asin(cornerRadius / radius / 2) * DEGREES * 2;
    var crAngleY = Math.asin(cornerRadiusY / radiusY / 2) * DEGREES * 2;
    if (innerRadius < innerCornerRadius) {
        innerRadius = innerCornerRadius;
    }
    if (innerRadiusY < innerCornerRadiusY) {
        innerRadiusY = innerCornerRadiusY;
    }
    var crInnerAngle = Math.asin(innerCornerRadius / innerRadius / 2) * DEGREES * 2;
    var crInnerAngleY = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * DEGREES * 2;
    if (!isNumber(crInnerAngle)) {
        crInnerAngle = 0;
    }
    if (!isNumber(crInnerAngleY)) {
        crInnerAngleY = 0;
    }
    var middleAngle = startAngle + arc / 2;
    var mPoint = { x: Math_round(Math_cos(middleAngle) * innerRadius, 4), y: Math_sin(middleAngle) * innerRadiusY };
    var a0 = { x: Math_cos(startAngle) * (innerRadius + innerCornerRadius), y: Math_sin(startAngle) * (innerRadiusY + innerCornerRadiusY) };
    var b0 = { x: Math_cos(startAngle) * (radius - cornerRadius), y: Math_sin(startAngle) * (radiusY - cornerRadiusY) };
    var c0 = { x: Math_cos(endAngle) * (radius - cornerRadius), y: Math_sin(endAngle) * (radiusY - cornerRadiusY) };
    var d0 = { x: Math_cos(endAngle) * (innerRadius + innerCornerRadius), y: Math_sin(endAngle) * (innerRadiusY + innerCornerRadiusY) };
    var b1 = { x: Math_cos(startAngle + crAngle) * radius, y: Math_sin(startAngle + crAngleY) * radiusY };
    var d1 = { x: Math_cos(endAngle - crInnerAngle) * innerRadius, y: Math_sin(endAngle - crInnerAngleY) * innerRadiusY };
    // some magic math
    innerCornerRadius += innerCornerRadius * Math_sin(crInnerAngle / 2);
    innerCornerRadiusY += innerCornerRadiusY * Math_sin(crInnerAngleY / 2);
    if (crInnerAngle > (endAngle - startAngle) / 2) {
        d1 = mPoint;
    }
    var path = "";
    // start from b if this is full circle
    if (arc == 360) {
        path = moveTo(b0);
    }
    // otherwise start from a
    else {
        path = moveTo(a0);
        path += lineTo(b0);
        path += arcToPoint(b1, cornerRadius, cornerRadiusY, true);
    }
    // draw arc
    path += arcTo(startAngle + crAngle, arc - 2 * crAngle, radius, radiusY);
    // draw inner arc
    if (isNumber(innerRadius) && innerRadius != 0) {
        // move to B if this is full circle
        if (arc == 360 && cornerRadius == 0) {
            path += moveTo(d0);
        }
        // draw line otherwise
        else {
            path += arcToPoint(c0, cornerRadius, cornerRadiusY, true);
            path += lineTo(d0);
            path += arcToPoint(d1, innerCornerRadius, innerCornerRadiusY, true);
        }
        path += arcTo(endAngle - crInnerAngle, -(arc - 2 * crInnerAngle), innerRadius, innerRadiusY);
        if (arc < 360 || cornerRadius > 0) {
            path += arcToPoint(a0, innerCornerRadius, innerCornerRadiusY, true);
        }
        path += lineTo(a0);
    }
    else {
        path += arcToPoint(c0, cornerRadius, cornerRadiusY, true);
        if (arc < 360) {
            path += lineTo(a0);
        }
    }
    return path;
}
/**
 * Creates a path for an arc to specific coordinate.
 *
 * @ignore Exclude from docs
 * @todo Description
 * @param point         Reference point
 * @param radius        Radius
 * @param radiusY       Vertical radius (for skewed arcs)
 * @param sweepFlag     [description]
 * @param largeArcFlag  [description]
 * @param xAxisRotation [description]
 * @return Arc path
 */
function arcToPoint(point, radius, radiusY, sweepFlag, largeArcFlag, xAxisRotation) {
    if (radius == 0) {
        return "";
    }
    xAxisRotation = xAxisRotation || 0;
    largeArcFlag = Boolean(largeArcFlag);
    sweepFlag = Boolean(sweepFlag);
    var c = ",";
    var sweepFlagValue = +sweepFlag; // converts to 1 or 0
    var largeArcFlagValue = +largeArcFlag; // converts to 1 or 0
    return " A" + radius + c + radiusY + c + xAxisRotation + c + largeArcFlagValue + c + sweepFlagValue + c + Math_round(point.x, 4) + c + Math_round(point.y, 4);
}
/**
 * Creates a new rectangle.
 *
 * @ignore Exclude from docs
 * @param width   Width (px)
 * @param height  Height (px)
 * @param x       X position
 * @param y       Y position
 * @return Rectangle
 */
function Path_rectangle(width, height, x, y) {
    if (!isNumber(x)) {
        x = 0;
    }
    if (!isNumber(y)) {
        y = 0;
    }
    return moveTo({ x: x, y: y }) + lineTo({ x: x + width, y: y }) + lineTo({ x: x + width, y: y + height }) + lineTo({ x: x, y: y + height }) + closePath();
}
/**
 * Converts a rectangle to an SVG path.
 *
 * @ignore Exclude from docs
 * @param rect  Rectangle
 * @param ccw   Counter-clockwise?
 * @return SVG path
 */
function rectToPath(rect, ccw) {
    var c = ",";
    var L = " L";
    if (ccw) {
        return "M" + rect.x
            + c + rect.y + L + rect.x
            + c + (rect.y + rect.height) + L + (rect.x + rect.width)
            + c + (rect.y + rect.height) + L + (rect.x + rect.width)
            + c + rect.y + L + rect.x
            + c + rect.y;
    }
    else {
        return "M" + rect.x
            + c + rect.y + L + (rect.x + rect.width)
            + c + rect.y + L + (rect.x + rect.width)
            + c + (rect.y + rect.height) + L + rect.x
            + c + (rect.y + rect.height) + L + rect.x
            + c + rect.y;
    }
}
/**
 * Converts SVG path to array of points.
 *
 * Note, this is experimental feature based on method which is deprecated
 * on some browsers and some browsers do not support it at all.
 *
 * You can save the output of this function, but not rely on it completely.
 */
function pathToPoints(path, pointCount) {
    var paper = getGhostPaper();
    var svgPath = paper.add("path").node;
    svgPath.setAttribute("d", path);
    if (svgPath.getPointAtLength && svgPath.getTotalLength) {
        var length_1 = svgPath.getTotalLength();
        var toPoints = [];
        for (var i = 0; i < pointCount; i++) {
            var point = svgPath.getPointAtLength(i / pointCount * length_1);
            toPoints.push({ x: point.x, y: point.y });
        }
        return toPoints;
    }
    svgPath.remove();
}
function spiralPoints(cx, cy, radius, radiusY, innerRadius, step, radiusStep, startAngle, endAngle) {
    if (!isNumber(startAngle)) {
        startAngle = 0;
    }
    if (!isNumber(startAngle)) {
        endAngle = startAngle;
    }
    var r = innerRadius + 0.01;
    var angle = startAngle * RADIANS;
    var points = [];
    while (r < radius + radiusStep) {
        var stepSize = step;
        if (stepSize / 2 > r) {
            stepSize = 2 * r;
        }
        angle += 2 * Math.asin(stepSize / 2 / r);
        if (angle * DEGREES > endAngle + ((radius - innerRadius) / radiusStep) * 360) {
            break;
        }
        var degrees = angle * DEGREES;
        var point = { x: cx + r * Math.cos(angle), y: cy + r * radiusY / radius * Math.sin(angle) };
        points.push(point);
        r = innerRadius + degrees / 360 * radiusStep;
    }
    points.shift();
    return points;
}
function pointsToPath(points) {
    if (!points || points.length == 0) {
        return "";
    }
    var path = moveTo(points[0]);
    if (points && points.length > 0) {
        for (var i = 1; i < points.length; i++) {
            path += lineTo(points[i]);
        }
    }
    return path;
}
//# sourceMappingURL=Path.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Polyline.js
/**
 * Polyline module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a polyline.
 *
 * @see {@link IPolylineEvents} for a list of available events
 * @see {@link IPolylineAdapters} for a list of available Adapters
 */
var Polyline_Polyline = /** @class */ (function (_super) {
    __extends(Polyline, _super);
    /**
     * Constructor
     */
    function Polyline() {
        var _this = _super.call(this) || this;
        /**
         * [_distance description]
         *
         * @todo Description
         */
        _this._distance = 0;
        _this.className = "Polyline";
        _this.element = _this.paper.add("path");
        _this.shapeRendering = "auto";
        _this.fill = Color_color();
        _this.strokeOpacity = 1;
        _this.applyTheme();
        return _this;
    }
    /**
     * Creats and adds an SVG path for the arc.
     *
     * @ignore Exclude from docs
     */
    Polyline.prototype.makePath = function () {
        this._distance = 0;
        var segments = this.segments;
        if (segments && segments.length > 0) {
            var path = "";
            for (var i = 0, len = segments.length; i < len; i++) {
                var points = segments[i];
                if (points.length > 0) {
                    path += moveTo(points[0]);
                    for (var p = 1; p < points.length; p++) {
                        var point = points[p];
                        path += lineTo(point);
                        this._distance += getDistance(points[p - 1], point);
                    }
                }
            }
            this.path = path;
        }
        this._realSegments = segments;
    };
    Object.defineProperty(Polyline.prototype, "segments", {
        /**
         * @return Segments
         */
        get: function () {
            return this.getPropertyValue("segments");
        },
        /**
         * A list of segment coordinates for the multi-part line.
         *
         * @todo Example
         * @param segments  Segments
         */
        set: function (segments) {
            this.setPropertyValue("segments", segments);
            this.makePath();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Polyline.prototype, "distance", {
        /**
         * [distance description]
         *
         * @todo Description
         * @return [description]
         */
        get: function () {
            return this._distance;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts relative position along the line (0-1) into pixel coordinates.
     *
     * @param position  Position (0-1)
     * @return Coordinates
     */
    Polyline.prototype.positionToPoint = function (position) {
        var deltaAngle = 0;
        if (position < 0) {
            position = Math.abs(position);
            deltaAngle = 180;
        }
        var segments = this._realSegments;
        if (segments) {
            var totalDistance = this.distance;
            var currentDistance = 0;
            var distanceAB = void 0;
            var positionA = 0;
            var positionB = 0;
            var pointA = void 0;
            var pointB = void 0;
            for (var s = 0; s < segments.length; s++) {
                var points = segments[s];
                if (points.length > 1) {
                    for (var p = 1; p < points.length; p++) {
                        pointA = points[p - 1];
                        pointB = points[p];
                        positionA = currentDistance / totalDistance;
                        distanceAB = getDistance(pointA, pointB);
                        currentDistance += distanceAB;
                        positionB = currentDistance / totalDistance;
                        if (positionA <= position && positionB > position) {
                            s = segments.length;
                            break;
                        }
                    }
                }
                else if (points.length == 1) {
                    pointA = points[0];
                    pointB = points[0];
                    positionA = 0;
                    positionB = 1;
                }
            }
            if (pointA && pointB) {
                var positionAB = (position - positionA) / (positionB - positionA);
                var midPoint = getMidPoint(pointA, pointB, positionAB);
                return { x: midPoint.x, y: midPoint.y, angle: deltaAngle + getAngle(pointA, pointB) };
            }
        }
        return { x: 0, y: 0, angle: 0 };
    };
    Object.defineProperty(Polyline.prototype, "realSegments", {
        /**
         * @ignore
         */
        get: function () {
            return this._realSegments;
        },
        enumerable: true,
        configurable: true
    });
    return Polyline;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Polyline"] = Polyline_Polyline;
//# sourceMappingURL=Polyline.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Polyarc.js
/**
 * Module for a multi-part arched line.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a multi-part arched line.
 *
 * @see {@link IPolyarcEvents} for a list of available events
 * @see {@link IPolyarcAdapters} for a list of available Adapters
 */
var Polyarc_Polyarc = /** @class */ (function (_super) {
    __extends(Polyarc, _super);
    /**
     * Constructor
     */
    function Polyarc() {
        var _this = _super.call(this) || this;
        _this.className = "Polyarc";
        _this.controlPointDistance = 0.5;
        _this.controlPointPosition = 0.5;
        _this.applyTheme();
        return _this;
    }
    /**
     * Creats and adds an SVG path for the arc.
     *
     * @ignore Exclude from docs
     */
    Polyarc.prototype.makePath = function () {
        this._distance = 0;
        var segments = this.segments;
        if (segments && segments.length > 0) {
            var path = "";
            this._realSegments = [];
            for (var i = 0, len = segments.length; i < len; i++) {
                var points = segments[i];
                var realPoints = [];
                this._realSegments.push(realPoints);
                if (points.length > 0) {
                    path += moveTo(points[0]);
                    for (var p = 1; p < points.length; p++) {
                        var pointA = points[p - 1];
                        var pointB = points[p];
                        var distanceAB = getDistance(pointB, pointA);
                        var cpDistance = distanceAB * this.controlPointDistance;
                        var controlPointPosition = this.controlPointPosition;
                        var angle = -getAngle(pointA, pointB);
                        var cpx = pointA.x + (pointB.x - pointA.x) * controlPointPosition * 0.5 - cpDistance * Math_sin(angle);
                        var cpy = pointA.y + (pointB.y - pointA.y) * controlPointPosition * 0.5 - cpDistance * Math_cos(angle);
                        var controlPoint1 = { x: cpx, y: cpy };
                        var cpx2 = pointA.x + (pointB.x - pointA.x) * controlPointPosition * 1.5 - cpDistance * Math_sin(angle);
                        var cpy2 = pointA.y + (pointB.y - pointA.y) * controlPointPosition * 1.5 - cpDistance * Math_cos(angle);
                        var controlPoint2 = { x: cpx2, y: cpy2 };
                        path += cubicCurveTo(pointB, controlPoint1, controlPoint2);
                        // we add a lot of points in order to get the position/angle later
                        var stepCount = Math.ceil(distanceAB);
                        var prevPoint = pointA;
                        if (stepCount > 0) {
                            for (var i_1 = 0; i_1 <= stepCount; i_1++) {
                                var point = getPointOnCubicCurve(pointA, pointB, controlPoint1, controlPoint2, i_1 / stepCount);
                                realPoints.push(point);
                                this._distance += getDistance(prevPoint, point);
                                prevPoint = point;
                            }
                        }
                        else {
                            realPoints.push(pointA);
                        }
                    }
                }
            }
            this.path = path;
        }
    };
    Object.defineProperty(Polyarc.prototype, "controlPointPosition", {
        /**
         * @return Position (0-1)
         */
        get: function () {
            return this.getPropertyValue("controlPointPosition");
        },
        /**
         * Relative position along the line the control point is. (0-1)
         *
         * @default 0.5
         * @param value  Position (0-1)
         */
        set: function (value) {
            this.setPropertyValue("controlPointPosition", value);
            this.makePath();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Polyarc.prototype, "controlPointDistance", {
        /**
         * @return Distance (0-1)
         */
        get: function () {
            return this.getPropertyValue("controlPointDistance");
        },
        /**
         * Relative distance of the control point. (0-1)
         *
         * Default is half the length of the line. (0.5)
         *
         * @default 0.5
         * @param value  Distance (0-1)
         */
        set: function (value) {
            this.setPropertyValue("controlPointDistance", value);
            this.makePath();
        },
        enumerable: true,
        configurable: true
    });
    return Polyarc;
}(Polyline_Polyline));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Polyarc"] = Polyarc_Polyarc;
//# sourceMappingURL=Polyarc.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Morpher.js
/**
 * Morpher module contains functionality that allows morphing one polygon to
 * another.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * Morpher can be used to morph one polygon to some other polygon.
 */
var Morpher_Morpher = /** @class */ (function (_super) {
    __extends(Morpher, _super);
    /**
     * Constructor.
     *
     * @param morphable An object to morph
     */
    function Morpher(morphable) {
        var _this = _super.call(this) || this;
        /**
         * A storage for measurements.
         */
        _this._bboxes = [];
        /**
         * Duration of the morphing animation in milliseconds.
         */
        _this.morphDuration = 800;
        /**
         * An easing function to use for morphing animation.
         *
         * @see {@link Ease}
         */
        _this.morphEasing = cubicOut;
        /**
         * If set to `true`, all separate parts of the multi-part polygon will
         * morph into a single circle or polygon when using built-in methods
         * `morphToCircle()` or `morphToPolygon()`.
         *
         * Otherwise each separate part of polygon will morph to individual target
         * circle or polgyon.
         */
        _this.morphToSingle = true;
        /**
         * A ratio to scale morphed object in relation to the source object.
         */
        _this.scaleRatio = 1;
        _this.className = "Morpher";
        _this.morphable = morphable;
        _this.applyTheme();
        return _this;
    }
    /**
     * Morphs a polygon to another polygon.
     *
     * @param toPoints  Corner points of the target shape
     * @param duration  Duration in milliseconds
     * @param easing    Easing function
     * @return Animation
     */
    Morpher.prototype.morphToPolygon = function (toPoints, duration, easing) {
        var points = this.morphable.currentPoints;
        if (points && toPoints) {
            this.sortPoints(points);
            this.sortPoints(toPoints);
            this._morphFromPointsReal = [];
            this._morphToPointsReal = [];
            if (!hasValue(duration)) {
                duration = this.morphDuration;
            }
            if (!hasValue(easing)) {
                easing = this.morphEasing;
            }
            this._morphFromPointsReal = this.normalizePoints(toPoints, points);
            this._morphToPointsReal = this.normalizePoints(points, toPoints);
            this.morphable.currentPoints = this._morphFromPointsReal;
            var animation = new Animation_Animation(this, { property: "morphProgress", from: 0, to: 1 }, duration, easing);
            this._disposers.push(animation);
            animation.start();
            return animation;
        }
    };
    /**
     * [normalizePoints description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param pointsA  Point A
     * @param pointsB  Point B
     * @return Normalized points
     */
    Morpher.prototype.normalizePoints = function (pointsA, pointsB) {
        for (var i = 0, len = pointsA.length; i < len; i++) {
            var surfaceA = pointsA[i][0];
            var holeA = pointsA[i][1];
            var bboxA = getValue(getBBox(surfaceA));
            var middleX = bboxA.x + bboxA.width;
            var middleY = bboxA.y + bboxA.height;
            // check if we have the same in PointsB
            if (!pointsB[i]) {
                pointsB[i] = [];
            }
            // check if we have surface in pointsB
            if (surfaceA && !pointsB[i][0]) {
                pointsB[i][0] = [{ x: middleX, y: middleY }, { x: middleX, y: middleY }];
            }
            if (pointsB[i][0]) {
                pointsB[i][0] = this.addPoints(pointsB[i][0], surfaceA.length);
                var distance = Infinity;
                var splitAt = 0;
                for (var a = 0; a < pointsB[i][0].length; a++) {
                    var newDistance = getDistance(pointsB[i][0][a], surfaceA[0]);
                    if (newDistance < distance) {
                        splitAt = a;
                        distance = newDistance;
                    }
                }
                var partA = pointsB[i][0].slice(0, splitAt);
                var partB = pointsB[i][0].slice(splitAt);
                pointsB[i][0] = partB.concat(partA);
            }
            if (holeA) {
                if (!pointsB[i][1]) {
                    pointsB[i][1] = [{ x: middleX, y: middleY }, { x: middleX, y: middleY }];
                }
                pointsB[i][1] = this.addPoints(pointsB[i][1], holeA.length);
            }
        }
        return pointsB;
    };
    /**
     * [sortPoints description]
     *
     * @ignore Exclude from doc
     * @todo Description
     * @param points  [description]
     * @return                        common bbox of points
     */
    Morpher.prototype.sortPoints = function (points) {
        points.sort(function (a, b) {
            var bbox1 = getValue(getBBox(a[0]));
            var bbox2 = getValue(getBBox(b[0]));
            if (bbox1.width * bbox1.height > bbox2.width * bbox2.height) {
                return -1;
            }
            else {
                return 1;
            }
        });
        var bboxes = [];
        for (var i = 0, len = points.length; i < len; i++) {
            var surface = points[i][0];
            if (surface) {
                bboxes.push(getValue(getBBox(surface)));
            }
        }
        return getCommonRectangle(bboxes);
    };
    /**
     * Morphs polygon to a circle (it is actually a polygon which makes a circle).
     *
     * @param radius    Target circle radius (px)
     * @param duration  Duration (ms)
     * @param easing    Easing function
     * @return Animation
     */
    Morpher.prototype.morphToCircle = function (radius, duration, easing) {
        var points = this.morphable.points;
        var commonBBox = this.sortPoints(points);
        this._morphFromPointsReal = [];
        this._morphToPointsReal = [];
        if (!hasValue(duration)) {
            duration = this.morphDuration;
        }
        if (!hasValue(easing)) {
            easing = this.morphEasing;
        }
        // surface
        for (var i = 0, len = points.length; i < len; i++) {
            var surface = points[i][0];
            var hole = points[i][1];
            this._morphFromPointsReal[i] = [];
            this._morphToPointsReal[i] = [];
            if (surface) {
                var toPoints = surface;
                var fromPoints = surface;
                var bbox = getValue(getBBox(fromPoints)); // this._bboxes[i];
                if (this.morphToSingle) {
                    bbox = getValue(commonBBox);
                }
                var middleX = bbox.x + bbox.width / 2;
                var middleY = bbox.y + bbox.height / 2;
                var realRadius = radius;
                if (!isNumber(realRadius)) {
                    realRadius = Math.min(bbox.width / 2, bbox.height / 2);
                }
                toPoints = [];
                // find angle for the first point
                var startAngle = getAngle({ x: middleX, y: middleY }, surface[0]);
                var count = 100;
                if (surface.length > count) {
                    count = surface.length;
                }
                fromPoints = this.addPoints(surface, count);
                count = fromPoints.length; // add Points might increase number a bit
                var angle = 360 / (count - 1);
                for (var a = 0; a < count; a++) {
                    var realAngle = angle * a + startAngle;
                    var pointOnCircle = { x: middleX + realRadius * Math_cos(realAngle), y: middleY + realRadius * Math_sin(realAngle) };
                    toPoints[a] = pointOnCircle;
                }
                if (hole && hole.length > 0) {
                    for (var i_1 = 0, hlen = hole.length; i_1 < hlen; i_1++) {
                        toPoints.push({ x: middleX, y: middleY });
                    }
                }
                this._morphFromPointsReal[i][0] = fromPoints;
                this._morphToPointsReal[i][0] = toPoints;
            }
        }
        this.morphable.currentPoints = this._morphFromPointsReal;
        var animation = new Animation_Animation(this, { property: "morphProgress", from: 0, to: 1 }, duration, easing);
        this._disposers.push(animation);
        animation.start();
        return animation;
    };
    /**
     * [addPoints description]
     *
     * @ignore Exclude from doc
     * @todo Description
     * @param points         [description]
     * @param mustHaveCount  [description]
     * @return [description]
     */
    Morpher.prototype.addPoints = function (points, mustHaveCount) {
        var addToSegmentCount = Math.round(mustHaveCount / points.length);
        var newPoints = [];
        for (var i = 0, len = points.length; i < len; i++) {
            var point0 = points[i];
            var point1 = void 0;
            if (i == points.length - 1) {
                point1 = points[0];
            }
            else {
                point1 = points[i + 1];
            }
            newPoints.push(point0);
            for (var p = 1; p < addToSegmentCount; p++) {
                var percent = p / addToSegmentCount;
                var extraPoint = { x: point0.x + (point1.x - point0.x) * percent, y: point0.y + (point1.y - point0.y) * percent };
                newPoints.push(extraPoint);
            }
            // stop adding in case we already added more than left in original
            if (newPoints.length + points.length - i == mustHaveCount) {
                addToSegmentCount = 0;
            }
        }
        if (newPoints.length < mustHaveCount && points.length > 0) {
            var lastPoint = points[points.length - 1];
            for (var p = newPoints.length; p < mustHaveCount; p++) {
                // add same as last
                newPoints.push({ x: lastPoint.x, y: lastPoint.y });
            }
        }
        return newPoints;
    };
    /**
     * Morphs polygon into a rectangular polygon.
     *
     * @param width     Width of the target rectangle (px)
     * @param height    Height of the target rectangle (px)
     * @param duration  Duration (ms)
     * @param easing    Easing function
     * @return Animation
     */
    Morpher.prototype.morphToRectangle = function (width, height, duration, easing) {
        var points = this.morphable.points;
        this.sortPoints(points);
        this._morphFromPointsReal = [];
        this._morphToPointsReal = [];
        if (!hasValue(duration)) {
            duration = this.morphDuration;
        }
        if (!hasValue(easing)) {
            easing = this.morphEasing;
        }
        //		let biggestBBox: IRectangle = this._bboxes[this._biggestIndex];
        // surface
        for (var i = 0, len = points.length; i < len; i++) {
            var surface = points[i][0];
            var hole = points[i][1];
            this._morphFromPointsReal[i] = [];
            this._morphToPointsReal[i] = [];
            if (surface) {
                var toPoints = surface;
                var fromPoints = surface;
                var bbox = this._bboxes[i];
                // we only work with first area. TODO: maybe we should find the biggest one?
                if (this.morphToSingle) {
                    //if (i != this._biggestIndex) {
                    //	bbox = { x: biggestBBox.x + biggestBBox.width / 2, y: biggestBBox.y + biggestBBox.height / 2, width: 0, height: 0 };
                    //}
                }
                var x = bbox.x;
                var y = bbox.y;
                var realWidth = width;
                var realHeight = height;
                if (!isNumber(realWidth)) {
                    realWidth = bbox.width;
                }
                if (!isNumber(realHeight)) {
                    realHeight = bbox.height;
                }
                toPoints = [{ x: x, y: y }, { x: x + realWidth, y: y }, { x: x + realWidth, y: y + realHeight }, { x: x, y: y + realHeight }];
                toPoints = this.addPoints(toPoints, surface.length);
                // if polygon has less points then count, add
                if (surface.length < 4) {
                    for (var i_2 = surface.length; i_2 < 4; i_2++) {
                        toPoints.push({ x: surface[i_2].x, y: surface[i_2].y });
                    }
                }
                if (hole && hole.length > 0) {
                    var middleX = bbox.x + bbox.width / 2;
                    var middleY = bbox.y + bbox.height / 2;
                    for (var i_3 = 0, hlen = hole.length; i_3 < hlen; i_3++) {
                        toPoints.push({ x: middleX, y: middleY });
                    }
                }
                this._morphFromPointsReal[i][0] = fromPoints;
                this._morphToPointsReal[i][0] = toPoints;
            }
        }
        this.morphable.currentPoints = this._morphFromPointsReal;
        var animation = new Animation_Animation(this, { property: "morphProgress", from: 0, to: 1 }, duration, easing);
        this._disposers.push(animation);
        animation.start();
        return animation;
    };
    Object.defineProperty(Morpher.prototype, "morphProgress", {
        /**
         * Returns the progress of morph transition.
         *
         * @return Progress (0-1)
         */
        get: function () {
            return this._morphProgress;
        },
        /**
         * Progress of the morph transition.
         *
         * Setting this will also trigger actual transformation.
         *
         * @param value  Progress (0-1)
         */
        set: function (value) {
            this._morphProgress = value;
            var currentPoints = [];
            if (value != null) {
                var fromPoints = this._morphFromPointsReal;
                var toPoints = this._morphToPointsReal;
                if (fromPoints != null && toPoints != null) {
                    for (var i = 0, len = fromPoints.length; i < len; i++) {
                        var currentArea = [];
                        currentPoints.push(currentArea);
                        var surfaceFrom = fromPoints[i][0];
                        var holeFrom = fromPoints[i][1];
                        var surfaceTo = toPoints[i][0];
                        var holeTo = toPoints[i][1];
                        if (surfaceFrom && surfaceFrom.length > 0 && surfaceTo && surfaceTo.length > 0) {
                            var currentSurface = [];
                            for (var i_4 = 0, slen = surfaceFrom.length; i_4 < slen; i_4++) {
                                var point0 = surfaceFrom[i_4];
                                var point1 = surfaceTo[i_4];
                                var currentPoint = { x: point0.x + (point1.x * this.scaleRatio - point0.x) * value, y: point0.y + (point1.y * this.scaleRatio - point0.y) * value };
                                currentSurface.push(currentPoint);
                            }
                            currentArea[0] = currentSurface;
                        }
                        if (holeFrom && holeFrom.length > 0 && holeTo && holeTo.length > 0) {
                            var currentHole = [];
                            for (var i_5 = 0, hlen = holeFrom.length; i_5 < hlen; i_5++) {
                                var point0 = holeFrom[i_5];
                                var point1 = holeTo[i_5];
                                var currentPoint = { x: point0.x + (point1.x * this.scaleRatio - point0.x) * value, y: point0.y + (point1.y * this.scaleRatio - point0.y) * value };
                                currentHole.push(currentPoint);
                            }
                            currentArea[1] = currentHole;
                        }
                    }
                }
            }
            this.morphable.currentPoints = currentPoints;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Restores the polygon to its original appearance.
     *
     * @param duration  Duration (ms)
     * @param easing    Easing function
     * @return Animation
     */
    Morpher.prototype.morphBack = function (duration, easing) {
        this._morphToPointsReal = this._morphFromPointsReal;
        this._morphFromPointsReal = this.morphable.currentPoints;
        if (!hasValue(duration)) {
            duration = this.morphDuration;
        }
        if (!hasValue(easing)) {
            easing = this.morphEasing;
        }
        var animation = new Animation_Animation(this, { property: "morphProgress", from: 0, to: 1 }, duration, easing);
        this._disposers.push(animation);
        animation.start();
        return animation;
    };
    Object.defineProperty(Morpher.prototype, "animations", {
        /**
         * Returns a list of morph animations currently being played.
         *
         * @return List of animations
         */
        get: function () {
            if (!this._animations) {
                this._animations = [];
                this._disposers.push(new Animation_AnimationDisposer(this._animations));
            }
            return this._animations;
        },
        enumerable: true,
        configurable: true
    });
    return Morpher;
}(Base_BaseObject));

//# sourceMappingURL=Morpher.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Polygon.js
/**
 * Polygon module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a polygon.
 *
 * @see {@link IPolygonEvents} for a list of available events
 * @see {@link IPolygonAdapters} for a list of available Adapters
 */
var Polygon_Polygon = /** @class */ (function (_super) {
    __extends(Polygon, _super);
    /**
     * Constructor
     */
    function Polygon() {
        var _this = _super.call(this) || this;
        _this.className = "Polygon";
        _this.element = _this.paper.add("path");
        _this.shapeRendering = "auto";
        _this._currentPoints = [];
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(Polygon.prototype, "points", {
        /**
         * @return Polygon points
         */
        get: function () {
            var points = this.getPropertyValue("points");
            var path = this.path;
            if (path && (!points || points.length == 0)) {
                var valueStr = path.slice(1, path.length - 1);
                var segments = valueStr.split("ZM");
                for (var s = 0; s < segments.length; s++) {
                    var segment = segments[s];
                    if (segment.length > 0) {
                        var areaHole = segment.split("M");
                        var areaArr = areaHole[0];
                        var holeArr = areaHole[1];
                        if (areaArr && areaArr.length > 0) {
                            var pointsArr = areaArr.split("L");
                            if (pointsArr.length > 0) {
                                var area = [];
                                var areaAndHole = [area];
                                points.push(areaAndHole);
                                for (var p = 0; p < pointsArr.length; p++) {
                                    var coords = pointsArr[p].split(",");
                                    area.push({ x: +coords[0], y: +coords[1] });
                                }
                                if (holeArr && holeArr.length > 0) {
                                    var pointsArr_1 = holeArr.split("L");
                                    if (pointsArr_1.length > 0) {
                                        var hole = [];
                                        areaAndHole.push(hole);
                                        for (var p = pointsArr_1.length - 1; p >= 0; p--) {
                                            var coords = pointsArr_1[p].split(",");
                                            hole.push({ x: +coords[0], y: +coords[1] });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                this.setPropertyValue("points", points);
                this._currentPoints = points;
            }
            return points;
        },
        /**
         * An array of X/Y coordinates for each elbow of the polygon.
         *
         * @todo Example
         * @param points  Polygon points
         */
        set: function (points) {
            this.setPropertyValue("points", points, true);
            this._currentPoints = points;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Polygon.prototype, "currentPoints", {
        /**
         * @return Polygon points
         */
        get: function () {
            if ((!this._currentPoints || this._currentPoints.length == 0) && this.path) {
                this._currentPoints = this.points;
            }
            return this._currentPoints;
        },
        /**
         * Current points. Used when morphing the element, so that original `points`
         * are not overwritten.
         *
         * @param points  Polygon points
         */
        set: function (points) {
            if (this._currentPoints != points) {
                this._currentPoints = points;
                this.draw();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    Polygon.prototype.draw = function () {
        var path = "";
        var points = this._currentPoints;
        var left;
        var right;
        var top;
        var bottom;
        if (points.length > 0) {
            // separate areas
            for (var i = 0, len = points.length; i < len; i++) {
                // surface
                var surface = points[i][0];
                var hole = points[i][1];
                if (surface && surface.length > 0) {
                    var point = surface[0];
                    path += moveTo(point);
                    for (var s = 0; s < surface.length; s++) {
                        point = surface[s];
                        path += lineTo(point);
                        if (!isNumber(right) || (right < point.x)) {
                            right = point.x;
                        }
                        if (!isNumber(left) || (left > point.x)) {
                            left = point.x;
                        }
                        if (!isNumber(top) || (top > point.y)) {
                            top = point.y;
                        }
                        if (!isNumber(bottom) || (bottom < point.y)) {
                            bottom = point.y;
                        }
                    }
                }
                // hole
                if (hole && hole.length > 0) {
                    var point = hole[0];
                    path += moveTo(point);
                    for (var h = 0, hlen = hole.length; h < hlen; h++) {
                        point = hole[h];
                        path += lineTo(point);
                    }
                }
            }
            if (path) {
                path += closePath();
            }
            this.bbox.x = left;
            this.bbox.y = top;
            this.bbox.width = right - left;
            this.bbox.height = bottom - top;
            _super.prototype.setPath.call(this, path);
        }
    };
    /**
     * @ignore
     */
    Polygon.prototype.setPath = function (value) {
        if (_super.prototype.setPath.call(this, value)) {
            this.points = [];
            this._bbox = this.group.getBBox();
            return true;
        }
        return false;
    };
    /**
     * Measures element
     */
    Polygon.prototype.measureElement = function () {
        // Overriding to avoid extra measurement.
    };
    Object.defineProperty(Polygon.prototype, "centerPoint", {
        /**
         * A calculated center point for the shape.
         *
         * @readonly
         * @return Center
         */
        get: function () {
            return { x: this.bbox.x + this.bbox.width / 2, y: this.bbox.y + this.bbox.height / 2 };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Polygon.prototype, "morpher", {
        /**
         * A [[Morpher]] instance that is used to morph polygon into some other
         * shape.
         *
         * @readonly
         * @return Morpher instance
         */
        get: function () {
            if (!this._morpher) {
                this._morpher = new Morpher_Morpher(this);
                this._disposers.push(this._morpher);
            }
            return this._morpher;
        },
        enumerable: true,
        configurable: true
    });
    return Polygon;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Polygon"] = Polygon_Polygon;
//# sourceMappingURL=Polygon.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Polyspline.js
/**
 * Polyspline (smoothed line) module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a polysline. (smoothed multi-sigment line)
 *
 * @see {@link IPolysplineEvents} for a list of available events
 * @see {@link IPolysplineAdapters} for a list of available Adapters
 */
var Polyspline_Polyspline = /** @class */ (function (_super) {
    __extends(Polyspline, _super);
    /**
     * Constructor
     */
    function Polyspline() {
        var _this = _super.call(this) || this;
        _this.className = "Polyspline";
        _this.tensionX = 0.5;
        _this.tensionY = 0.5;
        _this.applyTheme();
        return _this;
    }
    /**
     * Creats and adds an SVG path for the arc.
     *
     * @ignore Exclude from docs
     */
    Polyspline.prototype.makePath = function () {
        this._distance = 0;
        var segments = this.segments;
        var tensionX = this.tensionX;
        var tensionY = this.tensionY;
        this.allPoints = [];
        if (segments && segments.length > 0) {
            var path = "";
            this._realSegments = [];
            for (var i = 0, len = segments.length; i < len; i++) {
                var points = segments[i];
                var realPoints = [];
                this._realSegments.push(realPoints);
                if (points.length > 0) {
                    var first = points[0];
                    var last = points[points.length - 1];
                    var closed_1 = false;
                    if (Math_round(first.x, 3) == Math_round(last.x) && Math_round(first.y) == Math_round(last.y)) {
                        closed_1 = true;
                    }
                    path += moveTo(points[0]);
                    for (var p = 0; p < points.length - 1; p++) {
                        var p0 = points[p - 1];
                        var p1 = points[p];
                        var p2 = points[p + 1];
                        var p3 = points[p + 2];
                        if (p === 0) {
                            p0 = points[p];
                        }
                        else if (p == points.length - 2) {
                            p3 = points[p + 1];
                        }
                        if (!p3) {
                            p3 = p2;
                        }
                        if (p === 0) {
                            if (closed_1) {
                                p0 = points[points.length - 2];
                            }
                            else {
                                p0 = points[i];
                            }
                        }
                        else if (p == points.length - 2) {
                            if (closed_1) {
                                p3 = points[1];
                            }
                            else {
                                p3 = points[p + 1];
                            }
                        }
                        var controlPointA = getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);
                        var controlPointB = getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);
                        path += cubicCurveTo(p2, controlPointA, controlPointB);
                        // now split to small segments so that we could have positionToPoint later
                        var stepCount = Math.ceil(getCubicCurveDistance(p1, p2, controlPointA, controlPointB, 20)) * 1.2;
                        var prevPoint = p1;
                        if (stepCount > 0) {
                            // not good for curved charts
                            //this.allPoints[0] = { x: points[0].x, y: points[0].y, angle: $math.getAngle(points[0], points[1]) };
                            //realPoints.push(this.allPoints[0]);
                            for (var s = 0; s <= stepCount; s++) {
                                var point = getPointOnCubicCurve(p1, p2, controlPointA, controlPointB, s / stepCount);
                                if (point.x == prevPoint.x && point.y == prevPoint.y) {
                                    continue;
                                }
                                realPoints.push(point);
                                var angle = Math_round(getAngle(prevPoint, point), 5);
                                //this.allPoints.push({ x: point.x, y: point.y, angle: angle });
                                this._distance += getDistance(prevPoint, point);
                                this.allPoints[Math.floor(this._distance)] = { x: point.x, y: point.y, angle: angle };
                                prevPoint = point;
                            }
                        }
                        else {
                            realPoints.push(p0);
                        }
                    }
                }
                var allPoints = this.allPoints;
                if (allPoints.length > 1) {
                    for (var i_1 = 0; i_1 < allPoints.length; i_1++) {
                        if (!allPoints[i_1]) {
                            if (i_1 > 1) {
                                allPoints[i_1] = allPoints[i_1 - 1];
                            }
                            else {
                                for (var k = 1; k < allPoints.length; k++) {
                                    if (allPoints[k]) {
                                        allPoints[i_1] = allPoints[k];
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.path = path;
        }
    };
    /**
     * Returns an index of the point that is closest to specified coordinates.
     *
     * @param   point  Reference point
     * @return         Index
     */
    Polyspline.prototype.getClosestPointIndex = function (point) {
        var points = this.allPoints;
        var index;
        var closest = Infinity;
        if (points.length > 1) {
            for (var p = 1; p < points.length; p++) {
                var distance = getDistance(point, points[p]);
                if (distance < closest) {
                    index = p;
                    closest = distance;
                }
            }
        }
        return index;
    };
    Object.defineProperty(Polyspline.prototype, "tensionX", {
        /**
         * @return Tension
         */
        get: function () {
            return this.getPropertyValue("tensionX");
        },
        /**
         * Horizontal tension for the spline.
         *
         * Used by the line smoothing algorithm.
         *
         * @default 0.5
         * @param value  Tension
         */
        set: function (value) {
            this.setPropertyValue("tensionX", value);
            this.makePath();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Polyspline.prototype, "tensionY", {
        /**
         * @return Tension
         */
        get: function () {
            return this.getPropertyValue("tensionY");
        },
        /**
         * Vertical tension for the spline.
         *
         * Used by the line smoothing algorithm.
         *
         * @default 0.5
         * @param value  Tensions
         */
        set: function (value) {
            this.setPropertyValue("tensionY", value, true);
            this.makePath();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts relative position along the line (0-1) into pixel coordinates.
     *
     * @param position  Position (0-1)
     * @return Coordinates
     */
    Polyspline.prototype.positionToPoint = function (position, extend) {
        var deltaAngle = 0;
        var allPoints = this.allPoints;
        var len = allPoints.length;
        if (!isNumber(position)) {
            position = 0;
        }
        if (len > 1) {
            if (extend && len > 3) {
                if (position < 0) {
                    if (position < -0.01) {
                        position = -0.01;
                    }
                    var f0 = allPoints[0];
                    var f1 = allPoints[1];
                    var x = f0.x - (f0.x - f1.x) * len * position;
                    var y = f0.y - (f0.y - f1.y) * len * position;
                    return { x: x, y: y, angle: getAngle(f0, f1) };
                }
                else if (position > 1) {
                    if (position > 1.01) {
                        position = 1.01;
                    }
                    var f0 = allPoints[allPoints.length - 2];
                    var f1 = allPoints[allPoints.length - 3];
                    var x = f0.x + (f0.x - f1.x) * len * (position - 1);
                    var y = f0.y + (f0.y - f1.y) * len * (position - 1);
                    return { x: x, y: y, angle: getAngle(f0, { x: x, y: y }) };
                }
                else if (position == 1) {
                    var point_1 = allPoints[allPoints.length - 1];
                    return { x: point_1.x, y: point_1.y, angle: point_1.angle };
                }
            }
            else {
                if (position < 0) {
                    position = Math.abs(position);
                    deltaAngle = 180;
                }
                if (position >= 1) {
                    position = 0.9999999999999;
                }
            }
            var point = allPoints[Math.floor(position * len)];
            return { x: point.x, y: point.y, angle: point.angle + deltaAngle };
        }
        else if (len == 1) {
            var point = allPoints[0];
            return { x: point.x, y: point.y, angle: point.angle };
        }
        else {
            return { x: 0, y: 0, angle: 0 };
        }
    };
    return Polyspline;
}(Polyline_Polyline));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Polyspline"] = Polyspline_Polyspline;
//# sourceMappingURL=Polyspline.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Slice.js
/**
 * Slice module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a wedged semi-circle - slice. Usually used for Pie/Donut charts.
 *
 * @see {@link ISliceEvents} for a list of available events
 * @see {@link ISliceAdapters} for a list of available Adapters
 */
var Slice_Slice = /** @class */ (function (_super) {
    __extends(Slice, _super);
    /**
     * Constructor
     */
    function Slice() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "Slice";
        // Set defaults
        _this.setPropertyValue("cornerRadius", 0);
        _this.setPropertyValue("startAngle", 0);
        _this.setPercentProperty("innerRadius", 0);
        _this.setPercentProperty("radius", 0);
        _this.setPropertyValue("arc", 0);
        _this.setPropertyValue("shiftRadius", 0);
        _this.strokeOpacity = 1;
        _this.setPropertyValue("layout", "none");
        // Create a slice wedge element
        _this.slice = _this.createChild(Sprite_Sprite);
        _this.slice.isMeasured = false;
        _this._disposers.push(_this.slice);
        //this.element.attr({ "stroke-linejoin": "round" });
        //this.element.attr({ "stroke-linecap": "round" });
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    Slice.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var radiusY = this.radiusY;
        if (this.radius > 0 && radiusY == 0) {
            radiusY = 0.01;
        }
        this.slice.path = Path_arc(this.startAngle, this.arc, this.radius, this.pixelInnerRadius, radiusY, this.cornerRadius, this.innerCornerRadius);
        this.slice.invalidate();
        this.shiftRadius = this.shiftRadius;
        if (this.realFill instanceof RadialGradient_RadialGradient) {
            this.updateGradient(this.realFill);
        }
        if (this.realStroke instanceof RadialGradient_RadialGradient) {
            this.updateGradient(this.realStroke);
        }
    };
    Slice.prototype.updateGradient = function (gradient) {
        gradient.element.attr({ "gradientUnits": "userSpaceOnUse" });
        gradient.element.attr({ "r": this.radius });
        gradient.cx = 0;
        gradient.cy = 0;
        gradient.element.attr({ radius: this.radius });
    };
    Object.defineProperty(Slice.prototype, "bbox", {
        /**
         * Returns bounding box (square) for this element.
         *
         * @ignore Exclude from docs
         */
        get: function () {
            if (this.definedBBox) {
                return this.definedBBox;
            }
            if (this.isMeasured) {
                var innerRect = getArcRect(this.startAngle, this.startAngle + this.arc, this.pixelInnerRadius);
                var outerRect = getArcRect(this.startAngle, this.startAngle + this.arc, this.radius);
                return getCommonRectangle([innerRect, outerRect]);
            }
            else {
                return { x: 0, y: 0, width: 0, height: 0 };
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "startAngle", {
        /**
         * @return Angle (0-360)
         */
        get: function () {
            return this.getPropertyValue("startAngle");
        },
        /**
         * The angle at which left edge of the slice is drawn. (0-360)
         *
         * 0 is to the right of the center.
         *
         * @param value  Angle (0-360)
         */
        set: function (value) {
            this.setPropertyValue("startAngle", normalizeAngle(value), true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "arc", {
        /**
         * @return [description]
         */
        get: function () {
            return this.getPropertyValue("arc");
        },
        /**
         * [arc description]
         *
         * @todo Description
         * @param value [description]
         */
        set: function (value) {
            if (!isNumber(value)) {
                value = 0;
            }
            this.setPropertyValue("arc", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "radius", {
        /**
         * @return Radius (px)
         */
        get: function () {
            var radius = this.getPropertyValue("radius");
            if (!isNumber(radius)) {
                radius = 0;
            }
            return radius;
        },
        /**
         * Radius of the slice in pixels.
         *
         * @param value  Radius (px)
         */
        set: function (value) {
            this.setPropertyValue("radius", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "radiusY", {
        /**
         * @return Vertical radius (0-1)
         */
        get: function () {
            var value = this.getPropertyValue("radiusY");
            if (!isNumber(value)) {
                value = this.radius;
            }
            return value;
        },
        /**
         * Vertical radius for creating skewed slices.
         *
         * This is relevant to `radius`, e.g. 0.5 will set vertical radius to half
         * the `radius`.
         *
         * @param value Vertical radius (0-1)
         */
        set: function (value) {
            this.setPropertyValue("radiusY", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "innerRadius", {
        /**
         * @return Radius (px or %)
         */
        get: function () {
            return this.getPropertyValue("innerRadius");
        },
        /**
         * Inner radius of the slice for creating cut out (donut) slices.
         *
         * @default 0
         * @param value  Radius (px or %)
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "pixelInnerRadius", {
        /**
         * @return Radius px
         */
        get: function () {
            return relativeToValue(this.innerRadius, this.radius);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "cornerRadius", {
        /**
         * @return Radius (px)
         */
        get: function () {
            return this.getPropertyValue("cornerRadius");
        },
        /**
         * Radius of slice's outer corners in pixels.
         *
         * @default 0
         * @param value  Radius (px)
         */
        set: function (value) {
            this.setPropertyValue("cornerRadius", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "innerCornerRadius", {
        /**
         * @return Radius (px)
         */
        get: function () {
            return this.getPropertyValue("innerCornerRadius");
        },
        /**
         * Radius of slice's inner corners in pixels.
         *
         * @default 0
         * @param value  Radius (px)
         */
        set: function (value) {
            this.setPropertyValue("innerCornerRadius", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "shiftRadius", {
        /**
         * @return Radius shift
         */
        get: function () {
            return this.getPropertyValue("shiftRadius");
        },
        /**
         * Indicates how far (relatively to center) a slice should be moved.
         *
         * The value is relative to the radius of the slice. Meaning 0 no shift,
         * 1 - slice shifted outside by whole of its radius.
         *
         * @param  value  Radius shift
         */
        set: function (value) {
            this.setPropertyValue("shiftRadius", value);
            this.dx = value * this.radius * this.ix;
            this.dy = value * this.radiusY * this.iy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "ix", {
        /**
         * [ix description]
         *
         * @ignore Exclude from docs
         * @todo Description
         * @return [description]
         */
        get: function () {
            return Math_cos(this.middleAngle);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "iy", {
        /**
         * [iy description]
         *
         * @ignore Exclude from docs
         * @todo Description
         * @return [description]
         */
        get: function () {
            if (this.radius > 0) {
                return Math_sin(this.middleAngle);
            }
            else {
                return Math_sin(this.middleAngle);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice.prototype, "middleAngle", {
        /**
         * An angle of the slice's middle.
         *
         * @ignore Exclude from docs
         * @return Angle
         */
        get: function () {
            return this.startAngle + this.arc / 2;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * X coordinate for the slice tooltip.
     *
     * @return X
     */
    Slice.prototype.getTooltipX = function () {
        var value = this.getPropertyValue("tooltipX");
        if (isNumber(value)) {
            return value;
        }
        var p = 0.5;
        if (value instanceof Percent) {
            p = value.value;
        }
        var innerRadius = relativeToValue(this.innerRadius, this.radius);
        return this.ix * (innerRadius + (this.radius - innerRadius) * p);
    };
    /**
     * Y coordinate for the slice tooltip.
     *
     * @return Y
     */
    Slice.prototype.getTooltipY = function () {
        var value = this.getPropertyValue("tooltipY");
        if (isNumber(value)) {
            return value;
        }
        var p = 0.5;
        if (value instanceof Percent) {
            p = value.value;
        }
        var innerRadius = relativeToValue(this.innerRadius, this.radius);
        return this.iy * (innerRadius + (this.radius - innerRadius) * p) + this.slice.dy;
    };
    return Slice;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Slice"] = Slice_Slice;
//# sourceMappingURL=Slice.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Preloader.js
/**
 * Preloader module.
 *
 * Preloader is a progress indicator.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A class used to draw and display progress indicator.
 *
 * @see {@link IPreloaderEvents} for a list of available events
 * @see {@link IPreloaderAdapters} for a list of available Adapters
 */
var Preloader_Preloader = /** @class */ (function (_super) {
    __extends(Preloader, _super);
    /**
     * Constructor
     */
    function Preloader() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "Preloader";
        // Set dimensions
        _this.width = Percent_percent(100);
        _this.height = Percent_percent(100);
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        // Create main container
        var sliceContainer = _this.createChild(Container_Container);
        sliceContainer.shouldClone = false;
        // Add background (100%) slice
        var backgroundSlice = sliceContainer.createChild(Slice_Slice);
        backgroundSlice.shouldClone = false;
        backgroundSlice.radius = 53;
        backgroundSlice.arc = 360;
        backgroundSlice.fill = interfaceColors.getFor("fill");
        backgroundSlice.fillOpacity = 0.8;
        backgroundSlice.innerRadius = 42;
        backgroundSlice.isMeasured = false;
        _this.backgroundSlice = backgroundSlice;
        // Add progress slice
        var progressSlice = sliceContainer.createChild(Slice_Slice);
        progressSlice.shouldClone = false;
        progressSlice.radius = 50;
        progressSlice.innerRadius = 45;
        progressSlice.fill = interfaceColors.getFor("alternativeBackground");
        progressSlice.fillOpacity = 0.2;
        progressSlice.isMeasured = false;
        _this.progressSlice = progressSlice;
        // Add text label element
        var label = sliceContainer.createChild(Label_Label);
        label.shouldClone = false;
        label.horizontalCenter = "middle";
        label.verticalCenter = "middle";
        label.isMeasured = false;
        label.fill = interfaceColors.getFor("text");
        label.align = "center";
        label.valign = "middle";
        label.textAlign = "middle";
        label.fillOpacity = 0.4;
        _this.label = label;
        // Set defaults
        _this.background.opacity = 1;
        _this.background.fill = interfaceColors.getFor("background");
        _this.contentAlign = "center";
        _this.contentValign = "middle";
        _this.delay = 300;
        // Create hidden state
        var hiddenState = _this.states.create("hidden");
        hiddenState.properties.opacity = 0;
        // Hide by default
        _this.visible = false;
        _this.hide(0);
        _this.__disabled = true;
        // Make it disposable
        // @todo Maybe it's enough to just dispose `sliceContainer`?
        _this._disposers.push(_this.backgroundSlice);
        _this._disposers.push(_this.progressSlice);
        _this._disposers.push(_this.label);
        _this._disposers.push(sliceContainer);
        return _this;
    }
    Object.defineProperty(Preloader.prototype, "progress", {
        /**
         * @return Progress (0-1)
         */
        get: function () {
            return this.getPropertyValue("progress");
        },
        /**
         * Current preload progress. (0-1)
         *
         * * 0 - 0%
         * * 0.5 - 50%
         * * 1 - 100%
         *
         * Setting this to a value less than 1, will automatically reveal the
         * preloader, while setting it to 1 (100%) will hide it.
         *
         * @param value Progress (0-1)
         */
        set: function (value) {
            var _this = this;
            this.__disabled = false;
            this.validateLayout(); // show not in center without this
            this.setPropertyValue("progress", value);
            /*if (!this.visible && value == 1) {
                return;
            }*/
            this.progressSlice.arc = 360 * value;
            if (this.label) {
                this.label.text = Math.round(value * 100) + "%";
            }
            if (value >= 1) {
                // Cancel the timeout
                if (this._started) {
                    this._started = undefined;
                }
                // TODO remove closure ?
                registry.events.once("enterframe", function () {
                    var animation = _this.hide();
                    if (animation && !animation.isFinished()) {
                        animation.events.once("animationended", function () {
                            _this.__disabled = true;
                        });
                    }
                    else {
                        _this.__disabled = true;
                    }
                });
                this.interactionsEnabled = false;
                this.setPropertyValue("progress", 0);
            }
            else if (value > 0) {
                if (this.delay) {
                    if (!this._started) {
                        this._started = new Date().getTime();
                    }
                    else if ((this._started + this.delay) <= new Date().getTime()) {
                        this.__disabled = false;
                        this.show();
                        this.interactionsEnabled = true;
                    }
                }
                else {
                    this.__disabled = false;
                    this.show();
                    this.interactionsEnabled = true;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Preloader.prototype, "delay", {
        /**
         * @return Delay (ms)
         */
        get: function () {
            return this.getPropertyValue("delay");
        },
        /**
         * Delay display of preloader by X milliseconds.
         *
         * When loading starts (`progress` is set to <1) and finishes (`progress` is
         * set to 1) before `delay` ms, the loader is never shown.
         *
         * This is used to avoid brief flashing of the preload for very quick loads.
         *
         * @default 1000
         * @param value  Delay (ms)
         */
        set: function (value) {
            this.setPropertyValue("delay", value);
        },
        enumerable: true,
        configurable: true
    });
    return Preloader;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Preloader"] = Preloader_Preloader;
//# sourceMappingURL=Preloader.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/ResizeButton.js
/**
 * Resize button module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a draggable resize/grip button.
 *
 * @see {@link IResizeButtonEvents} for a list of available events
 * @see {@link IResizeButtonAdapters} for a list of available Adapters
 */
var ResizeButton_ResizeButton = /** @class */ (function (_super) {
    __extends(ResizeButton, _super);
    /**
     * Constructor
     */
    function ResizeButton() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "ResizeButton";
        // Set defaults
        _this.orientation = "horizontal";
        _this.layout = "absolute";
        _this.horizontalCenter = "middle";
        _this.verticalCenter = "middle";
        _this.draggable = true;
        _this.padding(8, 8, 8, 8);
        _this.background.cornerRadius(20, 20, 20, 20);
        // Create an icon
        var icon = new Sprite_Sprite();
        icon.element = _this.paper.add("path");
        var path = moveTo({ x: -2, y: -6 });
        path += lineTo({ x: -2, y: 6 });
        path += moveTo({ x: 2, y: -6 });
        path += lineTo({ x: 2, y: 6 });
        icon.path = path;
        icon.pixelPerfect = true;
        icon.padding(0, 4, 0, 4);
        icon.stroke = new InterfaceColorSet_InterfaceColorSet().getFor("alternativeText");
        icon.strokeOpacity = 0.7;
        //icon.align = "center";
        //icon.valign = "middle";
        _this.icon = icon;
        _this.label.dispose();
        _this.label = undefined;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(ResizeButton.prototype, "orientation", {
        /**
         * Use for setting of direction (orientation) of the resize button.
         *
         * Available options: "horizontal", "vertical".
         *
         * @param value Orientation
         */
        set: function (value) {
            var icon = this.icon;
            if (icon) {
                if (value == "horizontal") {
                    icon.rotation = 0;
                }
                else {
                    icon.rotation = -90;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    return ResizeButton;
}(Button_Button));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ResizeButton"] = ResizeButton_ResizeButton;
//# sourceMappingURL=ResizeButton.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/CloseButton.js
/**
 * Zoom out button functionality.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a zoom out button.
 *
 * @see {@link ICloseButtonEvents} for a list of available events
 * @see {@link ICloseButtonAdapters} for a list of available Adapters
 */
var CloseButton_CloseButton = /** @class */ (function (_super) {
    __extends(CloseButton, _super);
    /**
     * Constructor
     */
    function CloseButton() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "CloseButton";
        _this.padding(8, 8, 8, 8);
        _this.showSystemTooltip = true;
        _this.width = 30;
        _this.height = 30;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.cursorOverStyle = MouseCursorStyle.pointer;
        var background = _this.background;
        background.cornerRadius(20, 20, 20, 20);
        var bgc = interfaceColors.getFor("background");
        background.fill = bgc;
        background.stroke = interfaceColors.getFor("primaryButton");
        background.strokeOpacity = 1;
        background.strokeWidth = 1;
        var downColor = interfaceColors.getFor("primaryButtonActive");
        var bhs = background.states.getKey("hover");
        bhs.properties.strokeWidth = 3;
        bhs.properties.fill = bgc;
        var bds = background.states.getKey("down");
        bds.properties.stroke = downColor;
        bds.properties.fill = bgc;
        // Create an icon
        var icon = new Sprite_Sprite();
        icon.element = _this.paper.add("path");
        icon.stroke = background.stroke;
        _this.icon = icon;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    CloseButton.prototype.validate = function () {
        _super.prototype.validate.call(this);
        var w = this.pixelWidth / 3;
        var h = this.pixelHeight / 3;
        var path = moveTo({ x: -w / 2, y: -h / 2 });
        path += lineTo({ x: w / 2, y: h / 2 });
        path += moveTo({ x: w / 2, y: -h / 2 });
        path += lineTo({ x: -w / 2, y: h / 2 });
        this.icon.path = path;
        this.invalidateLayout();
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    CloseButton.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Close");
        }
    };
    return CloseButton;
}(Button_Button));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["CloseButton"] = CloseButton_CloseButton;
//# sourceMappingURL=CloseButton.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/SwitchButton.js
/**
 * Functionality for drawing simple SwitchButtons.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * SwitchButton class is capable of drawing a simple rectangular SwitchButton with
 * optionally rounded corners and an icon in it.
 *
 * @see {@link ISwitchButtonEvents} for a list of available events
 * @see {@link ISwitchButtonAdapters} for a list of available Adapters
 */
var SwitchButton_SwitchButton = /** @class */ (function (_super) {
    __extends(SwitchButton, _super);
    /**
     * Constructor
     */
    function SwitchButton() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "SwitchButton";
        _this.tooltipY = 0;
        // Set defaults
        _this.layout = "horizontal";
        _this.contentAlign = "center";
        _this.contentValign = "middle";
        _this.padding(8, 16, 8, 16);
        _this.setStateOnChildren = true;
        _this.states.create("active");
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        // Create the label element
        var leftLabel = new Label_Label();
        leftLabel.fillOpacity = 0.3;
        var llas = leftLabel.states.create("active");
        llas.properties.fillOpacity = 1;
        leftLabel.isActive = true;
        _this.leftLabel = leftLabel;
        var button = new Button_Button();
        var circle = new Circle_Circle();
        button.contentValign = "none";
        button.padding(0, 0, 0, 0);
        circle.radius = 10;
        button.icon = circle;
        button.icon.valign = "middle";
        button.label = undefined;
        var p100 = Percent_percent(100);
        button.background.cornerRadius(p100, p100, p100, p100);
        button.width = circle.radius * 3.5;
        button.height = circle.radius * 2.1;
        button.marginLeft = 8;
        button.marginRight = 8;
        button.togglable = true;
        circle.dx = -circle.radius * 0.7;
        circle.fill = interfaceColors.getFor("primaryButton");
        var hs = circle.states.create("hover");
        hs.properties.fill = interfaceColors.getFor("primaryButtonHover");
        var as = circle.states.create("active");
        as.properties.fill = interfaceColors.getFor("primaryButtonActive");
        as.properties.dx = circle.radius * 0.7;
        _this.switchButton = button;
        _this.events.on("toggled", function () {
            _this.leftLabel.isActive = !_this.isActive;
            _this.rightLabel.isActive = _this.isActive;
        });
        // Create the label element
        var rightLabel = new Label_Label();
        rightLabel.fillOpacity = 0.3;
        var rlas = rightLabel.states.create("active");
        rlas.properties.fillOpacity = 1;
        _this.rightLabel = rightLabel;
        // Set up accessibility
        // A Button should be always focusable
        _this.role = "button";
        _this.focusable = true;
        rightLabel.valign = "middle";
        leftLabel.valign = "middle";
        button.valign = "middle";
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(SwitchButton.prototype, "leftLabel", {
        /**
         * @return Left label element
         */
        get: function () {
            return this._leftLabel;
        },
        /**
         * [[Label]] element to be used for left text.
         *
         * @param left label element
         */
        set: function (label) {
            if (this._leftLabel) {
                this.removeDispose(this._leftLabel);
            }
            this._leftLabel = label;
            if (label) {
                label.parent = this;
                label.interactionsEnabled = false;
                label.shouldClone = false;
                this._disposers.push(this._leftLabel);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchButton.prototype, "rightLabel", {
        /**
         * @return Rigth label element
         */
        get: function () {
            return this._rightLabel;
        },
        /**
         * [[Label]] element to be used for left text.
         *
         * @param rigth label element
         */
        set: function (label) {
            if (this._rightLabel) {
                this.removeDispose(this._rightLabel);
            }
            this._rightLabel = label;
            if (label) {
                label.parent = this;
                label.interactionsEnabled = false;
                label.shouldClone = false;
                this._disposers.push(this._rightLabel);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchButton.prototype, "switch", {
        /**
         * @return Left label element
         */
        get: function () {
            return this._switchButton;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SwitchButton.prototype, "switchButton", {
        /**
         * [[Label]] element to be used for left text.
         *
         * @param rigth label element
         */
        set: function (button) {
            if (this._switchButton) {
                this.removeDispose(this._switchButton);
            }
            this._switchButton = button;
            if (button) {
                button.parent = this;
                button.shouldClone = false;
                this._disposers.push(this._switchButton);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies properties and other attributes.
     *
     * @param source  Source
     */
    SwitchButton.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (source.leftLabel) {
            this.leftLabel.copyFrom(source.leftLabel);
        }
        if (source.rightLabel) {
            this.rightLabel.copyFrom(source.rightLabel);
        }
        if (source.switchButton) {
            this.switchButton.copyFrom(source.switchButton);
        }
    };
    return SwitchButton;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["SwitchButton"] = SwitchButton_SwitchButton;
//# sourceMappingURL=SwitchButton.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Scrollbar.js
/**
 * Provides functionality used to build scrollbars.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */














;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Scrollbar is a generic control allowing to select a range of values or pan
 * the selection.
 *
 * @see {@link IScrollbarEvents} for a list of available events
 * @see {@link IScrollbarAdapters} for a list of available Adapters
 */
var Scrollbar_Scrollbar = /** @class */ (function (_super) {
    __extends(Scrollbar, _super);
    /**
     * Construtor
     */
    function Scrollbar() {
        var _this = _super.call(this) || this;
        /**
         * Previously selected lower (start) value.
         */
        _this._previousStart = 0;
        /**
         * Previously selected upper (end) value.
         */
        _this._previousEnd = 1;
        /**
         * A value of previously selected lower value, used for doubleclick function.
         */
        _this._prevStart = 0;
        /**
         * A value of previously selected upper value, used for doubleclick function.
         */
        _this._prevEnd = 1;
        /**
         * Indicates if the Scrollbar is currently "busy" (animating and or
         * performing zoom by user interaction).
         */
        _this._isBusy = false;
        /**
         * [_skipRangeEvents description]
         *
         * @todo Description
         */
        _this._skipRangeEvents = false;
        /**
         * Update the selection when dragging the grips.
         *
         * If set to `false` selection will be updated only when the grip is
         * released.
         *
         * @default true
         */
        _this.updateWhileMoving = true;
        _this.className = "Scrollbar";
        _this.minHeight = 12;
        _this.minWidth = 12;
        _this.animationDuration = 0;
        _this.animationEasing = cubicOut;
        _this.margin(10, 10, 10, 10);
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        // background is also container as it might contain graphs, grid, etc
        var background = _this.background;
        background.cornerRadius(10, 10, 10, 10);
        background.fill = interfaceColors.getFor("fill");
        background.fillOpacity = 0.5;
        // Make system tooltips appear by default
        _this.showSystemTooltip = true;
        _this.startGrip = new ResizeButton_ResizeButton();
        _this.endGrip = new ResizeButton_ResizeButton();
        // Default orientation...
        // ... is set in `applyInternalDefaults()` because it accesses `language`
        // and should only be started to access when parent is set
        // Set events
        _this.events.on("transformed", _this.updateThumb, _this, false);
        // Initial positions
        _this.start = 0;
        _this.end = 1;
        // Set roles
        _this.role = "scrollbar";
        _this.thumb.role = "slider";
        _this.thumb.readerLive = "polite";
        _this.startGrip.role = "slider";
        _this.endGrip.role = "slider";
        // otherwise range changed wont' be registered
        _this.events.once("inited", function () {
            _this._previousStart = undefined;
            _this.dispatchRangeChange();
        }, undefined, false);
        _this.hideGrips = false;
        _this.orientation = "horizontal";
        // Min/max values for accessibility
        _this.setSVGAttribute({ "aria-valuemin": "0" });
        _this.setSVGAttribute({ "aria-valuemax": "100" });
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    Scrollbar.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Set screen reader tetxt accordingly
        if (this.orientation === "horizontal") {
            if (!hasValue(this.readerTitle)) {
                this.readerTitle = this.language.translate("Use TAB to select grip buttons or left and right arrows to change selection");
            }
            if (!hasValue(this.thumb.readerDescription)) {
                this.thumb.readerDescription = this.language.translate("Use left and right arrows to move selection");
            }
            if (!hasValue(this.startGrip.readerDescription)) {
                this.startGrip.readerDescription = this.language.translate("Use left and right arrows to move left selection");
            }
            if (!hasValue(this.endGrip.readerDescription)) {
                this.endGrip.readerDescription = this.language.translate("Use left and right arrows to move right selection");
            }
            this.readerOrientation = "horizontal";
        }
        else {
            if (!hasValue(this.readerTitle)) {
                this.readerTitle = this.language.translate("Use TAB select grip buttons or up and down arrows to change selection");
            }
            if (!hasValue(this.thumb.readerDescription)) {
                this.thumb.readerDescription = this.language.translate("Use up and down arrows to move selection");
            }
            if (!hasValue(this.startGrip.readerDescription)) {
                this.startGrip.readerDescription = this.language.translate("Use up and down arrows to move upper selection");
            }
            if (!hasValue(this.endGrip.readerDescription)) {
                this.endGrip.readerDescription = this.language.translate("Use up and down arrows to move lower selection");
            }
            this.readerOrientation = "vertical";
        }
        this.readerControls = this.baseSprite.uidAttr();
    };
    /**
     * Validates the layout of the scrollbar's elements.
     *
     * @ignore Exclude from docs
     */
    Scrollbar.prototype.validateLayout = function () {
        this.updateSize();
        _super.prototype.validateLayout.call(this);
        // when size changes, need to update extremes
        this.updateExtremes();
    };
    /**
     * Update background for the scrollbar.
     *
     * @ignore Exclude from docs
     */
    Scrollbar.prototype.processBackground = function () {
        _super.prototype.processBackground.call(this);
        var background = this.background;
        background.clickable = true;
        background.events.on("hit", this.handleBgHit, this, undefined);
    };
    /**
     * Zooms to the particular place when clicked/tapped on the scrollbar
     * background.
     *
     * @ignore Exclude from docs
     * @param event  Event
     */
    Scrollbar.prototype.handleBgHit = function (event) {
        this.makeBusy();
        var point = event.spritePoint;
        point = spritePointToSprite(point, this.background, this);
        var thumb = this.thumb;
        if (this.orientation == "horizontal") {
            var thumbX = point.x - thumb.pixelWidth / 2;
            thumbX = fitToRange(thumbX, 0, this.innerWidth - thumb.pixelWidth);
            this._thumbAnimation = thumb.animate({ property: "x", to: thumbX }, this.animationDuration, this.animationEasing);
        }
        else {
            var thumbY = point.y - thumb.pixelHeight / 2;
            thumbY = fitToRange(thumbY, 0, this.innerHeight - thumb.pixelHeight);
            this._thumbAnimation = thumb.animate({ property: "y", to: thumbY }, this.animationDuration, this.animationEasing);
        }
        if (this.animationDuration > 0) {
            this._thumbAnimation.events.on("animationended", this.makeUnbusy, this, false);
        }
        else {
            this._thumb.validate();
            this.makeUnbusy();
        }
    };
    /**
     * Set scrollbar as busy. (currently zooming)
     *
     * @ignore Exclude from docs
     */
    Scrollbar.prototype.makeBusy = function () {
        this._isBusy = true;
        this._skipRangeEvents = false;
        if (this._unbusyTimeout) {
            this.removeDispose(this._unbusyTimeout);
        }
        this._unbusyTimeout = undefined;
        this.stopAnimations();
    };
    /**
     * Stops all animations, currently playing for the scrollbar.
     *
     * @ignore Exclude from docs
     */
    Scrollbar.prototype.stopAnimations = function () {
        if (this._thumbAnimation) {
            this._thumbAnimation.stop(true);
        }
        if (this._zoomAnimation) {
            this._zoomAnimation.stop(true);
        }
    };
    /**
     * Cancels "busy" status of the Scrollbar.
     *
     * @ignore Exclude from docs
     */
    Scrollbar.prototype.makeUnbusy = function () {
        /**
         * We cannot make Scrollbar not busy right after release, because then axes
         * will take over controll and Scrollbar will start to animate.
         * Theorethically, it's not right to set timeout by `animationDuration`,
         * however we can not know all the durations of elements we scroll, so we
         * assume that animation duration will be the same as
         * `interpolationDuration` or `rangeChange` duration.
         */
        this._unbusyTimeout = this.setTimeout(this.makeUnbusyReal.bind(this), this.animationDuration * 1.1);
    };
    /**
     * [makeUnbusyReal description]
     *
     * @todo Description
     * @ignore Exclude from docs
     */
    Scrollbar.prototype.makeUnbusyReal = function () {
        this._usingGrip = undefined;
        this._isBusy = false;
        if (!this.updateWhileMoving) {
            this.dispatchRangeChange();
        }
    };
    /**
     * Disptatches rangechanged event if it really changed
     *
     * @ignore Exclude from docs
     */
    Scrollbar.prototype.dispatchRangeChange = function () {
        if (this._previousEnd != this.end || this._previousStart != this.start) {
            this._previousStart = this.start;
            this._previousEnd = this.end;
            this.dispatch("rangechanged");
        }
    };
    /**
     * Updates the "thumb" element. A draggable element between the grips.
     */
    Scrollbar.prototype.updateThumb = function () {
        if (!this.parent) {
            return;
        }
        var thumb = this.thumb;
        var start = this.start;
        var end = this.end;
        var startGrip = this.startGrip;
        var endGrip = this.endGrip;
        if (this.orientation == "horizontal") {
            var innerWidth_1 = this.innerWidth;
            thumb.width = innerWidth_1 * (end - start);
            thumb.maxX = innerWidth_1 - thumb.pixelWidth;
            thumb.x = start * innerWidth_1;
            startGrip.moveTo({ x: thumb.pixelX, y: 0 }, undefined, undefined, true); // overrides dragging
            endGrip.moveTo({ x: thumb.pixelX + thumb.pixelWidth, y: 0 }, undefined, undefined, true);
            startGrip.readerTitle = this.language.translate("From %1", undefined, this.adapter.apply("positionValue", {
                value: Math.round(start * 100) + "%",
                position: start
            }).value);
            startGrip.readerValueNow = "" + Math.round(start * 100);
            startGrip.readerValueText = startGrip.readerTitle;
            endGrip.readerTitle = this.language.translate("To %1", undefined, this.adapter.apply("positionValue", {
                value: Math.round(end * 100) + "%",
                position: end
            }).value);
            endGrip.readerValueNow = "" + Math.round(end * 100);
            endGrip.readerValueText = endGrip.readerTitle;
        }
        else {
            var innerHeight_1 = this.innerHeight;
            thumb.height = innerHeight_1 * (end - start);
            thumb.maxY = innerHeight_1 - thumb.pixelHeight;
            thumb.y = (1 - end) * innerHeight_1;
            startGrip.moveTo({ x: 0, y: thumb.pixelY + thumb.pixelHeight }, undefined, undefined, true);
            endGrip.moveTo({ x: 0, y: thumb.pixelY }, undefined, undefined, true);
            startGrip.readerTitle = this.language.translate("To %1", undefined, this.adapter.apply("positionValue", {
                value: Math.round((1 - start) * 100) + "%",
                position: (1 - start)
            }).value);
            startGrip.readerValueNow = "" + Math.round(start * 100);
            startGrip.readerValueText = startGrip.readerTitle;
            endGrip.readerTitle = this.language.translate("From %1", undefined, this.adapter.apply("positionValue", {
                value: Math.round((1 - end) * 100) + "%",
                position: (1 - end)
            }).value);
            endGrip.readerValueNow = "" + Math.round(end * 100);
            endGrip.readerValueText = endGrip.readerTitle;
        }
        // Add accessibility
        thumb.readerTitle = this.language.translate("From %1 to %2", undefined, this.adapter.apply("positionValue", {
            value: Math.round(start * 100) + "%",
            position: start
        }).value, this.adapter.apply("positionValue", {
            value: Math.round(end * 100) + "%",
            position: end
        }).value);
        thumb.readerValueNow = "" + Math.round(start * 100);
        thumb.readerValueText = thumb.readerTitle;
        this.readerValueNow = "" + Math.round(start * 100);
        this.readerValueText = thumb.readerTitle;
        if (!this._skipRangeEvents && this.updateWhileMoving) {
            this.dispatchRangeChange();
        }
    };
    /**
     * Updates extremes of the scrollbar.
     */
    Scrollbar.prototype.updateExtremes = function () {
        var orientation = this.orientation;
        var minX = 0;
        var minY = 0;
        var maxX = 0;
        var maxY = 0;
        if (orientation == "horizontal") {
            maxX = this.innerWidth;
            minY = maxY = this.innerHeight / 2;
        }
        else {
            maxY = this.innerHeight;
            minX = maxX = this.innerWidth / 2;
        }
        var startGrip = this.startGrip;
        startGrip.minX = minX;
        startGrip.maxX = maxX;
        startGrip.minY = minY;
        startGrip.maxY = maxY;
        var endGrip = this.endGrip;
        endGrip.minX = minX;
        endGrip.maxX = maxX;
        endGrip.minY = minY;
        endGrip.maxY = maxY;
        var thumb = this.thumb;
        thumb.minX = minX;
        thumb.maxX = maxX;
        thumb.minY = minY;
        thumb.maxY = maxY;
    };
    /**
     * Updates size of the scrollbar.
     */
    Scrollbar.prototype.updateSize = function () {
        var orientation = this.orientation;
        var startGrip = this.startGrip;
        if (startGrip) {
            startGrip.orientation = orientation;
        }
        if (this.endGrip) {
            this.endGrip.orientation = orientation;
        }
        var thumb = this.thumb;
        if (thumb) {
            if (orientation == "horizontal") {
                if (!isNumber(this._pixelWidth)) {
                    if (!(this.width instanceof Percent)) {
                        this.width = Percent_percent(100);
                    }
                }
                // this teorethically might be wrong, if user indeed sets height of a horizontal scrollbar in percent
                // however without this height might be equal to 100% if previous orientation was set to horizontal
                // so this is ok solution, in case user really wants to have scrollbar height set in percent,
                // he should do this after orientation.
                if (hasValue(this.percentHeight)) {
                    this.height = this.minHeight;
                }
                thumb.height = this.innerHeight;
                thumb.verticalCenter = "middle";
                thumb.horizontalCenter = "left";
            }
            else {
                if (!isNumber(this._pixelHeight)) {
                    if (!(this.height instanceof Percent)) {
                        this.height = Percent_percent(100);
                    }
                }
                // same as above with percentHeight
                if (hasValue(this.percentWidth)) {
                    this.width = this.minWidth;
                }
                thumb.width = this.innerWidth;
                thumb.verticalCenter = "top";
                thumb.horizontalCenter = "middle";
            }
        }
    };
    Object.defineProperty(Scrollbar.prototype, "isBusy", {
        /**
         * Indicates if the Scrollbar is currently "busy" (animating and or
         * performing zoom by user interaction).
         * @return boolean
         */
        get: function () {
            return this._isBusy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Scrollbar.prototype, "start", {
        /**
         * @return Position (0-1)
         */
        get: function () {
            return Math.min(this.getPosition(this._start), this.getPosition(this._end));
        },
        /**
         * ==========================================================================
         * POSITIONS
         * ==========================================================================
         * @hidden
         */
        /**
         * Relative position (0-1) of the start grip.
         *
         * @param position  Position (0-1)
         */
        set: function (position) {
            if (!this._isBusy) {
                this.__start = position;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Scrollbar.prototype, "__start", {
        /**
         * @return [description]
         */
        get: function () {
            return this._start;
        },
        /**
         * [__start description]
         *
         * @todo Description
         * @param position [description]
         */
        set: function (position) {
            this._start = this.getPosition(position);
            this.updateThumb();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Scrollbar.prototype, "end", {
        /**
         * @return Position (0-1)
         */
        get: function () {
            return Math.max(this.getPosition(this._start), this.getPosition(this._end));
        },
        /**
         * Relative position (0-1) of the end grip.
         *
         * @param position  Position (0-1)
         */
        set: function (position) {
            if (!this._isBusy) {
                this.__end = position;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Scrollbar.prototype, "__end", {
        /**
         * @return [description]
         */
        get: function () {
            return this._end;
        },
        /**
         * [__end description]
         *
         * @todo Description
         * @param position [description]
         */
        set: function (position) {
            this._end = this.getPosition(position);
            this.updateThumb();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Scrollbar.prototype, "range", {
        /**
         * Current selection range.
         *
         * @readonly
         * @return Range
         */
        get: function () {
            return { start: this.start, end: this.end, priority: this._usingGrip };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disables range change events.
     *
     * @ignore Exclude from docs
     */
    Scrollbar.prototype.skipRangeEvents = function () {
        if (!this._isBusy) {
            this._skipRangeEvents = true;
        }
    };
    /**
     * [fixRange description]
     *
     * @todo Description
     * @ignore Exclude from docs
     * @param range  Range
     */
    Scrollbar.prototype.fixRange = function (range) {
        if (range.start != Math_round(this._start, 2) || range.end != Math_round(this._end, 2)) {
            this._start = range.start;
            this._end = range.end;
            this._skipRangeEvents = true;
            this.updateThumb();
            this._skipRangeEvents = false;
            this.thumb.validate();
            this.thumb.background.validate();
        }
    };
    /**
     * [getPosition description]
     *
     * @todo Description
     * @param position  [description]
     * @return [description]
     */
    Scrollbar.prototype.getPosition = function (position) {
        return fitToRange(Math_round(position, 4), 0, 1);
    };
    Object.defineProperty(Scrollbar.prototype, "orientation", {
        /**
         * @return Orientation
         */
        get: function () {
            return this.getPropertyValue("orientation");
        },
        /**
         * ==========================================================================
         * MISC
         * ==========================================================================
         * @hidden
         */
        /**
         * Orientation of the scrollbar.
         *
         * Available options: "horizontal" (default) and "vertical".
         *
         * @default "horizontal"
         * @param value  Orientation
         */
        set: function (value) {
            if (this.setPropertyValue("orientation", value)) {
                // Set mouse cursors and screen reader tetxt accordingly
                if (value === "horizontal") {
                    // Mouse styles
                    this.startGrip.cursorOverStyle = MouseCursorStyle.horizontalResize;
                    this.endGrip.cursorOverStyle = MouseCursorStyle.horizontalResize;
                    // Reader text
                    /*this.readerTitle = this.language.translate("Use TAB to select grip buttons or left and right arrows to change selection");
                    this.thumb.readerDescription = this.language.translate("Use left and right arrows to move selection");
                    this.startGrip.readerDescription = this.language.translate("Use left and right arrows to move left selection");
                    this.endGrip.readerDescription = this.language.translate("Use left and right arrows to move right selection");*/
                }
                else {
                    // Mouse styles
                    this.startGrip.cursorOverStyle = MouseCursorStyle.verticalResize;
                    this.endGrip.cursorOverStyle = MouseCursorStyle.verticalResize;
                    // Reader text
                    /*this.readerTitle = this.language.translate("Use TAB select grip buttons or up and down arrows to change selection");
                    this.thumb.readerDescription = this.language.translate("Use up and down arrows to move selection");
                    this.startGrip.readerDescription = this.language.translate("Use up and down arrows to move upper selection");
                    this.endGrip.readerDescription = this.language.translate("Use up and down arrows to move lower selection");*/
                }
                this.updateByOrientation();
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    Scrollbar.prototype.updateByOrientation = function () {
    };
    Object.defineProperty(Scrollbar.prototype, "startGrip", {
        /**
         * @return Grip element
         */
        get: function () {
            return this._startGrip;
        },
        /**
         * ==========================================================================
         * GRIPS
         * ==========================================================================
         * @hidden
         */
        /**
         * Start grip element. (button)
         *
         * @param button  Grip element
         */
        set: function (button) {
            if (this._startGrip) {
                this.removeDispose(this._startGrip);
            }
            this._startGrip = button;
            this.processGrip(button);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Scrollbar.prototype, "endGrip", {
        /**
         * @return Grip element
         */
        get: function () {
            return this._endGrip;
        },
        /**
         * End grip element. (button)
         *
         * @param button  Grip element
         */
        set: function (button) {
            if (this._endGrip) {
                this.removeDispose(this._endGrip);
            }
            this._endGrip = button;
            this.processGrip(button);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Decorates the grip button with properties and events.
     *
     * @ignore Exclude from docs
     * @param button Grip button
     */
    Scrollbar.prototype.processGrip = function (button) {
        button.parent = this;
        button.isMeasured = false;
        button.focusable = true;
        button.shouldClone = false;
        // Set button defaults
        //button.showSystemTooltip = true; // setting this here is not right because we break inheritance
        button.zIndex = 100;
        button.events.on("drag", this.handleGripDrag, this, false);
        button.events.on("dragstop", this.makeUnbusy, this, false);
        button.events.on("down", this.makeBusy, this, false);
        this._disposers.push(button);
    };
    /**
     * Updates positions of related elements after grip element is dragged.
     *
     * @ignore Exclude from docs
     * @param event  Event
     */
    Scrollbar.prototype.handleGripDrag = function (event) {
        this.makeBusy();
        if (event.target === this._startGrip) {
            this._usingGrip = "start";
        }
        else {
            this._usingGrip = "end";
        }
        if (this.orientation == "horizontal") {
            this._start = this.startGrip.pixelX / this.innerWidth;
            this._end = this.endGrip.pixelX / this.innerWidth;
        }
        else {
            this._start = 1 - this.startGrip.pixelY / this.innerHeight;
            this._end = 1 - this.endGrip.pixelY / this.innerHeight;
        }
        this.updateThumb();
    };
    Object.defineProperty(Scrollbar.prototype, "thumb", {
        /**
         * @return Thumb element
         */
        get: function () {
            if (!this._thumb) {
                // Create scrollbar controls (setters will handle adding disposers)
                var thumb = new Button_Button();
                thumb.background.cornerRadius(10, 10, 10, 10);
                thumb.padding(0, 0, 0, 0);
                this.thumb = thumb;
            }
            return this._thumb;
        },
        /**
         * A "thumb" element.
         *
         * It's a draggable square space between the grips, that can be used to
         * pan the selection.
         *
         * @param thumb  Thumb element
         */
        set: function (thumb) {
            var _this = this;
            if (thumb) {
                if (this._thumb) {
                    this.removeDispose(this._thumb);
                }
                this._thumb = thumb;
                thumb.parent = this;
                thumb.isMeasured = false;
                thumb.inert = true;
                thumb.draggable = true;
                thumb.clickable = true;
                thumb.hoverable = true;
                thumb.focusable = true;
                thumb.shouldClone = false;
                thumb.zIndex = 0;
                // TODO remove closures ?
                // Add events
                // Add cursor styles to thumb
                thumb.cursorOverStyle = MouseCursorStyle.grab;
                thumb.cursorDownStyle = MouseCursorStyle.grabbing;
                thumb.events.on("dragstart", this.makeBusy, this, false);
                thumb.events.on("dragstop", this.makeUnbusy, this, false);
                thumb.events.on("positionchanged", this.handleThumbPosition, this, false);
                thumb.events.on("sizechanged", this.handleThumbPosition, this, false);
                thumb.events.on("doublehit", this.handleDoubleClick, this, false);
                // Add event for space and ENTER to toggle full zoom out and back
                // (same as doubleclick)
                this._disposers.push(getInteraction().body.events.on("keyup", function (ev) {
                    if (keyboard.isKey(ev.event, ["space", "enter"]) && _this.thumb.isFocused) {
                        ev.event.preventDefault();
                        _this.handleDoubleClick();
                    }
                }));
                this._disposers.push(this._thumb);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Zooms-in and out the selection on double-click of the thumb.
     *
     * @ignore Exclude from docs
     */
    Scrollbar.prototype.handleDoubleClick = function () {
        this.makeBusy();
        var newStart = 0;
        var newEnd = 1;
        if (this.start != 0 || this.end != 1) {
            this._prevStart = this.start;
            this._prevEnd = this.end;
        }
        else {
            newStart = this._prevStart;
            newEnd = this._prevEnd;
        }
        var zoomAnimation = this.animate([{ property: "__start", to: newStart }, { property: "__end", to: newEnd }], this.animationDuration, this.animationEasing);
        if (zoomAnimation && !zoomAnimation.isFinished()) {
            zoomAnimation.events.on("animationended", this.makeUnbusy, this, false);
            this._zoomAnimation = zoomAnimation;
        }
        else {
            this.makeUnbusy();
        }
    };
    /**
     * Updates positions of other elements when thumb is moved.
     *
     * @ignore Exclude from docs
     */
    Scrollbar.prototype.handleThumbPosition = function () {
        var thumb = this.thumb;
        if (this.orientation == "horizontal") {
            var innerWidth_2 = this.innerWidth;
            var w = thumb.innerWidth;
            var x = thumb.pixelX;
            this._start = x / innerWidth_2;
            this._end = (x + w) / innerWidth_2;
            this.updateThumb();
        }
        else {
            var innerHeight_2 = this.innerHeight;
            var h = thumb.innerHeight;
            var y = thumb.pixelY;
            this._start = 1 - (y + h) / innerHeight_2;
            this._end = 1 - y / innerHeight_2;
            this.updateThumb();
        }
    };
    /**
     * Creates a background element for the scrollbar.
     *
     * @ignore Exclude from docs
     * @return Background
     */
    Scrollbar.prototype.createBackground = function () {
        return new RoundedRectangle_RoundedRectangle();
    };
    Object.defineProperty(Scrollbar.prototype, "hideGrips", {
        /**
         * @return Show only on hover?
         */
        get: function () {
            return this._hideGrips;
        },
        /**
         * Use this property to set whether grips should be always visible (`false`),
         * or they should just appear on scrollbar hover (`true`).
         *
         * @param value  Show only on hover?
         */
        set: function (value) {
            var _this = this;
            this._hideGrips = value;
            if (this._overDisposer) {
                this.removeDispose(this._overDisposer);
            }
            if (this._outDisposer) {
                this.removeDispose(this._outDisposer);
            }
            if (value) {
                this._overDisposer = this.events.on("over", function () {
                    _this.startGrip.show();
                    _this.endGrip.show();
                }, undefined, false);
                this._outDisposer = this.events.on("out", function () {
                    _this.startGrip.hide();
                    _this.endGrip.hide();
                }, undefined, false);
                this.startGrip.hide();
                this.endGrip.hide();
            }
            else {
                this.startGrip.show();
                this.endGrip.show();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Scrollbar.prototype, "animationDuration", {
        /**
         * @return Orientation
         */
        get: function () {
            return this.getPropertyValue("animationDuration");
        },
        /**
         * Duration in milliseconds of scrollbar animation (happens when user clicks on a background of a scrollbar)
         * @default 0
         * @param value number
         */
        set: function (value) {
            this.setPropertyValue("animationDuration", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Scrollbar.prototype, "animationEasing", {
        /**
         * @return {Function}
         */
        get: function () {
            return this.getPropertyValue("animationEasing");
        },
        /**
         * Animation easing function.
         * @todo: review description and default
         * @default $ease.cubicOut
         * @param value (value: number) => number
         */
        set: function (value) {
            this.setPropertyValue("animationEasing", value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds easing functions to "function" fields.
     *
     * @param field  Field name
     * @return Assign as function?
     */
    Scrollbar.prototype.asFunction = function (field) {
        return field == "animationEasing" || _super.prototype.asIs.call(this, field);
    };
    return Scrollbar;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Scrollbar"] = Scrollbar_Scrollbar;
//# sourceMappingURL=Scrollbar.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Slider.js
/**
 * Slider is a scrollbar with just one selection grip.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a slider - a version of scrollbar with just one grip.
 *
 * @see {@link ISliderEvents} for a list of available events
 * @see {@link ISliderAdapters} for a list of available Adapters
 */
var Slider_Slider = /** @class */ (function (_super) {
    __extends(Slider, _super);
    /**
     * Constructor
     */
    function Slider() {
        var _this = _super.call(this) || this;
        _this.className = "Slider";
        _this.thumb.opacity = 0;
        _this.thumb.interactionsEnabled = false;
        _this.endGrip.opacity = 0;
        _this.endGrip.interactionsEnabled = false;
        _this.startGrip.events.on("drag", function () {
            _this.endGrip.x = _this.startGrip.x;
            _this.endGrip.y = _this.startGrip.y;
        });
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(Slider.prototype, "__end", {
        /**
         * @return [description]
         */
        get: function () {
            return this._start;
        },
        set: function (value) {
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "end", {
        /**
         * @return [description]
         */
        get: function () {
            return this._start;
        },
        /**
         * Relative position (0-1) of the end grip.
         *
         * @param position  Position (0-1)
         */
        set: function (position) {
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "start", {
        /**
         * @return Position (0-1)
         */
        get: function () {
            return this._start;
        },
        /**
         * Relative position (0-1) of the start grip.
         *
         * @param position  Position (0-1)
         */
        set: function (position) {
            if (!this._isBusy) {
                this.__start = position;
            }
        },
        enumerable: true,
        configurable: true
    });
    return Slider;
}(Scrollbar_Scrollbar));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Slider"] = Slider_Slider;
//# sourceMappingURL=Slider.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/TextLink.js
/**
 * A module that defines Text element used to indicate links.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a text element with a link.
 *
 * @see {@link ITextLinkEvents} for a list of available events
 * @see {@link ITextLinkAdapters} for a list of available Adapters
 */
var TextLink_TextLink = /** @class */ (function (_super) {
    __extends(TextLink, _super);
    /**
     * Constructor
     */
    function TextLink() {
        var _this = _super.call(this) || this;
        _this.className = "TextLink";
        _this.selectable = true;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.fill = interfaceColors.getFor("primaryButton").brighten(0.3);
        var hoverState = _this.states.create("hover");
        hoverState.properties.fill = interfaceColors.getFor("primaryButtonHover").brighten(0.3);
        var downState = _this.states.create("down");
        downState.properties.fill = interfaceColors.getFor("primaryButtonDown").brighten(0.3);
        _this.cursorOverStyle = MouseCursorStyle.pointer;
        _this.applyTheme();
        return _this;
    }
    return TextLink;
}(Label_Label));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["TextLink"] = TextLink_TextLink;
//# sourceMappingURL=TextLink.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/filters/Filter.js
/**
 * This module contains a base class for an SVG filter.
 *
 * Filters can be used to decorate, change and transform just about any DOM
 * element.
 *
 * A Filter works by applying one or more effects (primitives) to SVG element.
 *
 * For more information on how SVG filters work, refer to
 * [this MDN tutorial](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/SVG_Filters_Tutorial).
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Base filter class.
 *
 * This class while can be instantiated will not do anything. It is just a base
 * functionality for any other "real" filters to extend.
 *
 * Filters can be used to decorate, change and transform just about any DOM
 * element.
 *
 * A Filter works by applying one or more effects (primitives) to SVG element.
 *
 * For more information on how SVG filters work, refer to
 * [this MDN tutorial](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/SVG_Filters_Tutorial).
 *
 * @todo Example
 */
var Filter_Filter = /** @class */ (function (_super) {
    __extends(Filter, _super);
    /**
     * Constructor
     */
    function Filter() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * A storage for Filter property/value pairs.
         *
         * @ignore Exclude from docs
         * @see {@link FilterProperties}
         */
        _this.properties = {};
        /**
         * Identifies if this object is a "template" and should not be treated as
         * real object that is drawn or actually used in the chart.
         */
        _this.isTemplate = false;
        /**
         * [_scale description]
         *
         * @todo Description
         */
        _this._scale = 1;
        /**
         * [_nonScaling description]
         *
         * @todo Description
         */
        _this._nonScaling = true;
        _this.className = "Filter";
        // Create a list to hold primitives (effect elements)
        _this.filterPrimitives = new List_List();
        _this.properties.filterUnits = "objectBoundingBox";
        // Automatically add added primitives to `_disposers` so they are discarded
        // when Filter object is destroyed (disposed)
        _this.filterPrimitives.events.on("inserted", function (ev) {
            _this._disposers.push(ev.newValue);
        });
        // Set default dimensions
        _this.width = 120;
        _this.height = 120;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Appends actual filter elements to the filter group.
     *
     * @ignore Exclude from docs
     * @param filterElement An SVG `<group>` element to add filter element to
     */
    Filter.prototype.appendPrimitives = function (filterElement) {
        Iterator_each(this.filterPrimitives.iterator(), function (filterPrimitive) {
            filterElement.add(filterPrimitive);
        });
    };
    /**
     * Uses Transitions filter's values from current to target. This is used to
     * smoothly appear filter, rather than it pop into effect.
     *
     * @ignore Exclude from docs
     * @param animationOptions  Animation options
     * @param duration          Duration in milliseconds
     * @param easing            Easing function
     * @return Animation instance
     */
    Filter.prototype.animate = function (animationOptions, duration, easing) {
        var animation = new Animation_Animation(this, animationOptions, duration, easing).start();
        return animation;
    };
    Object.defineProperty(Filter.prototype, "width", {
        /**
         * @return Width (%)
         */
        get: function () {
            return this.properties["width"];
        },
        /**
         * Width of the filter element in percent.
         *
         * If the filter is designed to "bleed out" of the original target element,
         * like for example a shadow, you need this bigger than 100, or the
         * non-fitting parts will be clipped.
         *
         * @default 120
         * @param value Width (px)
         */
        set: function (value) {
            this.properties["width"] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter.prototype, "height", {
        /**
         * @return Height
         */
        get: function () {
            return this.properties["height"];
        },
        /**
         * Height of the filter element in percent.
         *
         * If the filter is designed to "bleed out" of the original target element,
         * like for example a shadow, you need this bigger than 100, or the
         * non-fitting parts will be clipped.
         *
         * @default 120
         * @param value Height (%)
         */
        set: function (value) {
            this.properties["height"] = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies properties from another [[Filter]] object.
     *
     * @param filter Source [[Filter]] object
     */
    Filter.prototype.copyFrom = function (filter) {
        var _this = this;
        _super.prototype.copyFrom.call(this, filter);
        Object_each(filter.properties, function (key, value) {
            _this[key] = value;
        });
    };
    Object.defineProperty(Filter.prototype, "paper", {
        /**
         * @return Paper
         */
        get: function () {
            if (this._paper) {
                return this._paper;
            }
            return getGhostPaper();
        },
        /**
         * Sets [[Paper]] instance to create filter's elements in.
         *
         * @ignore Exclude from docs
         * @param paper  Paper
         */
        set: function (paper) {
            if (this._paper != paper) {
                this._paper = paper;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter.prototype, "animations", {
        /**
         * All animations currently in play.
         *
         * @ignore Exclude from docs
         * @return List of animations
         */
        get: function () {
            if (!this._animations) {
                this._animations = [];
                this._disposers.push(new Animation_AnimationDisposer(this._animations));
            }
            return this._animations;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter.prototype, "scale", {
        /**
         * @ignore Exclude from docs
         */
        get: function () {
            return this._scale;
        },
        /**
         * [[Sprite]] uses this method to inform filter about it's scale.
         *
         * @ignore Exclude from docs
         */
        set: function (value) {
            this._scale = value;
            this.updateScale();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates filter properties which depend on scale.
     *
     * @ignore Exclude from docs
     */
    Filter.prototype.updateScale = function () {
        // Dummy method for extending classes to override.
    };
    Object.defineProperty(Filter.prototype, "filterUnits", {
        /**
         * @return Filter units
         */
        get: function () {
            return this.properties.filterUnits;
        },
        /**
         * Which units are used when drawing filter.
         *
         * Use `"userSpaceOnUse"` when applying filters on a perfectly straight line.
         *
         * @since 4.9.17
         * @default objectBoundingBox
         * @param value Filter units
         */
        set: function (value) {
            this.properties.filterUnits = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter.prototype, "nonScaling", {
        /**
         * @return Non scaling?
         */
        get: function () {
            return this._nonScaling;
        },
        /**
         * If a filter is non scaling, it will look the same even if the sprite is
         * scaled, otherwise filter will scale together with a [[Sprite]].
         *
         * @default false
         * @param value  Non scaling?
         */
        set: function (value) {
            this._nonScaling = value;
            if (!value) {
                this._scale = 1;
            }
            this.updateScale();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter.prototype, "sprite", {
        /**
         * A target element this filter is currently attached to.
         *
         * We need to keep track of it because one filter can be used for just one
         * element, so we have to remove it from the old "parent" when attaching to
         * the new one.
         *
         * @ignore Exclude from docs
         * @param value  Target element
         */
        set: function (value) {
            this.setSprite(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets filter's target element.
     *
     * @ignore Exclude from docs
     * @param value  Element filter is being attached to
     */
    Filter.prototype.setSprite = function (value) {
        if (this._sprite && this._sprite != value) {
            this._sprite.filters.removeValue(this);
        }
        this._sprite = value;
    };
    return Filter;
}(Base_BaseObject));

//# sourceMappingURL=Filter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/filters/DropShadowFilter.js
/**
 * Module for "Drop Shadow" filter.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creats a "Drop Shadow" filter.
 */
var DropShadowFilter_DropShadowFilter = /** @class */ (function (_super) {
    __extends(DropShadowFilter, _super);
    /**
     * Constructor
     */
    function DropShadowFilter() {
        var _this = _super.call(this) || this;
        _this.className = "DropShadowFilter";
        // Create elements
        // NOTE: we do not need to add each individual element to `_disposers`
        // because `filterPrimitives` has an event handler which automatically adds
        // anything added to it to `_disposers`
        _this.color = Color_color("#000");
        _this.feGaussianBlur = _this.paper.add("feGaussianBlur");
        _this.feGaussianBlur.attr({ "result": "blurOut", "in": "SourceGraphic" });
        _this.filterPrimitives.push(_this.feGaussianBlur);
        _this.feOffset = _this.paper.add("feOffset");
        _this.feOffset.attr({ "result": "offsetBlur" });
        _this.filterPrimitives.push(_this.feOffset);
        _this.feFlood = _this.paper.add("feFlood");
        _this.feFlood.attr({ "flood-color": _this.color });
        _this.filterPrimitives.push(_this.feFlood);
        _this.feComposite = _this.paper.add("feComposite");
        _this.feComposite.attr({ "in2": "offsetBlur", operator: "in" });
        _this.filterPrimitives.push(_this.feComposite);
        _this.feMerge = _this.paper.addGroup("feMerge");
        _this.feMerge.add(_this.paper.add("feMergeNode"));
        _this.feMerge.add(_this.paper.add("feMergeNode").attr({ "in": "SourceGraphic" }));
        _this.filterPrimitives.push(_this.feMerge);
        // Set default properties
        _this.width = 200;
        _this.height = 200;
        _this.blur = 1.5;
        _this.dx = 3;
        _this.dy = 3;
        _this.opacity = 0.5;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(DropShadowFilter.prototype, "color", {
        /**
         * @return Color
         */
        get: function () {
            return this.properties.color;
        },
        /**
         * Shadow color.
         *
         * @param value  Color
         */
        set: function (value) {
            this.properties.color = value;
            if (this.feFlood) {
                this.feFlood.attr({ "flood-color": value });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropShadowFilter.prototype, "opacity", {
        /**
         * @return Opacity (0-1)
         */
        get: function () {
            return this.properties.opacity;
        },
        /**
         * Opacity of the shadow. (0-1)
         *
         * @param value  Opacity (0-1)
         */
        set: function (value) {
            this.properties.opacity = value;
            this.feFlood.attr({ "flood-opacity": value });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropShadowFilter.prototype, "dx", {
        /**
         * @return Horizontal offset (px)
         */
        get: function () {
            return this.properties.dx;
        },
        /**
         * Horizontal offset in pixels.
         *
         * @param value  Horizontal offset (px)
         */
        set: function (value) {
            this.properties.dx = value;
            this.feOffset.attr({ "dx": value / this.scale });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropShadowFilter.prototype, "dy", {
        /**
         * @return Vertical offset (px)
         */
        get: function () {
            return this.properties.dy;
        },
        /**
         * Vertical offset in pixels.
         *
         * @param value Vertical offset (px)
         */
        set: function (value) {
            this.properties.dy = value;
            this.feOffset.attr({ "dy": value / this.scale });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DropShadowFilter.prototype, "blur", {
        /**
         * @return Blur
         */
        get: function () {
            return this.properties.blur;
        },
        /**
         * Blur.
         *
         * @param value  Blur
         */
        set: function (value) {
            this.properties.blur = value;
            this.feGaussianBlur.attr({ "stdDeviation": value / this.scale });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * [updateScale description]
     *
     * @todo Description
     */
    DropShadowFilter.prototype.updateScale = function () {
        this.dx = this.dx;
        this.dy = this.dy;
        this.blur = this.blur;
    };
    return DropShadowFilter;
}(Filter_Filter));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["DropShadowFilter"] = DropShadowFilter_DropShadowFilter;
//# sourceMappingURL=DropShadowFilter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Tooltip.js
/**
 * Provides functionality used to creating and showing tooltips (balloons).
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */










/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Tooltip displays text and/or multimedia information in a balloon over chart
 * area.
 * @see {@link ITooltipEvents} for a list of available events
 * @see {@link ITooltipAdapters} for a list of available Adapters
 */
var Tooltip_Tooltip = /** @class */ (function (_super) {
    __extends(Tooltip, _super);
    /**
     * Constructor
     */
    function Tooltip() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Holds numeric boundary values. Calculated from the `boundingContainer`.
         * @ignore
         */
        _this._boundingRect = { x: -40000, y: -40000, width: 80000, height: 80000 };
        /**
         * Coordinates tooltip's pointer (stem) should point to.
         */
        _this._pointTo = { x: 0, y: 0 };
        /**
         * If set to `true` the pointer/stem of the Tooltip will not go outside
         * Tooltip's width or height depending on pointer's orientation.
         *
         * @default false
         */
        _this.fitPointerToBounds = false;
        /**
         * If `tooltipOrientation` is vertical, it can be drawn below or above point
         * We need to know this when solving overlapping.
         */
        _this._verticalOrientation = "up";
        _this.className = "Tooltip";
        _this.isMeasured = false;
        _this.getFillFromObject = true;
        _this.margin(5, 5, 5, 5);
        _this.defaultState.transitionDuration = 1;
        _this.hiddenState.transitionDuration = 1;
        // Create chrome/background
        var background = _this.background;
        background.interactionsEnabled = false;
        background.fillOpacity = 0.9;
        background.strokeWidth = 1;
        background.strokeOpacity = 1;
        background.stroke = Color_color("#ffffff");
        background.cornerRadius = 3;
        background.pointerLength = 6;
        background.pointerBaseWidth = 10;
        var dropShadow = new DropShadowFilter_DropShadowFilter();
        dropShadow.dy = 1;
        dropShadow.dx = 1;
        dropShadow.opacity = 0.5;
        background.filters.push(dropShadow);
        _this.autoTextColor = true;
        // Create text element
        var label = _this.createChild(Label_Label);
        label.shouldClone = false;
        _this.label = label;
        label.padding(7, 12, 4, 12);
        label.interactionsEnabled = false;
        label.horizontalCenter = "middle";
        label.fill = Color_color("#ffffff");
        _this._disposers.push(label);
        _this.label.events.on("sizechanged", _this.drawBackground, _this);
        _this.label.zIndex = 1; // @todo remove this line when bg sorting is solved
        // Set defaults
        _this.pointerOrientation = "vertical";
        _this.animationDuration = 0;
        _this.animationEasing = cubicOut;
        _this.setPropertyValue("showInViewport", false);
        // Set accessibility options
        _this.role = "tooltip";
        _this.visible = false;
        _this.opacity = 0;
        _this.x = 0;
        _this.y = 0;
        _this.events.on("visibilitychanged", _this.handleVisibility, _this);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    Tooltip.prototype.handleVisibility = function () {
        if (this.visible) {
            this.label.invalidate();
        }
    };
    Object.defineProperty(Tooltip.prototype, "getStrokeFromObject", {
        /**
         * Specifies if tooltip background should get stroke color from the sprite it is pointing to.
         *
         * @return {boolean}
         * @default false
         */
        get: function () {
            return this.getPropertyValue("getStrokeFromObject");
        },
        /**
         * Specifies if tooltip background should get stroke color from the sprite it is pointing to.
         *
         * @param value boolean
         */
        set: function (value) {
            this.setPropertyValue("getStrokeFromObject", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "autoTextColor", {
        /**
         * @return {boolean}
         */
        get: function () {
            return this.getPropertyValue("autoTextColor");
        },
        /**
         * Specifies if text color should be chosen automatically for a better
         * readability.
         *
         * IMPORTANT: this feature is generally ignored, if `getFillFromObject = false`.
         *
         * If inheriting of `fill` color from object tooltip is displayed for is
         * disabled, this feature will not work. If you are explicitly setting a
         * color for tooltip background, you may set a color for its label as well
         * using `tooltip.label.fill` property.
         *
         *
         * @param value boolean
         */
        set: function (value) {
            this.setPropertyValue("autoTextColor", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "keepTargetHover", {
        /**
         * @return Keep target hovered?
         */
        get: function () {
            return this.getPropertyValue("keepTargetHover");
        },
        /**
         * If this tooltip is displayed on hover on some other object, keep that
         * element hovered if hovering on the tooltip.
         *
         * @default false
         * @since 4.1.13
         * @param  value  Keep target hovered?
         */
        set: function (value) {
            var _this = this;
            if (this.setPropertyValue("keepTargetHover", value, true)) {
                if (value) {
                    this.hoverable = true;
                    this.background.interactionsEnabled = true;
                    this._disposers.push(this.events.on("over", function (ev) {
                        if (_this.targetSprite && _this.targetSprite.hoverable) {
                            _this.targetSprite.isHover = true;
                        }
                    }));
                    this._disposers.push(this.events.on("out", function (ev) {
                        if (_this.targetSprite && _this.targetSprite.hoverable) {
                            //this.hideTooltip();
                            //this.targetSprite.handleOut();
                            _this.targetSprite.isHover = false;
                        }
                    }));
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "showInViewport", {
        /**
         * @return Force showing tooltip?
         */
        get: function () {
            return this.getPropertyValue("showInViewport");
        },
        /**
         * Normally, a tooltip will hide itself if it is pointing to a coordinate
         * that is outside viewport.
         *
         * Setting this setting to `true` will override that and make tooltip
         * appear next to the viewport edge closest to the target point.
         *
         * @default false
         * @since 4.5.7
         * @param  value  Force showing tooltip?
         */
        set: function (value) {
            this.setPropertyValue("showInViewport", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "getFillFromObject", {
        /**
         * Specifies if tooltip background should get fill color from the sprite it is pointing to.
         *
         * @return {boolean}
         * @default true
         */
        get: function () {
            return this.getPropertyValue("getFillFromObject");
        },
        /**
         * @param value boolean
         */
        set: function (value) {
            this.setPropertyValue("getFillFromObject", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates and returns a background element.
     *
     * @ignore Exclude from docs
     * @return Background
     */
    Tooltip.prototype.createBackground = function () {
        return new PointedRectangle_PointedRectangle();
    };
    Object.defineProperty(Tooltip.prototype, "pointerOrientation", {
        /**
         * @return Orientation
         */
        get: function () {
            return this.getPropertyValue("pointerOrientation");
        },
        /**
         * Pointer orientation: `"horizontal"`, `"vertical"`, `"up"`, `"down"`,
         * `"right"`, or `"left"`.
         *
         * Options`"horizontal"` or `"vertical"` are location-aware, meaning they
         * will change position of the Tooltip based on the target point's position
         * in relation to chart center.
         *
         * Options `"up"`, `"down"`, `"right"`, `"left"` are static and will point
         * in the specified direction regardless of the position, even if that means
         * going out of chart/screen bounds.
         *
         * IMPORTANT: in some situations, like having multiple tooltips stacked for
         * multiple series, the `"up"` and `"down"` values might be ignored in order
         * to make tooltip overlap algorithm work.
         *
         * @default "vertical"
         * @param  value  Orientation
         */
        set: function (value) {
            this.setPropertyValue("pointerOrientation", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "animationDuration", {
        /**
         * @return Orientation
         */
        get: function () {
            return this.getPropertyValue("animationDuration");
        },
        /**
         * Duration in milliseconds for the animation to take place when the tooltip
         * is moving from one place to another.
         *
         * @default 0
         * @param value  number
         */
        set: function (value) {
            this.setPropertyValue("animationDuration", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "animationEasing", {
        /**
         * @return {Function}
         */
        get: function () {
            return this.getPropertyValue("animationEasing");
        },
        /**
         * Tooltip animation (moving from one place to another) easing function.
         *
         * @default $ease.cubicOut
         * @param value (value: number) => number
         */
        set: function (value) {
            this.setPropertyValue("animationEasing", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "html", {
        /**
         * @return HTML content
         */
        get: function () {
            return this.label.html;
        },
        /**
         * HTML content for the Tooltip.
         *
         * Provided value will be used as is, without applying any further
         * formatting to it.
         *
         * @param value  HTML content
         */
        set: function (value) {
            if (this.label.html != value) {
                this.label.html = value;
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "text", {
        /**
         * @return SVG text
         */
        get: function () {
            return this.label.text;
        },
        /**
         * SVG text content for the Tooltip.
         *
         * Text can have a number of formatting options supported by
         * [[TextFormatter]].
         *
         * @param value  SVG text
         */
        set: function (value) {
            if (this.label.text != value) {
                this.label.text = value;
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates the Tooltip.
     *
     * @ignore Exclude from docs
     */
    Tooltip.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var label = this.label;
        if (label.invalid) {
            label.validate();
        }
        var x = this._pointTo.x;
        var y = this._pointTo.y;
        var boundingRect = this._boundingRect;
        var textW = label.measuredWidth;
        var textH = label.measuredHeight;
        var pointerLength = this.background.pointerLength;
        var textX;
        var textY;
        // try to handle if text is wider than br
        if (textW > boundingRect.width) {
            // TODO maybe this isn't needed ?
            spritePointToDocument({ x: boundingRect.x, y: boundingRect.y }, this.parent);
            var p1 = spritePointToDocument({ x: boundingRect.x + boundingRect.width, y: boundingRect.y + boundingRect.height }, this.parent);
            var documentWidth = document.body.offsetWidth;
            // TODO maybe this isn't needed ?
            used(document.body.offsetHeight);
            if (p1.x > documentWidth / 2) {
                boundingRect.x = boundingRect.width - textW;
            }
            else {
                boundingRect.width = boundingRect.x + textW;
            }
        }
        var pointerOrientation = this.pointerOrientation;
        // horizontal
        if (pointerOrientation == "horizontal" || pointerOrientation == "left" || pointerOrientation == "right") {
            textY = -textH / 2;
            if (pointerOrientation == "horizontal") {
                if (x > boundingRect.x + boundingRect.width / 2) {
                    textX = -textW / 2 - pointerLength;
                }
                else {
                    textX = textW / 2 + pointerLength;
                }
            }
            else if (pointerOrientation == "left") {
                textX = textW / 2 + pointerLength;
            }
            else {
                textX = -textW / 2 - pointerLength;
            }
        }
        // vertical pointer
        else {
            textX = fitToRange(0, boundingRect.x - x + textW / 2, boundingRect.x - x + boundingRect.width - textW / 2);
            if (pointerOrientation == "vertical") {
                if (y > boundingRect.y + textH + pointerLength) {
                    textY = -textH - pointerLength;
                    this._verticalOrientation = "up";
                }
                else {
                    textY = pointerLength;
                    this._verticalOrientation = "down";
                }
            }
            else if (pointerOrientation == "down") {
                textY = -textH - pointerLength;
                this._verticalOrientation = "up";
            }
            else {
                textY = pointerLength;
                this._verticalOrientation = "down";
            }
        }
        textY = fitToRange(textY, boundingRect.y - y, boundingRect.y + boundingRect.height - textH - y);
        label.x = textX;
        label.y = textY;
        this.drawBackground();
    };
    /**
     * Overrides functionality from the superclass.
     *
     * @ignore Exclude from docs
     */
    Tooltip.prototype.updateBackground = function () {
        this.group.addToBack(this.background.group);
    };
    /**
     * Draws Tooltip background (chrome, background and pointer/stem).
     *
     * @ignore Exclude from docs
     */
    Tooltip.prototype.drawBackground = function () {
        var label = this.label;
        var background = this.background;
        var textWidth = label.measuredWidth;
        var textHeight = label.measuredHeight;
        var boundingRect = this._boundingRect;
        var bgWidth = textWidth;
        var bgX = label.pixelX - textWidth / 2;
        var bgHeight = textHeight;
        var bgY = label.pixelY;
        var x = this._pointTo.x;
        var y = this._pointTo.y;
        var boundX1 = boundingRect.x - x;
        var boundX2 = boundX1 + boundingRect.width;
        var boundY1 = boundingRect.y - y;
        var boundY2 = boundY1 + boundingRect.height;
        background.x = bgX;
        background.y = bgY;
        background.width = bgWidth;
        background.height = bgHeight;
        if (this.fitPointerToBounds) {
            background.pointerX = fitToRange(-background.x, boundX1 - background.x, boundX2 - background.x);
            background.pointerY = fitToRange(-background.y, boundY1 - background.y, boundY2 - background.y);
        }
        else {
            background.pointerX = -background.x;
            background.pointerY = -background.y;
        }
        background.validate();
    };
    /**
     *
     */
    Tooltip.prototype.delayedPointTo = function (point, instantly) {
        var _this = this;
        if (this._pointToDisposer) {
            this._pointToDisposer.dispose();
        }
        this._pointToDisposer = registry.events.once("exitframe", function () {
            _this.pointTo(point, instantly);
        });
        this.addDisposer(this._pointToDisposer);
    };
    /**
     * Set nes tooltip's anchor point and moves whole tooltip.
     *
     * @param x  X coordinate
     * @param y  Y coordinate
     */
    Tooltip.prototype.pointTo = function (point, instantly) {
        if (this._pointTo.x != point.x || this._pointTo.y != point.y) {
            this._pointTo = point;
            this.invalidate();
            // this helps to avoid strange animation from nowhere on initial show or when balloon was hidden already
            if (!this.visible || instantly) {
                this.moveTo(this._pointTo);
                if (this._animation) {
                    this._animation.kill();
                }
            }
            else {
                // helps to avoid flicker on top/left corner
                if (this.pixelX == 0 && this.pixelY == 0) {
                    this.moveTo(this._pointTo);
                }
                else {
                    if (this._animation) {
                        this._animation.kill();
                    }
                    this._animation = new Animation_Animation(this, [{ property: "x", to: point.x, from: this.pixelX }, { property: "y", to: point.y, from: this.pixelY }], this.animationDuration, this.animationEasing).start();
                }
            }
        }
    };
    /**
     * Sets numeric boundaries Tooltip needs to obey (so it does not go outside
     * specific area).
     *
     * @ignore Exclude from docs
     * @param rectangle Boundary rectangle
     */
    Tooltip.prototype.setBounds = function (rectangle) {
        var oldRect = this._boundingRect;
        if (oldRect.x != rectangle.x || oldRect.y != rectangle.y || oldRect.width != rectangle.width || oldRect.height != rectangle.height) {
            this._boundingRect = rectangle;
            this.invalidate();
        }
    };
    Object.defineProperty(Tooltip.prototype, "boundingContainer", {
        /**
         * Sets a [[Container]] instance to be used when calculating numeric
         * boundaries for the Tooltip.
         *
         * @ignore Exclude from docs
         * @param container  Boundary container
         */
        set: function (container) {
            this._boundingContainer = container;
            // TODO remove closures ?
            container.events.on("sizechanged", this.updateBounds, this);
            container.events.on("positionchanged", this.updateBounds, this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates numeric boundaries for the Tooltip, based on the
     * `boundingCountrainer`.
     */
    Tooltip.prototype.updateBounds = function () {
        var boundingContainer = this._boundingContainer;
        // to global
        var rect = spriteRectToSvg({
            x: boundingContainer.pixelX,
            y: boundingContainer.pixelY,
            width: boundingContainer.maxWidth,
            height: boundingContainer.maxHeight
        }, boundingContainer);
        this.setBounds(rect);
    };
    Object.defineProperty(Tooltip.prototype, "verticalOrientation", {
        /**
         * If tooltipOrientation is vertical, it can be drawn below or above point.
         * We need to know this when solving overlapping.
         *
         * @ignore Exclude from docs
         * @return "up" | "down"
         */
        get: function () {
            return this._verticalOrientation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Tooltip.prototype, "tooltip", {
        /**
         * To avoid stackoverflow
         * @ignore
         */
        get: function () {
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies properties and other attributes.
     *
     * @param source  Source
     */
    Tooltip.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.label.copyFrom(source.label);
        if (source._boundingRect) {
            this._boundingRect = source._boundingRect;
        }
    };
    /**
     * Adds easing functions to "function" fields.
     *
     * @param field  Field name
     * @return Assign as function?
     */
    Tooltip.prototype.asFunction = function (field) {
        return field == "animationEasing" || _super.prototype.asIs.call(this, field);
    };
    return Tooltip;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Tooltip"] = Tooltip_Tooltip;
//# sourceMappingURL=Tooltip.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Trapezoid.js
/**
 * Functionality for drawing a trapezoid.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to draw a Trapezoid.
 *
 * @see {@link ITrapezoidEvents} for a list of available events
 * @see {@link ITrapezoidAdapters} for a list of available Adapters
 */
var Trapezoid_Trapezoid = /** @class */ (function (_super) {
    __extends(Trapezoid, _super);
    /**
     * Constructor
     */
    function Trapezoid() {
        var _this = _super.call(this) || this;
        _this.className = "Trapezoid";
        _this.element = _this.paper.add("path");
        _this.topSide = Percent_percent(100);
        _this.bottomSide = Percent_percent(100);
        _this.leftSide = Percent_percent(100);
        _this.rightSide = Percent_percent(100);
        _this.isMeasured = false; // todo: add measureElement
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    Trapezoid.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var w = this.pixelWidth;
        var h = this.pixelHeight;
        var ts = relativeToValue(this.topSide, w);
        var bs = relativeToValue(this.bottomSide, w);
        var ls = relativeToValue(this.leftSide, h);
        var rs = relativeToValue(this.rightSide, h);
        // 1----2
        // |    |
        // 4----3
        var x0 = (w - ts) / 2;
        var y0 = (h - ls) / 2;
        var x1 = w - (w - ts) / 2;
        var y1 = (h - rs) / 2;
        var x2 = w - (w - bs) / 2;
        var y2 = h - (h - rs) / 2;
        var x3 = (w - bs) / 2;
        var y3 = h - (h - ls) / 2;
        var mt = "";
        var mr = "";
        var mb = "";
        var ml = "";
        if (hasValue(this.horizontalNeck)) {
            var hn = this.horizontalNeck.value;
            mt = lineTo({ x: w * hn, y: Math.max(y0, y1) });
            mb = lineTo({ x: w * hn, y: Math.min(y2, y3) });
        }
        if (hasValue(this.verticalNeck)) {
            var vn = this.verticalNeck.value;
            mr = lineTo({ x: Math.min(x1, x2), y: h * vn });
            ml = lineTo({ x: Math.max(x0, x3), y: h * vn });
        }
        var path = moveTo({ x: x0, y: y0 })
            + mt
            + lineTo({ x: x1, y: y1 })
            + mr
            + lineTo({ x: x2, y: y2 })
            + mb
            + lineTo({ x: x3, y: y3 })
            + ml;
        this.path = path;
    };
    Object.defineProperty(Trapezoid.prototype, "topSide", {
        /**
         * @return Width
         */
        get: function () {
            return this.getPropertyValue("topSide");
        },
        /**
         * Wdith of the top side. Absolute (px) or relative ([[Percent]]).
         *
         * @default Percent(100)
         * @param value  Width
         */
        set: function (value) {
            this.setPercentProperty("topSide", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Trapezoid.prototype, "bottomSide", {
        /**
         * @return Width
         */
        get: function () {
            return this.getPropertyValue("bottomSide");
        },
        /**
         * Wdith of the bottom side. Absolute (px) or relative ([[Percent]]).
         *
         * @default Percent(100)
         * @param value  Width
         */
        set: function (value) {
            this.setPercentProperty("bottomSide", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Trapezoid.prototype, "leftSide", {
        /**
         * @return Height
         */
        get: function () {
            return this.getPropertyValue("leftSide");
        },
        /**
         * Height of the left side. Absolute (px) or relative ([[Percent]]).
         *
         * @default Percent(100)
         * @param value  Height
         */
        set: function (value) {
            this.setPercentProperty("leftSide", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Trapezoid.prototype, "rightSide", {
        /**
         * @return Height
         */
        get: function () {
            return this.getPropertyValue("rightSide");
        },
        /**
         * Height of the right side. Absolute (px) or relative ([[Percent]]).
         *
         * @default Percent(100)
         * @param value  Height
         */
        set: function (value) {
            this.setPercentProperty("rightSide", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Trapezoid.prototype, "horizontalNeck", {
        /**
         * @return Horizontal neck position
         */
        get: function () {
            return this.getPropertyValue("horizontalNeck");
        },
        /**
         * A relative vertical position of the "neck". If the top and bottom sides
         * are of different width, and `horizontalNeck` is set, a choke point
         * will be created at that position, creating a funnel shape.
         *
         * @param value  Horizontal neck position
         */
        set: function (value) {
            this.setPropertyValue("horizontalNeck", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Trapezoid.prototype, "verticalNeck", {
        /**
         * @return Vertical neck position
         */
        get: function () {
            return this.getPropertyValue("verticalNeck");
        },
        /**
         * A relative horizontal position of the "neck". If the left and right sides
         * are of different height, and `verticalNeck` is set, a choke point
         * will be created at that position, creating a funnel shape.
         *
         * @param value  Vertical neck position
         */
        set: function (value) {
            this.setPropertyValue("verticalNeck", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return Trapezoid;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Trapezoid"] = Trapezoid_Trapezoid;
//# sourceMappingURL=Trapezoid.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Triangle.js
/**
 * Functionality for drawing triangles.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to draw a triangle.
 *
 * @see {@link ITriangleEvents} for a list of available events
 * @see {@link ITriangleAdapters} for a list of available Adapters
 */
var Triangle_Triangle = /** @class */ (function (_super) {
    __extends(Triangle, _super);
    /**
     * Constructor
     */
    function Triangle() {
        var _this = _super.call(this) || this;
        _this.className = "Triangle";
        _this.element = _this.paper.add("path");
        _this.direction = "top";
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    Triangle.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var w = this.pixelWidth;
        var h = this.pixelHeight;
        var path;
        switch (this.direction) {
            case "right":
                path = moveTo({ x: 0, y: 0 })
                    + lineTo({ x: w, y: h / 2 })
                    + lineTo({ x: 0, y: h })
                    + closePath();
                break;
            case "left":
                path = moveTo({ x: w, y: 0 })
                    + lineTo({ x: 0, y: h / 2 })
                    + lineTo({ x: w, y: h })
                    + closePath();
                break;
            case "bottom":
                path = moveTo({ x: 0, y: 0 })
                    + lineTo({ x: w, y: 0 })
                    + lineTo({ x: w / 2, y: h })
                    + closePath();
                break;
            case "top":
                path = moveTo({ x: w / 2, y: 0 })
                    + lineTo({ x: w, y: h })
                    + lineTo({ x: 0, y: h })
                    + closePath();
                break;
        }
        this.path = path;
    };
    Object.defineProperty(Triangle.prototype, "direction", {
        /**
         * Returns direction of a triangle
         *
         * @return value
         */
        get: function () {
            return this.getPropertyValue("direction");
        },
        /**
         * Sets direction of a triangle
         *
         * @param value
         */
        set: function (value) {
            this.setPropertyValue("direction", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return Triangle;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Triangle"] = Triangle_Triangle;
//# sourceMappingURL=Triangle.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/Smoothing.js
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * @ignore Exclude from docs
 * @todo Description
 */
var Smoothing_Tension = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param tensionX [description]
     * @param tensionY [description]
     */
    function Tension(tensionX, tensionY) {
        this._tensionX = tensionX;
        this._tensionY = tensionY;
    }
    /**
     * [smooth description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param points  [description]
     * @return [description]
     */
    Tension.prototype.smooth = function (points) {
        for (var i = points.length - 1; i > 0; i--) {
            var p0 = points[i];
            var p1 = points[i - 1];
            if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {
                points.splice(i, 1);
            }
        }
        var tensionX = this._tensionX;
        var tensionY = this._tensionY;
        if (points.length < 3 || (tensionX >= 1 && tensionY >= 1)) {
            return polyline(points);
        }
        var first = points[0];
        var last = points[points.length - 1];
        var closed = false;
        if (Math_round(first.x, 3) == Math_round(last.x) && Math_round(first.y) == Math_round(last.y)) {
            closed = true;
        }
        // Can't moveTo here, as it wont be possible to have fill then.
        var path = "";
        for (var i = 0, len = points.length - 1; i < len; i++) {
            var p0 = points[i - 1];
            var p1 = points[i];
            var p2 = points[i + 1];
            var p3 = points[i + 2];
            if (i === 0) {
                if (closed) {
                    p0 = points[points.length - 2];
                }
                else {
                    p0 = points[i];
                }
            }
            else if (i == points.length - 2) {
                if (closed) {
                    p3 = points[1];
                }
                else {
                    p3 = points[i + 1];
                }
            }
            var controlPointA = getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);
            var controlPointB = getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);
            path += cubicCurveTo(p2, controlPointA, controlPointB);
        }
        return path;
    };
    return Tension;
}());

/**
 * Returns a waved line SVG path between two points.
 *
 * @ignore Exclude from docs
 * @param point1            Starting point
 * @param point2            Ending point
 * @param waveLength        Wave length
 * @param waveHeight        Wave height
 * @param adjustWaveLength  Adjust wave length based on the actual line length
 * @return SVG path
 */
function wavedLine(point1, point2, waveLength, waveHeight, tension, adjustWaveLength) {
    var x1 = point1.x;
    var y1 = point1.y;
    var x2 = point2.x;
    var y2 = point2.y;
    var distance = getDistance(point1, point2);
    if (adjustWaveLength) {
        waveLength = distance / Math.round(distance / waveLength);
    }
    var d = registry.getCache(stringify(["wavedLine", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]));
    if (!d) {
        if (distance > 0) {
            var angle = Math.atan2(y2 - y1, x2 - x1);
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var waveLengthX = waveLength * cos;
            var waveLengthY = waveLength * sin;
            if (waveLength <= 1 || waveHeight <= 1) {
                d = lineTo(point2);
            }
            else {
                var halfWaveCount = Math.round(2 * distance / waveLength);
                var points = [];
                var sign = 1;
                if (x2 < x1) {
                    sign *= -1;
                }
                if (y2 < y1) {
                    sign *= -1;
                }
                for (var i = 0; i <= halfWaveCount; i++) {
                    sign *= -1;
                    var x = x1 + i * waveLengthX / 2 + sign * waveHeight / 2 * sin;
                    var y = y1 + i * waveLengthY / 2 - sign * waveHeight / 2 * cos;
                    points.push({ x: x, y: y });
                }
                d = new Smoothing_Tension(tension, tension).smooth(points);
            }
        }
        else {
            d = "";
        }
        registry.setCache(stringify(["wavedLine", point1.x, point2.x, point1.y, point2.y, waveLength, waveHeight]), d);
    }
    return d;
}
/**
 * @ignore Exclude from docs
 * @todo Description
 */
var Smoothing_Basis = /** @class */ (function () {
    /**
     * Constructor.
     *
     * @param info  [description]
     */
    function Basis(info) {
        this._closed = info.closed;
    }
    /**
     * [smooth description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param points  [description]
     * @return [description]
     */
    Basis.prototype.smooth = function (points) {
        var _this = this;
        var x0 = NaN;
        var x1 = NaN;
        var x2 = NaN;
        var x3 = NaN;
        var x4 = NaN;
        var y0 = NaN;
        var y1 = NaN;
        var y2 = NaN;
        var y3 = NaN;
        var y4 = NaN;
        var point = 0;
        var output = "";
        var pushCurve = function (x, y) {
            output += cubicCurveTo({
                x: (x0 + 4 * x1 + x) / 6,
                y: (y0 + 4 * y1 + y) / 6
            }, {
                x: (2 * x0 + x1) / 3,
                y: (2 * y0 + y1) / 3
            }, {
                x: (x0 + 2 * x1) / 3,
                y: (y0 + 2 * y1) / 3
            });
        };
        var pushPoint = function (_a) {
            var x = _a.x, y = _a.y;
            switch (point) {
                case 0:
                    point = 1;
                    if (_this._closed) {
                        x2 = x;
                        y2 = y;
                    }
                    else {
                        output += lineTo({ x: x, y: y });
                    }
                    break;
                case 1:
                    point = 2;
                    if (_this._closed) {
                        x3 = x;
                        y3 = y;
                    }
                    break;
                case 2:
                    point = 3;
                    if (_this._closed) {
                        x4 = x;
                        y4 = y;
                        output += moveTo({ x: (x0 + 4 * x1 + x) / 6, y: (y0 + 4 * y1 + y) / 6 });
                        break;
                    }
                    else {
                        output += lineTo({ x: (5 * x0 + x1) / 6, y: (5 * y0 + y1) / 6 });
                        // fall-through
                    }
                default:
                    pushCurve(x, y);
                    break;
            }
            x0 = x1;
            x1 = x;
            y0 = y1;
            y1 = y;
        };
        each(points, pushPoint);
        if (this._closed) {
            switch (point) {
                case 1:
                    output += moveTo({ x: x2, y: y2 });
                    output += closePath();
                    break;
                case 2:
                    output += moveTo({ x: (x2 + 2 * x3) / 3, y: (y2 + 2 * y3) / 3 });
                    output += lineTo({ x: (x3 + 2 * x2) / 3, y: (y3 + 2 * y2) / 3 });
                    output += closePath();
                    break;
                case 3:
                    pushPoint({ x: x2, y: y2 });
                    pushPoint({ x: x3, y: y3 });
                    pushPoint({ x: x4, y: y4 });
                    break;
            }
        }
        else {
            switch (point) {
                case 3:
                    pushCurve(x1, y1);
                // fall-through
                case 2:
                    output += lineTo({ x: x1, y: y1 });
                    break;
            }
            output += closePath();
        }
        return output;
    };
    return Basis;
}());

//# sourceMappingURL=Smoothing.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/WavedCircle.js
/**
 * Functionality for drawing waved circles.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a waved circle.
 *
 * @see {@link IWavedCircleEvents} for a list of available events
 * @see {@link IWavedCircleAdapters} for a list of available Adapters
 */
var WavedCircle_WavedCircle = /** @class */ (function (_super) {
    __extends(WavedCircle, _super);
    /**
     * Constructor
     */
    function WavedCircle() {
        var _this = _super.call(this) || this;
        _this.className = "WavedCircle";
        _this.element = _this.paper.add("path");
        _this.waveLength = 16;
        _this.waveHeight = 4;
        _this.fill = undefined;
        _this.fillOpacity = 0;
        _this.tension = 0.8;
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the waved line.
     *
     * @ignore Exclude from docs
     */
    WavedCircle.prototype.draw = function () {
        var path = "";
        var radius = this.pixelRadius;
        if (radius > 0) {
            var points = this.getPoints(radius);
            path = moveTo(points[0]) + new Smoothing_Tension(this.tension, this.tension).smooth(points);
        }
        var innerRadius = this.pixelInnerRadius;
        if (innerRadius > 0) {
            var points = this.getPoints(innerRadius);
            points.reverse();
            path += moveTo(points[0]) + new Smoothing_Tension(this.tension, this.tension).smooth(points);
        }
        this.path = path;
    };
    /**
     * Returns points that circle consists of.
     *
     * @param radius  Radius (px)
     * @return Points
     */
    WavedCircle.prototype.getPoints = function (radius) {
        var circleLength = radius * Math.PI * 2;
        var halfWaveHeight = this.waveHeight / 2;
        var waveLength = circleLength / Math.round(circleLength / this.waveLength);
        var halfWaveLength = waveLength / 2;
        var points = [];
        var count = circleLength / waveLength;
        for (var i = 0; i <= count; i++) {
            var angle1 = (i * waveLength) / circleLength * 360;
            var angle2 = (i * waveLength + halfWaveLength) / circleLength * 360;
            points.push({ x: (radius - halfWaveHeight) * Math_cos(angle1), y: (radius - halfWaveHeight) * Math_sin(angle1) });
            points.push({ x: (radius + halfWaveHeight) * Math_cos(angle2), y: (radius + halfWaveHeight) * Math_sin(angle2) });
        }
        points.pop();
        return points;
    };
    Object.defineProperty(WavedCircle.prototype, "innerRadius", {
        /**
         * @return Inner radius
         */
        get: function () {
            return this.getPropertyValue("innerRadius");
        },
        /**
         * Inner radius of the circle in pixels (absolute) or [[Percent]] (relative).
         *
         * @param value  Inner radius
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, true, false, 10, false);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedCircle.prototype, "pixelInnerRadius", {
        /**
         * Calculated inner radius of the circle in pixels.
         *
         * @readonly
         * @return Inner radius (px)
         */
        get: function () {
            return relativeToValue(this.innerRadius, Math_min(this.innerWidth / 2, this.innerHeight / 2));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedCircle.prototype, "waveLength", {
        /**
         * @return Wave length (px)
         */
        get: function () {
            return this.getPropertyValue("waveLength");
        },
        /**
         * Wave length in pixels.
         *
         * @default 16
         * @param value  Wave length (px)
         */
        set: function (value) {
            this.setPropertyValue("waveLength", value);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedCircle.prototype, "waveHeight", {
        /**
         * @return Wave height (px)
         */
        get: function () {
            return this.getPropertyValue("waveHeight");
        },
        /**
         * Wave height in pixels.
         *
         * @default 4
         * @param value  Wave height (px)
         */
        set: function (value) {
            this.setPropertyValue("waveHeight", value);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedCircle.prototype, "tension", {
        /**
         * @return Tension
         */
        get: function () {
            return this.getPropertyValue("tension");
        },
        /**
         * Tension of the wave.
         *
         * @default 0.8
         * @param value  Tension
         */
        set: function (value) {
            this.setPropertyValue("tension", value);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    return WavedCircle;
}(Circle_Circle));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["WavedCircle"] = WavedCircle_WavedCircle;
//# sourceMappingURL=WavedCircle.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/WavedLine.js
/**
 * Functionality for drawing waved lines.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a waved line.
 *
 * @see {@link IWavedLineEvents} for a list of available events
 * @see {@link IWavedLineAdapters} for a list of available Adapters
 */
var WavedLine_WavedLine = /** @class */ (function (_super) {
    __extends(WavedLine, _super);
    /**
     * Constructor
     */
    function WavedLine() {
        var _this = _super.call(this) || this;
        _this.className = "WavedLine";
        _this.element = _this.paper.add("path");
        _this.waveLength = 16;
        _this.waveHeight = 4;
        _this.tension = 0.8;
        _this.pixelPerfect = false;
        _this.fill = Color_color();
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the waved line.
     *
     * @ignore Exclude from docs
     */
    WavedLine.prototype.draw = function () {
        //super.draw();
        var p1 = { x: this.x1, y: this.y1 };
        var p2 = { x: this.x2, y: this.y2 };
        this.path = moveTo(p1) + wavedLine(p1, p2, this.waveLength, this.waveHeight, this.tension, true);
    };
    Object.defineProperty(WavedLine.prototype, "waveLength", {
        /**
         * @return Wave length (px)
         */
        get: function () {
            return this.getPropertyValue("waveLength");
        },
        /**
         * Wave length in pixels.
         *
         * @default 16
         * @param value  Wave length (px)
         */
        set: function (value) {
            this.setPropertyValue("waveLength", value);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedLine.prototype, "waveHeight", {
        /**
         * @return Wave height (px)
         */
        get: function () {
            return this.getPropertyValue("waveHeight");
        },
        /**
         * Wave height in pixels.
         *
         * @default 4
         * @param value  Wave height (px)
         */
        set: function (value) {
            this.setPropertyValue("waveHeight", value);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedLine.prototype, "tension", {
        /**
         * @return Tension
         */
        get: function () {
            return this.getPropertyValue("tension");
        },
        /**
         * Tension of the wave.
         *
         * @default 0.8
         * @param value  Tension
         */
        set: function (value) {
            this.setPropertyValue("tension", value);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    return WavedLine;
}(Line_Line));

//# sourceMappingURL=WavedLine.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/WavedRectangle.js
/**
 * Functionality for drawing rectangles with waved edges.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a rectangle with waved edges.
 *
 * @see {@link IWavedRectangleEvents} for a list of available events
 * @see {@link IWavedRectangleAdapters} for a list of available Adapters
 */
var WavedRectangle_WavedRectangle = /** @class */ (function (_super) {
    __extends(WavedRectangle, _super);
    /**
     * Constructor
     */
    function WavedRectangle() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "WavedRectangle";
        // Add path element
        _this.element = _this.paper.add("path");
        // Set defaults
        _this.waveLength = 16;
        _this.waveHeight = 4;
        _this.tension = 0.8;
        _this.setPropertyValue("wavedLeft", true);
        _this.setPropertyValue("wavedRight", true);
        _this.setPropertyValue("wavedTop", true);
        _this.setPropertyValue("wavedBottom", true);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the waved rectangle.
     *
     * @ignore Exclude from docs
     */
    WavedRectangle.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var w = this.pixelWidth;
        var h = this.pixelHeight;
        if (w > 0 && h > 0) {
            var p1 = { x: 0, y: 0 };
            var p2 = { x: w, y: 0 };
            var p3 = { x: w, y: h };
            var p4 = { x: 0, y: h };
            var waveLengthH = Math.min(w, this.waveLength);
            var waveHeightH = Math.min(h, this.waveHeight);
            var waveLengthV = Math.min(h, this.waveLength);
            var waveHeightV = Math.min(w, this.waveHeight);
            var td = "";
            var rd = "";
            var bd = "";
            var ld = "";
            if (this.wavedTop) {
                td = wavedLine(p1, p2, waveLengthH, waveHeightH, this.tension, true);
            }
            if (this.wavedRight) {
                rd = wavedLine(p2, p3, waveLengthV, waveHeightV, this.tension, true);
            }
            if (this.wavedBottom) {
                bd = wavedLine(p3, p4, waveLengthH, waveHeightH, this.tension, true);
            }
            if (this.wavedLeft) {
                ld = wavedLine(p4, p1, waveLengthV, waveHeightV, this.tension, true);
            }
            this.path = moveTo(p1) + td + lineTo(p2) + rd + lineTo(p3) + bd + lineTo(p4) + ld + "z";
        }
    };
    Object.defineProperty(WavedRectangle.prototype, "waveLength", {
        /**
         * @return Wave length (px)
         */
        get: function () {
            return this.getPropertyValue("waveLength");
        },
        /**
         * Wave length in pixels.
         *
         * @default 16
         * @param value  Wave length (px)
         */
        set: function (value) {
            this.setPropertyValue("waveLength", value);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedRectangle.prototype, "waveHeight", {
        /**
         * @return Wave height (px)
         */
        get: function () {
            return this.getPropertyValue("waveHeight");
        },
        /**
         * Wave height in pixels.
         *
         * @default 4
         * @param value  Wave height (px)
         */
        set: function (value) {
            this.setPropertyValue("waveHeight", value);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets which side should be waved or not. If particular side is set to
     * `false`, a straight line will be drawn on that side.
     *
     * @param top     Top waved?
     * @param right   Right side waved?
     * @param bottom  Bottom Waved?
     * @param left    Left side waved?
     */
    WavedRectangle.prototype.setWavedSides = function (top, right, bottom, left) {
        this.wavedTop = top;
        this.wavedRight = right;
        this.wavedBottom = bottom;
        this.wavedLeft = left;
    };
    Object.defineProperty(WavedRectangle.prototype, "tension", {
        /**
         * @return Tension
         */
        get: function () {
            return this.getPropertyValue("tension");
        },
        /**
         * Tension of the wave.
         *
         * @default 0.8
         * @param value  Tension
         */
        set: function (value) {
            this.setPropertyValue("tension", value);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedRectangle.prototype, "wavedRight", {
        /**
         * @return Wave right side?
         */
        get: function () {
            return this.getPropertyValue("wavedRight");
        },
        /**
         * Specifies if right side should be waved.
         *
         * @default true
         * @param value Waved?
         */
        set: function (value) {
            this.setPropertyValue("wavedRight", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedRectangle.prototype, "wavedLeft", {
        /**
         * @return Wave left side?
         */
        get: function () {
            return this.getPropertyValue("wavedLeft");
        },
        /**
         * Specifies if left side should be waved.
         *
         * @default true
         * @param value Waved?
         */
        set: function (value) {
            this.setPropertyValue("wavedLeft", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedRectangle.prototype, "wavedTop", {
        /**
         * @return Wave top side?
         */
        get: function () {
            return this.getPropertyValue("wavedTop");
        },
        /**
         * Specifies if top side should be waved.
         *
         * @default true
         * @param value Waved?
         */
        set: function (value) {
            this.setPropertyValue("wavedTop", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WavedRectangle.prototype, "wavedBottom", {
        /**
         * @return Wave bottom side?
         */
        get: function () {
            return this.getPropertyValue("wavedBottom");
        },
        /**
         * Specifies if bottom side should be waved.
         *
         * @default true
         * @param value Waved?
         */
        set: function (value) {
            this.setPropertyValue("wavedBottom", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return WavedRectangle;
}(Rectangle_Rectangle));

//# sourceMappingURL=WavedRectangle.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/ZoomOutButton.js
/**
 * Zoom out button functionality.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a zoom out button.
 *
 * @see {@link IZoomOutButtonEvents} for a list of available events
 * @see {@link IZoomOutButtonAdapters} for a list of available Adapters
 */
var ZoomOutButton_ZoomOutButton = /** @class */ (function (_super) {
    __extends(ZoomOutButton, _super);
    /**
     * Constructor
     */
    function ZoomOutButton() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "ZoomOutButton";
        _this.padding(9, 9, 9, 9);
        //this.dx = - 5;
        //this.dy = 5;
        _this.showSystemTooltip = true;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        var background = _this.background;
        background.cornerRadius(20, 20, 20, 20);
        background.fill = interfaceColors.getFor("primaryButton");
        background.stroke = interfaceColors.getFor("primaryButtonStroke");
        background.strokeOpacity = 0;
        background.states.getKey("hover").properties.fill = interfaceColors.getFor("primaryButtonHover");
        background.states.getKey("down").properties.fill = interfaceColors.getFor("primaryButtonActive");
        // Create an icon
        var icon = new Sprite_Sprite();
        icon.element = _this.paper.add("path");
        var path = moveTo({ x: 0, y: 0 });
        path += lineTo({ x: 11, y: 0 });
        icon.path = path;
        icon.pixelPerfect = true;
        icon.padding(8, 3, 8, 3);
        icon.stroke = interfaceColors.getFor("primaryButtonText");
        _this.icon = icon;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    ZoomOutButton.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Zoom Out");
        }
    };
    return ZoomOutButton;
}(Button_Button));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ZoomOutButton"] = ZoomOutButton_ZoomOutButton;
//# sourceMappingURL=ZoomOutButton.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/PlayButton.js
/**
 * Play button functionality.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a zoom out button.
 *
 * @see {@link IPlayButtonEvents} for a list of available events
 * @see {@link IPlayButtonAdapters} for a list of available Adapters
 */
var PlayButton_PlayButton = /** @class */ (function (_super) {
    __extends(PlayButton, _super);
    /**
     * Constructor
     */
    function PlayButton() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "PlayButton";
        _this.padding(12, 12, 12, 12);
        _this.showSystemTooltip = true;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        var background = _this.background;
        background.cornerRadius(25, 25, 25, 25);
        background.fill = interfaceColors.getFor("primaryButton");
        background.stroke = interfaceColors.getFor("primaryButtonStroke");
        background.strokeOpacity = 0;
        background.states.getKey("hover").properties.fill = interfaceColors.getFor("primaryButtonHover");
        background.states.getKey("down").properties.fill = interfaceColors.getFor("primaryButtonActive");
        // Create a play icon
        var playIcon = new Triangle_Triangle();
        playIcon.direction = "right";
        playIcon.width = 9;
        playIcon.height = 11;
        playIcon.marginLeft = 1;
        playIcon.marginRight = 1;
        playIcon.horizontalCenter = "middle";
        playIcon.verticalCenter = "middle";
        playIcon.stroke = interfaceColors.getFor("primaryButtonText");
        playIcon.fill = playIcon.stroke;
        _this.icon = playIcon;
        // Create a play icon
        var stopIcon = new RoundedRectangle_RoundedRectangle();
        stopIcon.width = 11;
        stopIcon.height = 11;
        stopIcon.horizontalCenter = "middle";
        stopIcon.verticalCenter = "middle";
        stopIcon.cornerRadius(0, 0, 0, 0);
        stopIcon.stroke = interfaceColors.getFor("primaryButtonText");
        stopIcon.fill = playIcon.stroke;
        _this.togglable = true;
        var activeState = _this.states.create("active");
        activeState.transitionDuration = 0;
        activeState.properties.icon = stopIcon;
        _this.defaultState.transitionDuration = 0;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    PlayButton.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Play");
        }
    };
    return PlayButton;
}(Button_Button));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["PlayButton"] = PlayButton_PlayButton;
//# sourceMappingURL=PlayButton.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/ColorModifier.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A base class for color modifiers.
 *
 * @ignore Exclude from docs
 */
var ColorModifier_ColorModifier = /** @class */ (function (_super) {
    __extends(ColorModifier, _super);
    /**
     * Constructor
     */
    function ColorModifier() {
        var _this = _super.call(this) || this;
        _this.className = "ColorModifier";
        _this.applyTheme();
        return _this;
    }
    /**
     * Modifies color value.
     *
     * @ignore Exclude from docs
     * @param value  Original color
     * @return Modified
     */
    ColorModifier.prototype.modify = function (value) {
        return value;
    };
    return ColorModifier;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ColorModifier"] = ColorModifier_ColorModifier;
//# sourceMappingURL=ColorModifier.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/GradientModifier.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * This class can be used to modify linear gradient steps, changing visual
 * properties like lightness, brightness, opacity of each set.
 *
 * It can also set offsets for each gradient step.
 *
 * E.g. if I want to fill a columns in a column series to be a solid fill from
 * top to 80% of height, then gradually fades out, I can use the following
 * gradient modifier as a `fillModifier`:
 *
 * ```TypeScript
 * let fillModifier = new am4core.GradientModifier();
 * fillModifier.opacities = [1, 1, 0];
 * fillModifier.offsets = [0, 0.8, 1];
 * columnSeries.columns.template.fillModifier = fillModifier;
 * ```
 * ```JavaScript
 * var fillModifier = new am4core.GradientModifier();
 * fillModifier.opacities = [1, 1, 0];
 * fillModifier.offsets = [0, 0.8, 1];
 * columnSeries.columns.template.fillModifier = fillModifier;
 * ```
 * ```JSON
 * "series": [{
 *   "type": "ColumnSeries",
 *   "columns": {
 *     "fillModifier": {
 *       "type": "GradientModifier",
 *       "opacities": [1, 1, 0],
 *       "offsets": [0, 0.8, 1]
 *     }
 *   }
 * }]
 * ```
 */
var GradientModifier_GradientModifier = /** @class */ (function (_super) {
    __extends(GradientModifier, _super);
    /**
     * Constructor.
     */
    function GradientModifier() {
        var _this = _super.call(this) || this;
        _this.lightnesses = [];
        _this.brightnesses = [];
        _this.opacities = [];
        _this.offsets = [];
        _this.className = "GradientModifier";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(GradientModifier.prototype, "lightnesses", {
        /**
         * @return Lightness values
         */
        get: function () {
            return this._lightnesses;
        },
        /**
         * An array of lightness values for each step.
         *
         * @param value  Lightness values
         */
        set: function (value) {
            this._lightnesses = value;
            this._brightnesses = [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GradientModifier.prototype, "brightnesses", {
        /**
         * @return Brightness values
         */
        get: function () {
            return this._brightnesses;
        },
        /**
         * An array of brightness values for each step.
         *
         * @param value  Brightness values
         */
        set: function (value) {
            this._brightnesses = value;
            this._lightnesses = [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GradientModifier.prototype, "opacities", {
        /**
         * @return Opacity values
         */
        get: function () {
            return this._opacities;
        },
        /**
         * An array of opacity values for each step.
         *
         * @param value  Opacity values
         */
        set: function (value) {
            this._opacities = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GradientModifier.prototype, "offsets", {
        /**
         * @return Offsets
         */
        get: function () {
            return this._offsets;
        },
        /**
         * An array of relative position (0-1) for each step.
         *
         * If not set, all steps will be of equal relative length.
         *
         * @param value  Offsets
         */
        set: function (value) {
            this._offsets = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Modifies the color based on step setting.
     *
     * @ignore Exclude from docs
     * @param value  Source color
     * @return A gradient that matches set modification rules
     */
    GradientModifier.prototype.modify = function (value) {
        // Clear current gradient
        this.gradient.clear();
        // Get step count
        var count = 0;
        if (this.opacities) {
            count = Math_max(count, this.opacities.length);
        }
        if (this.lightnesses) {
            count = Math_max(count, this.lightnesses.length);
        }
        if (this.brightnesses) {
            count = Math_max(count, this.brightnesses.length);
        }
        // Init step values
        var opacity = 1, lightness, brightness;
        // Apply steps
        for (var i = 0; i < count; i++) {
            // Take base color
            var color = value;
            // Check if there are any parameters for this step
            if (this.opacities && isNumber(this.opacities[i])) {
                opacity = this.opacities[i];
            }
            if (this.lightnesses && isNumber(this.lightnesses[i])) {
                lightness = this.lightnesses[i];
                brightness = undefined;
            }
            if (this.brightnesses && isNumber(this.brightnesses[i])) {
                brightness = this.brightnesses[i];
                lightness = undefined;
            }
            // Check if we need to brighten/lighten color
            if (isNumber(brightness)) {
                color = value.brighten(this.brightnesses[i]);
            }
            else if (isNumber(lightness)) {
                color = value.lighten(this.lightnesses[i]);
            }
            // Get offset (it's OK if it's undefined)
            var offset = this.offsets[i];
            // Apply step
            this.gradient.addColor(color, opacity, offset);
        }
        return this.gradient;
    };
    GradientModifier.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this._offsets = source.offsets;
        this._brightnesses = source.brightnesses;
        this._lightnesses = source.lightnesses;
        this._opacities = source.opacities;
    };
    return GradientModifier;
}(ColorModifier_ColorModifier));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["GradientModifier"] = GradientModifier_GradientModifier;
//# sourceMappingURL=GradientModifier.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/LinearGradientModifier.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * This class can be used to modify linear gradient steps, changing visual
 * properties like lightness, brightness, opacity of each set.
 *
 * It can also set offsets for each gradient step.
 *
 * E.g. if I want to fill a columns in a column series to be a solid fill from
 * top to 80% of height, then gradually fades out, I can use the following
 * gradient modifier as a `fillModifier`:
 *
 * ```TypeScript
 * let fillModifier = new am4core.LinearGradientModifier();
 * fillModifier.opacities = [1, 1, 0];
 * fillModifier.offsets = [0, 0.8, 1];
 * columnSeries.columns.template.fillModifier = fillModifier;
 * ```
 * ```JavaScript
 * var fillModifier = new am4core.LinearGradientModifier();
 * fillModifier.opacities = [1, 1, 0];
 * fillModifier.offsets = [0, 0.8, 1];
 * columnSeries.columns.template.fillModifier = fillModifier;
 * ```
 * ```JSON
 * "series": [{
 *   "type": "ColumnSeries",
 *   "columns": {
 *     "fillModifier": {
 *       "type": "LinearGradientModifier",
 *       "opacities": [1, 1, 0],
 *       "offsets": [0, 0.8, 1]
 *     }
 *   }
 * }]
 * ```
 */
var LinearGradientModifier_LinearGradientModifier = /** @class */ (function (_super) {
    __extends(LinearGradientModifier, _super);
    /**
     * Constructor.
     */
    function LinearGradientModifier() {
        var _this = _super.call(this) || this;
        _this.className = "LinearGradientModifier";
        _this.gradient = new LinearGradient_LinearGradient();
        _this.applyTheme();
        return _this;
    }
    LinearGradientModifier.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.gradient = source.gradient.clone();
    };
    return LinearGradientModifier;
}(GradientModifier_GradientModifier));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["LinearGradientModifier"] = LinearGradientModifier_LinearGradientModifier;
//# sourceMappingURL=LinearGradientModifier.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/3d/Cone.js
/**
 * Cone module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Builds a round cone/cylinder.
 *
 * @see {@link IConeEvents} for a list of available events
 * @see {@link IConeAdapters} for a list of available Adapters
 */
var Cone_Cone = /** @class */ (function (_super) {
    __extends(Cone, _super);
    /**
     * Constructor
     */
    function Cone() {
        var _this = _super.call(this) || this;
        _this.className = "Cone";
        _this.angle = 30;
        _this.radius = Percent_percent(100);
        _this.topRadius = Percent_percent(100);
        _this.top = _this.createChild(Ellipse_Ellipse);
        _this.top.shouldClone = false;
        _this.bottom = _this.createChild(Ellipse_Ellipse);
        _this.bottom.shouldClone = false;
        _this.body = _this.createChild(Sprite_Sprite);
        _this.body.shouldClone = false;
        _this.body.setElement(_this.paper.add("path"));
        _this.layout = "none";
        _this.bodyFillModifier = new LinearGradientModifier_LinearGradientModifier();
        _this.bodyFillModifier.lightnesses = [0, -0.25, 0];
        _this.body.fillModifier = _this.bodyFillModifier;
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    Cone.prototype.draw = function () {
        _super.prototype.draw.call(this);
        copyProperties(this, this.top, visualProperties);
        copyProperties(this, this.bottom, visualProperties);
        copyProperties(this, this.body, visualProperties);
        var w = this.innerWidth;
        var h = this.innerHeight;
        var bottom = this.bottom;
        var top = this.top;
        var angle = this.angle;
        var radiusBase;
        var dx;
        var dy;
        if (this.orientation == "horizontal") {
            radiusBase = h / 2;
            bottom.y = h / 2;
            top.y = h / 2;
            top.x = w;
            dx = (90 - angle) / 90;
            dy = 0;
            this.bodyFillModifier.gradient.rotation = 90;
        }
        else {
            dx = 0;
            dy = (90 - angle) / 90;
            radiusBase = w / 2;
            bottom.y = h;
            bottom.x = w / 2;
            top.x = w / 2;
            this.bodyFillModifier.gradient.rotation = 0;
        }
        var radius = this.radius.value * radiusBase;
        var topRadius = this.topRadius.value * radiusBase;
        bottom.radius = radius - radius * dx;
        bottom.radiusY = radius - radius * dy;
        top.radius = topRadius - topRadius * dx;
        top.radiusY = topRadius - topRadius * dy;
        var path;
        if (this.orientation == "horizontal") {
            path = moveTo({ x: 0, y: h / 2 - bottom.radiusY }) + arcTo(-90, -180, bottom.radius, bottom.radiusY) + lineTo({ x: w, y: h / 2 + top.radiusY }) + arcTo(90, 180, top.radius, top.radiusY) + closePath();
        }
        else {
            path = moveTo({ x: w / 2 - top.radius, y: 0 }) + arcTo(180, -180, top.radius, top.radiusY) + lineTo({ x: w / 2 + bottom.radius, y: h }) + arcTo(0, 180, bottom.radius, bottom.radiusY) + closePath();
        }
        this.body.path = path;
    };
    Object.defineProperty(Cone.prototype, "angle", {
        /**
         * @return Angle
         */
        get: function () {
            return this.getPropertyValue("angle");
        },
        /**
         * Angle of the point of view to the 3D element. (0-360)
         *
         * @default 30
         * @param value  Angle
         */
        set: function (value) {
            this.setPropertyValue("angle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cone.prototype, "radius", {
        /**
         * @return Bottom radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * A relative radius of the cone's bottom (base).
         *
         * It is relevant to the inner width or height of the element.
         *
         * @default Percent(100)
         * @param value  Bottom radius
         */
        set: function (value) {
            this.setPropertyValue("radius", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cone.prototype, "topRadius", {
        /**
         * @return Top radius
         */
        get: function () {
            return this.getPropertyValue("topRadius");
        },
        /**
         * A relative radius of the cone's top (tip).
         *
         * It is relevant to the inner width or height of the element.
         *
         * @default Percent(0)
         * @param value  Top radius
         */
        set: function (value) {
            this.setPropertyValue("topRadius", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cone.prototype, "orientation", {
        /**
         * Orientation
         */
        get: function () {
            return this.getPropertyValue("orientation");
        },
        /**
         * Orientation of the cone
         *
         * @default "vertical"
         * @param value  Orientation
         */
        set: function (value) {
            this.setPropertyValue("orientation", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return Cone;
}(Container_Container));

//# sourceMappingURL=Cone.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/filters/LightenFilter.js
/**
 * Module for "Lighten" filter.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a "Lighten" filter.
 */
var LightenFilter_LightenFilter = /** @class */ (function (_super) {
    __extends(LightenFilter, _super);
    /**
     * Constructor
     */
    function LightenFilter() {
        var _this = _super.call(this) || this;
        _this.className = "LightenFilter";
        // Create elements
        // NOTE: we do not need to add each individual element to `_disposers`
        // because `filterPrimitives` has an event handler which automatically adds
        // anything added to it to `_disposers`
        _this.feColorMatrix = _this.paper.add("feColorMatrix");
        _this.feColorMatrix.attr({ "type": "matrix" });
        _this.filterPrimitives.push(_this.feColorMatrix);
        // Set default properties
        _this.lightness = 0;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(LightenFilter.prototype, "lightness", {
        /**
         * @return Lightness
         */
        get: function () {
            return this.properties["lightness"];
        },
        /**
         * Lightness of the target colors.
         *
         * If `lightness` is a positive number, the filter will make all colors
         * lighter.
         *
         * If `lightness` is negative, colors will be darkened.
         *
         * @param value  Lightness
         */
        set: function (value) {
            this.properties["lightness"] = value;
            var v = value + 1;
            this.feColorMatrix.attr({ "values": v + " 0 0 0 0 0 " + v + " 0 0 0 0 0 " + v + " 0 0 0 0 0 1 0" });
        },
        enumerable: true,
        configurable: true
    });
    return LightenFilter;
}(Filter_Filter));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["LightenFilter"] = LightenFilter_LightenFilter;
//# sourceMappingURL=LightenFilter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/3d/Rectangle3D.js
/**
 * Creates a 3D rectangle.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Builds a 3D rectangle
 * @see {@link IRectangle3DEvents} for a list of available events
 * @see {@link IRectangle3DAdapters} for a list of available Adapters
 */
var Rectangle3D_Rectangle3D = /** @class */ (function (_super) {
    __extends(Rectangle3D, _super);
    /**
     * Constructor
     */
    function Rectangle3D() {
        var _this = _super.call(this) || this;
        _this.angle = 30;
        _this.depth = 30;
        _this.className = "Rectangle3D";
        _this.layout = "none";
        var sideBack = _this.createChild(Sprite_Sprite);
        sideBack.shouldClone = false;
        sideBack.setElement(_this.paper.add("path"));
        sideBack.isMeasured = false;
        _this.sideBack = sideBack;
        _this._disposers.push(_this.sideBack);
        var sideBottom = _this.createChild(Sprite_Sprite);
        sideBottom.shouldClone = false;
        sideBottom.setElement(_this.paper.add("path"));
        sideBottom.isMeasured = false;
        _this.sideBottom = sideBottom;
        _this._disposers.push(_this.sideBottom);
        var sideLeft = _this.createChild(Sprite_Sprite);
        sideLeft.shouldClone = false;
        sideLeft.setElement(_this.paper.add("path"));
        sideLeft.isMeasured = false;
        _this.sideLeft = sideLeft;
        _this._disposers.push(_this.sideLeft);
        var sideRight = _this.createChild(Sprite_Sprite);
        sideRight.shouldClone = false;
        sideRight.setElement(_this.paper.add("path"));
        sideRight.isMeasured = false;
        _this.sideRight = sideRight;
        _this._disposers.push(_this.sideRight);
        var sideTop = _this.createChild(Sprite_Sprite);
        sideTop.shouldClone = false;
        sideTop.setElement(_this.paper.add("path"));
        sideTop.isMeasured = false;
        _this.sideTop = sideTop;
        _this._disposers.push(_this.sideTop);
        var sideFront = _this.createChild(Sprite_Sprite);
        sideFront.shouldClone = false;
        sideFront.setElement(_this.paper.add("path"));
        sideFront.isMeasured = false;
        _this.sideFront = sideFront;
        _this._disposers.push(_this.sideFront);
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    Rectangle3D.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var w = this.innerWidth;
        var h = this.innerHeight;
        var depth = this.depth;
        var angle = this.angle;
        var sin = Math_sin(angle);
        var cos = Math_cos(angle);
        var a = { x: 0, y: 0 };
        var b = { x: w, y: 0 };
        var c = { x: w, y: h };
        var d = { x: 0, y: h };
        var ah = { x: depth * cos, y: -depth * sin };
        var bh = { x: depth * cos + w, y: -depth * sin };
        var ch = { x: depth * cos + w, y: -depth * sin + h };
        var dh = { x: depth * cos, y: -depth * sin + h };
        this.sideFront.path = moveTo(a) + lineTo(b) + lineTo(c) + lineTo(d) + closePath();
        this.sideBack.path = moveTo(ah) + lineTo(bh) + lineTo(ch) + lineTo(dh) + closePath();
        this.sideLeft.path = moveTo(a) + lineTo(ah) + lineTo(dh) + lineTo(d) + closePath();
        this.sideRight.path = moveTo(b) + lineTo(bh) + lineTo(ch) + lineTo(c) + closePath();
        this.sideBottom.path = moveTo(d) + lineTo(dh) + lineTo(ch) + lineTo(c) + closePath();
        this.sideTop.path = moveTo(a) + lineTo(ah) + lineTo(bh) + lineTo(b) + closePath();
    };
    Object.defineProperty(Rectangle3D.prototype, "depth", {
        /**
         * @return Depth (px)
         */
        get: function () {
            return this.getPropertyValue("depth");
        },
        /**
         * Depth (Z dimension) of the 3D rectangle in pixels.
         *
         * @default 30
         * @param value  Depth (px)
         */
        set: function (value) {
            this.setPropertyValue("depth", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle3D.prototype, "angle", {
        /**
         * @return Angle
         */
        get: function () {
            return this.getPropertyValue("angle");
        },
        /**
         * Angle of the point of view to the 3D element. (0-360)
         *
         * @default 30
         * @param value  Angle
         */
        set: function (value) {
            this.setPropertyValue("angle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets actual `fill` property on the SVG element, including applicable color
     * modifiers.
     *
     * @ignore Exclude from docs
     * @param value  Fill
     */
    Rectangle3D.prototype.setFill = function (value) {
        _super.prototype.setFill.call(this, value);
        if (isString(value)) {
            value = toColor(value);
        }
        var colorStr;
        if (value instanceof Color_Color) {
            colorStr = value.hex;
        }
        else if (value instanceof LinearGradient_LinearGradient || value instanceof RadialGradient_RadialGradient) {
            colorStr = value.stops.getIndex(0).color.hex;
        }
        else {
            var filter = new LightenFilter_LightenFilter();
            filter.lightness = -0.2;
            this.sideBack.filters.push(filter);
            var filter2 = filter.clone();
            filter2.lightness = -0.4;
            this.sideLeft.filters.push(filter2);
            var filter3 = filter.clone();
            filter3.lightness = -0.2;
            this.sideRight.filters.push(filter3);
            var filter4 = filter.clone();
            filter4.lightness = -0.1;
            this.sideTop.filters.push(filter4);
            var filter5 = filter.clone();
            filter5.lightness = -0.5;
            this.sideBottom.filters.push(filter5);
        }
        if (colorStr) {
            this.sideBack.fill = Color_color(colorStr).lighten(-0.2);
            this.sideLeft.fill = Color_color(colorStr).lighten(-0.4);
            this.sideRight.fill = Color_color(colorStr).lighten(-0.2);
            this.sideTop.fill = Color_color(colorStr).lighten(-0.1);
            this.sideBottom.fill = Color_color(colorStr).lighten(-0.5);
        }
    };
    /**
     * Copies all properties and related data from a different instance of Rectangle3D.
     *
     * @param source Source Rectangle3D
     */
    Rectangle3D.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.sideBack.copyFrom(source.sideBack);
        this.sideLeft.copyFrom(source.sideLeft);
        this.sideRight.copyFrom(source.sideRight);
        this.sideTop.copyFrom(source.sideTop);
        this.sideBottom.copyFrom(source.sideBottom);
    };
    return Rectangle3D;
}(Container_Container));

//# sourceMappingURL=Rectangle3D.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/3d/Slice3D.js
/**
 * 3D slice module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to draw a 3D slice of a Pie chart.
 *
 * @see {@link ISlice3DEvents} for a list of available events
 * @see {@link ISlice3DAdapters} for a list of available Adapters
 */
var Slice3D_Slice3D = /** @class */ (function (_super) {
    __extends(Slice3D, _super);
    /**
     * Constructor
     */
    function Slice3D() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "Slice3D";
        _this.layout = "none";
        // Create edge container
        var edge = _this.createChild(Sprite_Sprite);
        _this.edge = edge;
        edge.shouldClone = false;
        edge.isMeasured = false;
        edge.toBack();
        // Set defaults
        _this.angle = 30;
        _this.depth = 20;
        // Create side A element
        var sideA = _this.createChild(Sprite_Sprite);
        _this.sideA = sideA;
        sideA.shouldClone = false;
        sideA.isMeasured = false;
        //sideA.setElement(this.paper.add("path"));
        //sideA.strokeOpacity = 0;
        // Crate side B element
        var sideB = _this.createChild(Sprite_Sprite);
        _this.sideB = sideB;
        sideB.shouldClone = false;
        sideB.isMeasured = false;
        //sideB.setElement(this.paper.add("path"));
        //sideB.strokeOpacity = 0;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets actual `fill` property on the SVG element, including applicable color
     * modifiers.
     *
     * @ignore Exclude from docs
     * @param value  Fill
     */
    Slice3D.prototype.setFill = function (value) {
        _super.prototype.setFill.call(this, value);
        var colorStr;
        if (value instanceof Color_Color) {
            colorStr = value.hex;
        }
        else if (value instanceof LinearGradient_LinearGradient || value instanceof RadialGradient_RadialGradient) {
            colorStr = value.stops.getIndex(0).color.hex;
        }
        else {
            var filter = new LightenFilter_LightenFilter();
            filter.lightness = -0.25;
            this.edge.filters.push(filter);
            this.sideA.filters.push(filter.clone());
            this.sideB.filters.push(filter.clone());
        }
        if (colorStr) {
            var edgeFill = Color_color(colorStr).lighten(-0.25);
            this.edge.fill = edgeFill;
            this.sideA.fill = edgeFill;
            this.sideB.fill = edgeFill;
            this.edge.stroke = edgeFill;
            this.sideA.stroke = edgeFill;
            this.sideB.stroke = edgeFill;
        }
    };
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    Slice3D.prototype.draw = function () {
        this.cornerRadius = 0;
        this.innerCornerRadius = 0;
        _super.prototype.draw.call(this);
        if (this.arc !== 0 && this.radius > 0 && this.depth > 0) {
            this.sideB.show(0);
            this.sideA.show(0);
            this.edge.show(0);
            var startAngle = this.startAngle;
            var arc = this.arc;
            var innerRadius = this.pixelInnerRadius || 0;
            var radiusY = this.radiusY || 0;
            //let cornerRadius = this.cornerRadius || 0;
            //let innerCornerRadius = this.innerCornerRadius;
            var radius = this.radius;
            // this is code duplicate with $path.arc. @todo to think how to avoid it
            var endAngle = startAngle + arc;
            //let crSin = $math.sin($math.min(arc, 45) / 2);
            //innerCornerRadius = innerCornerRadius || cornerRadius;
            var innerRadiusY = (radiusY / radius) * innerRadius;
            //let cornerRadiusY = (radiusY / radius) * cornerRadius;
            //let innerCornerRadiusY = (radiusY / radius) * innerCornerRadius;
            //cornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);
            //cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);
            //innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);
            //innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);
            //cornerRadius = $math.fitToRange(cornerRadius, 0, radius * crSin);
            //cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, radiusY * crSin);
            //innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, innerRadius * crSin);
            //innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin);
            //let crAngle: number = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;
            //let crAngleY: number = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;
            //if (innerRadius < innerCornerRadius) {
            //	innerRadius = innerCornerRadius;
            //}
            //if (innerRadiusY < innerCornerRadiusY) {
            //	innerRadiusY = innerCornerRadiusY;
            //}
            //let crInnerAngle: number = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;
            //let crInnerAngleY: number = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;
            //if (!$type.isNumber(crInnerAngle)) {
            //	crInnerAngle = 0;
            //}
            //if (!$type.isNumber(crInnerAngleY)) {
            //	crInnerAngleY = 0;
            //}
            //let middleAngle = startAngle + arc / 2;
            //let mPoint = { x: $math.round($math.cos(middleAngle) * innerRadius, 4), y: $math.round($math.sin(middleAngle) * innerRadiusY, 4) };
            var a0 = { x: Math_cos(startAngle) * (innerRadius), y: Math_sin(startAngle) * (innerRadiusY) };
            var b0 = { x: Math_cos(startAngle) * (radius), y: Math_sin(startAngle) * (radiusY) };
            var c0 = { x: Math_cos(endAngle) * (radius), y: Math_sin(endAngle) * (radiusY) };
            var d0 = { x: Math_cos(endAngle) * (innerRadius), y: Math_sin(endAngle) * (innerRadiusY) };
            // end of duplicate
            var h = this.depth;
            var ah = { x: a0.x, y: a0.y - h };
            var bh = { x: b0.x, y: b0.y - h };
            var ch = { x: c0.x, y: c0.y - h };
            var dh = { x: d0.x, y: d0.y - h };
            var edgePath = "";
            var count = Math.ceil(arc / 5);
            var step = arc / count;
            var mangle = startAngle;
            var prevPoint = bh;
            for (var i = 0; i < count; i++) {
                mangle += step;
                if (mangle > 0 && mangle < 180) {
                    edgePath += moveTo(prevPoint);
                    var pp = { x: Math_cos(mangle) * (radius), y: Math_sin(mangle) * (radiusY) - h };
                    edgePath += lineTo({ x: prevPoint.x, y: prevPoint.y + h });
                    edgePath += arcToPoint({ x: pp.x, y: pp.y + h }, radius, radiusY, true);
                    edgePath += lineTo(pp);
                    edgePath += arcToPoint(prevPoint, radius, radiusY);
                    edgePath += "z";
                    prevPoint = pp;
                }
                else {
                    edgePath += moveTo(prevPoint);
                    var pp = { x: Math_cos(mangle) * (radius), y: Math_sin(mangle) * (radiusY) - h };
                    edgePath += arcToPoint(pp, radius, radiusY, true);
                    edgePath += lineTo({ x: pp.x, y: pp.y + h });
                    edgePath += arcToPoint({ x: prevPoint.x, y: prevPoint.y + h }, radius, radiusY);
                    edgePath += lineTo(prevPoint);
                    edgePath += "z";
                    prevPoint = pp;
                }
            }
            prevPoint = ah;
            mangle = startAngle;
            for (var i = 0; i < count; i++) {
                mangle += step;
                if (mangle > 0 && mangle < 180) {
                    edgePath += moveTo(prevPoint);
                    var pp = { x: Math_cos(mangle) * (innerRadius), y: Math_sin(mangle) * (innerRadiusY) - h };
                    edgePath += lineTo({ x: prevPoint.x, y: prevPoint.y + h });
                    edgePath += arcToPoint({ x: pp.x, y: pp.y + h }, innerRadius, innerRadiusY, true);
                    edgePath += lineTo(pp);
                    edgePath += arcToPoint(prevPoint, innerRadius, innerRadiusY);
                    edgePath += "z";
                    prevPoint = pp;
                }
                else {
                    edgePath += moveTo(prevPoint);
                    var pp = { x: Math_cos(mangle) * (innerRadius), y: Math_sin(mangle) * (innerRadiusY) - h };
                    edgePath += arcToPoint(pp, innerRadius, innerRadiusY, true);
                    edgePath += lineTo({ x: pp.x, y: pp.y + h });
                    edgePath += arcToPoint({ x: prevPoint.x, y: prevPoint.y + h }, innerRadius, innerRadiusY);
                    edgePath += lineTo(prevPoint);
                    edgePath += "z";
                    prevPoint = pp;
                }
            }
            this.edge.path = edgePath;
            /*
                        a0 = { x: $math.cos(startAngle) * (innerRadius + innerCornerRadius), y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY) };
                        b0 = { x: $math.cos(startAngle) * (radius - cornerRadius), y: $math.sin(startAngle) * (radiusY - cornerRadiusY) };
                        c0 = { x: $math.cos(endAngle) * (radius - cornerRadius), y: $math.sin(endAngle) * (radiusY - cornerRadiusY) };
                        d0 = { x: $math.cos(endAngle) * (innerRadius + innerCornerRadius), y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY) };
                        // end of duplicate
            
                        ah = { x: a0.x, y: a0.y - h };
                        bh = { x: b0.x, y: b0.y - h };
                        ch = { x: c0.x, y: c0.y - h };
                        dh = { x: d0.x, y: d0.y - h };
            */
            this.sideA.path = moveTo(a0) + lineTo(b0) + lineTo(bh) + lineTo(ah) + closePath();
            this.sideB.path = moveTo(c0) + lineTo(d0) + lineTo(dh) + lineTo(ch) + closePath();
            if (this.startAngle < 90) {
                this.sideA.toBack();
            }
            else {
                this.sideA.toFront();
            }
            if (this.startAngle + this.arc > 90) {
                this.sideB.toBack();
            }
            else {
                this.sideB.toFront();
            }
            this.slice.dy = -h;
        }
        else {
            this.sideA.hide(0);
            this.sideB.hide(0);
            this.edge.hide(0);
        }
    };
    Object.defineProperty(Slice3D.prototype, "depth", {
        /**
         * @return Depth (px)
         */
        get: function () {
            return this.getPropertyValue("depth");
        },
        /**
         * Depth (height) of the 3D slice in pixels.
         *
         * @default 20
         * @param depth  Depth (px)
         */
        set: function (depth) {
            this.setPropertyValue("depth", depth, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice3D.prototype, "angle", {
        /**
         * @return Angle
         */
        get: function () {
            var angle = this.getPropertyValue("angle");
            if (!isNumber(angle)) {
                angle = 0;
            }
            return angle;
        },
        /**
         * Angle of the point of view to the 3D element. (0-360)
         *
         * @default 30
         * @param value  Angle
         */
        set: function (value) {
            this.setPropertyValue("angle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slice3D.prototype, "radiusY", {
        /**
         * @return Vertical radius (0-1)
         */
        get: function () {
            var radiusY = this.getPropertyValue("radiusY");
            if (!isNumber(radiusY)) {
                radiusY = this.radius - this.radius * this.angle / 90;
            }
            return radiusY;
        },
        /**
         * Vertical radius for creating skewed slices.
         *
         * This is relevant to `radius`, e.g. 0.5 will set vertical radius to half
         * the `radius`.
         *
         * @param value Vertical radius (0-1)
         */
        set: function (value) {
            this.setPropertyValue("radiusY", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all properties and related data from a different instance of Axis.
     *
     * @param source Source Axis
     */
    Slice3D.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.edge.copyFrom(source.edge);
        this.sideA.copyFrom(source.sideA);
        this.sideB.copyFrom(source.sideB);
    };
    return Slice3D;
}(Slice_Slice));

//# sourceMappingURL=Slice3D.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/RadialGradientModifier.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * This class can be used to modify radial gradient steps, changing visual
 * properties like lightness, brightness, opacity of each set.
 *
 * It can also set offsets for each gradient step.
 *
 * E.g. if I want to fill a columns in a column series to be a solid fill from
 * top to 80% of height, then gradually fades out, I can use the following
 * gradient modifier as a `fillModifier`:
 *
 * ```TypeScript
 * let fillModifier = new am4core.LinearGradientModifier();
 * fillModifier.opacities = [1, 1, 0];
 * fillModifier.offsets = [0, 0.8, 1];
 * columnSeries.columns.template.fillModifier = fillModifier;
 * ```
 * ```JavaScript
 * var fillModifier = new am4core.LinearGradientModifier();
 * fillModifier.opacities = [1, 1, 0];
 * fillModifier.offsets = [0, 0.8, 1];
 * columnSeries.columns.template.fillModifier = fillModifier;
 * ```
 * ```JSON
 * "series": [{
 *   "type": "ColumnSeries",
 *   "columns": {
 *     "fillModifier": {
 *       "type": "LinearGradientModifier",
 *       "opacities": [1, 1, 0],
 *       "offsets": [0, 0.8, 1]
 *     }
 *   }
 * }]
 * ```
 */
var RadialGradientModifier_RadialGradientModifier = /** @class */ (function (_super) {
    __extends(RadialGradientModifier, _super);
    /**
     * Constructor.
     */
    function RadialGradientModifier() {
        var _this = _super.call(this) || this;
        _this.className = "RadialGradientModifier";
        _this.gradient = new RadialGradient_RadialGradient();
        _this.applyTheme();
        return _this;
    }
    RadialGradientModifier.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.gradient = source.gradient.clone();
    };
    return RadialGradientModifier;
}(GradientModifier_GradientModifier));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["RadialGradientModifier"] = RadialGradientModifier_RadialGradientModifier;
//# sourceMappingURL=RadialGradientModifier.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/LinePattern.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Line pattern.
 */
var LinePattern_LinePattern = /** @class */ (function (_super) {
    __extends(LinePattern, _super);
    /**
     * Constructor
     */
    function LinePattern() {
        var _this = _super.call(this) || this;
        _this.properties["gap"] = 0;
        _this._line = _this.paper.add("path");
        _this.addElement(_this._line);
        return _this;
    }
    /**
     * Draws the pattern.
     */
    LinePattern.prototype.draw = function () {
        _super.prototype.draw.call(this);
        if (Math.round(this.rotation / 90) != this.rotation / 90) {
            this.properties["shapeRendering"] = "auto";
        }
        if (this._line) {
            var w = this.width;
            var h = this.height;
            var path = "";
            if (!this.gap) {
                if (Math.round(this.rotation / 90) != this.rotation / 90) {
                    path = moveTo({ x: -w, y: h / 2 }) + lineTo({ x: w * 2, y: h / 2 });
                    this.properties["rotationX"] = this.width / 2;
                    this.properties["rotationY"] = this.height / 2;
                }
                else {
                    path = moveTo({ x: 0, y: 0 }) + lineTo({ x: w, y: 0 });
                }
            }
            else {
                var step = this.gap + this.strokeWidth;
                var count = this.height / step;
                for (var i = -count / 2; i < count * 1.5; i++) {
                    if (Math.round(this.rotation / 90) != this.rotation / 90) {
                        path += moveTo({ x: -w, y: (i + 0.5) * step }) + lineTo({ x: w * 2, y: (i + 0.5) * step });
                        this.properties["rotationX"] = this.width / 2;
                        this.properties["rotationY"] = this.height / 2;
                    }
                    else {
                        path += moveTo({ x: -w, y: i * step }) + lineTo({ x: w * 2, y: i * step });
                    }
                }
            }
            this._line.attr({ "d": path });
        }
    };
    Object.defineProperty(LinePattern.prototype, "gap", {
        /**
         * @return gap
         */
        get: function () {
            return this.properties["gap"];
        },
        /**
         * Number of pixels between pattern lines.
         *
         * The pattern will automatically draw required number of lines to fill
         * pattern area maintaining `gap` distance between them.
         *
         * 0 (zero) means only single line will be drawn.
         *
         * @default 0
         * @since 4.7.7
         */
        set: function (value) {
            this.properties["gap"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    return LinePattern;
}(Pattern_Pattern));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["LinePattern"] = LinePattern_LinePattern;
//# sourceMappingURL=LinePattern.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/CirclePattern.js
/**
 * Rectangular pattern module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Circular pattern
 */
var CirclePattern_CirclePattern = /** @class */ (function (_super) {
    __extends(CirclePattern, _super);
    /**
     * Constructor
     */
    function CirclePattern() {
        var _this = _super.call(this) || this;
        _this.properties["radius"] = 2;
        _this._circle = _this.paper.add("circle");
        _this.addElement(_this._circle);
        _this.shapeRendering = "auto";
        return _this;
    }
    /**
     * Draws the circle element.
     */
    CirclePattern.prototype.draw = function () {
        _super.prototype.draw.call(this);
        if (this._circle) {
            this._circle.attr({ "r": this.radius, "cx": this.width / 2, "cy": this.height / 2 });
        }
    };
    Object.defineProperty(CirclePattern.prototype, "radius", {
        /**
         * @return Radius (px)
         */
        get: function () {
            return this.properties["radius"];
        },
        /**
         * Circle radius in pixels.
         *
         * @param value Radius (px)
         */
        set: function (value) {
            this.properties["radius"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    return CirclePattern;
}(Pattern_Pattern));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["CirclePattern"] = CirclePattern_CirclePattern;
//# sourceMappingURL=CirclePattern.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/fills/RectPattern.js
/**
 * Rectangular pattern module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Rectangular pattern
 */
var RectPattern_RectPattern = /** @class */ (function (_super) {
    __extends(RectPattern, _super);
    /**
     * Constructor
     */
    function RectPattern() {
        var _this = _super.call(this) || this;
        _this.rectHeight = 1;
        _this.rectWidth = 1;
        _this._rect = _this.paper.add("rect");
        _this.addElement(_this._rect);
        return _this;
    }
    /**
     * Draws the rectangular element.
     */
    RectPattern.prototype.draw = function () {
        _super.prototype.draw.call(this);
        this.properties["rotationX"] = this.width / 2;
        this.properties["rotationY"] = this.height / 2;
        if (this._rect) {
            this._rect.attr({ "width": this.rectWidth, "height": this.rectHeight, "x": (this.width - this.rectWidth) / 2, "y": (this.height - this.rectHeight) / 2 });
        }
    };
    Object.defineProperty(RectPattern.prototype, "rectWidth", {
        /**
         * @return Width (px)
         */
        get: function () {
            return this.properties["rectWidth"];
        },
        /**
         * Rectangle width in pixels.
         *
         * @param value Width (px)
         */
        set: function (value) {
            this.properties["rectWidth"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RectPattern.prototype, "rectHeight", {
        /**
         * @return Height (px)
         */
        get: function () {
            return this.properties["rectHeight"];
        },
        /**
         * Rectangle height in pixels.
         *
         * @param value Height (px)
         */
        set: function (value) {
            this.properties["rectHeight"] = value;
            this.draw();
        },
        enumerable: true,
        configurable: true
    });
    return RectPattern;
}(Pattern_Pattern));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["RectPattern"] = RectPattern_RectPattern;
//# sourceMappingURL=RectPattern.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/filters/ColorizeFilter.js
/**
 * Module for "Colorize" filter.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a "Colorize" filter.
 */
var ColorizeFilter_ColorizeFilter = /** @class */ (function (_super) {
    __extends(ColorizeFilter, _super);
    /**
     * Constructor
     */
    function ColorizeFilter() {
        var _this = _super.call(this) || this;
        _this.className = "ColorizeFilter";
        // Create elements
        // NOTE: we do not need to add each individual element to `_disposers`
        // because `filterPrimitives` has an event handler which automatically adds
        // anything added to it to `_disposers`
        _this.feColorMatrix = _this.paper.add("feColorMatrix");
        _this.feColorMatrix.attr({ "type": "matrix" });
        //this.feColorMatrix.setAttribute("in", "SourceAlpha");
        _this.filterPrimitives.push(_this.feColorMatrix);
        // Set default properties
        _this.intensity = 1;
        _this.applyTheme();
        return _this;
    }
    /**
     * (Re)applies colors to the already existing filter by modifying filyer's
     * color matrix element.
     *
     * @ignore Exclude from docs
     */
    ColorizeFilter.prototype.applyFilter = function () {
        var i = this.intensity;
        var ii = 1 - i;
        var r;
        var g;
        var b;
        var color = this.color;
        if (color && color.rgb) {
            r = color.rgb.r / 255 * i;
            g = color.rgb.g / 255 * i;
            b = color.rgb.b / 255 * i;
        }
        else {
            r = 0;
            g = 0;
            b = 0;
        }
        this.feColorMatrix.attr({ "values": ii + " 0 0 0 " + r + " 0 " + ii + " 0 0 " + g + " 0 0 " + ii + " 0 " + b + " 0 0 0 1 0" });
    };
    Object.defineProperty(ColorizeFilter.prototype, "color", {
        /**
         * @return Color
         */
        get: function () {
            return this.properties["color"];
        },
        /**
         * Target color to apply to the element.
         *
         * Depending on the `intensity`, all colors of the target element will steer
         * towards this color.
         *
         * E.g. setting to `am4core.color("greener")` will make all colors greener.
         *
         * @param value  Color
         */
        set: function (value) {
            this.properties["color"] = value;
            this.applyFilter();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorizeFilter.prototype, "intensity", {
        /**
         * @return Intensity (0-1)
         */
        get: function () {
            return this.properties.intensity;
        },
        /**
         * Intensity of the color (0-1).
         *
         * The bigger the number the more of a `color` target's colors will become.
         *
         * 0 means the colors will remain as they are.
         * 1 means all colors will become the target `color`.
         *
         * @default 1
         * @param value  Intensity (0-1)
         */
        set: function (value) {
            this.properties.intensity = value;
            this.applyFilter();
        },
        enumerable: true,
        configurable: true
    });
    return ColorizeFilter;
}(Filter_Filter));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ColorizeFilter"] = ColorizeFilter_ColorizeFilter;
//# sourceMappingURL=ColorizeFilter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/filters/DesaturateFilter.js
/**
 * Module for "Desaturate" filter.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creats a "Desaturate" filter
 */
var DesaturateFilter_DesaturateFilter = /** @class */ (function (_super) {
    __extends(DesaturateFilter, _super);
    /**
     * Constructor
     */
    function DesaturateFilter() {
        var _this = _super.call(this) || this;
        _this.className = "DesaturateFilter";
        // Create elements
        // NOTE: we do not need to add each individual element to `_disposers`
        // because `filterPrimitives` has an event handler which automatically adds
        // anything added to it to `_disposers`
        _this.feColorMatrix = _this.paper.add("feColorMatrix");
        _this.feColorMatrix.attr({ "type": "saturate" });
        _this.filterPrimitives.push(_this.feColorMatrix);
        // Set default properties
        _this.width = 120;
        _this.height = 120;
        _this.saturation = 0;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(DesaturateFilter.prototype, "saturation", {
        /**
         * @return Saturation (0-1)
         */
        get: function () {
            return this.properties["saturation"];
        },
        /**
         * Saturation.
         *
         * 0 - completely desaturated.
         * 1 - fully saturated (gray).
         *
         * @param value  Saturation (0-1)
         */
        set: function (value) {
            this.properties["saturation"] = value;
            this.feColorMatrix.attr({ "values": value.toString() });
        },
        enumerable: true,
        configurable: true
    });
    return DesaturateFilter;
}(Filter_Filter));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["DesaturateFilter"] = DesaturateFilter_DesaturateFilter;
//# sourceMappingURL=DesaturateFilter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/filters/BlurFilter.js
/**
 * Module for "Blur" filter.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


;
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a "Blur" filter.
 */
var BlurFilter_BlurFilter = /** @class */ (function (_super) {
    __extends(BlurFilter, _super);
    /**
     * Constructor
     */
    function BlurFilter() {
        var _this = _super.call(this) || this;
        _this.className = "BlurFilter";
        // Create elements
        // NOTE: we do not need to add each individual element to `_disposers`
        // because `filterPrimitives` has an event handler which automatically adds
        // anything added to it to `_disposers`
        _this.feGaussianBlur = _this.paper.add("feGaussianBlur");
        _this.feGaussianBlur.attr({ "result": "blurOut", "in": "SourceGraphic" });
        _this.filterPrimitives.push(_this.feGaussianBlur);
        // Set default properties
        _this.width = 200;
        _this.height = 200;
        _this.blur = 1.5;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(BlurFilter.prototype, "blur", {
        /**
         * @return Blur
         */
        get: function () {
            return this.properties.blur;
        },
        /**
         * Blur value.
         *
         * The bigger the value, the blurrier the target element will become.
         *
         * @default 1.5
         * @param value Blur
         */
        set: function (value) {
            this.properties.blur = value;
            this.feGaussianBlur.attr({ "stdDeviation": value / this.scale });
        },
        enumerable: true,
        configurable: true
    });
    return BlurFilter;
}(Filter_Filter));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["BlurFilter"] = BlurFilter_BlurFilter;
//# sourceMappingURL=BlurFilter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/rendering/filters/FocusFilter.js
/**
 * Module for "Focus" filter.
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a "Focus" filter.
 *
 * @see {@link https://www.amcharts.com/docs/v4/concepts/accessibility/} more about accessibility
 * @see {@link https://www.amcharts.com/docs/v4/tutorials/changing-appearance-of-focused-items/} cusomizing focus appearance
 */
var FocusFilter_FocusFilter = /** @class */ (function (_super) {
    __extends(FocusFilter, _super);
    /**
     * Constructor
     */
    function FocusFilter() {
        var _this = _super.call(this) || this;
        _this.className = "FocusFilter";
        // Create elements
        // NOTE: we do not need to add each individual element to `_disposers`
        // because `filterPrimitives` has an event handler which automatically adds
        // anything added to it to `_disposers`
        _this.feFlood = _this.paper.add("feFlood");
        _this.feFlood.attr({ "flood-color": new InterfaceColorSet_InterfaceColorSet().getFor("primaryButtonHover"), "result": "base" });
        _this.filterPrimitives.push(_this.feFlood);
        _this.feMorphology = _this.paper.add("feMorphology");
        _this.feMorphology.attr({ "result": "bigger", "in": "SourceGraphic", "operator": "dilate", "radius": "2" });
        _this.filterPrimitives.push(_this.feMorphology);
        _this.feColorMatrix = _this.paper.add("feColorMatrix");
        _this.feColorMatrix.attr({ "result": "mask", "in": "bigger", "type": "matrix", "values": "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0" });
        _this.filterPrimitives.push(_this.feColorMatrix);
        _this.feComposite = _this.paper.add("feComposite");
        _this.feComposite.attr({ "result": "drop", "in": "base", "in2": "mask", "operator": "in" });
        _this.filterPrimitives.push(_this.feComposite);
        _this.feBlend = _this.paper.add("feBlend");
        _this.feBlend.attr({ "in": "SourceGraphic", "in2": "drop", "mode": "normal" });
        _this.filterPrimitives.push(_this.feBlend);
        // Set default properties
        _this.width = 130;
        _this.height = 130;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(FocusFilter.prototype, "stroke", {
        /**
         * @return Color
         */
        get: function () {
            return this.properties["stroke"];
        },
        /**
         * Stroke (outline) color.
         *
         * @param value  Color
         */
        set: function (value) {
            this.properties["stroke"] = value;
            this.feFlood.attr({ "flood-color": value });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusFilter.prototype, "strokeWidth", {
        /**
         * @return Outline thickness (px)
         */
        get: function () {
            return this.properties["strokeWidth"];
        },
        /**
         * Stroke (outline) thickness in pixels.
         *
         * @param value  Outline thickness (px)
         */
        set: function (value) {
            this.properties["strokeWidth"] = value;
            this.feMorphology.attr({ "radius": value });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusFilter.prototype, "opacity", {
        /**
         * @return Outline opacity (0-1)
         */
        get: function () {
            return this.properties["opacity"];
        },
        /**
         * Opacity of the outline. (0-1)
         *
         * @param value  Outline opacity (0-1)
         */
        set: function (value) {
            this.properties["opacity"] = value;
            this.feColorMatrix.attr({ "values": "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 " + value + " 0" });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets filter's target element.
     *
     * In addition it also disables built-in focus outline on element this
     * filter is applied to.
     *
     * @ignore Exclude from docs
     * @param value  Element filter is being attached to
     */
    FocusFilter.prototype.setSprite = function (value) {
        if (this._sprite && this._sprite != value) {
            this._sprite.group.removeStyle("outline");
        }
        value.group.addStyle({
            "outline": "none"
        });
        _super.prototype.setSprite.call(this, value);
    };
    return FocusFilter;
}(Filter_Filter));

//# sourceMappingURL=FocusFilter.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/ColorSet.js
/**
 * This module contains ColorSet object definition
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Represents a set of colors. Can also generate colors according to set rules.
 *
 * @important
 * @see {@link https://www.amcharts.com/docs/v4/concepts/colors/} for color-related info
 */
var ColorSet_ColorSet = /** @class */ (function (_super) {
    __extends(ColorSet, _super);
    /**
     * Constructor
     */
    function ColorSet() {
        var _this = _super.call(this) || this;
        /**
         * Holds the list of the colors in this set. (preset or auto-generated)
         */
        _this._list = [];
        /**
         * Current step in a color generator's cycle.
         */
        _this._currentStep = 0;
        /**
         * If set to non-zero value, the ColorSet will start iterating colors from
         * that particular index, not the first color in the list.
         */
        _this._startIndex = 0;
        /**
         * Current pass in the color generator's cycle. Normally a generator would
         * cycle through all available hue range, then repeat it, alternating other
         * color properties, to generate distinctive colors.
         */
        _this._currentPass = 0;
        /**
         * A base color. If there are no colors pre-set in the color list, ColorSet
         * will use this color as a base when generating new ones, applying
         * `stepOptions` and `passOptions` to this base color.
         */
        _this.baseColor = new Color_Color({
            r: 103,
            g: 183,
            b: 220
        });
        /**
         * Modifications to apply with each new generated color.
         */
        _this.stepOptions = {};
        /**
         * Modifications to apply on top of `stepOptions` for each "pass" of the
         * color generation.
         *
         * A "pass" is when ColorSet generates `minColors` number of colors.
         */
        _this.passOptions = {
            brighten: -0.2
        };
        /**
         * An index increment to use when iterating through color list.
         *
         * Default is 1, which means returning each and every color.
         *
         * Setting it to a bigger number will make ColorSet `next()` iterator skip
         * some colors.
         *
         * E.g. setting to 2, will return every second color in the list.
         *
         * This is useful, when the color list has colors that are too close each
         * other for contrast.
         *
         * However, having bigger number will mean that `next()` iterator will go
         * through the list quicker, and the generator will kick sooner.
         */
        _this.step = 1;
        /**
         * A number of colors to generate in one "pass".
         *
         * This setting can be automatically overridden, if ColorSet has a list of
         * pre-set colors. In such case ColorSet will generate exactly the same
         * number of colors with each pass as there were colors in original set.
         */
        _this.minColors = 20;
        /**
         * Do not let the "lightness" of generated color to fall below this
         * threshold.
         */
        _this.minLightness = 0.2;
        /**
         * Do not let the "lightness" of generated color to get above this threshold.
         */
        _this.maxLightness = 0.9;
        /**
         * Randomly shuffle generated colors.
         */
        _this.shuffle = false;
        /**
         * When colors are generated, based on `stepOptions`, each generated color
         * gets either lighter or darker.
         *
         * If this is set to `true`, color generator will switch to opposing spectrum
         * when reaching `minLightness` or `maxLightness`.
         *
         * E.g. if we start off with a red color, then gradually generate lighter
         * colors through rose shades, then switch back to dark red and gradually
         * increase the lightness of it until it reaches the starting red.
         *
         * If set to `false` it will stop there and cap lightness at whatever level
         * we hit `minLightness` or `maxLightness`, which may result in a number of
         * the same colors.
         */
        _this.wrap = true;
        /**
         * Re-use same colors in the pre-set list, when ColorSet runs out of colors,
         * rather than start generating new ones.
         */
        _this.reuse = false;
        /**
         * Saturation of colors. This will change saturation of all colors of color
         * set.
         *
         * It is recommended to set this in theme, as changing it at run time won't
         * make the items to redraw and change color.
         */
        _this.saturation = 1;
        _this.className = "ColorSet";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(ColorSet.prototype, "list", {
        /**
         * Returns current list of colors.
         *
         * If there are none, a new list of colors is generated, based on various
         * ColorSet settings.
         *
         * @return Color list
         */
        get: function () {
            if (!this._list) {
                this.generate(this.minColors);
            }
            return this._list;
        },
        /**
         * Sets a list of pre-defined colors to use for the iterator.
         *
         * @param value Color list
         */
        set: function (value) {
            this._list = value;
            this.reset();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets reusable color.
     *
     * @param   index  Index of color
     * @return         Color
     */
    ColorSet.prototype.getReusableColor = function (index) {
        if (this._list.length == 0) {
            this.generate(1);
            return this.list[0];
        }
        else {
            var tmpstep = index - (Math.floor(index / this._list.length) * this.list.length);
            return this.list[tmpstep];
        }
    };
    /**
     * Returns next color in the list using internal iterator counter.
     *
     * If `step` is set to something other than 1, it may return other color than
     * exact next one in the list.
     *
     * @return Color
     */
    ColorSet.prototype.next = function () {
        var color;
        if (this.list.length <= this._currentStep) {
            if (this.reuse) {
                color = this.getReusableColor(this._currentStep);
            }
            else {
                this.generate(this.minColors);
                color = this.list[this._currentStep];
            }
        }
        else {
            color = this.list[this._currentStep];
        }
        this._currentStep += this.step;
        return color.saturate(this.saturation);
    };
    /**
     * Returns a color at specific index in the list.
     *
     * @param i  Index
     * @return Color
     */
    ColorSet.prototype.getIndex = function (i) {
        var color;
        if (this.list.length <= i) {
            if (this.reuse) {
                color = this.getReusableColor(i);
            }
            else {
                this.generate(this.minColors);
                color = this.getIndex(i);
            }
        }
        else {
            color = this.list[i];
        }
        return color.saturate(this.saturation);
    };
    /**
     * Resets internal iterator.
     *
     * Calling `next()` after this will return the very first color in the color
     * list, even if it was already returned before.
     */
    ColorSet.prototype.reset = function () {
        this._currentStep = this._startIndex;
    };
    Object.defineProperty(ColorSet.prototype, "currentStep", {
        /**
         * @return Step
         */
        get: function () {
            return this._currentStep;
        },
        /**
         * Sets current color iteration. You can use this property to skip some
         * colors from iteration. E.g. setting it to `10` will skip first ten
         * colors.
         *
         * Please note that the number is zero-based.
         *
         * @param value  Step
         */
        set: function (value) {
            this._currentStep = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorSet.prototype, "startIndex", {
        /**
         * @return Index
         */
        get: function () {
            return this._startIndex;
        },
        /**
         * If set to non-zero value, the ColorSet will start iterating colors from
         * that particular index, not the first color in the list.
         *
         * @default 0
         * @since 4.4.9
         * @param  value  Index
         */
        set: function (value) {
            this._startIndex = value;
            this.reset();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Generates colors based on the various ColorSet settings.
     *
     * @param count Number of colors to generate
     */
    ColorSet.prototype.generate = function (count) {
        // Init
        var curColor = this.currentColor;
        var hsl = rgbToHsl(getValue(curColor.rgb));
        var hueStep = hasValue(this.stepOptions.hue) ? this.stepOptions.hue : 1 / count;
        var mods = {
            brighten: 0,
            lighten: 0,
            hue: hsl.h,
            lightness: hsl.l,
            saturation: hsl.s
        };
        // Generate list of hues, and shuffle them
        var hues = [];
        var startIndex = this.list.length == 0 ? 0 : 1;
        if (this.reuse) {
            for (var i = startIndex; i <= count; i++) {
                hues.push(rgbToHsl(getValue(this._list[i].rgb)).h);
            }
        }
        else {
            for (var i = startIndex; i <= count; i++) {
                var h = hsl.h + hueStep * i;
                if (this.wrap && (h > 1)) {
                    h -= 1;
                }
                hues.push(h);
            }
        }
        // Shuffle colors randomly
        if (this.shuffle) {
            hues.sort(function (a, b) {
                return Math.random() - 0.5;
            });
        }
        // Generate colors by rotating hue
        for (var i = 0; i < count; i++) {
            // Update hue
            if (this.reuse) {
                hsl = rgbToHsl(getValue(this._list[i].rgb));
            }
            else {
                hsl.h = hues.shift();
            }
            // Apply HSL mods
            this.applyStepOptions(hsl, mods, i, this._currentPass);
            // Convert back to Color
            var c = Color_color(hslToRgb(hsl));
            // Apply regular color mods
            var brighten = (this.stepOptions.brighten || 0) * i + (this.passOptions.brighten || 0) * this._currentPass;
            if (brighten != 0) {
                if (this.wrap) {
                    brighten = fitNumberRelative(brighten, this.minLightness, this.maxLightness);
                }
                else {
                    brighten = fitNumber(brighten, this.minLightness, this.maxLightness);
                }
                c = c.brighten(brighten);
            }
            var lighten = (this.stepOptions.lighten || 0) * i + (this.passOptions.lighten || 0) * this._currentPass;
            if (lighten != 0) {
                if (this.wrap) {
                    lighten = fitNumberRelative(lighten, this.minLightness, this.maxLightness);
                }
                else {
                    lighten = fitNumber(lighten, this.minLightness, this.maxLightness);
                }
                c = c.lighten(lighten);
            }
            this._list.push(c);
        }
        this._currentPass++;
    };
    Object.defineProperty(ColorSet.prototype, "currentColor", {
        /**
         * Returns current last color. It's either the last color in the list of
         * colors, or `baseColor` if list is empty.
         *
         * @return Color
         */
        get: function () {
            if (this._list.length == 0) {
                return this.baseColor.saturate(this.saturation);
            }
            else {
                return this._list[this._list.length - 1].saturate(this.saturation);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Generates modifiers for color, based on what step and pass.
     *
     * @param hsl   Curren HSL value of the color to modify
     * @param base  The modifiers that were before modification to use as a base
     * @param step  Current step
     * @param pass  Current pass
     */
    ColorSet.prototype.applyStepOptions = function (hsl, base, step, pass) {
        // Process lightness
        hsl.l = base.lightness + (this.stepOptions.lightness || 0) * step + (this.passOptions.lightness || 0) * pass;
        if (this.wrap) {
            if (hsl.l > 1) {
                hsl.l = hsl.l - Math.floor(hsl.l);
            }
            else if (hsl.l < 0) {
                hsl.l = -(hsl.l - Math.floor(hsl.l));
            }
            hsl.l = fitNumberRelative(hsl.l, this.minLightness, this.maxLightness);
        }
        else {
            if (hsl.l > 1) {
                hsl.l = 1;
            }
            else if (hsl.l < 0) {
                hsl.l = 0;
            }
            hsl.l = fitNumber(hsl.l, this.minLightness, this.maxLightness);
        }
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    ColorSet.prototype.processConfig = function (config) {
        if (config) {
            // Set up axis ranges
            if (hasValue(config.list) && isArray(config.list)) {
                for (var i = 0, len = config.list.length; i < len; i++) {
                    if (!(config.list[i] instanceof Color_Color)) {
                        config.list[i] = Color_color(config.list[i]);
                    }
                }
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    return ColorSet;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ColorSet"] = ColorSet_ColorSet;
//# sourceMappingURL=ColorSet.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/PatternSet.js
/**
 * This module contains PatternSet object definition
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * REQUISITES
 * ============================================================================
 * @hidden
 */
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines an interable list of distinctive patterns that can be used in
 * conjunction to colors to generate various fill patterns.
 *
 * @important
 * @since 4.7.5
 * @see {@link https://www.amcharts.com/docs/v4/concepts/colors/} for color-related info
 */
var PatternSet_PatternSet = /** @class */ (function (_super) {
    __extends(PatternSet, _super);
    /**
     * Constructor
     */
    function PatternSet() {
        var _this = _super.call(this) || this;
        /**
         * Holds the list of the colors in this set. (preset or auto-generated)
         */
        _this._list = [];
        /**
         * Current step.
         */
        _this._currentStep = 0;
        /**
         * If set to non-zero value, the PatternSet will start iterating patterns from
         * that particular index, not the first pattern in the list.
         */
        _this._startIndex = 0;
        /**
         * Current pass in cycle. Once all patterns in the list are iterated,
         * iteration restarts from beginning and currentPass is incremented.
         */
        _this._currentPass = 0;
        /**
         * A base color. If there are no colors pre-set in the color list, ColorSet
         * will use this color as a base when generating new ones, applying
         * `stepOptions` and `passOptions` to this base color.
         */
        _this.baseColor = new Color_Color({
            r: 103,
            g: 183,
            b: 220
        });
        _this.className = "PatternSet";
        // Set base color to be used for pattern elements
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        // Set default patterns
        _this.list = [
            _this.getLinePattern(1000, 45, 1, 6),
            _this.getRectPattern(10, 0, 4),
            _this.getLinePattern(1000, -45, 1, 6),
            _this.getCirclePattern(11, 2, true),
            _this.getLinePattern(6, 90, 1),
            _this.getRectPattern(12, 45, 6, true),
            _this.getLinePattern(6, 0, 1),
            _this.getRectPattern(7, 0, 4),
            _this.getLinePattern(1000, 45, 2, 3, "4,2"),
            _this.getCirclePattern(9, 3, false),
            _this.getLinePattern(1000, -45, 2, 3, "4,2"),
            _this.getRectPattern(10, 45, Math.sqrt(50)),
            _this.getLinePattern(1000, -45, 2, 1),
            _this.getRectPattern(10, 0, 9),
            _this.getLinePattern(1000, 45, 2, 1),
            _this.getLinePattern(1000, 0, 3, 1),
            _this.getRectPattern(10, 45, 10),
            _this.getLinePattern(1000, 90, 3, 1)
        ];
        _this.baseColor = interfaceColors.getFor("stroke");
        _this.applyTheme();
        return _this;
    }
    PatternSet.prototype.getLinePattern = function (size, rotation, thickness, gap, strokeDashArray) {
        var pattern = new LinePattern_LinePattern();
        pattern.width = size;
        pattern.height = size;
        pattern.stroke = this.baseColor;
        pattern.gap = gap;
        pattern.strokeDasharray = strokeDashArray;
        pattern.strokeWidth = thickness;
        pattern.rotation = rotation;
        return pattern;
    };
    PatternSet.prototype.getRectPattern = function (size, rotation, thickness, outline) {
        var pattern = new RectPattern_RectPattern();
        pattern.width = size;
        pattern.height = size;
        pattern.rectWidth = thickness;
        pattern.rectHeight = thickness;
        if (outline) {
            pattern.stroke = this.baseColor;
            pattern.strokeWidth = 1;
            pattern.fillOpacity = 0;
        }
        else {
            pattern.fill = this.baseColor;
            pattern.strokeWidth = 0;
        }
        if (rotation != 0) {
            pattern.shapeRendering = "auto";
        }
        pattern.rotation = rotation;
        return pattern;
    };
    PatternSet.prototype.getCirclePattern = function (size, radius, outline) {
        var pattern = new CirclePattern_CirclePattern();
        pattern.width = size;
        pattern.height = size;
        pattern.shapeRendering = "auto";
        pattern.radius = radius;
        if (outline) {
            pattern.stroke = this.baseColor;
            pattern.strokeWidth = 1;
            pattern.fillOpacity = 0;
        }
        else {
            pattern.fill = this.baseColor;
            pattern.strokeWidth = 0;
        }
        return pattern;
    };
    Object.defineProperty(PatternSet.prototype, "list", {
        /**
         * @return Pattern list
         */
        get: function () {
            return this._list;
        },
        /**
         * List of pre-defined patterns to be used in set.
         *
         * @param value Pattern list
         */
        set: function (value) {
            this._list = value;
            this.reset();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the next pattern in list.
     *
     * @return Pattern
     */
    PatternSet.prototype.next = function () {
        var pattern = this.getIndex(this.currentStep);
        this._currentStep++;
        return pattern;
    };
    /**
     * Returns a color at specific index in the list.
     *
     * @param  i  Index
     * @return Pattern
     */
    PatternSet.prototype.getIndex = function (i) {
        var pattern;
        while (this.list.length <= i) {
            this.generatePatterns();
        }
        pattern = this.list[i];
        return pattern.clone();
    };
    /**
     * Generates a new set of patterns.
     */
    PatternSet.prototype.generatePatterns = function () {
        var count = this.list.length / (this._currentPass + 1);
        this._currentPass++;
        for (var i = 0; i < count; i++) {
            this.list.push(this.list[i].clone());
        }
    };
    /**
     * Resets internal iterator.
     *
     * Calling `next()` after this will return the very first color in the color
     * list, even if it was already returned before.
     */
    PatternSet.prototype.reset = function () {
        this._currentStep = this._startIndex;
    };
    Object.defineProperty(PatternSet.prototype, "currentStep", {
        /**
         * @return Step
         */
        get: function () {
            return this._currentStep;
        },
        /**
         * Sets current color iteration. You can use this property to skip some
         * colors from iteration. E.g. setting it to `10` will skip first ten
         * colors.
         *
         * Please note that the number is zero-based.
         *
         * @param value  Step
         */
        set: function (value) {
            this._currentStep = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PatternSet.prototype, "startIndex", {
        /**
         * @return Index
         */
        get: function () {
            return this._startIndex;
        },
        /**
         * If set to non-zero value, the ColorSet will start iterating colors from
         * that particular index, not the first color in the list.
         *
         * @default 0
         * @param  value  Index
         */
        set: function (value) {
            this._startIndex = value;
            this.reset();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    PatternSet.prototype.processConfig = function (config) {
        // if (config) {
        // 	// Set up axis ranges
        // 	if ($type.hasValue(config.list) && $type.isArray(config.list)) {
        // 		for (let i = 0, len = config.list.length; i < len; i++) {
        // 			if (!(config.list[i] instanceof Color)) {
        // 				config.list[i] = color(config.list[i]);
        // 			}
        // 		}
        // 	}
        // }
        _super.prototype.processConfig.call(this, config);
    };
    return PatternSet;
}(Base_BaseObject));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["PatternSet"] = PatternSet_PatternSet;
//# sourceMappingURL=PatternSet.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Plugin.js
/**
 * A plugin base class.
 */
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * This is a base class that provides core functionality for plugins.
 *
 * The easiest way to start off with a new plugin is to extend this class.
 *
 * It will provide all the mandatory functionality, such as disposers.
 *
 * @since 4.2.2
 */
var Plugin = /** @class */ (function () {
    /**
     * Constructor
     */
    function Plugin() {
        /**
         * Is this object disposed?
         */
        this._disposed = false;
        /**
         * List of IDisposer which will be disposed when the BaseObject is disposed.
         *
         * @ignore Exclude from docs
         */
        this._disposers = [];
        // Nothing to do here
    }
    /**
     * Decorates series with required events and adapters used to hijack its
     * data.
     */
    Plugin.prototype.init = function () {
        // Does nothing
        // Override it
    };
    /**
     * Returns if this element is already disposed.
     *
     * @return Is disposed?
     */
    Plugin.prototype.isDisposed = function () {
        return this._disposed;
    };
    /**
     * Disposes this object and related stuff.
     */
    Plugin.prototype.dispose = function () {
        if (!this._disposed) {
            this._disposed = true;
            var a = this._disposers;
            this._disposers = null;
            while (a.length !== 0) {
                var disposer = a.shift();
                disposer.dispose();
            }
        }
    };
    return Plugin;
}());

//# sourceMappingURL=Plugin.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/AmChartsLogo.js
/**
 * AmChartsLogo module.
 *
 * AmChartsLogo shows amCharts logo for non-commercial users of a library.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A class used to draw and display progress indicator.
 *
 * @see {@link IAmChartsLogoEvents} for a list of available events
 * @see {@link IAmChartsLogoAdapters} for a list of available Adapters
 * @ignore Exclude from docs
 */
var AmChartsLogo_AmChartsLogo = /** @class */ (function (_super) {
    __extends(AmChartsLogo, _super);
    /**
     * Constructor
     */
    function AmChartsLogo() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "AmChartsLogo";
        _this.valign = "bottom";
        var d = 0.3;
        _this.opacity = 0.3;
        _this.defaultState.properties.opacity = 0.4;
        _this.url = "https://www.amcharts.com/";
        _this.urlTarget = "_blank";
        _this.showSystemTooltip = true;
        _this.readerTitle = "Chart created using amCharts library";
        _this.width = 220 * d;
        _this.height = 70 * d;
        _this.background.opacity = 0;
        var aColor = Color_color("#474758");
        if (new InterfaceColorSet_InterfaceColorSet().getFor("background").alternative.hex == "#ffffff") {
            aColor = Color_color("#ffffff");
        }
        var aGradient = new LinearGradient_LinearGradient();
        aGradient.addColor(aColor);
        aGradient.addColor(aColor, 1, 0.75);
        aGradient.addColor(Color_color("#3cabff"), 1, 0.755);
        aGradient.rotation = -10;
        var aStroke = aGradient;
        var m = _this.createChild(Polyspline_Polyspline);
        m.shouldClone = false;
        m.isMeasured = false;
        m.segments = [[{ x: 50 * d, y: 50 * d }, { x: 90 * d, y: 50 * d }, { x: 120 * d, y: 20 * d }, { x: 135 * d, y: 35 * d }, { x: 150 * d, y: 20 * d }, { x: 180 * d, y: 50 * d }, { x: 200 * d, y: 50 * d }]];
        m.strokeWidth = 6 * d;
        m.tensionX = 0.8;
        m.tensionY = 1;
        m.stroke = Color_color("#3cabff");
        var a = _this.createChild(Polyspline_Polyspline);
        a.shouldClone = false;
        a.isMeasured = false;
        a.segments = [[{ x: 20 * d, y: 50 * d }, { x: 50 * d, y: 50 * d }, { x: 90 * d, y: 12 * d }, { x: 133 * d, y: 50 * d }, { x: 170 * d, y: 50 * d }, { x: 200 * d, y: 50 * d }]];
        a.strokeWidth = 6 * d;
        a.tensionX = 0.75;
        a.tensionY = 1;
        a.stroke = aStroke;
        _this._disposers.push(a);
        var desaturateFilter = new DesaturateFilter_DesaturateFilter();
        _this.filters.push(desaturateFilter);
        var desaturateFilterHover = new DesaturateFilter_DesaturateFilter();
        desaturateFilterHover.saturation = 1;
        var hoverState = _this.states.create("hover");
        hoverState.properties.opacity = 1;
        hoverState.filters.push(desaturateFilterHover);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    return AmChartsLogo;
}(Container_Container));

//# sourceMappingURL=AmChartsLogo.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/utils/Instance.js
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


















/**
 * ============================================================================
 * INSTANTIATION FUNCTIONS
 * ============================================================================
 * @hidden
 */
/**
 * Creates all HTML and SVG containers needed for the chart instance, as well
 * as the new [[Sprite]] (as specified in `classType` parameter).
 *
 * @param htmlElement  A container to creat elements in
 * @param classType    A class definition of the new element to create
 * @return Newly-created Sprite object
 */
function createChild(htmlElement, classType) {
    var htmlContainer = getElement(htmlElement);
    if (htmlContainer) {
        htmlContainer.innerHTML = "";
        //htmlContainer.style.overflow = "hidden";
        var svgDiv_1 = new SVGContainer_SVGContainer(htmlContainer);
        var paper = new Paper_Paper(svgDiv_1.SVGContainer, "svg-" + (svgContainers.length - 1));
        // the approach with masks is chosen because overflow:visible is set on SVG element in order tooltips could go outside
        // svg area - this is often needed when working with small charts.
        // main container which holds content container and tooltips container
        var container_1 = new Container_Container();
        container_1.htmlContainer = htmlContainer;
        container_1.svgContainer = svgDiv_1;
        container_1.width = Percent_percent(100);
        container_1.height = Percent_percent(100);
        container_1.background.fillOpacity = 0;
        container_1.paper = paper;
        paper.append(container_1.group);
        // this is set from parent container, but this one doesn't have, so do it manually.
        container_1.relativeWidth = 1;
        container_1.relativeHeight = 1;
        svgDiv_1.container = container_1;
        // creating classType instance
        var sprite_1 = container_1.createChild(classType);
        sprite_1.topParent = container_1;
        var uid = sprite_1.uid;
        registry.invalidSprites[uid] = [];
        registry.invalidDatas[uid] = [];
        registry.invalidPositions[uid] = [];
        registry.invalidLayouts[uid] = [];
        container_1.baseId = uid;
        sprite_1.isBaseSprite = true;
        sprite_1.focusFilter = new FocusFilter_FocusFilter();
        registry.baseSprites.push(sprite_1);
        registry.baseSpritesByUid[uid] = sprite_1;
        sprite_1.maskRectangle = { x: 0, y: 0, width: Math.max(svgDiv_1.width, 0), height: Math.max(svgDiv_1.height, 0) };
        // this solves issues with display:none, as all children are measured as 0x0
        container_1.events.on("maxsizechanged", function (event) {
            if (event.previousWidth == 0 || event.previousHeight == 0) {
                container_1.deepInvalidate();
            }
            if (sprite_1.maskRectangle) {
                sprite_1.maskRectangle = { x: 0, y: 0, width: Math.max(svgDiv_1.width, 0), height: Math.max(svgDiv_1.height, 0) };
            }
        });
        var loopTimer_1 = null;
        // Checks to see whether the chart was properly disposed or not
        var loop_1 = function () {
            if (!sprite_1.isDisposed()) {
                if (getRoot(sprite_1.dom) == null) {
                    warn("Chart was not disposed", sprite_1.uid);
                    loopTimer_1 = null;
                }
                else {
                    loopTimer_1 = window.setTimeout(loop_1, 1000);
                }
            }
            else {
                loopTimer_1 = null;
            }
        };
        loop_1();
        sprite_1.addDisposer(new Disposer(function () {
            if (loopTimer_1 !== null) {
                clearTimeout(loopTimer_1);
            }
            remove(registry.baseSprites, sprite_1);
            registry.baseSpritesByUid[sprite_1.uid] = undefined;
        }));
        // TODO figure out a better way of doing this
        sprite_1.addDisposer(container_1);
        // tooltip container
        var tooltipContainer_1 = container_1.createChild(Container_Container);
        tooltipContainer_1.topParent = container_1;
        tooltipContainer_1.width = Percent_percent(100);
        tooltipContainer_1.height = Percent_percent(100);
        tooltipContainer_1.isMeasured = false;
        container_1.tooltipContainer = tooltipContainer_1;
        sprite_1.tooltip = new Tooltip_Tooltip();
        sprite_1.tooltip.hide(0);
        sprite_1.tooltip.setBounds({ x: 0, y: 0, width: tooltipContainer_1.maxWidth, height: tooltipContainer_1.maxHeight });
        tooltipContainer_1.events.on("maxsizechanged", function () {
            getValue(sprite_1.tooltip).setBounds({ x: 0, y: 0, width: tooltipContainer_1.maxWidth, height: tooltipContainer_1.maxHeight });
        }, undefined, false);
        //@todo: maybe we don't need to create one by default but only on request?
        var preloader_1 = new Preloader_Preloader();
        preloader_1.events.on("inited", function () {
            preloader_1.__disabled = true;
        }, undefined, false);
        container_1.preloader = preloader_1;
        //if (!options.commercialLicense) {
        if (sprite_1 instanceof Container_Container && !sprite_1.hasLicense()) {
            var logo_1 = tooltipContainer_1.createChild(AmChartsLogo_AmChartsLogo);
            tooltipContainer_1.events.on("maxsizechanged", function (ev) {
                if ((tooltipContainer_1.maxWidth <= 100) || (tooltipContainer_1.maxHeight <= 50)) {
                    logo_1.hide();
                }
                else if (logo_1.isHidden || logo_1.isHiding) {
                    logo_1.show();
                }
            }, undefined, false);
            sprite_1.logo = logo_1;
            logo_1.align = "left";
            logo_1.valign = "bottom";
        }
        used(sprite_1.numberFormatter); // need to create one.
        // Set this as an autonomouse instance
        // Controls like Preloader, Export will use this.
        container_1.isStandaloneInstance = true;
        if (Options_options.onlyShowOnViewport) {
            if (!isElementInViewport(htmlContainer, Options_options.viewportTarget)) {
                sprite_1.__disabled = true;
                sprite_1.tooltipContainer.__disabled = true;
                var disposers = [
                    addEventListener(window, "DOMContentLoaded", function () { viewPortHandler(sprite_1); }),
                    addEventListener(window, "load", function () { viewPortHandler(sprite_1); }),
                    addEventListener(window, "resize", function () { viewPortHandler(sprite_1); }),
                    addEventListener(window, "scroll", function () { viewPortHandler(sprite_1); })
                ];
                if (Options_options.viewportTarget) {
                    var targets = isArray(Options_options.viewportTarget) ? Options_options.viewportTarget : Options_options.viewportTarget ? [Options_options.viewportTarget] : [];
                    for (var i = 0; i < targets.length; i++) {
                        var target = targets[i];
                        disposers.push(addEventListener(target, "resize", function () { viewPortHandler(sprite_1); }));
                        disposers.push(addEventListener(target, "scroll", function () { viewPortHandler(sprite_1); }));
                    }
                }
                var disposer = new Disposer_MultiDisposer(disposers);
                sprite_1.addDisposer(disposer);
                sprite_1.vpDisposer = disposer;
            }
            else if (Options_options.queue) {
                addToQueue(sprite_1);
            }
        }
        else if (Options_options.queue) {
            addToQueue(sprite_1);
        }
        return sprite_1;
    }
    else {
        system.log("html container not found");
        throw new Error("html container not found");
    }
}
/**
 * Disposes all of the currently active charts.
 */
function disposeAllCharts() {
    while (registry.baseSprites.length !== 0) {
        registry.baseSprites.pop().dispose();
    }
}
function addToQueue(sprite) {
    if (registry.queue.indexOf(sprite) == -1) {
        sprite.__disabled = true;
        sprite.tooltipContainer.__disabled = true;
        sprite.events.disableType("appeared");
        if (registry.queue.length == 0) {
            queueHandler(sprite);
        }
        sprite.addDisposer(new Disposer(function () {
            removeFromQueue(sprite);
        }));
        registry.queue.push(sprite);
    }
}
function removeFromQueue(sprite) {
    var index = registry.queue.indexOf(sprite);
    if (index >= 0) {
        registry.queue.splice(registry.queue.indexOf(sprite), 1);
        var nextSprite = registry.queue[index];
        if (nextSprite) {
            queueHandler(nextSprite);
        }
    }
}
function viewPortHandler(sprite) {
    if (sprite.__disabled && isElementInViewport(sprite.htmlContainer, Options_options.viewportTarget)) {
        if (sprite.vpDisposer) {
            sprite.vpDisposer.dispose();
        }
        addToQueue(sprite);
    }
}
function queueHandler(sprite) {
    sprite.__disabled = false;
    sprite.tooltipContainer.__disabled = false;
    sprite.events.enableType("appeared");
    if (sprite.showOnInit) {
        sprite.events.on("appeared", function () {
            removeFromQueue(sprite);
        });
    }
    if (sprite.vpDisposer) {
        sprite.vpDisposer.dispose();
    }
    if (sprite instanceof Container_Container) {
        sprite.invalidateLabels();
    }
    if (sprite.tooltipContainer) {
        sprite.tooltipContainer.invalidateLayout();
    }
    if (sprite instanceof Component_Component) {
        sprite.invalidateData();
        sprite.reinit();
        sprite.events.once("datavalidated", function () {
            if (sprite.showOnInit) {
                sprite.appear();
            }
            else {
                removeFromQueue(sprite);
            }
        });
    }
    else {
        if (sprite.showOnInit) {
            sprite.appear();
        }
        else {
            removeFromQueue(sprite);
        }
    }
}
/**
 * A shortcut to creating a chart instance.
 *
 * The first argument is either a reference to or an id of a DOM element to be
 * used as a container for the chart.
 *
 * The second argument is the type reference of the chart type. (for plain
 * JavaScript users this can also be a string indicating chart type)
 *
 * ```TypeScript
 * let chart = am4core.create("chartdiv", am4charts.PieChart);
 * ```
 * ```JavaScript
 * // Can pass in chart type reference like this:
 * var chart = am4core.create("chartdiv", am4charts.PieChart);
 *
 * // ... or chart class type as a string:
 * var chart = am4core.create("chartdiv", "PieChart");
 * ```
 *
 * @param htmlElement  Reference or id of the target container element
 * @param classType    Class type of the target chart type
 * @return Chart instance
 */
function create(htmlElement, classType) {
    // This is a nasty hack for the benefit of vanilla JS users, who do not
    // enjoy benefits of type-check anyway.
    // We're allowing passing in a name of the class rather than type reference
    // itself.
    var classError;
    if (isString(classType)) {
        if (hasValue(registry.registeredClasses[classType])) {
            classType = registry.registeredClasses[classType];
        }
        else {
            classType = registry.registeredClasses["Container"];
            classError = new Error("Class [" + classType + "] is not loaded.");
        }
    }
    // Create the chart
    var chart = createChild(htmlElement, classType);
    // Error?
    if (classError) {
        chart.raiseCriticalError(classError);
    }
    return chart;
}
/**
 * A shortcut to creating a chart from a config object.
 *
 * Example:
 *
 * ```TypeScript
 * let chart am4core.createFromConfig({ ... }, "chartdiv", am4charts.XYChart );
 * ```
 * ```JavaScript
 * var chart am4core.createFromConfig({ ... }, "chartdiv", "XYChart" );
 * ```
 *
 * If `chartType` parameter is not supplied it must be set in a config object,
 * via reference to chart type, e.g.:
 *
 * ```TypeScript
 * {
 *   "type": am4charts.XYChart,
 *   // ...
 * }
 * ```
 * ```JavaScript
 * {
 *   "type": am4charts.XYChart,
 *   // ...
 * }
 * ```
 *
 * Or via string: (if you are using JavaScript)
 *
 * ```TypeScript
 * {
 *   "type": "XYChart",
 *   // ...
 * }
 * ```
 * ```JavaScript
 * {
 *   "type": "XYChart",
 *   // ...
 * }
 * ```
 *
 * A `container` can either be a reference to an HTML container to put chart
 * in, or it's unique id.
 *
 * If `container` is not specified, it must be included in the config object:
 *
 * ```TypeScript
 * {
 *   "type": "XYChart",
 *   "container": "chartdiv",
 *   // ...
 * }
 * ```
 * ```JavaScript
 * {
 *   "type": "XYChart",
 *   "container": "chartdiv",
 *   // ...
 * }
 * ```
 *
 * @param config       Config object in property/value pairs
 * @param htmlElement  Container reference or ID
 * @param objectType   Chart type
 * @return A newly created chart instance
 * @todo Throw exception if type is not correct
 */
function createFromConfig(config, htmlElement, classType) {
    // Extract chart type from config if necessary
    if (!hasValue(classType)) {
        classType = config.type;
        delete config.type;
    }
    // Extract element from config if necessary
    if (!hasValue(htmlElement)) {
        htmlElement = config.container;
        delete config.container;
    }
    // Check if we need to extract actual type reference
    var finalType;
    var classError;
    if (isString(classType) && hasValue(registry.registeredClasses[classType])) {
        finalType = registry.registeredClasses[classType];
    }
    else if (typeof classType !== "function") {
        finalType = Container_Container;
        classError = new Error("Class [" + classType + "] is not loaded.");
    }
    else {
        finalType = classType;
    }
    // Create the chart
    var chart = createChild(htmlElement, finalType);
    // Set config
    if (classError) {
        chart.raiseCriticalError(classError);
    }
    else {
        chart.config = config;
    }
    return chart;
}
/**
 * Applies a theme to System, and subsequently all chart instances created
 * from that point forward.
 *
 * amCharts supports multiple themes. Calling `useTheme` multiple times will
 * make the System apply multiple themes, rather than overwrite previously
 * set one.
 *
 * This enables combining features from multiple themes on the same chart.
 * E.g.:
 *
 * ```TypeScript
 * am4core.useTheme(am4themes.material);
 * am4core.useTheme(am4themes.animated);
 * ```
 * ```JavaScript
 * am4core.useTheme(am4themes.material);
 * am4core.useTheme(am4themes.animated);
 * ```
 *
 * The above will apply both the Material color and animation options to all
 * charts created.
 *
 * @param value  A reference to a theme
 */
function useTheme(value) {
    if (registry.themes.indexOf(value) === -1) {
        registry.themes.push(value);
    }
}
/**
 * Removes a theme from "active themes" list, so it won't get applied to any
 * charts created subsequently.
 *
 * @param value  A reference to a theme
 */
function unuseTheme(value) {
    remove(registry.themes, value);
}
/**
 * Removes all "active" themes. Any charts created subsequently will not have
 * any theme applied to them.
 */
function unuseAllThemes() {
    registry.themes = [];
}
/**
 * Adds a license, e.g.:
 *
 * ```TypeScript
 * am4core.addLicense("xxxxxxxx");
 * ```
 * ```JavaScript
 * am4core.addLicense("xxxxxxxx");
 * ```
 *
 * Multiple licenses can be added to cover for multiple products.
 *
 * @since 4.5.16
 * @param  license  License key
 */
function addLicense(license) {
    Options_options.licenses.push(license);
}
//# sourceMappingURL=Instance.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/core.js
/**
 * This module houses all core/framework functionality and is required for
 * all charting components to work
 */
/**
 * Elements: core
 */










/**
 * Elements: data
 */






/**
 * Elements: elements
 */
































/**
 * Elements: 3d
 */



/**
 * Elements: export
 */


/**
 * Elements: formatters
 */




/**
 * Elements: interaction
 */






/**
 * Elements: rendering
 */





/**
 * Elements: fills
 */









/**
 * Elements: filters
 */







/**
 * Elements: utils
 */

























/**
 * Functions: rendering
 */


/**
 * Functions: utils
 */


























//# sourceMappingURL=core.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/Grip.js
/**
 * Grip module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a grip element that can be used for scrolling or other things.
 *
 * @see {@link IGripEvents} for a list of available events
 * @see {@link IGripAdapters} for a list of available Adapters
 * @since 4.4.0
 */
var Grip_Grip = /** @class */ (function (_super) {
    __extends(Grip, _super);
    /**
     * Constructor
     */
    function Grip() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "Grip";
        var cs = new InterfaceColorSet_InterfaceColorSet();
        // Set defaults
        _this.layout = "absolute";
        _this.padding(10, 10, 10, 10);
        _this.margin(3, 3, 3, 3);
        _this.background.fillOpacity = 0.3;
        _this.background.cornerRadius(10, 10, 10, 10);
        // Create an icon
        var icon = new Sprite_Sprite();
        icon.element = _this.paper.add("path");
        var path = moveTo({ x: -6, y: 0 });
        path += lineTo({ x: 6, y: 0 });
        path += moveTo({ x: -8, y: -6 });
        path += lineTo({ x: 0, y: -12 });
        path += lineTo({ x: 8, y: -6 });
        path += moveTo({ x: -8, y: 6 });
        path += lineTo({ x: 0, y: 12 });
        path += lineTo({ x: 8, y: 6 });
        icon.path = path;
        icon.strokeWidth = 2;
        icon.fillOpacity = 0;
        icon.pixelPerfect = true;
        icon.padding(0, 4, 0, 4);
        icon.stroke = cs.getFor("text");
        icon.strokeOpacity = 0.7;
        icon.align = "center";
        icon.valign = "middle";
        _this.icon = icon;
        _this.label.dispose();
        _this.label = undefined;
        // Set default position
        _this.position = "right";
        // Set up autohide
        _this.autoHideDelay = 3000;
        _this.events.on("shown", function (ev) {
            if (_this._autoHideTimeout) {
                _this._autoHideTimeout.dispose();
            }
            if (_this.autoHideDelay) {
                _this._autoHideTimeout = _this.setTimeout(function () {
                    _this.hide();
                }, _this.autoHideDelay);
            }
        });
        _this.events.on("down", function (ev) {
            if (_this._autoHideTimeout) {
                _this._autoHideTimeout.dispose();
            }
        });
        _this.events.on("out", function (ev) {
            if (_this.autoHideDelay) {
                _this._autoHideTimeout = _this.setTimeout(function () {
                    _this.hide();
                }, _this.autoHideDelay);
            }
        });
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(Grip.prototype, "position", {
        /**
         * @return Position
         */
        get: function () {
            return this.getPropertyValue("position");
        },
        /**
         * Sets position of the grip.
         *
         * Available options: "left", "right" (default), "top", "bottom".
         *
         * @param  value  Position
         */
        set: function (value) {
            if (this.setPropertyValue("position", value)) {
                switch (value) {
                    case "left":
                        this.align = "left";
                        this.valign = "middle";
                        this.horizontalCenter = "left";
                        this.verticalCenter = "middle";
                        this.icon.rotation = 0;
                        this.width = undefined;
                        this.height = Percent_percent(30);
                        break;
                    case "right":
                        this.align = "right";
                        this.valign = "middle";
                        this.horizontalCenter = "right";
                        this.verticalCenter = "middle";
                        this.icon.rotation = 0;
                        this.width = undefined;
                        this.height = Percent_percent(30);
                        break;
                    case "top":
                        this.align = "center";
                        this.valign = "top";
                        this.horizontalCenter = "middle";
                        this.verticalCenter = "top";
                        this.icon.rotation = 90;
                        this.width = Percent_percent(30);
                        this.height = undefined;
                        break;
                    case "bottom":
                        this.align = "center";
                        this.valign = "bottom";
                        this.horizontalCenter = "middle";
                        this.verticalCenter = "bottom";
                        this.icon.rotation = 90;
                        this.width = Percent_percent(30);
                        this.height = undefined;
                        break;
                    default:
                        this.align = "center";
                        this.valign = "middle";
                        this.horizontalCenter = "middle";
                        this.verticalCenter = "middle";
                        this.icon.rotation = 90;
                        this.width = Percent_percent(30);
                        this.height = undefined;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grip.prototype, "autoHideDelay", {
        /**
         * @return Delay
         */
        get: function () {
            return this.getPropertyValue("autoHideDelay");
        },
        /**
         * Number of milliseconds to show grip until it is hidden automatically.
         *
         * @default 3000
         * @param  value  Delay
         */
        set: function (value) {
            this.setPropertyValue("autoHideDelay", value);
        },
        enumerable: true,
        configurable: true
    });
    return Grip;
}(Button_Button));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Grip"] = Grip_Grip;
//# sourceMappingURL=Grip.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/Chart.js
/**
 * [[Chart]] class provides base functionality for all chart types to inherit.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */












/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[Chart]].
 *
 * @see {@link DataItem}
 */
var Chart_ChartDataItem = /** @class */ (function (_super) {
    __extends(ChartDataItem, _super);
    /**
     * Constructor
     */
    function ChartDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "ChartDataItem";
        _this.applyTheme();
        return _this;
    }
    return ChartDataItem;
}(DataItem_DataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A base class for all Charts.
 *
 * @see {@link IChartEvents} for a list of available Events
 * @see {@link IChartAdapters} for a list of available Adapters
 */
var Chart_Chart = /** @class */ (function (_super) {
    __extends(Chart, _super);
    /**
     * Constructor
     */
    function Chart() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * A reference to chart's [[Legend]].
         * @ignore
         */
        _this._legend = new Disposer_MutableValueDisposer();
        if (_this.constructor === Chart) {
            throw new Error("'Chart' cannot be instantiated directly. Please use a specific chart type.");
        }
        _this.className = "Chart";
        // Create a list of titles
        var template = new Label_Label();
        _this.titles = new List_ListTemplate(template);
        _this._disposers.push(new List_ListDisposer(_this.titles));
        _this._disposers.push(template);
        // Chart component is also a container. it holds _chartAndLegendCont and titles
        _this.width = Percent_percent(100);
        _this.height = Percent_percent(100);
        _this.layout = "vertical";
        // Chart and legend
        var chartAndLegendContainer = _this.createChild(Container_Container);
        chartAndLegendContainer.shouldClone = false;
        chartAndLegendContainer.layout = "vertical";
        chartAndLegendContainer.width = Percent_percent(100);
        chartAndLegendContainer.height = Percent_percent(100);
        _this.chartAndLegendContainer = chartAndLegendContainer;
        // Chart container holds all the elements of a chart, extept titles and legend
        var chartContainer = chartAndLegendContainer.createChild(Container_Container);
        chartContainer.shouldClone = false;
        chartContainer.width = Percent_percent(100);
        chartContainer.height = Percent_percent(100);
        _this.chartContainer = chartContainer;
        _this.showOnInit = true;
        _this._disposers.push(_this._legend);
        // Add title list events to apply certain formatting options and to make
        // the chart reference them as accessible screen reader labels
        _this.titles.events.on("inserted", function (label) {
            _this.processTitle(label);
            _this.updateReaderTitleReferences();
        }, _this, false);
        _this.titles.events.on("removed", function (label) {
            _this.updateReaderTitleReferences();
        }, _this, false);
        // Accessibility
        // It seems we can't set focusable on the whole chart because it seems to
        // mess up the whole focus event system - getting a focus on an inside
        // object also trigger focus on parent
        //this.focusable = true;
        _this.role = "region";
        _this.defaultState.transitionDuration = 1;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    Chart.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Chart");
        }
    };
    /**
     * Initiates drawing of the chart.
     *
     * @ignore Exclude from docs
     */
    Chart.prototype.draw = function () {
        this.fixLayout();
        _super.prototype.draw.call(this);
    };
    /**
     * Updates legend's hierarchy based on the position.
     */
    Chart.prototype.fixLayout = function () {
        var legend = this.legend;
        if (legend) {
            var chartAndLegendContainer = this.chartAndLegendContainer;
            var chartContainer = this.chartContainer;
            chartContainer.x = undefined;
            chartContainer.y = undefined;
            legend.x = undefined;
            legend.y = undefined;
            switch (legend.position) {
                case "left":
                    chartAndLegendContainer.layout = "horizontal";
                    legend.toBack();
                    break;
                case "right":
                    chartAndLegendContainer.layout = "horizontal";
                    legend.toFront();
                    break;
                case "top":
                    chartAndLegendContainer.layout = "vertical";
                    legend.toBack();
                    break;
                case "bottom":
                    chartAndLegendContainer.layout = "vertical";
                    legend.toFront();
            }
        }
    };
    /**
     * Setups the legend to use the chart's data.
     */
    Chart.prototype.feedLegend = function () {
        // Nothing here. This method is provided only as a "placeholder" for
        // extending classes to override
    };
    /**
     * Adds a new title to the chart when it is inserted into chart's titles
     * list.
     * @param event  An event object which is triggered when inserting into titles list
     * @return Label object
     */
    Chart.prototype.processTitle = function (event) {
        var title = event.newValue;
        title.parent = this;
        title.toBack();
        title.shouldClone = false;
        title.align = "center";
        // Need to explicitly apply the `id` attribute so it can be referenced by
        // `aria-labelledby`
        title.uidAttr();
        return title;
    };
    /**
     * Checks if chart has any title elements. If it does, we will use them in an
     * `aria-labelledby` attribute so that screen readers can use them to properly
     * describe the chart when it is focused or hovered.
     *
     * @ignore Exclude from docs
     */
    Chart.prototype.updateReaderTitleReferences = function () {
        if (this.titles.length) {
            var titleIds_1 = [];
            Iterator_each(this.titles.iterator(), function (title) {
                titleIds_1.push(title.uid);
            });
            this.setSVGAttribute({ "aria-labelledby": titleIds_1.join(" ") });
        }
        else {
            this.removeSVGAttribute("aria-labelledby");
        }
    };
    Object.defineProperty(Chart.prototype, "legend", {
        /**
         * @return Legend
         */
        get: function () {
            return this._legend.get();
        },
        /**
         * Holds the instance of chart's [[Leged]].
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/} for more information about legends
         * @param Legend
         */
        set: function (legend) {
            this.setLegend(legend);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Prepares the legend instance for use in this chart.
     *
     * @param legend  Legend
     */
    Chart.prototype.setLegend = function (legend) {
        var _this = this;
        if (this._legend.get() !== legend) {
            if (legend) {
                legend.maxWidth = 200;
                // Set legend options
                legend.parent = this.chartAndLegendContainer;
                this._legend.set(legend, legend.events.on("propertychanged", function (event) {
                    if (event.property == "position") {
                        _this.fixLayout();
                    }
                }, undefined, false));
            }
            else {
                this._legend.reset();
            }
            this.feedLegend();
        }
    };
    /**
     * Destroys this object and all related data.
     */
    Chart.prototype.dispose = function () {
        // otherwise there might be some errors when disposing chart which was just inited
        if (this.legend) {
            this.legend.dispose();
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    Chart.prototype.processConfig = function (config) {
        if (config) {
            // Set up legend
            if (hasValue(config.legend) && !hasValue(config.legend.type)) {
                config.legend.type = "Legend";
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    /**
     * Copies all properties from another instance of [[Series]].
     *
     * @param source  Source series
     */
    Chart.prototype.copyFrom = function (source) {
        this.titles.copyFrom(source.titles);
        this.chartContainer.copyFrom(source.chartContainer);
        if (source.legend) {
            this.legend = source.legend.clone();
            this.legend.removeChildren();
        }
        _super.prototype.copyFrom.call(this, source);
    };
    Object.defineProperty(Chart.prototype, "dragGrip", {
        /**
         * @return Grip
         */
        get: function () {
            var _this = this;
            if (!this._dragGrip) {
                var grip_1 = this.tooltipContainer.createChild(Grip_Grip);
                grip_1.align = "right";
                grip_1.valign = "middle";
                grip_1.hide(0);
                grip_1.events.on("down", function (ev) {
                    if (ev.touch) {
                        _this.interactionsEnabled = false;
                    }
                });
                grip_1.events.on("up", function (ev) {
                    _this.interactionsEnabled = true;
                });
                this.events.on("down", function (ev) {
                    if (ev.touch) {
                        grip_1.show();
                    }
                });
                this._dragGrip = grip_1;
            }
            return this._dragGrip;
        },
        /**
         * An instance of [[Grip]] which serves as a grip point which appears on
         * touch and allows scrolling whole page even if chart is occupying the
         * whole of the screen and would otherwise prevent scrolling.
         *
         * @since 4.4.0
         * @see {@link https://www.amcharts.com/docs/v4/concepts/touch/} For more information.
         * @param  value  Grip
         */
        set: function (value) {
            this._dragGrip = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Chart.prototype, "focusable", {
        get: function () {
            return this.parent.focusable;
        },
        set: function (value) {
            this.parent.focusable = true;
        },
        enumerable: true,
        configurable: true
    });
    return Chart;
}(Component_Component));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Chart"] = Chart_Chart;
/**
 * Add default responsive rules
 */
/**
 * Reduce horizontal margins
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.widthXS,
    state: function (target, stateId) {
        if (target instanceof Chart_Chart) {
            var state = target.states.create(stateId);
            if (target.pixelPaddingLeft > 10) {
                state.properties.paddingLeft = 10;
            }
            if (target.pixelPaddingRight > 10) {
                state.properties.paddingRight = 10;
            }
            return state;
        }
        return null;
    }
});
/**
 * Reduce vertical margins
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.heightXS,
    state: function (target, stateId) {
        if (target instanceof Chart_Chart) {
            var state = target.states.create(stateId);
            if (target.pixelPaddingTop > 10) {
                state.properties.paddingTop = 10;
            }
            if (target.pixelPaddingBottom > 10) {
                state.properties.paddingBottom = 10;
            }
            return state;
        }
        return null;
    }
});
/**
 * Remove horizontal padding
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.widthXXS,
    state: function (target, stateId) {
        if (target instanceof Chart_Chart) {
            var state = target.states.create(stateId);
            state.properties.paddingLeft = 0;
            state.properties.paddingRight = 0;
            return state;
        }
        return null;
    }
});
/**
 * Remove vertical padding
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.heightXXS,
    state: function (target, stateId) {
        if (target instanceof Chart_Chart) {
            var state = target.states.create(stateId);
            state.properties.paddingTop = 0;
            state.properties.paddingBottom = 0;
            return state;
        }
        return null;
    }
});
//# sourceMappingURL=Chart.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/Bullet.js
/**
 * Module that defines everything related to building bullets.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Class used to creates bullets.
 *
 * @see {@link IBulletEvents} for a list of available events
 * @see {@link IBulletAdapters} for a list of available Adapters
 * @todo Usage example
 * @important
 */
var Bullet_Bullet = /** @class */ (function (_super) {
    __extends(Bullet, _super);
    /**
     * Constructor
     */
    function Bullet() {
        var _this = _super.call(this) || this;
        _this.className = "Bullet";
        _this.isMeasured = false;
        _this.tooltipX = 0;
        _this.tooltipY = 0;
        _this.layout = "none";
        _this.applyOnClones = true;
        _this.copyToLegendMarker = true;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(Bullet.prototype, "locationX", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("locationX");
        },
        /**
         * Relative horizontal location within cell. (0-1)
         *
         * @param value  Location (0-1)
         */
        set: function (value) {
            if (this.setPropertyValue("locationX", value)) {
                var dataItem = this.dataItem;
                if (dataItem && dataItem.component) {
                    dataItem.component.invalidate();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Bullet.prototype, "locationY", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("locationY");
        },
        /**
         * Relative vertical location within cell. (0-1)
         *
         * @param value  Location (0-1)
         */
        set: function (value) {
            if (this.setPropertyValue("locationY", value)) {
                var dataItem = this.dataItem;
                if (dataItem && dataItem.component) {
                    dataItem.component.invalidate();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Bullet.prototype, "xField", {
        /**
         * @return [description]
         */
        get: function () {
            return this.getPropertyValue("xField");
        },
        /**
         * [xField description]
         *
         * @todo Description
         * @param value  [description]
         */
        set: function (value) {
            this.setPropertyValue("xField", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Bullet.prototype, "yField", {
        /**
         * @return [description]
         */
        get: function () {
            return this.getPropertyValue("yField");
        },
        /**
         * [yField description]
         *
         * Description
         * @param value  [description]
         */
        set: function (value) {
            this.setPropertyValue("yField", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Bullet.prototype, "isDynamic", {
        /**
         * @return Redraw on data change?
         */
        get: function () {
            return this.getPropertyValue("isDynamic");
        },
        /**
         * Indicates if the bullet is "dynamic".
         *
         * In most cases the bullets remain the same, even if the underlying data
         * changes.
         *
         * However, in cases where bullet also displays a label, or its size depends
         * on data, it also needs to be redrawn when the underlying data changes.
         *
         * Only those bullets that have set `isDynamic = true` will be redrawn each
         * time data changes. Regular bullets will be reused as they are.
         *
         * @default false
         * @param value  Redraw on data change?
         */
        set: function (value) {
            this.setPropertyValue("isDynamic", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Bullet.prototype, "copyToLegendMarker", {
        /**
         * @return Redraw on data change?
         */
        get: function () {
            return this.getPropertyValue("copyToLegendMarker");
        },
        /**
         * Indicates if the bullet should be copied to legend marker
         *
         * @default false
         * @param value  Redraw on data change?
         */
        set: function (value) {
            this.setPropertyValue("copyToLegendMarker", value);
        },
        enumerable: true,
        configurable: true
    });
    return Bullet;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Bullet"] = Bullet_Bullet;
/**
 * Add default responsive rules
 */
/**
 * Hide bullets
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.isXS,
    state: function (target, stateId) {
        if (target instanceof Bullet_Bullet) {
            var state = target.states.create(stateId);
            state.properties.disabled = true;
            return state;
        }
        return null;
    }
});
//# sourceMappingURL=Bullet.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/Legend.js
/**
 * Legend-related functionality.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



















/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[Legend]].
 *
 * @see {@link DataItem}
 */
var Legend_LegendDataItem = /** @class */ (function (_super) {
    __extends(LegendDataItem, _super);
    /**
     * Constructor
     */
    function LegendDataItem() {
        var _this = _super.call(this) || this;
        /**
         * @ignore
         */
        _this.childrenCreated = false;
        _this.className = "LegendDataItem";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(LegendDataItem.prototype, "label", {
        /**
         * A legend item's [[Label]] element.
         *
         * @return Label
         */
        get: function () {
            var _this = this;
            if (!this._label) {
                var label_1 = this.component.labels.create();
                this._label = label_1;
                this.addSprite(label_1);
                this._disposers.push(label_1);
                label_1.parent = this.itemContainer;
                this._disposers.push(new Disposer(function () {
                    if (hasValue(_this.component)) {
                        _this.component.labels.removeValue(label_1);
                    }
                }));
            }
            return this._label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LegendDataItem.prototype, "color", {
        /**
         * @return Main color
         */
        get: function () {
            return this.properties.color;
        },
        /**
         * Main color of legend data item.
         *
         * This is set by the target element this legend item represents, like
         * a Series or a Slice.
         *
         * It can be used to derive a color in legend's sub-items, like label:
         *
         * ```TypeScript
         * chart.legend.labels.template.text = "[{color}]{name}[/]";
         * ```
         * ```JavaScript
         * chart.legend.labels.template.text = "[{color}]{name}[/]";
         * ```
         * ```JSON
         * {
         *   // ...
         *   "legend": {
         *     // ...
         *     "labels": {
         *       "text": "[{color}]{name}[/]"
         *     }
         *   }
         * }
         * ```
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/#Legend_labels} For more information about configuring legend labels.
         * @param value  Main color
         */
        set: function (value) {
            this.setProperty("color", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LegendDataItem.prototype, "valueLabel", {
        /**
         * A legend item's [[Label]] element for "value label".
         *
         * @return Label
         */
        get: function () {
            var _this = this;
            if (!this._valueLabel) {
                var valueLabel_1 = this.component.valueLabels.create();
                this._valueLabel = valueLabel_1;
                this.addSprite(valueLabel_1);
                this._disposers.push(valueLabel_1);
                valueLabel_1.parent = this.itemContainer;
                this._disposers.push(new Disposer(function () {
                    if (hasValue(_this.component)) {
                        _this.component.valueLabels.removeValue(valueLabel_1);
                    }
                }));
            }
            return this._valueLabel;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LegendDataItem.prototype, "itemContainer", {
        /**
         * A reference to the main [[Container]] that holds legend item's elements:
         * marker and labels.
         *
         * @return Item container
         */
        get: function () {
            var _this = this;
            if (!this._itemContainer) {
                var component_1 = this.component;
                var itemContainer_1 = component_1.itemContainers.create();
                itemContainer_1.parent = component_1;
                this._itemContainer = itemContainer_1;
                this.addSprite(itemContainer_1);
                this._disposers.push(itemContainer_1);
                // Add click/tap event to toggle item
                if (itemContainer_1.togglable) {
                    itemContainer_1.events.on("toggled", function (ev) {
                        component_1.toggleDataItem(ev.target.dataItem);
                    }, undefined, false);
                }
                // Add focus event so that we can track which object is currently in focus
                // for keyboard toggling
                if (itemContainer_1.focusable) {
                    itemContainer_1.events.on("hit", function (ev) {
                        // We need this here in order to reset focused item when it is clicked
                        // normally so that it is not toggled by ENTER afterwards
                        component_1.focusedItem = undefined;
                    }, undefined, false);
                    itemContainer_1.events.on("focus", function (ev) {
                        component_1.focusedItem = ev.target.dataItem;
                    }, undefined, false);
                    itemContainer_1.events.on("blur", function (ev) {
                        component_1.focusedItem = undefined;
                    }, undefined, false);
                }
                this._disposers.push(new Disposer(function () {
                    if (hasValue(_this.component)) {
                        _this.component.itemContainers.removeValue(itemContainer_1);
                    }
                }));
                if (this.dataContext.uidAttr) {
                    itemContainer_1.readerControls = this.dataContext.uidAttr();
                    itemContainer_1.readerLabelledBy = this.dataContext.uidAttr();
                }
                var sprite = this.dataContext;
                if ((sprite instanceof DataItem_DataItem || sprite instanceof Sprite_Sprite) && !sprite.isDisposed()) {
                    var visibilitychanged = function (ev) {
                        itemContainer_1.readerChecked = ev.visible;
                        itemContainer_1.events.disableType("toggled");
                        itemContainer_1.isActive = !ev.visible;
                        itemContainer_1.events.enableType("toggled");
                    };
                    sprite.addDisposer(new Disposer(function () {
                        if (_this.component) {
                            _this.component.dataItems.remove(_this);
                        }
                    }));
                    if (sprite instanceof Sprite_Sprite) {
                        itemContainer_1.addDisposer(sprite.events.on("visibilitychanged", visibilitychanged, undefined, false));
                        itemContainer_1.addDisposer(sprite.events.on("hidden", function (ev) {
                            itemContainer_1.readerChecked = false;
                            itemContainer_1.events.disableType("toggled");
                            itemContainer_1.isActive = true;
                            itemContainer_1.events.enableType("toggled");
                        }, undefined, false));
                        itemContainer_1.addDisposer(sprite.events.on("shown", function (ev) {
                            itemContainer_1.readerChecked = true;
                            itemContainer_1.events.disableType("toggled");
                            itemContainer_1.isActive = false;
                            itemContainer_1.events.enableType("toggled");
                        }, undefined, false));
                    }
                    else {
                        itemContainer_1.addDisposer(sprite.events.on("visibilitychanged", visibilitychanged, undefined, false));
                    }
                }
            }
            return this._itemContainer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LegendDataItem.prototype, "marker", {
        /**
         * A [[Container]] that holds legend item's marker element.
         *
         * @return Marker
         */
        get: function () {
            var _this = this;
            if (!this._marker) {
                var marker_1 = this.component.markers.create();
                this._marker = marker_1;
                marker_1.parent = this.itemContainer;
                this.addSprite(marker_1);
                this._disposers.push(marker_1);
                this._disposers.push(new Disposer(function () {
                    if (hasValue(_this.component)) {
                        _this.component.markers.removeValue(marker_1);
                    }
                }));
            }
            return this._marker;
        },
        enumerable: true,
        configurable: true
    });
    return LegendDataItem;
}(DataItem_DataItem));

/**
 * ============================================================================
 * REQUISITES
 * ============================================================================
 * @hidden
 */
/**
 * Defines a class that carries legend settings.
 *
 * A legend might change its settings dynamically. Legend can also be shared
 * by several elements, requiring different settings.
 *
 * Having legend's settings in a separate object is a good way to "hot swap"
 * a set of settings for the legend.
 */
var LegendSettings = /** @class */ (function () {
    function LegendSettings() {
        /**
         * Should marker be created for each legend item.
         */
        this.createMarker = true;
    }
    return LegendSettings;
}());

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * [[Legend]] class is used to create legend for the chart.
 *
 * @see {@link https://www.amcharts.com/docs/v4/concepts/legend/} for Legend documentation
 * @see {@link ILegendEvents} for a list of available events
 * @see {@link ILegendAdapters} for a list of available Adapters
 */
var Legend_Legend = /** @class */ (function (_super) {
    __extends(Legend, _super);
    /**
     * Constructor
     */
    function Legend() {
        var _this = _super.call(this) || this;
        _this.className = "Legend";
        // Set defaults
        _this.layout = "grid";
        _this.setPropertyValue("useDefaultMarker", false);
        _this.setPropertyValue("scrollable", false);
        _this.setPropertyValue("contentAlign", "center");
        // Create a template container and list for legend items
        var itemContainer = new Container_Container();
        itemContainer.applyOnClones = true;
        itemContainer.padding(8, 0, 8, 0);
        itemContainer.margin(0, 10, 0, 10);
        itemContainer.layout = "horizontal";
        itemContainer.clickable = true;
        itemContainer.focusable = true;
        itemContainer.role = "switch";
        itemContainer.togglable = true;
        itemContainer.cursorOverStyle = MouseCursorStyle.pointer;
        itemContainer.background.fillOpacity = 0; // creates hit area
        // Create container list using item template we just created
        _this.itemContainers = new List_ListTemplate(itemContainer);
        _this._disposers.push(new List_ListDisposer(_this.itemContainers));
        _this._disposers.push(_this.itemContainers.template);
        // Set up global keyboard events for toggling elements
        _this._disposers.push(getInteraction().body.events.on("keyup", function (ev) {
            if (keyboard.isKey(ev.event, "enter") && _this.focusedItem) {
                var focusedItem = _this.focusedItem;
                var target = focusedItem.itemContainer;
                if (target.togglable) {
                    _this.toggleDataItem(focusedItem);
                }
                else if (target.clickable && target.events.isEnabled("hit")) {
                    target.dispatchImmediately("hit", { event: ev });
                    // We need this here because "hit" event resets `this.focusedItem`
                    // And we need it here
                    _this.focusedItem = focusedItem;
                }
            }
        }, _this));
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        // Create a template container and list for the a marker
        var marker = new Container_Container();
        marker.width = 23;
        marker.height = 23;
        marker.interactionsEnabled = false;
        marker.applyOnClones = true;
        marker.setStateOnChildren = true;
        marker.background.fillOpacity = 0;
        marker.background.strokeOpacity = 0;
        marker.propertyFields.fill = "fill";
        marker.valign = "middle";
        var disabledColor = interfaceColors.getFor("disabledBackground");
        marker.events.on("childadded", function (event) {
            var child = event.newValue;
            var activeState = child.states.create("active");
            activeState.properties.stroke = disabledColor;
            activeState.properties.fill = disabledColor;
        });
        _this.markers = new List_ListTemplate(marker);
        _this._disposers.push(new List_ListDisposer(_this.markers));
        _this._disposers.push(_this.markers.template);
        // Create a legend background element
        var rectangle = marker.createChild(RoundedRectangle_RoundedRectangle);
        rectangle.width = Percent_percent(100);
        rectangle.height = Percent_percent(100);
        rectangle.applyOnClones = true;
        rectangle.propertyFields.fill = "fill";
        rectangle.strokeOpacity = 0;
        // Create a template container and list for item labels
        var label = new Label_Label();
        label.text = "{name}";
        label.margin(0, 5, 0, 5);
        label.valign = "middle";
        label.applyOnClones = true;
        label.states.create("active").properties.fill = interfaceColors.getFor("disabledBackground");
        _this.labels = new List_ListTemplate(label);
        _this._disposers.push(new List_ListDisposer(_this.labels));
        _this._disposers.push(_this.labels.template);
        label.interactionsEnabled = false;
        label.truncate = true;
        label.fullWords = false;
        // Create a template container and list for item value labels
        var valueLabel = new Label_Label();
        valueLabel.margin(0, 5, 0, 0);
        valueLabel.valign = "middle";
        valueLabel.width = 50; // to avoid rearranging legend entries when value changes.
        valueLabel.align = "right";
        valueLabel.textAlign = "end";
        valueLabel.applyOnClones = true;
        valueLabel.states.create("active").properties.fill = interfaceColors.getFor("disabledBackground");
        valueLabel.interactionsEnabled = false;
        _this.valueLabels = new List_ListTemplate(valueLabel);
        _this._disposers.push(new List_ListDisposer(_this.valueLabels));
        _this._disposers.push(_this.valueLabels.template);
        _this.position = "bottom"; // don't use setPropertyValue here!
        // Create a state for disabled legend items
        itemContainer.states.create("active");
        itemContainer.setStateOnChildren = true;
        // Apply accessibility settings
        _this.role = "group";
        _this.events.on("layoutvalidated", _this.handleScrollbar, _this, false);
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    Legend.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Legend");
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    Legend.prototype.createDataItem = function () {
        return new Legend_LegendDataItem();
    };
    /**
     * [validateDataElement description]
     *
     * @ignore Exclude from docs
     * @param dataItem Data item
     * @todo Description
     * @todo Figure out how to update appearance of legend item without losing focus
     * @todo Update legend marker appearance as apperance of related series changes
     */
    Legend.prototype.validateDataElement = function (dataItem) {
        _super.prototype.validateDataElement.call(this, dataItem);
        // Get data item (legend item's) container
        var container = dataItem.itemContainer;
        var marker = dataItem.marker;
        used(dataItem.label);
        var valueLabel = dataItem.valueLabel;
        // Set parent and update current state
        container.readerChecked = dataItem.dataContext.visible;
        // Tell series its legend data item
        dataItem.dataContext.legendDataItem = dataItem;
        var tempMaxWidth = dataItem.label.maxWidth;
        dataItem.label.width = undefined;
        if (tempMaxWidth > 0) {
            dataItem.label.maxWidth = tempMaxWidth;
        }
        if (valueLabel.align == "right") {
            valueLabel.width = undefined;
        }
        var legendSettings = dataItem.dataContext.legendSettings;
        // If we are not using default markers, create a unique legend marker based
        // on the data item type
        var dataContext = dataItem.dataContext;
        if (dataContext.createLegendMarker && (!this.useDefaultMarker || !(dataContext instanceof Sprite_Sprite))) {
            if (!dataItem.childrenCreated) {
                dataContext.createLegendMarker(marker);
                dataItem.childrenCreated = true;
            }
        }
        if (dataContext.updateLegendValue) {
            dataContext.updateLegendValue(); // this solves issue with external legend, as legend is created after chart updates legend values
        }
        if (dataContext.component && dataContext.component.updateLegendValue) {
            dataContext.component.updateLegendValue(dataContext);
        }
        if (valueLabel.invalid) {
            valueLabel.validate();
        }
        if (valueLabel.text == "" || valueLabel.text == undefined) {
            valueLabel.__disabled = true;
        }
        else {
            valueLabel.__disabled = false;
        }
        if (legendSettings && (legendSettings.itemValueText != undefined || legendSettings.valueText != undefined)) {
            valueLabel.__disabled = false;
        }
        var visible = dataItem.dataContext.visible;
        if (visible === undefined) {
            visible = true;
        }
        visible = toBoolean(visible);
        dataItem.dataContext.visible = visible;
        container.events.disableType("toggled");
        container.isActive = !visible;
        if (container.isActive) {
            container.setState("active", 0);
        }
        else {
            container.setState("default", 0);
        }
        container.events.enableType("toggled");
    };
    Legend.prototype.afterDraw = function () {
        var _this = this;
        var maxWidth = this.getPropertyValue("maxWidth");
        var maxLabelWidth = 0;
        this.labels.each(function (label) {
            if (label.invalid) {
                label.validate();
            }
            if (label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight > maxLabelWidth) {
                maxLabelWidth = label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight;
            }
        });
        var maxValueLabelWidth = 0;
        this.valueLabels.each(function (label) {
            if (label.invalid) {
                label.validate();
            }
            if (label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight > maxValueLabelWidth) {
                maxValueLabelWidth = label.measuredWidth + label.pixelMarginLeft + label.pixelMarginRight;
            }
        });
        var maxMarkerWidth = 0;
        this.markers.each(function (marker) {
            if (marker.invalid) {
                marker.validate();
            }
            if (marker.measuredWidth + marker.pixelMarginLeft + marker.pixelMarginRight > maxMarkerWidth) {
                maxMarkerWidth = marker.measuredWidth + marker.pixelMarginLeft + marker.pixelMarginRight;
            }
        });
        var itemContainer = this.itemContainers.template;
        var margin = itemContainer.pixelMarginRight + itemContainer.pixelMarginLeft;
        var maxAdjustedLabelWidth;
        var trueMaxWidth = maxLabelWidth + maxValueLabelWidth + maxMarkerWidth;
        if (!isNumber(maxWidth)) {
            maxAdjustedLabelWidth = maxLabelWidth;
        }
        else {
            maxWidth = maxWidth - margin;
            if (maxWidth > trueMaxWidth) {
                maxWidth = trueMaxWidth;
            }
            maxAdjustedLabelWidth = maxWidth - maxMarkerWidth - maxValueLabelWidth;
        }
        this.labels.each(function (label) {
            if (_this.valueLabels.template.align == "right" || label.measuredWidth > maxAdjustedLabelWidth) {
                label.width = Math.min(label.maxWidth, maxAdjustedLabelWidth - label.pixelMarginLeft - label.pixelMarginRight);
            }
        });
        if (this.valueLabels.template.align == "right") {
            this.valueLabels.each(function (valueLabel) {
                valueLabel.width = maxValueLabelWidth - valueLabel.pixelMarginRight - valueLabel.pixelMarginLeft;
            });
        }
        _super.prototype.afterDraw.call(this);
    };
    Legend.prototype.handleScrollbar = function () {
        var scrollbar = this.scrollbar;
        if (this.scrollable && scrollbar) {
            scrollbar.height = this.measuredHeight;
            scrollbar.x = this.measuredWidth - scrollbar.pixelWidth - scrollbar.pixelMarginLeft;
            if (this.contentHeight > this.measuredHeight) {
                scrollbar.visible = true;
                scrollbar.thumb.height = scrollbar.height * this.measuredHeight / this.contentHeight;
                this.paddingRight = scrollbar.pixelWidth + scrollbar.pixelMarginLeft + +scrollbar.pixelMarginRight;
            }
            else {
                scrollbar.visible = false;
            }
            this.updateMasks();
        }
    };
    Object.defineProperty(Legend.prototype, "position", {
        /**
         * @return Position
         */
        get: function () {
            return this.getPropertyValue("position");
        },
        /**
         * Position of the legend.
         *
         * Options: "left", "right", "top", "bottom" (default), or "absolute".
         *
         * IMPORTANT: [[MapChart]] will ignore this setting, as it is using different
         * layout structure than other charts.
         *
         * To position legend in [[MapChart]] set legend's `align` (`"left"` or
         * `"right"`) and `valign` (`"top"` or `"bottom"`) properties instead.
         *
         * @default "bottom"
         * @param value  Position
         */
        set: function (value) {
            if (this.setPropertyValue("position", value)) {
                if (value == "left" || value == "right") {
                    this.margin(10, 5, 10, 10);
                    this.valign = "middle";
                    this.contentAlign = "none";
                    this.valueLabels.template.align = "right";
                    if (!isNumber(this.maxColumns)) {
                        this.maxColumns = 1;
                    }
                    this.width = undefined;
                    this.maxWidth = 220;
                }
                else {
                    this.maxColumns = undefined;
                    this.width = Percent_percent(100);
                    this.valueLabels.template.align = "left";
                }
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Legend.prototype, "useDefaultMarker", {
        /**
         * @return Use default marker?
         */
        get: function () {
            return this.getPropertyValue("useDefaultMarker");
        },
        /**
         * Should legend try to mirror the look of the related item when building
         * the marker for legend item?
         *
         * If set to `true` it will try to make the marker look like its related
         * item.
         *
         * E.g. if an item is for a Line Series, it will display a line of the
         * same thickness, color, and will use the same bullets if series have them.
         *
         * @default false
         * @param value Use default marker?
         */
        set: function (value) {
            this.setPropertyValue("useDefaultMarker", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Legend.prototype, "scrollable", {
        /**
         * @return Legend Scrollable?
         */
        get: function () {
            return this.getPropertyValue("scrollable");
        },
        /**
         * If set to `true` the Legend will display a scrollbar if its contents do
         * not fit into its `maxHeight`.
         *
         * Please note that `maxHeight` is automatically set for Legend when its
         * `position` is set to `"left"` or `"right"`.
         *
         * @default false
         * @since 4.8.0
         * @param  value  Legend Scrollable?
         */
        set: function (value) {
            if (this.setPropertyValue("scrollable", value, true)) {
                if (value) {
                    var scrollbar = this.createChild(Scrollbar_Scrollbar);
                    this.scrollbar = scrollbar;
                    scrollbar.isMeasured = false;
                    scrollbar.orientation = "vertical";
                    scrollbar.endGrip.__disabled = true;
                    scrollbar.startGrip.__disabled = true;
                    scrollbar.visible = false;
                    scrollbar.marginLeft = 5;
                    this._mouseWheelDisposer = this.events.on("wheel", this.handleWheel, this, false);
                    this._disposers.push(this._mouseWheelDisposer);
                    this._disposers.push(scrollbar.events.on("rangechanged", this.updateMasks, this, false));
                }
                else {
                    if (this._mouseWheelDisposer) {
                        this._mouseWheelDisposer.dispose();
                        if (this.scrollbar) {
                            this.scrollbar.dispose();
                            this.scrollbar = undefined;
                        }
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handles mouse wheel scrolling of legend.
     *
     * @param  event  Event
     */
    Legend.prototype.handleWheel = function (event) {
        var shift = event.shift.y;
        var scrollbar = this.scrollbar;
        if (scrollbar) {
            var ds = (shift / 1000 * this.measuredHeight / this.contentHeight);
            var delta = scrollbar.end - scrollbar.start;
            if (shift > 0) {
                scrollbar.start = Math_max(0, scrollbar.start - ds);
                scrollbar.end = scrollbar.start + delta;
            }
            else {
                scrollbar.end = Math_min(1, scrollbar.end - ds);
                scrollbar.start = scrollbar.end - delta;
            }
        }
    };
    /**
     * @ignore
     */
    Legend.prototype.updateMasks = function () {
        var _this = this;
        if (this.scrollbar) {
            this.itemContainers.each(function (itemContainer) {
                itemContainer.dy = -_this.scrollbar.thumb.pixelY * _this.contentHeight / _this.measuredHeight;
                itemContainer.maskRectangle = { x: 0, y: -itemContainer.dy, width: _this.measuredWidth, height: _this.measuredHeight };
            });
        }
    };
    /**
     * Toggles a legend item.
     *
     * @ignore Exclude from docs
     * @param item Legend item
     * @todo Maybe do it with togglable instead
     */
    Legend.prototype.toggleDataItem = function (item) {
        var dataContext = item.dataContext;
        if (!dataContext.visible || dataContext.isHiding || (dataContext instanceof Sprite_Sprite && dataContext.isHidden)) {
            item.color = item.colorOrig;
            item.itemContainer.isActive = false;
            if (dataContext.hidden === true) {
                dataContext.hidden = false;
            }
            if (dataContext.show) {
                dataContext.show();
            }
            else {
                dataContext.visible = true;
            }
            this.svgContainer.readerAlert(this.language.translate("%1 shown", this.language.locale, item.label.readerTitle));
        }
        else {
            item.itemContainer.isActive = true;
            if (dataContext.hide) {
                dataContext.hide();
            }
            else {
                dataContext.visible = false;
            }
            this.svgContainer.readerAlert(this.language.translate("%1 hidden", this.language.locale, item.label.readerTitle));
            item.color = new InterfaceColorSet_InterfaceColorSet().getFor("disabledBackground");
        }
    };
    Object.defineProperty(Legend.prototype, "preloader", {
        /**
         * Override preloader method so that legend does not accidentally show its
         * own preloader.
         *
         * @ignore Exclude from docs
         * @return Always `undefined`
         */
        get: function () {
            return;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * [handleDataItemPropertyChange description]
     *
     * @ignore Exclude from docs
     */
    Legend.prototype.handleDataItemPropertyChange = function (dataItem, name) {
        dataItem.valueLabel.invalidate();
        dataItem.label.invalidate();
    };
    return Legend;
}(Component_Component));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Legend"] = Legend_Legend;
/**
 * Add default responsive rules
 */
/**
 * Move legend to below the chart if chart is narrow
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.widthXS,
    state: function (target, stateId) {
        if (target instanceof Legend_Legend && (target.position == "left" || target.position == "right")) {
            var state = target.states.create(stateId);
            state.properties.position = "bottom";
            return state;
        }
        return null;
    }
});
/**
 * Move legend to the right if chart is very short
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.heightXS,
    state: function (target, stateId) {
        if (target instanceof Legend_Legend && (target.position == "top" || target.position == "bottom")) {
            var state = target.states.create(stateId);
            state.properties.position = "right";
            return state;
        }
        return null;
    }
});
/**
 * Disable legend altogether on small charts
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.isXS,
    state: function (target, stateId) {
        if (target instanceof Legend_Legend) {
            var state = target.states.create(stateId);
            state.properties.disabled = true;
            return state;
        }
        return null;
    }
});
//# sourceMappingURL=Legend.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/Series.js
/**
 * Functionality for any series-based elements, like Line Series (graphs),
 * Pie slice lists, etc.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




















/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[Series]].
 *
 * @see {@link DataItem}
 */
var Series_SeriesDataItem = /** @class */ (function (_super) {
    __extends(SeriesDataItem, _super);
    /**
     * Constructor
     */
    function SeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "SeriesDataItem";
        //@todo Should we make `bullets` list disposable?
        //this._disposers.push(new DictionaryDisposer(this.bullets));
        _this.values.value = {};
        _this.values.value = {};
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(SeriesDataItem.prototype, "bullets", {
        /**
         * A dictionary of data items bullets, where key is uid of a bullet template.
         */
        get: function () {
            if (!this._bullets) {
                this._bullets = new Dictionary_Dictionary();
                this._disposers.push(new Dictionary_DictionaryDisposer(this._bullets));
            }
            return this._bullets;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Destroys this object and all related data.
     */
    SeriesDataItem.prototype.dispose = function () {
        this.bullets.clear();
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(SeriesDataItem.prototype, "value", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.value.value;
        },
        /**
         * data items's numeric value.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("value", value);
        },
        enumerable: true,
        configurable: true
    });
    return SeriesDataItem;
}(DataItem_DataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines base class for any kind of serial data.
 *
 * @see {@link ISeriesEvents} for a list of available Events
 * @see {@link ISeriesAdapters} for a list of available Adapters
 * @todo Separate axis-related stuff to some other class so that MapSeries would not have unrelated stuff
 */
var Series_Series = /** @class */ (function (_super) {
    __extends(Series, _super);
    /**
     * Constructor
     */
    function Series() {
        var _this = _super.call(this) || this;
        /**
         * Should this series excluded from the axis scale calculations?
         *
         * @default false
         */
        _this._ignoreMinMax = false;
        /**
         * Should series' bullets?
         *
         * @default true
         */
        _this._showBullets = true;
        /**
         * Settings for the appearance of the related legend items.
         */
        _this.legendSettings = new LegendSettings();
        /**
         * Lowest overal values by type.
         */
        _this._tmin = new Dictionary_Dictionary();
        /**
         * Highest overal values by type.
         */
        _this._tmax = new Dictionary_Dictionary();
        /**
         * Lowest values in current selection by type.
         */
        _this._smin = new Dictionary_Dictionary();
        /**
         * Highest values in current selection by type.
         */
        _this._smax = new Dictionary_Dictionary();
        /**
         * [dataItemsByAxis description]
         *
         * Both by category and date.
         *
         * @ignore Exclude from docs
         * @todo Description
         */
        _this.dataItemsByAxis = new Dictionary_Dictionary();
        /**
         * Normally series items are focusable using keyboard, so that people can
         * select them with a TAB key. However, if there are a lot of data points on
         * screen it might be long and useless to tab through all o fthem.
         *
         * This is where `skipFocusThreshold` comes in. If there are more items than
         * the value set here, we will not make those focusable and rather let screen
         * reader software rely on the series summary, or authors provide alternative
         * detailed information display, such as HTML table.
         *
         * Different series might have different threshold defaults.
         */
        _this.skipFocusThreshold = 20;
        /**
         * Used to indicate if `itemReaderText` was changed "from the outside".
         */
        _this._itemReaderTextChanged = false;
        /**
         * Most of the series use absolute values. However sometimes various
         * calculated percent values are need, e.g. item's percent representation
         * across all values in series, etc.
         *
         * It's a resource-intensive operation, so it is disabled by default.
         *
         * If you need percents to be calculated, e.g. for showing them in tooltips,
         * or creating 100% stacks, this setting needs to be set to `true`.
         *
         * NOTE: `PieChart`, which relies on slice percentages, has this
         * automatically set to `true`.
         *
         * @default false
         */
        _this.calculatePercent = false;
        /**
         * When `calculatePercent` is enabled and data item's percent value is
         * calculated, last item's real value is used instead of its working value.
         *
         * This is done for the animations when last item in series (e.g. slice in
         * a `PieSeries`) is hidden or shown. (if we would use real value, the
         * calculated percent would always be 100%).
         *
         * Sometimes there is a need (e.g. for drill-down Sunburst) to disable this
         * hack by setting `usePercentHack` to `false`.
         *
         * @since 4.9.13
         * @default true
         */
        _this.usePercentHack = true;
        /**
         * Specifies if series should be automatically disposed when removing from
         * chart's `series` list.
         *
         * @default true
         */
        _this.autoDispose = true;
        /**
         * When chart/series' data is processed, all kinds of derivative values are
         * calculated. E.g. sum, min, max, change, etc. This is a potentially
         * time-consuming operation, especially prominent in data-heavy charts.
         *
         * If your chart does not need those values, and you have a lot of data,
         * setting this to `true` might give a dramatic increase in initial chart
         * load speed.
         *
         * Please note, regular column and line series usage scenarios do not
         * require derivative values. Those come into play only when you do advanced
         * functionality like coloring segments of charts in different colors
         * depending on change between open and close values, have stacked series, or
         * display any of the derived values, like percent, in tooltips or bullets.
         *
         * @default false
         */
        _this.simplifiedProcessing = false;
        if (_this.constructor === Series) {
            throw new Error("'Series' cannot be instantiated directly. Please use a specific series type.");
        }
        _this.className = "Series";
        _this.isMeasured = false;
        _this.layout = "none";
        _this.shouldClone = false;
        _this.setPropertyValue("hidden", false);
        _this.axisRanges = new List_List();
        _this.axisRanges.events.on("inserted", _this.processAxisRange, _this, false);
        _this.minBulletDistance = 0; // otherwise we'll have a lot of cases when people won't see bullets and think it's a bug
        _this.mainContainer = _this.createChild(Container_Container);
        _this.mainContainer.shouldClone = false;
        _this.mainContainer.mask = _this.createChild(Sprite_Sprite);
        _this._disposers.push(_this.mainContainer);
        // all bullets should go on top of lines/fills. So we add a separate container for bullets and later set it's parent to chart.bulletsContainer
        var bulletsContainer = _this.mainContainer.createChild(Container_Container);
        _this._shouldBeReady.push(bulletsContainer);
        bulletsContainer.shouldClone = false;
        bulletsContainer.layout = "none";
        bulletsContainer.virtualParent = _this;
        _this._disposers.push(bulletsContainer);
        _this.bulletsContainer = bulletsContainer;
        _this.tooltip = new Tooltip_Tooltip();
        _this.tooltip.virtualParent = _this;
        _this._disposers.push(_this.tooltip);
        _this.hiddenState.transitionEasing = cubicIn;
        // this data item holds sums, averages, etc
        _this.dataItem = _this.createDataItem();
        _this._disposers.push(_this.dataItem);
        _this.dataItem.component = _this;
        // Apply accessibility
        _this.role = "group";
        _this.applyTheme();
        return _this;
    }
    /**
     * We need this here so that class names can be applied to bullets container.
     *
     * @ignore Exclude from docs
     */
    Series.prototype.applyTheme = function () {
        _super.prototype.applyTheme.call(this);
        if (Options_options.autoSetClassName && this.bulletsContainer) {
            this.bulletsContainer.className = this.className + "-bullets";
            this.bulletsContainer.setClassName();
        }
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    Series.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Series");
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    Series.prototype.createDataItem = function () {
        return new Series_SeriesDataItem();
    };
    Object.defineProperty(Series.prototype, "chart", {
        /**
         * @return Chart
         */
        get: function () {
            return this._chart;
        },
        /**
         * Chart series is used on.
         *
         * @param value  Chart
         */
        set: function (value) {
            this._chart = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Positions bullet.
     *
     * @param bullet  Sprite
     */
    Series.prototype.positionBullet = function (bullet) {
        // Placeholder method for extending classes to override.
    };
    /**
     * Decorates newly created bullet after it has been instert into the list.
     *
     * @param event  List event
     * @todo investigate why itemReaderText is undefined
     */
    Series.prototype.processBullet = function (event) {
        var _this = this;
        var bullet = event.newValue;
        bullet.isTemplate = true;
        // Add accessibility options to bullet
        // If there are relatively few bullets, make them focusable
        this.events.once("datavalidated", function (ev) {
            if (_this.itemsFocusable()) {
                bullet.focusable = true;
            }
        });
    };
    /**
     * removes bullets
     *
     * @param event  List event
     */
    Series.prototype.removeBullet = function (event) {
        var bullet = event.oldValue;
        this.dataItems.each(function (dataItem) {
            var eachBullet = dataItem.bullets.getKey(bullet.uid);
            if (eachBullet) {
                eachBullet.dispose();
            }
        });
        this.invalidate();
    };
    /**
     * Validates data items.
     *
     * @ignore Exclude from docs
     */
    Series.prototype.validateDataItems = function () {
        _super.prototype.validateDataItems.call(this);
        this.processValues(false);
    };
    /**
     * Returns first value for the specific key in the series.
     *
     * @param key  Key
     * @return Value
     * @todo Description
     * @todo Convert to propert object property iterator
     */
    Series.prototype.getFirstValue = function (key, startIndex) {
        // find first
        /*
        return $iter.findMap(this.dataItems.iterator(), (dataItem) => {
            for (let key in dataItem.values) {
                if ($object.hasKey(dataItem.values, key)) {
                    let value: number = dataItem.values[key].workingValue;
                    if ($type.isNumber(value)) {
                        return value;
                    }
                }
            }

            return null;
        });*/
        if (startIndex > 0 && startIndex < this.dataItems.length - 1) {
            startIndex++;
        }
        for (var i = startIndex; i >= 0; i--) {
            var dataItem = this.dataItems.getIndex(i);
            var value = dataItem.getActualWorkingValue(key);
            if (isNumber(value)) {
                return value;
            }
        }
        return null;
    };
    /**
     * Returns first value for the specific key in the series.
     *
     * @param key  Key
     * @return Value
     * @todo Description
     * @todo Convert to propert object property iterator
     */
    Series.prototype.getAbsoluteFirstValue = function (key) {
        for (var i = 0; i < this.dataItems.length; i++) {
            var dataItem = this.dataItems.getIndex(i);
            var value = dataItem.values[key].value;
            if (isNumber(value)) {
                return value;
            }
        }
        return null;
    };
    /**
     * [rangeChangeUpdate description]
     *
     * @todo Description
     */
    Series.prototype.rangeChangeUpdate = function () {
        _super.prototype.rangeChangeUpdate.call(this);
        this.processValues(true);
    };
    /**
     * [processValues description]
     *
     * @todo Description
     * @todo Convert to propert object property iterator
     * @param dataItems [description]
     */
    Series.prototype.processValues = function (working) {
        var _this = this;
        if (!this.simplifiedProcessing) {
            var dataItems = this.dataItems;
            var count_1 = {};
            var sum_1 = {};
            var absoluteSum_1 = {};
            var low_1 = {};
            var high_1 = {};
            var open_1 = {};
            var close_1 = {};
            var previous_1 = {};
            var first_1 = {};
            var absoluteFirst_1 = {};
            //let duration: number = 0; // todo: check if series uses selection.change or selection.change.percent and set duration to interpolationduration
            var startIndex_1 = Math_max(0, this._workingStartIndex);
            startIndex_1 = Math_min(startIndex_1, this.dataItems.length);
            var endIndex = Math_min(this._workingEndIndex, this.dataItems.length);
            if (!isNumber(startIndex_1)) {
                startIndex_1 = 0;
            }
            if (!isNumber(endIndex)) {
                endIndex = this.dataItems.length;
            }
            if (startIndex_1 > 0) {
                var dataItem_1 = dataItems.getIndex(startIndex_1 - 1);
                Object_each(dataItem_1.values, function (key, values) {
                    var value = dataItem_1.getActualWorkingValue(key);
                    if (isNumber(value)) {
                        // save previous
                        previous_1[key] = value;
                    }
                });
            }
            var _loop_1 = function (i) {
                var dataItem_2 = dataItems.getIndex(i);
                Object_each(dataItem_2.values, function (key, values) {
                    var value = dataItem_2.getActualWorkingValue(key);
                    //if (i >= startIndex && i <= endIndex) { // do not add to count, sum etc if it is not within start/end index
                    if (isNumber(value)) {
                        // count values
                        if (!isNumber(count_1[key])) {
                            count_1[key] = 0;
                        }
                        count_1[key]++;
                        // sum values
                        if (!isNumber(sum_1[key])) {
                            sum_1[key] = 0;
                        }
                        sum_1[key] += value;
                        // absolute sum values
                        if (!isNumber(absoluteSum_1[key])) {
                            absoluteSum_1[key] = 0;
                        }
                        absoluteSum_1[key] += Math.abs(value);
                        // open
                        if (!isNumber(open_1[key])) {
                            open_1[key] = value;
                        }
                        // close
                        close_1[key] = value;
                        // low
                        if (!isNumber(low_1[key])) {
                            low_1[key] = value;
                        }
                        else {
                            if (low_1[key] > value) {
                                low_1[key] = value;
                            }
                        }
                        // high
                        if (!isNumber(high_1[key])) {
                            high_1[key] = value;
                        }
                        else {
                            if (high_1[key] < value) {
                                high_1[key] = value;
                            }
                        }
                        if (!isNumber(first_1[key])) {
                            first_1[key] = _this.getFirstValue(key, startIndex_1);
                        }
                        if (!isNumber(absoluteFirst_1[key])) {
                            absoluteFirst_1[key] = _this.getAbsoluteFirstValue(key);
                        }
                        // change
                        dataItem_2.setCalculatedValue(key, value - first_1[key], "change");
                        // change from start percent
                        // will fail if first value is 0
                        dataItem_2.setCalculatedValue(key, (value - first_1[key]) / first_1[key] * 100, "changePercent");
                        dataItem_2.setCalculatedValue(key, (value - absoluteFirst_1[key]), "startChange");
                        dataItem_2.setCalculatedValue(key, (value - absoluteFirst_1[key]) / absoluteFirst_1[key] * 100, "startChangePercent");
                        // previous change
                        var prevValue = previous_1[key];
                        if (!isNumber(prevValue)) {
                            prevValue = value;
                        }
                        dataItem_2.setCalculatedValue(key, value - prevValue, "previousChange");
                        // previous change percent
                        dataItem_2.setCalculatedValue(key, (value - prevValue) / prevValue * 100, "previousChangePercent");
                        // save previous
                        previous_1[key] = value;
                    }
                });
            };
            for (var i = startIndex_1; i < endIndex; i++) {
                _loop_1(i);
            }
            if (this.calculatePercent) {
                var _loop_2 = function (i) {
                    var dataItem_3 = dataItems.getIndex(i);
                    Object_each(dataItem_3.values, function (key) {
                        var ksum = absoluteSum_1[key];
                        var value = dataItem_3.getActualWorkingValue(key);
                        if (isNumber(value)) {
                            if (ksum > 0) {
                                if (_this.usePercentHack) {
                                    // this hack is made in order to make it possible to animate single slice to 0
                                    // if there is only one slice left, percent value is always 100%, so it won't animate
                                    // so we use real value of a slice instead of current value
                                    if (value == ksum) {
                                        ksum = dataItem_3.values[key].value;
                                    }
                                }
                                var percent = value / ksum * 100;
                                dataItem_3.setCalculatedValue(key, percent, "percent");
                            }
                            else {
                                dataItem_3.setCalculatedValue(key, 0, "percent");
                            }
                        }
                    });
                };
                for (var i = startIndex_1; i < endIndex; i++) {
                    _loop_2(i);
                }
            }
            // calculate one before first (cant do that in cycle, as we don't know open yet
            // when drawing line chart we should draw line to the invisible data point to the left, otherwise the line will always look like it starts from the selected point
            // so we do startIndex - 1
            if (startIndex_1 > 0) {
                var zeroItem_1 = dataItems.getIndex(startIndex_1 - 1);
                Object_each(zeroItem_1.values, function (key) {
                    var value = zeroItem_1.values[key].value;
                    // change
                    zeroItem_1.setCalculatedValue(key, value - open_1[key], "change");
                    // change percent
                    zeroItem_1.setCalculatedValue(key, (value - open_1[key]) / open_1[key] * 100, "changePercent");
                });
            }
            // we save various data like sum, average to dataPoint of the series
            var dataItem_4 = this.dataItem;
            Object_each(dataItem_4.values, function (key) {
                dataItem_4.setCalculatedValue(key, sum_1[key], "sum");
                dataItem_4.setCalculatedValue(key, absoluteSum_1[key], "absoluteSum");
                dataItem_4.setCalculatedValue(key, sum_1[key] / count_1[key], "average");
                dataItem_4.setCalculatedValue(key, open_1[key], "open");
                dataItem_4.setCalculatedValue(key, close_1[key], "close");
                dataItem_4.setCalculatedValue(key, low_1[key], "low");
                dataItem_4.setCalculatedValue(key, high_1[key], "high");
                dataItem_4.setCalculatedValue(key, count_1[key], "count");
            });
        }
    };
    /**
     * (Re)validates the whole series, effectively causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    Series.prototype.validate = function () {
        if (isIE()) {
            this.filters.clear();
        }
        Iterator_each(this.axisRanges.iterator(), function (axisRange) {
            //axisRange.contents.disposeChildren(); // not good for columns, as they are reused
            //			axisRange.appendChildren();
            axisRange.validate();
        });
        _super.prototype.validate.call(this);
        var bulletsContainer = this.bulletsContainer;
        bulletsContainer.fill = this.fill;
        bulletsContainer.stroke = this.stroke;
        bulletsContainer.x = this.pixelX;
        bulletsContainer.y = this.pixelY;
        if (this.bulletsContainer.children.length > 0) {
            if (this._showBullets) {
                for (var i = 0; i < this.startIndex; i++) {
                    var dataItem = this.dataItems.getIndex(i);
                    if (dataItem) {
                        dataItem.bullets.each(function (key, bullet) {
                            bullet.__disabled = true;
                        });
                    }
                }
                for (var i = this.dataItems.length - 1; i > this.endIndex; i--) {
                    var dataItem = this.dataItems.getIndex(i);
                    if (dataItem) {
                        dataItem.bullets.each(function (key, bullet) {
                            bullet.__disabled = true;
                        });
                    }
                }
            }
            else {
                this.bulletsContainer.children.each(function (bullet) {
                    bullet.__disabled = true;
                });
            }
        }
        this.updateTooltipBounds();
    };
    /**
     * @ignore
     */
    Series.prototype.updateTooltipBounds = function () {
        if (this.topParent) {
            var x = 0;
            var y = 0;
            var w = this.topParent.maxWidth;
            var h = this.topParent.maxHeight;
            var rect = { x: x, y: y, width: w, height: h };
            this.tooltip.setBounds(rect);
        }
    };
    Series.prototype.shouldCreateBullet = function (dataItem, bulletTemplate) {
        return true;
    };
    /**
     * Validates data item's element, effectively redrawing it.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    Series.prototype.validateDataElement = function (dataItem) {
        var _this = this;
        _super.prototype.validateDataElement.call(this, dataItem);
        if (this._showBullets) {
            if (!this.isHidden) {
                this.bulletsContainer.visible = true;
            }
            this.bullets.each(function (bulletTemplate) {
                // always better to use the same, this helps to avoid redrawing
                var bullet = dataItem.bullets.getKey(bulletTemplate.uid);
                if (_this.shouldCreateBullet(dataItem, bulletTemplate)) {
                    if (!bullet) {
                        var disabledField = bulletTemplate.propertyFields.disabled;
                        var dataContext = dataItem.dataContext;
                        if (disabledField && dataContext && dataContext[disabledField] === false) {
                            bulletTemplate.applyOnClones = false;
                            bulletTemplate.disabled = false;
                            bullet = bulletTemplate.clone();
                            bulletTemplate.disabled = true;
                            bulletTemplate.applyOnClones = true;
                        }
                        else {
                            bullet = bulletTemplate.clone();
                        }
                        bullet.shouldClone = false;
                        dataItem.addSprite(bullet);
                        if (!_this.visible || _this.isHiding) {
                            bullet.hide(0);
                        }
                    }
                    var currentDataItem = bullet.dataItem;
                    if (currentDataItem != dataItem) {
                        // set to undefined in order not to reuse
                        if (currentDataItem) {
                            currentDataItem.bullets.setKey(bulletTemplate.uid, undefined);
                        }
                        var readerText_1 = _this.itemReaderText;
                        if (bullet instanceof Bullet_Bullet) {
                            if (!readerText_1) {
                                readerText_1 = ("{" + bullet.xField + "}: {" + bullet.yField + "}");
                            }
                            if (bullet.isDynamic) {
                                dataItem.events.on("workingvaluechanged", bullet.deepInvalidate, bullet, false);
                                //dataItem.events.on("calculatedvaluechanged", bullet.deepInvalidate, bullet, false);
                                _this.dataItem.events.on("workingvaluechanged", bullet.deepInvalidate, bullet, false);
                            }
                            bullet.deepInvalidate();
                        }
                        // Add accessibility to bullet
                        if (bullet.focusable) {
                            bullet.events.on("focus", function (ev) {
                                bullet.readerTitle = _this.populateString(readerText_1, bullet.dataItem);
                            }, undefined, false);
                            bullet.events.on("blur", function (ev) {
                                bullet.readerTitle = "";
                            }, undefined, false);
                        }
                        if (bullet.hoverable) {
                            bullet.events.on("over", function (ev) {
                                bullet.readerTitle = _this.populateString(readerText_1, bullet.dataItem);
                            }, undefined, false);
                            bullet.events.on("out", function (ev) {
                                bullet.readerTitle = "";
                            }, undefined, false);
                        }
                    }
                    bullet.parent = _this.bulletsContainer;
                    dataItem.bullets.setKey(bulletTemplate.uid, bullet);
                    // pass max w/h so we'd know if we should show/hide somethings
                    bullet.maxWidth = dataItem.itemWidth;
                    bullet.maxHeight = dataItem.itemHeight;
                    bullet.__disabled = false;
                    _this.positionBullet(bullet);
                }
                else {
                    if (bullet) {
                        bullet.__disabled = true;
                    }
                }
            });
        }
        else {
            this.bulletsContainer.visible = false;
        }
    };
    /**
     * [handleDataItemWorkingValueChange description]
     *
     * @ignore Exclude from docs
     */
    Series.prototype.handleDataItemWorkingValueChange = function (dataItem, name) {
        if (!this.dataRangeInvalid) {
            this.invalidateProcessedData();
        }
    };
    Object.defineProperty(Series.prototype, "ignoreMinMax", {
        /**
         * @return Exclude from calculations?
         */
        get: function () {
            return this._ignoreMinMax;
        },
        /**
         * Should this series excluded from the axis scale calculations?
         *
         * @default false
         * @param value  Exclude from calculations?
         */
        set: function (value) {
            this._ignoreMinMax = value;
            this.invalidateDataItems();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create a mask for the series.
     *
     * @ignore Exclude from docs
     */
    Series.prototype.createMask = function () {
        // A placeholder method for extending classes to override.
    };
    /**
     * Process axis range after it has been added to the list.
     *
     * @param event  Event
     */
    Series.prototype.processAxisRange = function (event) {
        // create container if not existing
        if (!this.rangesContainer) {
            this.rangesContainer = this.createChild(Container_Container);
            this.rangesContainer.shouldClone = false;
            this.rangesContainer.isMeasured = false;
        }
        var axisRange = event.newValue;
        if (axisRange) {
            axisRange.contents.parent = this.rangesContainer;
            axisRange.isRange = true;
            axisRange.events.on("valuechanged", this.invalidateDataItems, this, false);
        }
    };
    /**
     * [getAxisField description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param axis  [description]
     * @return [description]
     */
    Series.prototype.getAxisField = function (axis) {
        return;
    };
    /**
     * Shows the tooltip at specific position.
     *
     * @ignore Exclude from docs
     * @param xPosition  X
     * @param yPosition  Y
     */
    Series.prototype.showTooltipAtPosition = function (xPosition, yPosition) {
        // Placeholder method for extending classes to override.
    };
    Object.defineProperty(Series.prototype, "minBulletDistance", {
        /**
         * @return Distance (px)
         */
        get: function () {
            return this.getPropertyValue("minBulletDistance");
        },
        /**
         * Minimal distance between data points in pixels.
         *
         * If distance gets smaller than this, bullets are turned off to avoid
         * overlapping.
         *
         * `0` (zero) disables this behavior.
         *
         * IMPORTANT: This setting will work only when Series' base axis
         * is [[CategoryAxis]] or [[DateAxis]]. If base axis is [[ValueAxis]] the
         * setting will be ignored, because it would be a huge overhead to measure
         * distance between each and every bullet.
         *
         * @default 0
         * @param value  Distance (px)
         */
        set: function (value) {
            this.setPropertyValue("minBulletDistance", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Series.prototype, "bullets", {
        /**
         * A list of bullets that will be added to each and every items in the
         * series.
         *
         * You can push any object that is a descendant of a [[Sprite]] here. All
         * items added to this list will be copied and used as a bullet on all data
         * items, including their properties, events, etc.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/bullets/} for more info about the concept of Bullets
         * @return List of bullets.
         */
        get: function () {
            if (!this._bullets) {
                this._bullets = new List_ListTemplate(new Bullet_Bullet());
                this._bullets.template.virtualParent = this;
                this._bullets.events.on("inserted", this.processBullet, this, false);
                this._bullets.events.on("removed", this.removeBullet, this, false);
                this._disposers.push(new List_ListDisposer(this._bullets));
                this._disposers.push(this._bullets.template);
            }
            return this._bullets;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Binds related legend data item's visual settings to this series' visual
     * settings.
     *
     * @ignore Exclude from docs
     * @param marker  Legend item container
     */
    Series.prototype.createLegendMarker = function (marker) {
        // This is a placeholder method for extending classes to override.
    };
    Object.defineProperty(Series.prototype, "hiddenInLegend", {
        /**
         * @return Hidden in legend?
         */
        get: function () {
            return this.getPropertyValue("hiddenInLegend");
        },
        /**
         * Should the series be hidden in legend?
         *
         * @param value Hidden in legend?
         */
        set: function (value) {
            if (this.setPropertyValue("hiddenInLegend", value)) {
                if (this.chart) {
                    this.chart.feedLegend();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Series.prototype, "name", {
        /**
         * @return Name
         */
        get: function () {
            return this.getPropertyValue("name");
        },
        /**
         * Series' name.
         *
         * @param value  Name
         */
        set: function (value) {
            this.setPropertyValue("name", value);
            var legendDataItem = this.legendDataItem;
            if (legendDataItem) {
                legendDataItem.component.invalidate();
                legendDataItem.component.invalidateRawData();
            }
            this.readerTitle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Series.prototype, "itemReaderText", {
        /**
         * @return Screen reader text template
         */
        get: function () {
            // Get explicitly set reader text
            var readerText = this._itemReaderText;
            // Not set? Let's try something else
            if (!readerText) {
                // Tooltip text?
                if (this.tooltipText) {
                    readerText = plainText(this.tooltipText);
                }
                else if (this.tooltipHTML) {
                    readerText = plainText(this.tooltipHTML);
                }
            }
            if (!this._adapterO) {
                return readerText;
            }
            else {
                return this._adapterO.apply("itemReaderText", readerText);
            }
        },
        /**
         * Screen reader text to be applied to each individual data item, such
         * as bullets, columns or slices.
         *
         * The template can contain field reference meta codes, i.e. `{dateX}`,
         * `{valueY}`, etc.
         *
         * Any text formatting options, e.g. `[bold]` will be ignored.
         *
         * @param value Screen reader text template
         */
        set: function (value) {
            this._itemReaderText = value;
            this._itemReaderTextChanged = true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns if number of data items in the series are beyond non-focusable
     * count and should not be available for TAB-through.
     *
     * @ignore Exclude from docs
     * @return Items focusable?
     */
    Series.prototype.itemsFocusable = function () {
        return this.dataItems.length >= this.skipFocusThreshold ? false : true;
    };
    Object.defineProperty(Series.prototype, "legendDataItem", {
        /**
         * @return Data item
         */
        get: function () {
            return this._legendDataItem;
        },
        /**
         * Legend data item that corresponds to this series.
         *
         * @param value  Data item
         */
        set: function (value) {
            this._legendDataItem = value;
            this._legendDataItem.itemContainer.deepInvalidate();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates corresponding legend data item with current values.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    Series.prototype.updateLegendValue = function (dataItem, notRange) {
        // if this series has legend item
        if (this.legendDataItem) {
            var legendSettings = this.legendSettings;
            var legendDataItem = this.legendDataItem;
            var label = legendDataItem.label;
            var valueLabel = legendDataItem.valueLabel;
            // update legend
            if (dataItem || notRange) {
                if (valueLabel) {
                    if (legendSettings.itemValueText) {
                        valueLabel.text = legendSettings.itemValueText;
                    }
                    valueLabel.dataItem = dataItem;
                }
                if (label) {
                    if (legendSettings.itemLabelText) {
                        label.text = legendSettings.itemLabelText;
                    }
                    label.dataItem = dataItem;
                }
            }
            else {
                if (label) {
                    // if itemLabelText is set, means we have to reset label even if labelText is not set
                    if (legendSettings.labelText || legendSettings.itemLabelText != undefined) {
                        label.text = legendSettings.labelText;
                    }
                    label.dataItem = this.dataItem;
                }
                if (valueLabel) {
                    if (legendSettings.valueText || legendSettings.itemValueText != undefined) {
                        valueLabel.text = legendSettings.valueText;
                    }
                    valueLabel.dataItem = this.dataItem;
                }
            }
        }
    };
    /**
     * Copies all properties from another instance of [[Series]].
     *
     * @param source  Source series
     */
    Series.prototype.copyFrom = function (source) {
        this.bullets.copyFrom(source.bullets);
        this.bulletsContainer.copyFrom(source.bulletsContainer);
        this.calculatePercent = source.calculatePercent;
        this.usePercentHack = source.usePercentHack;
        this.simplifiedProcessing = source.simplifiedProcessing;
        _super.prototype.copyFrom.call(this, source);
    };
    /**
     * Displays a modal or console message with error, and halts any further
     * processing of this element.
     *
     * @param e Error
     */
    Series.prototype.raiseCriticalError = function (e) {
        if (this._chart && this._chart.modal) {
            this._chart.modal.content = this._chart.adapter.apply("criticalError", e).message;
            this._chart.modal.closable = false;
            if (!Options_options.suppressErrors) {
                this._chart.modal.open();
            }
            this._chart.disabled = true;
        }
        if (Options_options.verbose) {
            console.log(e);
        }
    };
    /**
     * Applies filters to the element.
     *
     * @ignore Exclude from docs
     */
    Series.prototype.applyFilters = function () {
        var _this = this;
        _super.prototype.applyFilters.call(this);
        this.bulletsContainer.filters.clear();
        // copyFrom of a list copies, does not clone
        Iterator_each(this.filters.iterator(), function (filter) {
            _this.bulletsContainer.filters.push(filter.clone());
        });
    };
    Object.defineProperty(Series.prototype, "heatRules", {
        /**
         * A list of heat rules to apply to series' elements based on the value
         * of the data item.
         *
         * Heat rules can be any "numeric" (including `Color`) property, and can also
         * be applied to child objects of series, like columns, bullets, etc.
         *
         * E.g.:
         *
         * ```TypeScript
         * series.heatRules.push({
         *  "target": series.columns.template,
         *  "property": "fill",
         *  "min": am4core.color("#F5DBCB"),
         *  "max": am4core.color("#ED7B84"),
         *  "dataField": "valueY"
         *});
         *```
         * ```Javacript
         * series.heatRules.push({
         *  "target": series.columns.template,
         *  "property": "fill",
         *  "min": am4core.color("#F5DBCB"),
         *  "max": am4core.color("#ED7B84"),
         *  "dataField": "valueY"
         *});
         *```
         *```JSON
         *{
         *  // ...
         *  "series": [{
         *    "type": "ColumnSeries",
         *    "heatRules": [{
         *      "target": "columns.template",
         *      "property": "fill",
         *      "min": "#F5DBCB",
         *      "max": "#ED7B84",
         *      "dataField": "valueY"
         *    }]
         *  }]
         *}
         *```
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/series/#Heat_maps} for more about heat rules
         * @return  Heat rules
         */
        get: function () {
            var _this = this;
            if (!this._heatRules) {
                this._heatRules = new List_List();
                this._heatRules.events.on("inserted", function (event) {
                    var heatRule = event.newValue;
                    var target = heatRule.target;
                    if (target) {
                        var dataField_1 = heatRule.dataField;
                        if (!hasValue(dataField_1)) {
                            dataField_1 = "value";
                        }
                        var seriesDataItem_1 = _this.dataItem;
                        var property_1 = heatRule.property;
                        var minValue = toNumber(heatRule.minValue);
                        var maxValue = toNumber(heatRule.maxValue);
                        if (!isNumber(minValue) && !isNumber(maxValue)) {
                            _this.dataItem.events.on("calculatedvaluechanged", function (event) {
                                if (event.property == dataField_1) {
                                    Iterator_each(_this.dataItems.iterator(), function (dataItem) {
                                        var foundSprite = false;
                                        each(dataItem.sprites, function (sprite) {
                                            if (sprite.clonedFrom == target) {
                                                var anySprite = sprite;
                                                anySprite[property_1] = anySprite[property_1];
                                                foundSprite = true;
                                            }
                                        });
                                        if (!foundSprite) {
                                            each(dataItem.sprites, function (sprite) {
                                                if (sprite instanceof Container_Container) {
                                                    Iterator_each(sprite.children.iterator(), function (child) {
                                                        if (child.className == target.className) {
                                                            var anyChild = child;
                                                            anyChild[property_1] = anyChild[property_1];
                                                        }
                                                        // giveup here
                                                        else if (child instanceof Container_Container) {
                                                            child.deepInvalidate();
                                                        }
                                                    });
                                                }
                                            });
                                        }
                                    });
                                }
                            });
                        }
                        _this.dataItems.template.events.on("workingvaluechanged", function (event) {
                            if (event.property == dataField_1) {
                                var dataItem = event.target;
                                var foundSprite_1 = false;
                                each(dataItem.sprites, function (sprite) {
                                    if (sprite.clonedFrom == target) {
                                        var anySprite = sprite;
                                        anySprite[property_1] = anySprite[property_1];
                                        foundSprite_1 = true;
                                    }
                                });
                                if (!foundSprite_1) {
                                    each(dataItem.sprites, function (sprite) {
                                        if (sprite instanceof Container_Container) {
                                            Iterator_each(sprite.children.iterator(), function (child) {
                                                if (child.className == target.className) {
                                                    var anyChild = child;
                                                    anyChild[property_1] = anyChild[property_1];
                                                }
                                                // givup here
                                                else if (child instanceof Container_Container) {
                                                    child.deepInvalidate();
                                                }
                                            });
                                        }
                                    });
                                }
                            }
                        });
                        target.adapter.add(property_1, function (value, ruleTarget, property) {
                            var minValue = toNumber(heatRule.minValue);
                            var maxValue = toNumber(heatRule.maxValue);
                            var min = heatRule.min;
                            var max = heatRule.max;
                            if (ruleTarget instanceof Sprite_Sprite) {
                                var anySprite = ruleTarget;
                                var propertyField = anySprite.propertyFields[property];
                                if (propertyField && ruleTarget.dataItem) {
                                    var dataContext = ruleTarget.dataItem.dataContext;
                                    if (dataContext && hasValue(dataContext[propertyField])) {
                                        return value;
                                    }
                                }
                            }
                            var dataItem = ruleTarget.dataItem;
                            if (!isNumber(minValue)) {
                                minValue = seriesDataItem_1.values[dataField_1].low;
                            }
                            if (!isNumber(maxValue)) {
                                maxValue = seriesDataItem_1.values[dataField_1].high;
                            }
                            if (dataItem) {
                                var fieldValues = dataItem.values[dataField_1];
                                if (fieldValues) {
                                    var workingValue = dataItem.getActualWorkingValue(dataField_1);
                                    if (hasValue(min) && hasValue(max) && isNumber(minValue) && isNumber(maxValue) && isNumber(workingValue)) {
                                        var percent = void 0;
                                        if (heatRule.logarithmic) {
                                            percent = (Math.log(workingValue) * Math.LOG10E - Math.log(minValue) * Math.LOG10E) / ((Math.log(maxValue) * Math.LOG10E - Math.log(minValue) * Math.LOG10E));
                                        }
                                        else {
                                            percent = (workingValue - minValue) / (maxValue - minValue);
                                        }
                                        if (isNumber(workingValue) && !isNumber(percent)) {
                                            percent = 0.5;
                                        }
                                        // fixes problems if all values are the same
                                        if (isNumber(min)) {
                                            return min + (max - min) * percent;
                                        }
                                        else if (min instanceof Color_Color) {
                                            return new Color_Color(interpolate(min.rgb, max.rgb, percent));
                                        }
                                    }
                                }
                            }
                            return value;
                        });
                    }
                });
            }
            return this._heatRules;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    Series.prototype.processConfig = function (config) {
        var heatRules;
        if (config) {
            // Set up bullets
            if (hasValue(config.bullets) && isArray(config.bullets)) {
                for (var i = 0, len = config.bullets.length; i < len; i++) {
                    var bullets = config.bullets[i];
                    if (!hasValue(bullets.type)) {
                        bullets.type = "Bullet";
                    }
                }
            }
            // Let's take heatRules out of the config, so that we can process
            // them later, when bullets are already there
            if (hasValue(config.heatRules) && isArray(config.heatRules)) {
                heatRules = config.heatRules;
                delete config.heatRules;
            }
        }
        _super.prototype.processConfig.call(this, config);
        // Process heat rules again, when all other elements are ready
        if (heatRules) {
            for (var i = 0, len = heatRules.length; i < len; i++) {
                var rule = heatRules[i];
                // Resolve target
                var target = this;
                if (hasValue(rule.target) && isString(rule.target)) {
                    // Check if we can find this element by id
                    if (this.map.hasKey(rule.target)) {
                        target = this.map.getKey(rule.target);
                    }
                    else {
                        var parts = rule.target.split(".");
                        for (var x = 0; x < parts.length; x++) {
                            if (target instanceof List_List) {
                                var listitem = target.getIndex(toNumber(parts[x]));
                                if (!listitem) {
                                    target = target[parts[x]];
                                }
                                else {
                                    target = listitem;
                                }
                            }
                            else {
                                target = target[parts[x]];
                            }
                        }
                    }
                }
                rule.target = target;
                // Resolve colors and percents
                if (hasValue(rule.min)) {
                    rule.min = this.maybeColorOrPercent(rule.min);
                }
                if (hasValue(rule.max)) {
                    rule.max = this.maybeColorOrPercent(rule.max);
                }
            }
            _super.prototype.processConfig.call(this, {
                heatRules: heatRules
            });
        }
    };
    /**
     * Returns visibility value
     * @ignore
     */
    /*
        protected getVisibility(): boolean {
            let hidden = this.getPropertyValue("hidden");
            if (hidden) {
                return false;
            }
            else {
                return super.getVisibility();
            }
        }*/
    /**
     * This function is used to sort element's JSON config properties, so that
     * some properties that absolutely need to be processed last, can be put at
     * the end.
     *
     * @ignore Exclude from docs
     * @param a  Element 1
     * @param b  Element 2
     * @return Sorting number
     */
    Series.prototype.configOrder = function (a, b) {
        if (a == b) {
            return 0;
        }
        // Must come last
        else if (a == "heatRules") {
            return 1;
        }
        else if (b == "heatRules") {
            return -1;
        }
        else {
            return _super.prototype.configOrder.call(this, a, b);
        }
    };
    /**
     * Sets `visibility` property:
     *
     * * `true` - visible
     * * `false` - hidden
     *
     * @param value  true - visible, false - hidden
     * @return Current visibility
     */
    Series.prototype.setVisibility = function (value) {
        _super.prototype.setVisibility.call(this, value);
        this.bulletsContainer.visible = value;
    };
    return Series;
}(Component_Component));

/**
 * Register class, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Series"] = Series_Series;
registry.registeredClasses["SeriesDataItem"] = Series_SeriesDataItem;
//# sourceMappingURL=Series.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/SerialChart.js
/**
 * Serial chart module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */











/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[SerialChart]].
 *
 * @see {@link DataItem}
 */
var SerialChart_SerialChartDataItem = /** @class */ (function (_super) {
    __extends(SerialChartDataItem, _super);
    /**
     * Constructor
     */
    function SerialChartDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "SerialChartDataItem";
        _this.applyTheme();
        return _this;
    }
    return SerialChartDataItem;
}(Chart_ChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A base class for all series-based charts, like XY, Pie, etc.
 *
 * Is not useful on its own.
 *
 * @see {@link ISerialChartEvents} for a list of available Events
 * @see {@link ISerialChartAdapters} for a list of available Adapters
 */
var SerialChart_SerialChart = /** @class */ (function (_super) {
    __extends(SerialChart, _super);
    /**
     * Constructor
     */
    function SerialChart() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "SerialChart";
        _this.colors = new ColorSet_ColorSet();
        _this._usesData = false;
        // Create a container for series
        var seriesContainer = _this.chartContainer.createChild(Container_Container);
        seriesContainer.shouldClone = false;
        seriesContainer.width = Percent_percent(100);
        seriesContainer.height = Percent_percent(100);
        seriesContainer.isMeasured = false;
        seriesContainer.layout = "none";
        seriesContainer.zIndex = 2;
        _this.seriesContainer = seriesContainer;
        // Create a container for bullets
        var bulletsContainer = _this.chartContainer.createChild(Container_Container);
        bulletsContainer.shouldClone = false;
        bulletsContainer.width = Percent_percent(100);
        bulletsContainer.height = Percent_percent(100);
        bulletsContainer.isMeasured = false;
        bulletsContainer.zIndex = 3;
        bulletsContainer.layout = "none";
        _this.bulletsContainer = bulletsContainer;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    SerialChart.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this.colors) {
            this.colors.dispose();
        }
        if (this.patterns) {
            this.patterns.dispose();
        }
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor
     */
    SerialChart.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Add a default screen reader title for accessibility
        // This will be overridden in screen reader if there are any `titles` set
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Serial chart");
        }
    };
    Object.defineProperty(SerialChart.prototype, "series", {
        /**
         * A list of chart's series.
         *
         * @return Chart's series
         */
        get: function () {
            if (!this._series) {
                this._series = new List_ListTemplate(this.createSeries());
                this._series.events.on("inserted", this.handleSeriesAdded, this, false);
                this._series.events.on("removed", this.handleSeriesRemoved, this, false);
                this._disposers.push(new List_ListDisposer(this._series, false));
                this._disposers.push(this._series.template);
            }
            return this._series;
        },
        enumerable: true,
        configurable: true
    });
    SerialChart.prototype.handleSeriesRemoved = function (event) {
        var series = event.oldValue;
        this.dataUsers.removeValue(series);
        this.dataUsers.each(function (dataUser) {
            dataUser.invalidateDataItems();
        });
        if (series.autoDispose) {
            series.dispose();
        }
        else {
            series.parent = undefined;
            series.bulletsContainer.parent = undefined;
        }
        //this.feedLegend();
        var legend = this.legend;
        if (legend) {
            var dataItems = this.legend.dataItems;
            for (var i = dataItems.length - 1; i >= 0; i--) {
                var dataItem = dataItems.getIndex(i);
                if (dataItem && dataItem.dataContext == series) {
                    legend.dataItems.remove(dataItem);
                }
            }
            for (var i = legend.data.length - 1; i >= 0; i--) {
                var di = legend.data[i];
                if (di && di == series) {
                    remove(legend.data, di);
                }
            }
        }
    };
    /**
     * Decorates a new [[Series]] object with required parameters when it is
     * added to the chart.
     *
     * @ignore Exclude from docs
     * @param event  Event
     */
    SerialChart.prototype.handleSeriesAdded = function (event) {
        var _this = this;
        var series = event.newValue;
        if (series.isDisposed()) {
            return;
        }
        series.chart = this;
        series.parent = this.seriesContainer;
        series.bulletsContainer.parent = this.bulletsContainer;
        this._dataUsers.moveValue(series);
        series.addDisposer(new Disposer(function () {
            _this.dataUsers.removeValue(series);
        }));
        this.handleSeriesAdded2(series);
        if (!series.hiddenInLegend) {
            if (this.legend) {
                this.legend.addData(series);
            }
        }
    };
    SerialChart.prototype.handleSeriesAdded2 = function (series) {
        var _this = this;
        if (!this.dataInvalid) {
            this._disposers.push(
            // on exit only as data is usually passed after push
            registry.events.once("exitframe", function () {
                if (!series.data || series.data.length == 0) {
                    series.data = _this.data;
                    if (series.showOnInit) {
                        series.reinit();
                        series.setPropertyValue("showOnInit", false);
                        series.showOnInit = true;
                    }
                    series.events.once("datavalidated", function () {
                        if (series.data == _this.data) {
                            series._data = [];
                        }
                    });
                }
            }));
        }
    };
    /**
     * Setups the legend to use the chart's data.
     * @ignore
     */
    SerialChart.prototype.feedLegend = function () {
        var legend = this.legend;
        if (legend) {
            var legendData_1 = [];
            Iterator_each(this.series.iterator(), function (series) {
                if (!series.hiddenInLegend) {
                    legendData_1.push(series);
                }
            });
            legend.dataFields.name = "name";
            legend.data = legendData_1;
        }
    };
    /**
     * Creates and returns a new Series, suitable for this chart type.
     *
     * @return New series
     */
    SerialChart.prototype.createSeries = function () {
        return new Series_Series();
    };
    Object.defineProperty(SerialChart.prototype, "colors", {
        /**
         * @return Color list
         */
        get: function () {
            return this.getPropertyValue("colors");
        },
        /**
         * Chart's color list.
         *
         * This list can be used by a number of serial items, like applying a new
         * color for each Series added. Or, applying a new color for each slice
         * of a Pie chart.
         *
         * Please see [[ColorSet]] for information on how you can set up to generate
         * unique colors.
         *
         * A theme you are using may override default pre-defined colors.
         *
         * @param value Color list
         */
        set: function (value) {
            this.setPropertyValue("colors", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SerialChart.prototype, "patterns", {
        /**
         * @return Pattern set
         */
        get: function () {
            return this.getPropertyValue("patterns");
        },
        /**
         * A [[PatternSet]] to use when creating patterned fills for slices.
         *
         * @since 4.7.5
         * @param value  Pattern set
         */
        set: function (value) {
            this.setPropertyValue("patterns", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all parameters from another [[SerialChart]].
     *
     * @param source Source SerialChart
     */
    SerialChart.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.series.copyFrom(source.series);
    };
    /**
     * Hides the chart instantly and then shows it. If defaultState.transitionDuration > 0, this will result an animation in which properties of hidden state will animate to properties of visible state.
     */
    SerialChart.prototype.appear = function () {
        _super.prototype.appear.call(this);
        this.series.each(function (series) {
            if (series.showOnInit && series.inited) {
                series.appear();
            }
        });
    };
    return SerialChart;
}(Chart_Chart));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["SerialChart"] = SerialChart_SerialChart;
//# sourceMappingURL=SerialChart.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisBreak.js
/**
 * Axis break module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Base class to define "breaks" on axes.
 *
 * @see {@link IAxisBreakEvents} for a list of available events
 * @see {@link IAxisBreakAdapters} for a list of available Adapters
 * @important
 */
var AxisBreak_AxisBreak = /** @class */ (function (_super) {
    __extends(AxisBreak, _super);
    /**
     * Constructor
     */
    function AxisBreak() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Reference to parent Axis.
         */
        _this._axis = new Disposer_MutableValueDisposer();
        /**
         * A list of axis data items which fall within this break.
         */
        _this.dataItems = new List_List();
        _this.className = "AxisBreak";
        // Set defaults
        _this.breakSize = 0.01;
        _this.marginLeft = -5;
        _this.marginRight = -5;
        _this.marginTop = -5;
        _this.marginBottom = -5;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        // Create elements
        // (these won't be used actually, just for setting properties)
        var fillShape = new WavedLine_WavedLine();
        fillShape.fill = interfaceColors.getFor("background");
        fillShape.stroke = Color_color();
        fillShape.fillOpacity = 0.9;
        fillShape.zIndex = 0;
        _this._fillShape = fillShape;
        var startLine = new WavedLine_WavedLine();
        startLine.fill = Color_color();
        startLine.stroke = interfaceColors.getFor("grid");
        startLine.strokeOpacity = 0.3;
        startLine.zIndex = 1;
        _this._startLine = startLine;
        var endLine = new WavedLine_WavedLine();
        endLine.fill = Color_color();
        endLine.stroke = Color_color("#000000"); // interfaceColors.getFor("grid");
        endLine.strokeOpacity = 0.3;
        endLine.zIndex = 2;
        _this._endLine = endLine;
        _this._disposers.push(_this._axis);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    AxisBreak.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this._fillShape) {
            this._fillShape.dispose();
        }
        if (this._startLine) {
            this._startLine.dispose();
        }
        if (this._endLine) {
            this._endLine.dispose();
        }
    };
    Object.defineProperty(AxisBreak.prototype, "startLine", {
        /**
         * @return Element
         */
        get: function () {
            return this._startLine;
        },
        /**
         * An element used for the starting line of the break.
         *
         * @param sprite  Element
         */
        set: function (sprite) {
            if (this._startLine) {
                this._startLine.dispose();
            }
            this._startLine = sprite;
            this.addBreakSprite(sprite);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisBreak.prototype, "endLine", {
        /**
         * @return Element
         */
        get: function () {
            return this._endLine;
        },
        /**
         * An element used for the end line of the break.
         *
         * @param sprite Element
         */
        set: function (sprite) {
            if (this._endLine) {
                this._endLine.dispose();
            }
            this._endLine = sprite;
            this.addBreakSprite(sprite);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisBreak.prototype, "fillShape", {
        /**
         * @return Element
         */
        get: function () {
            return this._fillShape;
        },
        /**
         * An element used for fill of the break.
         *
         * @param sprite Element
         */
        set: function (sprite) {
            if (this._fillShape) {
                this._fillShape.dispose();
            }
            this._fillShape = sprite;
            this.addBreakSprite(sprite);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a break element (e.g. lines, fill) to the break, which is
     * [[Container]].
     *
     * @ignore Exclude from docs
     * @param sprite Element to add
     */
    AxisBreak.prototype.addBreakSprite = function (sprite) {
        sprite.parent = this;
        sprite.isMeasured = false;
        this._disposers.push(sprite);
    };
    Object.defineProperty(AxisBreak.prototype, "axis", {
        /**
         * @return Axis
         */
        get: function () {
            return this._axis.get();
        },
        /**
         * An Axis this Break is associated with.
         *
         * @param axis  Axis
         */
        set: function (axis) {
            if (this._axis.get() !== axis) {
                this._axis.set(axis, axis.renderer.gridContainer.events.on("transformed", this.invalidate, this, false));
                axis.renderer.createBreakSprites(this);
                // this can't go to copyFrom, as axis is set later
                var breakTemplate = axis.axisBreaks.template;
                this.startLine.copyFrom(breakTemplate.startLine);
                this.endLine.copyFrom(breakTemplate.endLine);
                this.fillShape.copyFrom(breakTemplate.fillShape);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisBreak.prototype, "breakSize", {
        /**
         * @return Relative axis break
         */
        get: function () {
            return this.getPropertyValue("breakSize");
        },
        /**
         * A size of the break relative to the actual size of the scope break spans.
         *
         * For example, if `breakSize = 0.1` and unbroken scope of values it spans
         * would be 100 pixels, the break would be 10 pixels wide.
         *
         * 0 means the break will completely collapse and hide the values.
         * 1 means break would be not collapse at all, which would make it
         * effectively useless.
         *
         * @default 0.01
         * @param value  Relative axis break
         */
        set: function (value) {
            if (this.setPropertyValue("breakSize", value)) {
                if (this.axis) {
                    this.axis.invalidate();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisBreak.prototype, "startPoint", {
        /**
         * Returns pixel coordinates of axis break's start.
         *
         * @return Start point
         */
        get: function () {
            var renderer = this.axis.renderer;
            if (renderer) {
                return renderer.positionToPoint(this.startPosition);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisBreak.prototype, "endPoint", {
        /**
         * Returns pixel coordinates of axis break's end.
         *
         * @return End point
         */
        get: function () {
            var renderer = this.axis.renderer;
            if (renderer) {
                return renderer.positionToPoint(this.endPosition);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisBreak.prototype, "startPosition", {
        /**
         * Returns a relative position at which axis break starts.
         *
         * This is a calculated position, meaning it shows relative position of the
         * break after break is applied.
         *
         * @return Start position
         */
        get: function () {
            return;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisBreak.prototype, "endPosition", {
        /**
         * Returns a relative position at which axis break ends.
         *
         * This is a calculated position, meaning it shows relative position of the
         * break after break is applied.
         *
         * @return End position
         */
        get: function () {
            return;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Draws the axis break.
     *
     * @ignore Exclude from docs
     */
    AxisBreak.prototype.draw = function () {
        _super.prototype.draw.call(this);
        if (this.axis) {
            var renderer = this.axis.renderer;
            renderer.updateBreakElement(this);
        }
    };
    Object.defineProperty(AxisBreak.prototype, "startValue", {
        /**
         * @return Starting value
         */
        get: function () {
            return this.getPropertyValue("startValue");
        },
        /**
         * A starting value for the break.
         *
         * @param value  Starting value
         */
        set: function (value) {
            if (this.setPropertyValue("startValue", value)) {
                if (this.axis) {
                    this.axis.invalidate();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisBreak.prototype, "endValue", {
        /**
         * @return End value
         */
        get: function () {
            return this.getPropertyValue("endValue");
        },
        /**
         * An end value for the break.
         *
         * @param value  End value
         */
        set: function (value) {
            if (this.setPropertyValue("endValue", value)) {
                if (this.axis) {
                    this.axis.invalidate();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    return AxisBreak;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisBreak"] = AxisBreak_AxisBreak;
//# sourceMappingURL=AxisBreak.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/Axis.js
/**
 * Base class for all Axis
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


















/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[Axis]].
 *
 * @see {@link DataItem}
 */
var Axis_AxisDataItem = /** @class */ (function (_super) {
    __extends(AxisDataItem, _super);
    /**
     * Constructor
     */
    function AxisDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "AxisDataItem";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(AxisDataItem.prototype, "grid", {
        /**
         * @return Grid element
         */
        get: function () {
            if (!this._grid) {
                var component_1 = this.component;
                if (component_1) {
                    var template = void 0;
                    var grid_1;
                    if (this.isRange) {
                        template = component_1.axisRanges.template.grid;
                        if (template.disabled) {
                            return;
                        }
                        else {
                            grid_1 = template.clone();
                        }
                    }
                    else {
                        template = component_1.renderer.grid.template;
                        if (template.disabled) {
                            return;
                        }
                        else {
                            grid_1 = component_1.renderer.grid.create();
                            this._disposers.push(new Disposer(function () {
                                component_1.renderer.grid.removeValue(grid_1);
                            }));
                        }
                    }
                    this.grid = grid_1;
                    grid_1.shouldClone = false;
                    this._disposers.push(grid_1);
                    grid_1.axis = this.component;
                }
            }
            return this._grid;
        },
        /**
         * A [[Grid]] element associated with this data item.
         *
         * If there is no grid element associated with data item, a new one is
         * created and returned.
         *
         * @param grid  Grid element
         */
        set: function (grid) {
            if (this._grid && this._grid != grid) {
                remove(this.sprites, this._grid);
                this._grid.dataItem = undefined;
            }
            if (grid) {
                if (grid.dataItem && grid.dataItem != this) {
                    remove(grid.dataItem.sprites, grid);
                    grid.dataItem.grid = undefined;
                }
                this.addSprite(grid);
            }
            this._grid = grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisDataItem.prototype, "tick", {
        /**
         * @return Tick element
         */
        get: function () {
            if (!this._tick) {
                var component_2 = this.component;
                if (component_2) {
                    var template = void 0;
                    var tick_1;
                    if (this.isRange) {
                        template = component_2.axisRanges.template.tick;
                        if (template.disabled) {
                            return;
                        }
                        else {
                            tick_1 = template.clone();
                        }
                    }
                    else {
                        template = component_2.renderer.ticks.template;
                        if (template.disabled) {
                            return;
                        }
                        else {
                            tick_1 = component_2.renderer.ticks.create();
                            this._disposers.push(new Disposer(function () {
                                component_2.renderer.ticks.removeValue(tick_1);
                            }));
                        }
                    }
                    this.tick = tick_1;
                    tick_1.axis = this.component;
                    tick_1.shouldClone = false;
                    this._disposers.push(tick_1);
                }
            }
            return this._tick;
        },
        /**
         * An [[AxisTick]] element associated with this data item.
         *
         * If there is no tick element associated with data item, a new one is
         * created and returned.
         *
         * @param tick  Tick element
         */
        set: function (tick) {
            if (this._tick && this._tick != tick) {
                remove(this.sprites, this._tick);
                this._tick.dataItem = undefined;
            }
            if (tick) {
                if (tick.dataItem && tick.dataItem != this) {
                    remove(tick.dataItem.sprites, tick);
                    tick.dataItem.tick = undefined;
                }
                this.addSprite(tick);
            }
            this._tick = tick;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisDataItem.prototype, "label", {
        /**
         * @return Label element
         */
        get: function () {
            if (!this._label) {
                var component_3 = this.component;
                if (component_3) {
                    var template = void 0;
                    var label_1;
                    if (this.isRange) {
                        template = component_3.axisRanges.template.label;
                        if (template.disabled) {
                            return;
                        }
                        else {
                            label_1 = template.clone();
                        }
                    }
                    else {
                        template = component_3.renderer.labels.template;
                        if (template.disabled) {
                            return;
                        }
                        else {
                            label_1 = component_3.renderer.labels.create();
                            this._disposers.push(new Disposer(function () {
                                component_3.renderer.labels.removeValue(label_1);
                            }));
                        }
                    }
                    this._disposers.push(label_1);
                    this.label = label_1;
                    label_1.shouldClone = false;
                    label_1.axis = this.component;
                    label_1.virtualParent = component_3;
                }
            }
            return this._label;
        },
        /**
         * An [[AxisLabel]] element associated with this data item.
         *
         * If there is no label element associated with data item, a new one is
         * created and returned.
         *
         * @param label Label element
         */
        set: function (label) {
            if (this._label && this._label != label) {
                remove(this.sprites, this._label);
                this._label.dataItem = undefined;
            }
            if (label) {
                if (label.dataItem && label.dataItem != this) {
                    remove(label.dataItem.sprites, label);
                    label.dataItem.label = undefined;
                }
                this.addSprite(label);
            }
            this._label = label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisDataItem.prototype, "axisFill", {
        /**
         * @return Label element
         */
        get: function () {
            if (!this._axisFill) {
                var component_4 = this.component;
                if (component_4) {
                    var template = void 0;
                    var axisFill_1;
                    if (this.isRange) {
                        template = component_4.axisRanges.template.axisFill;
                        if (!this.isTemplate && template.disabled) {
                            return;
                        }
                        else {
                            axisFill_1 = template.clone();
                        }
                    }
                    else {
                        template = component_4.renderer.axisFills.template;
                        if (template.disabled) {
                            return;
                        }
                        else {
                            axisFill_1 = component_4.renderer.axisFills.create();
                            this._disposers.push(new Disposer(function () {
                                component_4.renderer.axisFills.removeValue(axisFill_1);
                            }));
                        }
                    }
                    this.axisFill = axisFill_1;
                    axisFill_1.shouldClone = false;
                    this._disposers.push(axisFill_1);
                }
            }
            return this._axisFill;
        },
        /**
         * An [[AxisFill]] associated element with this data item.
         *
         * If there is no fill element associated with data item, a new one is
         * created and returned.
         *
         * @param label Label element
         */
        set: function (axisFill) {
            if (this._axisFill && this._axisFill != axisFill) {
                remove(this.sprites, this._axisFill);
                this._axisFill.dataItem = undefined;
            }
            if (axisFill) {
                if (axisFill.dataItem && axisFill.dataItem != this) {
                    remove(axisFill.dataItem.sprites, axisFill);
                    axisFill.dataItem.axisFill = undefined;
                }
                axisFill.axis = this.component;
                this.addSprite(axisFill);
            }
            this._axisFill = axisFill;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisDataItem.prototype, "text", {
        /**
         * @return Text label
         */
        get: function () {
            return this._text;
        },
        /**
         * Text to be used as data item's label.
         *
         * @param text Text label
         */
        set: function (text) {
            this._text = text;
            if (this._label) { // do not use getter, it will create unwanted instances!
                this._label.text = text;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisDataItem.prototype, "mask", {
        /**
         * Data item's mask.
         *
         * @return Mask
         */
        get: function () {
            return this._mask;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisDataItem.prototype, "contents", {
        /**
         * Returns a [[Container]] to place all visual elements, related to data item
         * in.
         *
         * If there is no Container, a new one is created.
         *
         * @return Contents container
         */
        get: function () {
            if (!this._contents) {
                var contents = new Container_Container();
                this.addSprite(contents);
                contents.isMeasured = false;
                this._contents = contents;
                var component = this.component;
                if (component) {
                    var mask = component.renderer.createFill(this.component);
                    mask.disabled = false;
                    mask.axis = component;
                    this.addSprite(mask);
                    this._mask = mask;
                    contents.mask = mask;
                }
            }
            return this._contents;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisDataItem.prototype, "axisBreak", {
        /**
         * @return Axis break
         */
        get: function () {
            return this._axisBreak;
        },
        /**
         * An [[AxisBreak]] this data item falls within.
         *
         * @param axisBreak Axis break
         */
        set: function (axisBreak) {
            if (this._axisBreak) {
                this._axisBreak.dataItems.removeValue(this);
            }
            if (axisBreak) {
                axisBreak.dataItems.push(this);
            }
            this._axisBreak = axisBreak;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Re-draws the element.
     *
     * @ignore Exclude from docs
     */
    AxisDataItem.prototype.validate = function () {
        if (this.component) {
            this.component.validateDataElement(this);
        }
    };
    /**
     * Appends data item's elements to the parent [[Container]].
     *
     * @ignore Exclude from docs
     */
    AxisDataItem.prototype.appendChildren = function () {
        if (this.component) {
            this.component.appendDataItem(this);
        }
    };
    /**
     * Ordering function used in JSON setup.
     *
     * @param a  Item A
     * @param b  Item B
     * @return Order
     */
    AxisDataItem.prototype.configOrder = function (a, b) {
        if (a == b) {
            return 0;
        }
        else if (a == "language") {
            return -1;
        }
        else if (b == "language") {
            return 1;
        }
        else if (a == "component") {
            return -1;
        }
        else if (b == "component") {
            return 1;
        }
        else {
            return 0;
        }
    };
    /**
     * Checks if data item has particular property set.
     *
     * @param prop  Property name
     * @return Property set?
     */
    AxisDataItem.prototype.hasProperty = function (prop) {
        return prop == "component" ? true : _super.prototype.hasProperty.call(this, prop);
    };
    /**
     * Copies all parameters from another [[AxisDataItem]].
     *
     * @param source Source AxisDataItem
     */
    AxisDataItem.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.text = source.text;
        if (source.bullet) {
            this.bullet = source.bullet.clone();
        }
        this.minPosition = source.minPosition;
        this.maxPosition = source.maxPosition;
    };
    /**
     * Sets visibility of the Data Item.
     *
     * @param value Data Item
     */
    AxisDataItem.prototype.setVisibility = function (value, noChangeValues) {
        _super.prototype.setVisibility.call(this, value, noChangeValues);
        if (this._contents) {
            this._contents.visible = value;
        }
    };
    Object.defineProperty(AxisDataItem.prototype, "bullet", {
        /**
         * @return Bullet
         */
        get: function () {
            return this._bullet;
        },
        /**
         * Set it to an instance of any [[Sprite]]. It will be displayed as an axis
         * bullet in the middle of the cell, or specific value.
         *
         * If you need position bullet relatively to the cell, use [[AxisBullet]]
         * instead. It has a `location` property which can be used to indicate
         * precise relative location within cell/range.
         *
         * Also, [[AxisBullet]] is a [[Container]] so you can push any other element
         * into it.
         *
         * NOTE: `location` is relative to the parent axis range's scope, i.e.
         * between its `date` and `endDate` for [[DateAxis]], or `value`/`endValue`
         * ([[ValueAxis]]), or `category`/`endCategory` ([[categoryAxis]]).
         *
         * ```TypeScript
         * let range = dateAxis.axisRanges.create();
         * range.date = new Date(2018, 0, 5);
         *
         * let flag = new am4plugins_bullets.FlagBullet();
         * flag.label.text = "Hello";
         *
         * range.bullet = flag;
         * ```
         * ```JavaScript
         * var range = dateAxis.axisRanges.create();
         * range.date = new Date(2018, 0, 5);
         *
         * var flag = new am4plugins_bullets.FlagBullet();
         * flag.label.text = "Hello";
         *
         * range.bullet = flag;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "xAxes": [{
         *     "type": "DateAxis",
         *     // ...
         *     "axisRanges": [{
         *       "date": new Date(2018, 0, 5),
         *       "bullet: {
         *         "type": "FlagBullet",
         *         "label": {
         *           "text": "Hello"
         *         }
         *       }
         *     }]
         *   }]
         * }
         * ```
         *
         * @since 4.5.9
         * @param  value  Bullet
         */
        set: function (value) {
            if (this._bullet && this._bullet != value) {
                remove(this.sprites, this._bullet);
                this._bullet.dataItem = undefined;
            }
            this._bullet = value;
            if (value) {
                this.addSprite(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    return AxisDataItem;
}(DataItem_DataItem));

/**
 * ============================================================================
 * REQUISITES
 * ============================================================================
 * @hidden
 */
/**
 * Defines named positions for data item's location within [[Axis]].
 */
var AxisItemLocation;
(function (AxisItemLocation) {
    AxisItemLocation[AxisItemLocation["Start"] = 0] = "Start";
    AxisItemLocation[AxisItemLocation["Middle"] = 0.5] = "Middle";
    AxisItemLocation[AxisItemLocation["End"] = 1] = "End";
})(AxisItemLocation || (AxisItemLocation = {}));
/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A base class for all Axis elements.
 *
 * @see {@link IAxisEvents} for a list of available Events
 * @see {@link IAxisAdapters} for a list of available Adapters
 */
var Axis_Axis = /** @class */ (function (_super) {
    __extends(Axis, _super);
    /**
     * Constructor
     */
    function Axis() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Number of Grid elements on the axis.
         */
        _this._gridCount = 10;
        /**
         * A list of [[XYSeries]] that are using this Axis.
         */
        _this._series = new List_List();
        /**
         * Specifies if axis should be automatically disposed when removing from
         * chart's axis list.
         *
         * @default true
         */
        _this.autoDispose = true;
        /**
         * @ignore
         */
        _this._axisItemCount = 0;
        if (_this.constructor === Axis) {
            throw new Error("'Axis' cannot be instantiated directly. Please use a specific axis type.");
        }
        _this.hideTooltipWhileZooming = true;
        _this.minWidth = 0.0001;
        _this.minHeight = 0.0001;
        _this.className = "Axis";
        _this.shouldClone = false;
        _this.setPropertyValue("cursorTooltipEnabled", true);
        _this.toggleZoomOutButton = true;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        // Create title
        _this.title = new Label_Label();
        _this.title.shouldClone = false;
        _this._disposers.push(_this.title);
        _this.setPropertyValue("startLocation", 0);
        _this.setPropertyValue("endLocation", 1);
        // Data item iterator
        _this._dataItemsIterator = new Iterator_ListIterator(_this.dataItems, function () { return _this.dataItems.create(); });
        _this._dataItemsIterator.createNewItems = true;
        // Create tooltip
        var tooltip = new Tooltip_Tooltip();
        _this._disposers.push(tooltip);
        tooltip.label.padding(5, 10, 5, 10);
        tooltip.background.pointerLength = 5;
        tooltip.fitPointerToBounds = true;
        tooltip.background.filters.clear();
        // Set virtual parentfor the tooltip so that it can properly inheirt
        // formatters from the axis.
        tooltip.virtualParent = _this;
        // Create background element for the tooltip
        var background = tooltip.background;
        background.cornerRadius = 0;
        background.fill = interfaceColors.getFor("alternativeBackground");
        background.stroke = background.fill;
        background.strokeWidth = 1;
        background.fillOpacity = 1;
        tooltip.label.fill = interfaceColors.getFor("alternativeText");
        _this.tooltip = tooltip;
        // Accessibility
        _this.readerHidden = true;
        _this.events.on("rangechangestarted", function () {
            _this.series.each(function (series) {
                if (series.hideTooltipWhileZooming) {
                    series.tooltip.hide();
                    series.tooltip.preventShow = true;
                }
            });
            if (_this.hideTooltipWhileZooming) {
                _this.tooltip.hide();
                _this.tooltip.preventShow = true;
            }
        }, undefined, false);
        _this.events.on("rangechangeended", function () {
            _this.series.each(function (series) {
                if (series.hideTooltipWhileZooming) {
                    series.tooltip.hide();
                    series.tooltip.preventShow = false;
                }
            });
            if (_this.hideTooltipWhileZooming) {
                _this.tooltip.hide();
                _this.tooltip.preventShow = false;
            }
        }, undefined, false);
        _this.applyTheme();
        return _this;
    }
    /**
     * Holds reference to a function that accepts a DataItem and its index as
     * parameters.
     *
     * It can either return a fill opacity for a fill, or manipulate data item
     * directly, to create various highlighting scenarios.
     *
     * For example, you can set it up to highlight only weekends on a
     * [[DateAxis]].
     */
    Axis.prototype.fillRule = function (dataItem, index) {
        if (!isNumber(index)) {
            index = dataItem.index;
        }
        if (index / 2 == Math.round(index / 2)) {
            dataItem.axisFill.__disabled = true;
            dataItem.axisFill.opacity = 0;
        }
        else {
            dataItem.axisFill.opacity = 1;
            dataItem.axisFill.__disabled = false;
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    Axis.prototype.createDataItem = function () {
        return new Axis_AxisDataItem();
    };
    /**
     * Invalidates layout.
     *
     * @ignore Exclude from docs
     */
    Axis.prototype.invalidateLayout = function () {
        _super.prototype.invalidateLayout.call(this);
        // this puts series after axis in invalidation order also makes series update it's data items in case widht/height of a series is not 100%
        Iterator_each(this.series.iterator(), function (series) {
            series.invalidateLayout();
        });
    };
    /**
     * Invalidates series of this axis.
     */
    Axis.prototype.invalidateSeries = function () {
        // this puts series after axis in invalidation order also makes series update it's data items in case widht/height of a series is not 100%
        Iterator_each(this.series.iterator(), function (series) {
            series.invalidate();
        });
    };
    /**
     * Override to cancel super call for data element validation.
     * @ignore
     */
    Axis.prototype.validateDataElements = function () {
        this._axisItemCount = 0;
        if (this.ghostLabel) {
            this.renderer.updateLabelElement(this.ghostLabel, this.start, this.end);
            this.ghostLabel.validate();
        }
    };
    /**
     * Recalculates the number of grid items on the axis.
     */
    Axis.prototype.updateGridCount = function () {
        if (this.renderer) {
            var gridCount = this.axisLength / this.renderer.minGridDistance;
            if (gridCount != this._gridCount) {
                this._gridCount = gridCount;
                this.clearCache();
            }
        }
    };
    /**
     * Redraws the element.
     *
     * @ignore Exclude from docs
     */
    Axis.prototype.validateLayout = function () {
        this.axisFullLength = this.axisLength / (this.end - this.start);
        _super.prototype.validateLayout.call(this);
        this.updateGridCount();
        var renderer = this.renderer;
        if (renderer) {
            renderer.updateAxisLine();
            renderer.updateTooltip();
            renderer.updateBaseGridElement();
        }
        if (this._prevLength != this.axisLength) {
            this.dispatchImmediately("lengthchanged");
            this._prevLength = this.axisLength;
        }
    };
    /**
     * Initializes Axis' renderer.
     *
     * @ignore Exclude from docs
     */
    Axis.prototype.initRenderer = function () {
    };
    /**
     * Adds a data item to the Axis.
     *
     * @param dataItem Data item
     */
    Axis.prototype.appendDataItem = function (dataItem) {
        var renderer = this.renderer;
        var tick = dataItem.tick;
        if (tick) {
            if (tick.above) {
                tick.parent = renderer.bulletsContainer;
            }
            else {
                tick.parent = renderer.gridContainer;
            }
        }
        if (dataItem.label) {
            dataItem.label.parent = renderer;
        }
        var axisFill = dataItem.axisFill;
        if (axisFill) {
            if (axisFill.above) {
                axisFill.parent = renderer.bulletsContainer;
            }
            else {
                axisFill.parent = renderer.gridContainer;
            }
        }
        var grid = dataItem.grid;
        if (grid) {
            if (grid.above) {
                grid.parent = renderer.bulletsContainer;
            }
            else {
                grid.parent = renderer.gridContainer;
            }
        }
        if (dataItem.bullet) {
            dataItem.bullet.parent = renderer.bulletsContainer;
        }
    };
    /**
     * Redraws Axis' related items.
     *
     * @ignore Exclude from docs
     */
    Axis.prototype.validate = function () {
        _super.prototype.validate.call(this);
        this.validateLayout();
        this.renderer.updateGridContainer();
    };
    /**
     * Redars Axis ranges.
     *
     * @ignore Exclude from docs
     */
    Axis.prototype.validateAxisRanges = function () {
        var _this = this;
        Iterator_each(this.axisRanges.iterator(), function (axisRange) {
            _this.appendDataItem(axisRange);
            _this.validateDataElement(axisRange);
            if (axisRange.grid) {
                axisRange.grid.validate();
            }
            if (axisRange.tick) {
                axisRange.tick.validate();
            }
            if (axisRange.axisFill) {
                axisRange.axisFill.validate();
            }
            if (axisRange.label) {
                axisRange.label.validate();
            }
        });
    };
    /**
     * Invalidates all axis breaks, so they are redrawn.
     *
     * @ignore Exclude from docs
     */
    Axis.prototype.validateBreaks = function () {
        if (this._axisBreaks) {
            Iterator_each(this._axisBreaks.iterator(), function (axisBreak) {
                axisBreak.invalidate();
            });
        }
    };
    /**
     * Associates an Axis break with this Axis, after it is inserted into
     * `axisBreaks`.
     *
     * @ignore Exclude from docs
     * @param event Event
     */
    Axis.prototype.processBreak = function (event) {
        var axisBreak = event.newValue;
        axisBreak.parent = this.renderer.breakContainer;
        axisBreak.axis = this;
    };
    /**
     * Registers a [[XYSeries]] element with this Axis.
     *
     * Returns a [[Disposer]] for all events, added to Series for watching
     * changes in Axis, and vice versa.
     * @ignore
     * @param series  Series
     * @return Event disposer
     */
    Axis.prototype.registerSeries = function (series) {
        var _this = this;
        this.series.moveValue(series);
        return new Disposer_MultiDisposer([
            new Disposer(function () {
                _this.series.removeValue(series);
            }),
            this.events.on("lengthchanged", series.invalidate, series, false),
            this.events.on("lengthchanged", series.createMask, series, false),
            this.events.on("startchanged", series.invalidate, series, false),
            this.events.on("endchanged", series.invalidate, series, false),
        ]);
    };
    Object.defineProperty(Axis.prototype, "renderer", {
        /**
         * @return Renderer
         */
        get: function () {
            return this._renderer;
        },
        /**
         * An [[AxisRenderer]] to be used to render this Axis.
         *
         * Please note that most of the settings, related to Axis' appearance are set
         * via its renderer. Not directly on the Axis.
         *
         * E.g.:
         *
         * ```TypeScript
         * axis.renderer.inside = true;
         * axis.renderer.minLabelPosition = 0.1;
         * axis.renderer.maxLabelPosition = 0.9;
         * ```
         * ```JavaScript
         * axis.renderer.inside = true;
         * axis.renderer.minLabelPosition = 0.1;
         * axis.renderer.maxLabelPosition = 0.9;
         * ```
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/} for more info
         * @param renderer  Renderer
         */
        set: function (renderer) {
            if (renderer != this._renderer) {
                this._renderer = renderer;
                renderer.chart = this.chart;
                renderer.axis = this;
                renderer.parent = this;
                this.title.parent = this; // we add title to axis and set layout in renderer to avoid one extra container, as otherwise axis container would be used for holding renderer only
                this.initRenderer();
                this._disposers.push(renderer.gridContainer.events.on("maxsizechanged", this.invalidate, this, false));
                var ghostLabel_1 = this.renderer.labels.create();
                this._disposers.push(ghostLabel_1);
                ghostLabel_1.dataItem = this.dataItems.template.clone(); // just for the adapters not to fail
                ghostLabel_1.text = "L";
                ghostLabel_1.parent = this.renderer;
                ghostLabel_1.shouldClone = false;
                ghostLabel_1.fillOpacity = 0;
                ghostLabel_1.opacity = 0;
                ghostLabel_1.strokeOpacity = 0;
                ghostLabel_1.interactionsEnabled = false;
                ghostLabel_1.validate();
                this.ghostLabel = ghostLabel_1;
                this.events.on("beforedatavalidated", function () {
                    ghostLabel_1.text = "L";
                }, undefined, false);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts a relative position to angle. (for circular axes)
     *
     * @param position Position (0-1)
     * @return Angle
     */
    Axis.prototype.positionToAngle = function (position) {
        return this.renderer.positionToAngle(position);
    };
    /**
     * Converts pixel coordinates to a relative position. (0-1)
     *
     * @param point  Coorinates (px)
     * @return Position (0-1)
     */
    Axis.prototype.pointToPosition = function (point) {
        return this.renderer.pointToPosition(point);
    };
    /**
     * Converts relative position to coordinate.
     *
     * @since 4.7.15
     * @param position (0-1)
     * @return coordinate (px)
     */
    Axis.prototype.positionToCoordinate = function (position) {
        return this.renderer.positionToCoordinate(position);
    };
    /**
     * [getAnyRangePath description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param start  [description]
     * @param end    [description]
     * @return [description]
     */
    Axis.prototype.getAnyRangePath = function (start, end) {
        return this.renderer.getPositionRangePath(start, end);
    };
    /**
     * Converts any positional parameter to a relative position on axis.
     *
     * @todo Description (review)
     * @param value  Pisition
     * @return Position (0-1)
     */
    Axis.prototype.anyToPosition = function (value) {
        return 0;
    };
    /**
     * Converts any positional parameter to a relative position on axis.
     *
     * @todo Description (review)
     * @param value  Pisition
     * @return Orientation point
     */
    Axis.prototype.anyToPoint = function (value) {
        return { x: 0, y: 0, angle: 0 };
    };
    /**
     * [getPositionRangePath description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param startPosition [description]
     * @param endPosition   [description]
     * @return [description]
     */
    Axis.prototype.getPositionRangePath = function (startPosition, endPosition) {
        if (this.renderer) {
            return this.renderer.getPositionRangePath(startPosition, endPosition);
        }
        return "";
    };
    Object.defineProperty(Axis.prototype, "axisLength", {
        /**
         * Actual axis length in pixels.
         *
         * @return Axis length (px)
         */
        get: function () {
            if (this.renderer) {
                return this.renderer.axisLength;
            }
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Axis.prototype, "cursorTooltipEnabled", {
        /**
         * @return Display tooltip?
         */
        get: function () {
            return this.getPropertyValue("cursorTooltipEnabled");
        },
        /**
         * Indicates if axis should display a tooltip for chart's cursor.
         *
         * @param value Display tooltip?
         */
        set: function (value) {
            if (this.setPropertyValue("cursorTooltipEnabled", value)) {
                if (value && this.renderer) {
                    this.renderer.updateTooltip();
                }
                else if (this.tooltip) {
                    this.tooltip.hide(0);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Axis.prototype, "toggleZoomOutButton", {
        /**
         * @return Toggle zoom out button?
         */
        get: function () {
            return this.getPropertyValue("toggleZoomOutButton");
        },
        /**
         * Normally, when axis is zoomed in, a zoom out button is shown by a chart,
         * and vice versa: when axis is zoomed out completely, zoom out button is
         * hidden.
         *
         * Setting this to `false` will disable this behavior. Zooming in our out
         * this axis will not reveal or hide zoom out button.
         *
         * @default true
         * @since 4.6.2
         * @param  value  Toggle zoom out button?
         */
        set: function (value) {
            this.setPropertyValue("toggleZoomOutButton", value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Hides element's [[Tooltip]].
     *
     * @see {@link Tooltip}
     */
    Axis.prototype.hideTooltip = function (duration) {
        _super.prototype.hideTooltip.call(this, duration);
        this._tooltipPosition = undefined;
    };
    /**
     * Shows Axis tooltip at specific relative position within Axis. (0-1)
     *
     * @param position Position (0-1)
     * @param local or global position
     */
    Axis.prototype.showTooltipAtPosition = function (position, local) {
        var tooltip = this._tooltip;
        if (!tooltip || this.dataItems.length <= 0) {
            this._tooltipPosition = undefined;
        }
        else {
            if (!local) {
                position = this.toAxisPosition(position);
            }
            if (!isNumber(position) || position < this.start || position > this.end) {
                tooltip.hide(0);
                this._tooltipPosition = undefined;
                return;
            }
            var renderer = this.renderer;
            //@todo: think of how to solve this better
            if (!tooltip.parent) {
                tooltip.parent = this.tooltipContainer;
            }
            var tooltipLocation = renderer.tooltipLocation;
            var startPosition = this.getCellStartPosition(position);
            var endPosition = this.getCellEndPosition(position);
            if (this.tooltipPosition == "fixed") {
                position = ceil(startPosition + (endPosition - startPosition) * tooltipLocation, 4);
            }
            position = fitToRange(position, this.start, this.end);
            if (this._tooltipPosition != position) {
                this._tooltipPosition = position;
                var tooltipLocation2 = renderer.tooltipLocation2;
                var startPoint = renderer.positionToPoint(startPosition, tooltipLocation2);
                var endPoint = renderer.positionToPoint(endPosition, tooltipLocation2);
                // save values so cursor could use them
                this.currentItemStartPoint = startPoint;
                this.currentItemEndPoint = endPoint;
                if (renderer.fullWidthTooltip) {
                    tooltip.width = endPoint.x - startPoint.x;
                    tooltip.height = endPoint.y - startPoint.y;
                }
                var point = renderer.positionToPoint(position, tooltipLocation2);
                var globalPoint = spritePointToSvg(point, this.renderer.line);
                tooltip.text = this.getTooltipText(position);
                if (tooltip.text) {
                    tooltip.delayedPointTo(globalPoint);
                    tooltip.show();
                }
            }
            if (!this.cursorTooltipEnabled || this.tooltip.disabled) {
                tooltip.hide(0);
            }
        }
    };
    /**
     * Converts relative position (0-1) to Axis position with zoom level and
     * inversed taken into account.
     *
     * @param position Global position (0-1)
     * @return Position within Axis (0-1)
     */
    Axis.prototype.toAxisPosition = function (position) {
        position = this.renderer.toAxisPosition(position);
        if (position == undefined) {
            return;
        }
        position = position * (this.end - this.start);
        if (this.renderer.inversed) {
            position = this.end - position;
        }
        else {
            position = this.start + position;
        }
        return position;
    };
    /**
     * Converts position on the axis with zoom level and
     * inversed taken into account to global position.
     *
     * @param position Axis position (0-1)
     * @return Global position (0-1)
     */
    Axis.prototype.toGlobalPosition = function (position) {
        if (this.renderer.inversed) {
            position = this.end - position;
        }
        else {
            position = position - this.start;
        }
        return position / (this.end - this.start);
    };
    /**
     * Returns text to be used for cursor's Axis tooltip.
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @param position  Position coordinate (px)
     * @return Label text
     */
    Axis.prototype.getTooltipText = function (position) {
        return;
    };
    /**
     * Updates Axis' tooltip's position and possibly size, and pointer (stem)
     * place.
     *
     * @ignore Exclude from docs
     * @param pointerOrientation  Pointer (stem) orientation
     * @param boundingRectangle   A rectangle for tooltip to fit within
     */
    Axis.prototype.updateTooltip = function (pointerOrientation, boundingRectangle) {
        var tooltip = this._tooltip;
        if (tooltip) {
            tooltip.pointerOrientation = pointerOrientation;
            tooltip.setBounds(spriteRectToSvg(boundingRectangle, this.renderer.line));
        }
    };
    /**
     * [roundPosition description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param position  Relative position
     * @param location  Location on axis
     * @return Rounded position
     */
    Axis.prototype.roundPosition = function (position, location, axisLocation) {
        return position;
    };
    /**
     * [getCellStartPosition description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param position [description]
     * @return [description]
     */
    Axis.prototype.getCellStartPosition = function (position) {
        return position;
    };
    /**
     * [getCellEndPosition description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param position [description]
     * @return [description]
     */
    Axis.prototype.getCellEndPosition = function (position) {
        return position;
    };
    Object.defineProperty(Axis.prototype, "axisRanges", {
        /**
         * A list of axis ranges for this Axis.
         *
         * @return Axis ranges
         */
        get: function () {
            if (!this._axisRanges) {
                var dataItem = this.createDataItem();
                dataItem.isRange = true;
                dataItem.axisFill = this.renderer.axisFills.template.clone();
                dataItem.grid = this.renderer.grid.template.clone();
                dataItem.tick = this.renderer.ticks.template.clone();
                dataItem.label = this.renderer.labels.template.clone();
                dataItem.isTemplate = true;
                dataItem.component = this;
                dataItem.axisFill.disabled = false;
                dataItem.tick.disabled = false;
                dataItem.grid.disabled = false;
                dataItem.label.disabled = false;
                this._axisRanges = new List_ListTemplate(dataItem);
                this._axisRanges.events.on("inserted", this.processAxisRange, this, false);
                this._disposers.push(new List_ListDisposer(this._axisRanges));
                this._disposers.push(this._axisRanges.template);
            }
            return this._axisRanges;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Decorates an axis range after it has been added to the axis range list.
     *
     * @param event Event
     */
    Axis.prototype.processAxisRange = function (event) {
        var axisRange = event.newValue;
        axisRange.component = this;
        axisRange.isRange = true;
    };
    Object.defineProperty(Axis.prototype, "axisBreaks", {
        /**
         * A list of axis breaks on this Axis.
         *
         * @return Axis breaks.
         */
        get: function () {
            if (!this._axisBreaks) {
                this._axisBreaks = new SortedList_SortedListTemplate(this.createAxisBreak(), function (a, b) {
                    return Number_order(a.adjustedStartValue, b.adjustedStartValue);
                });
                this._axisBreaks.events.on("inserted", this.processBreak, this, false);
                this._disposers.push(new List_ListDisposer(this._axisBreaks));
                this._disposers.push(this._axisBreaks.template);
            }
            return this._axisBreaks;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new axis break.
     *
     * @return Axis break
     */
    Axis.prototype.createAxisBreak = function () {
        return new AxisBreak_AxisBreak();
    };
    Object.defineProperty(Axis.prototype, "series", {
        /**
         * A list of Series currently associated with this Axis.
         *
         * @return Series
         */
        get: function () {
            if (!this._series) {
                this._series = new List_List();
            }
            return this._series;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Processes Series' data items.
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     */
    Axis.prototype.processSeriesDataItems = function () {
    };
    /**
     * Processes Series' single data item.
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @param dataItem Data item
     */
    Axis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {
    };
    /**
     * Post-processes Serie's data items.
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     */
    Axis.prototype.postProcessSeriesDataItems = function (series) {
    };
    /**
     * Post-processes Serie's single data item.
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @param dataItem Data item
     */
    Axis.prototype.postProcessSeriesDataItem = function (dataItem) {
    };
    //
    /**
     * Updates Axis based on all Series that might influence it.
     *
     * Called by Series after Series data is validated.
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     */
    Axis.prototype.updateAxisBySeries = function () {
    };
    /**
     * Hides unused data items.
     *
     * @ignore Exclude from docs
     */
    Axis.prototype.hideUnusedDataItems = function () {
        var _this = this;
        // hide all unused
        var dataItemsIterator = this._dataItemsIterator;
        dataItemsIterator.createNewItems = false;
        Iterator_each(dataItemsIterator.iterator(), function (dataItem) {
            _this.validateDataElement(dataItem); // solves shrinking
            dataItem.__disabled = true;
        });
        dataItemsIterator.clear();
        dataItemsIterator.createNewItems = true;
    };
    /**
     * Returns a Series' data item that corresponds to specific position on Axis.
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @param series    Series
     * @param position  Position (0-1)
     * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position
     * @return Data item
     */
    Axis.prototype.getSeriesDataItem = function (series, position, findNearest) {
        return;
    };
    /**
     * Returns an angle that corresponds to specific position on axis.
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem  Data item
     * @param key       ???
     * @param location  Location
     * @param stackKey  ???
     * @return Angle
     */
    Axis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {
        return;
    };
    /**
     * [getX description]
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem [description]
     * @param key      [description]
     * @param location [description]
     * @param stackKey [description]
     * @return [description]
     */
    Axis.prototype.getX = function (dataItem, key, location, stackKey, range) {
        return;
    };
    /**
     * [getX description]
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem [description]
     * @param key      [description]
     * @param location [description]
     * @param stackKey [description]
     * @return [description]
     */
    Axis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {
        return;
    };
    /**
     * [getY description]
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem [description]
     * @param key      [description]
     * @param location [description]
     * @param stackKey [description]
     * @return [description]
     */
    Axis.prototype.getY = function (dataItem, key, location, stackKey, range) {
        return;
    };
    /**
     * [getY description]
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem [description]
     * @param key      [description]
     * @param location [description]
     * @param stackKey [description]
     * @return [description]
     */
    Axis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {
        return;
    };
    Object.defineProperty(Axis.prototype, "basePoint", {
        /**
         * Coordinates of the actual axis start.
         *
         * @ignore Exclude from docs
         * @return Base point coordinates
         */
        get: function () {
            return { x: 0, y: 0 };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * [dataChangeUpdate description]
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    Axis.prototype.dataChangeUpdate = function () {
    };
    /**
     * [dataChangeUpdate description]
     *
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    Axis.prototype.seriesDataChangeUpdate = function (series) {
    };
    /**
     * Removes axis breaks that fall between `min` and `max` (???)
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param min  Start value
     * @param max  End value
     * @return Spread o
     */
    Axis.prototype.adjustDifference = function (min, max) {
        var difference = max - min;
        if (isNumber(difference)) {
            if (this._axisBreaks) {
                Iterator_eachContinue(this._axisBreaks.iterator(), function (axisBreak) {
                    var startValue = axisBreak.adjustedStartValue;
                    var endValue = axisBreak.adjustedEndValue;
                    if (isNumber(startValue) && isNumber(endValue)) {
                        // breaks are sorted, we don't need go further anymore
                        if (startValue > max) {
                            return false;
                        }
                        if (endValue >= min) {
                            if (isNumber(startValue) && isNumber(endValue)) {
                                var breakSize = axisBreak.breakSize;
                                var intersection = Math_intersection({ start: startValue, end: endValue }, { start: min, end: max });
                                if (intersection) {
                                    difference -= (intersection.end - intersection.start) * (1 - breakSize);
                                }
                            }
                        }
                        return true;
                    }
                });
            }
            return difference;
        }
    };
    /**
     * Checks if specific value falls within a break.
     *
     * Returns [[AxisBreak]] the value falls into.
     *
     * @param value  Value to check
     * @return Axis break
     */
    Axis.prototype.isInBreak = function (value) {
        if (this._axisBreaks) {
            return Iterator_find(this._axisBreaks.iterator(), function (axisBreak) {
                return value >= axisBreak.adjustedStartValue &&
                    value <= axisBreak.adjustedEndValue;
            });
        }
    };
    /**
     * [fixAxisBreaks description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    Axis.prototype.fixAxisBreaks = function () {
        var _this = this;
        if (this._axisBreaks) {
            var axisBreaks = this._axisBreaks;
            if (axisBreaks.length > 0) {
                // first make sure that startValue is <= end value
                // This needs to make a copy of axisBreaks because it mutates the list while traversing
                // TODO very inefficient
                each(Iterator_toArray(axisBreaks.iterator()), function (axisBreak) {
                    var startValue = Math_min(axisBreak.startValue, axisBreak.endValue);
                    var endValue = Math_max(axisBreak.startValue, axisBreak.endValue);
                    axisBreak.adjustedStartValue = startValue;
                    axisBreak.adjustedEndValue = endValue;
                    _this._axisBreaks.update(axisBreak);
                });
                var firstAxisBreak = axisBreaks.first;
                var previousEndValue_1 = Math.min(firstAxisBreak.startValue, firstAxisBreak.endValue);
                // process breaks
                // TODO does this need to call axisBreaks.update ?
                Iterator_each(axisBreaks.iterator(), function (axisBreak) {
                    var startValue = axisBreak.adjustedStartValue;
                    var endValue = axisBreak.adjustedEndValue;
                    // breaks can't overlap
                    // if break starts before previous break ends
                    if (startValue < previousEndValue_1) {
                        startValue = previousEndValue_1;
                        if (endValue < previousEndValue_1) {
                            endValue = previousEndValue_1;
                        }
                    }
                    axisBreak.adjustedStartValue = startValue;
                    axisBreak.adjustedEndValue = endValue;
                });
            }
        }
    };
    Object.defineProperty(Axis.prototype, "startIndex", {
        /**
         * @ignore Exclude from docs
         * @return [description]
         */
        get: function () {
            return 0;
        },
        /**
         * We need start/end indexes of axes to be 0 - `dataItems.length`.
         *
         * Yes, also for category axis, this helps to avoid jumping of categories
         * while scrolling and does not do a lot of extra work as we use
         * protected `_startIndex` and `_endIndex` when working with items.
         *
         * @hidden
         */
        /**
         * [startIndex description]
         *
         * @ignore Exclude from docs
         * @todo Description
         * @param value [description]
         */
        set: function (value) {
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Axis.prototype, "endIndex", {
        /**
         * @ignore Exclude from docs
         * @return [description]
         */
        get: function () {
            return this.dataItems.length;
        },
        /**
         * [endIndex description]
         *
         * @ignore Exclude from docs
         * @todo Description
         * @param value [description]
         */
        set: function (value) {
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a formatted label based on position.
     *
     * Individual axis types should override this method to generate a label
     * that is relevant to axis type.
     *
     * Please note that `position` represents position within axis which may be
     * zoomed and not correspond to Cursor's `position`.
     *
     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.
     *
     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.
     * @param position  Relative position on axis (0-1)
     * @return Position label
     */
    Axis.prototype.getPositionLabel = function (position) {
        return Math.round(position * 100) + "%x";
    };
    Object.defineProperty(Axis.prototype, "chart", {
        /**
         * @return Chart
         */
        get: function () {
            return this._chart;
        },
        /**
         * A Chart this Axis belongs to.
         *
         * @param value  Chart
         */
        set: function (value) {
            this._chart = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a data item for a Series range.
     *
     * @param series  Target Series
     * @return Range data item
     */
    Axis.prototype.createSeriesRange = function (series) {
        var range = this.axisRanges.create();
        range.component = this;
        range.axisFill = this.renderer.axisFills.template.clone();
        range.axisFill.disabled = false;
        range.axisFill.fillOpacity = 0;
        range.grid = this.renderer.grid.template.clone();
        range.grid.disabled = true;
        range.tick = this.renderer.ticks.template.clone();
        range.tick.disabled = true;
        range.label = this.renderer.labels.template.clone();
        range.label.disabled = true;
        range.addDisposer(new Disposer(function () {
            series.axisRanges.removeValue(range);
        }));
        series.axisRanges.push(range);
        return range;
    };
    /**
     * Copies all properties and related data from a different instance of Axis.
     *
     * @param source Source Axis
     */
    Axis.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (this.renderer) {
            this.renderer.copyFrom(source.renderer);
        }
        else {
            if (source.renderer) {
                this.renderer = source.renderer.clone();
                this._disposers.push(this.renderer);
            }
        }
        if (source.title) {
            if (!this.title) {
                this.title = source.title.clone();
                this.title.parent = this;
            }
            else {
                this.title.copyFrom(source.title);
            }
            this._disposers.push(this.title);
        }
    };
    /**
     * Resets internal iterator.
     */
    Axis.prototype.resetIterators = function () {
        this._dataItemsIterator.reset();
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    Axis.prototype.processConfig = function (config) {
        if (config) {
            // Set up axis ranges
            if (hasValue(config.axisRanges) && isArray(config.axisRanges)) {
                for (var i = 0, len = config.axisRanges.length; i < len; i++) {
                    var range = config.axisRanges[i];
                    // If `series` is set, we know it's a series range
                    if (hasValue(range["series"])) {
                        if (isString(range["series"])) {
                            if (this.map.hasKey(range["series"])) {
                                //range["series"] = this.map.getKey(range["series"]);
                                config.axisRanges[i] = this.createSeriesRange(this.map.getKey(range["series"]));
                                delete (range["series"]);
                                config.axisRanges[i].config = range;
                            }
                        }
                    }
                }
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    Object.defineProperty(Axis.prototype, "startLocation", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("startLocation");
        },
        /**
         * Axis start location. Works on Date/Category axis, doesn't work on Value axis.
         *
         * * 0 - Full first cell is shown.
         * * 0.5 - Half of first cell is shown.
         * * 1 - None of the first cell is visible. (you probably don't want that)
         *
         * @param value Location (0-1)
         */
        set: function (value) {
            this.setPropertyValue("startLocation", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Axis.prototype, "endLocation", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("endLocation");
        },
        /**
         * Axis end location. Works on Date/Category axis, doesn't work on Value axis.
         *
         * * 0 - None of the last cell is shown. (don't do that)
         * * 0.5 - Half of the last cell is shown.
         * * 1 - Full last cell is shown.
         *
         * @param value Location (0-1)
         */
        set: function (value) {
            this.setPropertyValue("endLocation", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Axis.prototype.setDisabled = function (value) {
        var changed = _super.prototype.setDisabled.call(this, value);
        if (this.renderer) {
            this.renderer.gridContainer.disabled = value;
        }
        return changed;
    };
    Object.defineProperty(Axis.prototype, "title", {
        /**
         * @return Title label
         */
        get: function () {
            return this._title;
        },
        /**
         * A reference to a [[Label]] element which serves as a title to the axis.
         *
         * When axis is created it aleready has an element, so you can just modify
         * it.
         *
         * Or you can replace it with your own instance of `Label`.
         *
         * @param  value  Title label
         */
        set: function (value) {
            if (this._title && this._title != value) {
                this._title.dispose();
            }
            if (value) {
                this._title = value;
                value.parent = this;
                value.shouldClone = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Axis.prototype, "hideTooltipWhileZooming", {
        /**
         * @return Hide tooltip while zooming?
         */
        get: function () {
            return this.getPropertyValue("hideTooltipWhileZooming");
        },
        /**
         * Indicates if axis' tooltip should be hidden while axis range is animating
         * (zooming)
         *
         * @default true
         * @since 4.7.16
         * @param  value  Hide tooltip while zooming?
         */
        set: function (value) {
            this.setPropertyValue("hideTooltipWhileZooming", value);
        },
        enumerable: true,
        configurable: true
    });
    return Axis;
}(Component_Component));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Axis"] = Axis_Axis;
registry.registeredClasses["AxisDataItem"] = Axis_AxisDataItem;
/**
 * Add default responsive rules
 */
/**
 * Disable axis tooltips.
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.maybeXS,
    state: function (target, stateId) {
        if (target instanceof Axis_Axis && target.tooltip) {
            var state = target.states.create(stateId);
            state.properties.cursorTooltipEnabled = false;
            return state;
        }
        return null;
    }
});
//# sourceMappingURL=Axis.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisLine.js
/**
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to draw Axis line.
 *
 * @see {@link IAxisLineEvents} for a list of available events
 * @see {@link IAxisLineAdapters} for a list of available Adapters
 */
var AxisLine_AxisLine = /** @class */ (function (_super) {
    __extends(AxisLine, _super);
    /**
     * Constructor
     */
    function AxisLine() {
        var _this = _super.call(this) || this;
        _this.className = "AxisLine";
        _this.element = _this.paper.add("path");
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.stroke = interfaceColors.getFor("grid");
        _this.strokeOpacity = 0.15;
        _this.pixelPerfect = true;
        _this.fill = Color_color();
        _this.applyTheme();
        _this.interactionsEnabled = false;
        return _this;
        //this.element.moveTo({ x: 0, y: 0 });
    }
    return AxisLine;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisLine"] = AxisLine_AxisLine;
//# sourceMappingURL=AxisLine.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisFill.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * AxisFill is a base class used to defines fill shapes for various
 * type-specific Axes.
 *
 * Axis fills are used to add fills to specific ranges of those axes.
 *
 * @see {@link IAxisFillEvents} for a list of available events
 * @see {@link IAxisFillAdapters} for a list of available Adapters
 * @important
 */
var AxisFill_AxisFill = /** @class */ (function (_super) {
    __extends(AxisFill, _super);
    /**
     * Constructor.
     *
     * @param axis Axis
     */
    function AxisFill(axis) {
        var _this = _super.call(this) || this;
        _this.axis = axis;
        _this.element = _this.paper.add("path");
        _this.className = "AxisFill";
        _this.isMeasured = false;
        _this.location = 0;
        _this.above = false;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.fill = interfaceColors.getFor("alternativeBackground");
        _this.fillOpacity = 0;
        _this.applyTheme();
        return _this;
    }
    /**
     * @ignore
     */
    AxisFill.prototype.setDisabled = function (value) {
        var changed = _super.prototype.setDisabled.call(this, value);
        if (this.axis) {
            this.axis.invalidateDataItems();
        }
        return changed;
    };
    /**
     * Draws the fill element.
     *
     * @ignore Exclude from docs
     */
    AxisFill.prototype.draw = function () {
        _super.prototype.draw.call(this);
        if (this.__disabled || this.disabled) {
            return;
        }
        if (this.axis && isNumber(this.startPosition) && isNumber(this.endPosition)) {
            this.fillPath = this.axis.getPositionRangePath(this.startPosition, this.endPosition);
            this.path = this.fillPath;
            if (this.isMeasured) {
                this.measure();
            }
        }
    };
    Object.defineProperty(AxisFill.prototype, "startPosition", {
        /**
         * @return Start position
         */
        get: function () {
            return this.getPropertyValue("startPosition");
        },
        /**
         * An actual starting position of the fill.
         *
         * @param value  Starting position
         */
        set: function (value) {
            this.setPropertyValue("startPosition", value);
            this.invalidate(); // this is needed as relative position might not change when zooming
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisFill.prototype, "endPosition", {
        /**
         * @return End position
         */
        get: function () {
            return this.getPropertyValue("endPosition");
        },
        /**
         * An actual end position of the fill.
         *
         * @param value End position
         */
        set: function (value) {
            this.setPropertyValue("endPosition", value);
            this.invalidate(); // this is needed as relative position might not change when zooming
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisFill.prototype, "location", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("location");
        },
        /**
         * Relative location of the fill. (0-1)
         *
         * @param value Location (0-1)
         */
        set: function (value) {
            this.setPropertyValue("location", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    AxisFill.prototype.setPath = function (value) {
        if (this.setPropertyValue("path", value)) {
            this.element.attr({ "d": value });
            return true;
        }
        return false;
    };
    Object.defineProperty(AxisFill.prototype, "above", {
        /**
         * @return Draw above series?
         */
        get: function () {
            return this.getPropertyValue("above");
        },
        /**
         * Normally fill goes below series. Set this to `true` to go above.
         *
         * @default false
         * @since 4.5.9
         * @param  value  Draw above series?
         */
        set: function (value) {
            this.setPropertyValue("above", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return AxisFill;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisFill"] = AxisFill_AxisFill;
//# sourceMappingURL=AxisFill.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/Grid.js
/**
 * A module defining functionality for axis grid elements.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Displays an axis grid line.
 *
 * @see {@link IGridEvents} for a list of available events
 * @see {@link IGridAdapters} for a list of available Adapters
 * @todo Review: container is better, as we'll be able to attach something to the grid, also with 3d charts we might need some additional elements
 * @important
 */
var Grid_Grid = /** @class */ (function (_super) {
    __extends(Grid, _super);
    /**
     * Constructor
     */
    function Grid() {
        var _this = _super.call(this) || this;
        _this.className = "Grid";
        _this.element = _this.paper.add("path");
        _this.location = 0.5;
        _this.isMeasured = false;
        _this.above = false;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.stroke = interfaceColors.getFor("grid");
        _this.pixelPerfect = true;
        _this.strokeOpacity = 0.15;
        _this.fill = Color_color(); // "none";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(Grid.prototype, "location", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("location");
        },
        /**
         * Location within axis cell to place grid line on.
         *
         * * 0 - start
         * * 0.5 - middle
         * * 1 - end
         *
         * @param value  Location (0-1)
         */
        set: function (value) {
            this.setPropertyValue("location", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Grid.prototype, "above", {
        /**
         * @return Draw above series?
         */
        get: function () {
            return this.getPropertyValue("above");
        },
        /**
         * Normally fill goes below series. Set this to `true` to go above.
         *
         * @default false
         * @since 4.5.9
         * @param  value  Draw above series?
         */
        set: function (value) {
            this.setPropertyValue("above", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    Grid.prototype.setDisabled = function (value) {
        var changed = _super.prototype.setDisabled.call(this, value);
        if (this.axis) {
            this.axis.invalidateDataItems();
        }
        return changed;
    };
    return Grid;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Grid"] = Grid_Grid;
/**
 * Add default responsive rules
 */
/**
 * Disable grid on smaller charts
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.maybeXS,
    state: function (target, stateId) {
        if (target instanceof Grid_Grid) {
            var state = target.states.create(stateId);
            state.properties.disabled = true;
            return state;
        }
        return null;
    }
});
//# sourceMappingURL=Grid.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisLabel.js
/**
 * Axis Label module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Use to create labels on Axis.
 *
 * @see {@link IAxisLabelEvents} for a list of available events
 * @see {@link IAxisLabelAdapters} for a list of available Adapters
 * @important
 */
var AxisLabel_AxisLabel = /** @class */ (function (_super) {
    __extends(AxisLabel, _super);
    /**
     * Constructor
     */
    function AxisLabel() {
        var _this = _super.call(this) || this;
        _this.className = "AxisLabel";
        _this.isMeasured = false;
        _this.padding(10, 10, 10, 10);
        _this.location = 0.5;
        //this.nonScaling = true; // not good for perf
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(AxisLabel.prototype, "location", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("location");
        },
        /**
         * Relative location of the label. (0-1)
         *
         * @param value  Location (0-1)
         */
        set: function (value) {
            this.setPropertyValue("location", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisLabel.prototype, "inside", {
        /**
         * Returns if label is set to be drawn inside axis.
         *
         * @return Inside?
         */
        get: function () {
            return this.getPropertyValue("inside");
        },
        /**
         * Sets if label should be drawn inside axis.
         *
         * @param value  Inside?
         */
        set: function (value) {
            this.setPropertyValue("inside", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    AxisLabel.prototype.setDisabled = function (value) {
        var changed = _super.prototype.setDisabled.call(this, value);
        if (this.axis) {
            this.axis.invalidateDataItems();
        }
        return changed;
    };
    return AxisLabel;
}(Label_Label));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisLabel"] = AxisLabel_AxisLabel;
//# sourceMappingURL=AxisLabel.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/Tick.js
/**
 * Tick module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A basic Tick class.
 *
 * A tick is a short dash, mainly connecting an object like axis or slice to
 * it's textual label.
 *
 * @see {@link ITickEvents} for a list of available events
 * @see {@link ITickAdapters} for a list of available Adapters
 * @important
 */
var Tick_Tick = /** @class */ (function (_super) {
    __extends(Tick, _super);
    /**
     * Constructor
     */
    function Tick() {
        var _this = _super.call(this) || this;
        _this.className = "Tick";
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.fillOpacity = 0;
        _this.length = 6;
        _this.strokeOpacity = 0.2;
        _this.stroke = interfaceColors.getFor("grid");
        _this.isMeasured = false;
        _this.nonScalingStroke = true;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(Tick.prototype, "length", {
        /**
         * @return Length (px)
         */
        get: function () {
            if (this.disabled) {
                return 0;
            }
            return this.getPropertyValue("length");
        },
        /**
         * Length of the tick in pixels.
         *
         * @param value  Length (px)
         */
        set: function (value) {
            this.setPropertyValue("length", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return Tick;
}(Sprite_Sprite));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Tick"] = Tick_Tick;
//# sourceMappingURL=Tick.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisTick.js
/**
 * Axis Tick module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws an axis tick
 * @see {@link IAxisTickEvents} for a list of available events
 * @see {@link IAxisTickAdapters} for a list of available Adapters
 */
var AxisTick_AxisTick = /** @class */ (function (_super) {
    __extends(AxisTick, _super);
    function AxisTick() {
        var _this = _super.call(this) || this;
        _this.className = "AxisTick";
        _this.element = _this.paper.add("path");
        _this.location = 0.5;
        _this.above = false;
        _this.isMeasured = false;
        _this.pixelPerfect = true;
        _this.strokeOpacity = 0;
        _this.length = 5;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(AxisTick.prototype, "location", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("location");
        },
        /**
         * Relative location of the tick. (0-1)
         *
         * @param value  Location (0-1)
         */
        set: function (value) {
            this.setPropertyValue("location", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisTick.prototype, "inside", {
        /**
         * Returns if label is set to be drawn inside axis.
         *
         * @return Inside?
         */
        get: function () {
            return this.getPropertyValue("inside");
        },
        /**
         * Sets if tick should be drawn inside axis.
         *
         * @param value  Inside?
         */
        set: function (value) {
            this.setPropertyValue("inside", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisTick.prototype, "above", {
        /**
         * @return Draw above series?
         */
        get: function () {
            return this.getPropertyValue("above");
        },
        /**
         * Normally tick goes below series. Set this to `true` to go above.
         *
         * @default false
         * @since 4.5.9
         * @param  value  Draw above series?
         */
        set: function (value) {
            this.setPropertyValue("above", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    AxisTick.prototype.setDisabled = function (value) {
        var changed = _super.prototype.setDisabled.call(this, value);
        if (this.axis) {
            this.axis.invalidateDataItems();
        }
        return changed;
    };
    return AxisTick;
}(Tick_Tick));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisTick"] = AxisTick_AxisTick;
//# sourceMappingURL=AxisTick.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRenderer.js
/**
 * Module, defining base Axis Renderer.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */













/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A base class for all axis renderers.
 *
 * @see {@link IAxisRendererEvents} for a list of available events
 * @see {@link IAxisRendererAdapters} for a list of available Adapters
 */
var AxisRenderer_AxisRenderer = /** @class */ (function (_super) {
    __extends(AxisRenderer, _super);
    /**
     * Constructor.
     *
     * @param axis Related axis
     */
    function AxisRenderer() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * A related chart.
         */
        _this._chart = new Disposer_MutableValueDisposer();
        _this.className = "AxisRenderer";
        // Set defaults
        _this.minGridDistance = 50;
        _this.inside = false;
        _this.inversed = false;
        _this.tooltipLocation = 0.5;
        _this.fullWidthTooltip = false;
        _this.cellStartLocation = 0;
        _this.cellEndLocation = 1;
        _this.minLabelPosition = 0;
        _this.maxLabelPosition = 1;
        _this.shouldClone = false;
        var gridContainer = _this.createChild(Container_Container);
        gridContainer.shouldClone = false;
        gridContainer.layout = "none";
        //	gridContainer.isMeasured = false;
        gridContainer.virtualParent = _this;
        gridContainer.width = Percent_percent(100);
        gridContainer.height = Percent_percent(100);
        _this.gridContainer = gridContainer;
        // not good without this
        gridContainer.events.on("maxsizechanged", function () {
            if (_this.inited) {
                _this.invalidateAxisItems();
            }
        }, _this, false);
        var breakContainer = _this.createChild(Container_Container);
        breakContainer.shouldClone = false;
        breakContainer.isMeasured = false;
        breakContainer.layout = "none";
        breakContainer.width = Percent_percent(100);
        breakContainer.height = Percent_percent(100);
        _this.breakContainer = breakContainer;
        var bulletsContainer = _this.createChild(Container_Container);
        bulletsContainer.shouldClone = false;
        bulletsContainer.isMeasured = false;
        bulletsContainer.layout = "none";
        bulletsContainer.width = Percent_percent(100);
        bulletsContainer.height = Percent_percent(100);
        _this.bulletsContainer = bulletsContainer;
        _this.line = _this.createChild(AxisLine_AxisLine);
        _this.line.shouldClone = false;
        _this.line.strokeOpacity = 0;
        var baseGrid = _this.createChild(Grid_Grid);
        baseGrid.shouldClone = false;
        _this.baseGrid = baseGrid;
        // Make elements disposable
        var disposers = _this._disposers;
        disposers.push(baseGrid);
        disposers.push(_this.line);
        disposers.push(gridContainer);
        disposers.push(breakContainer);
        disposers.push(bulletsContainer);
        disposers.push(_this._chart);
        _this.ticks.template.disabled = true;
        _this.axisFills.template.disabled = true;
        _this.axisFills.template.interactionsEnabled = false;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(AxisRenderer.prototype, "axis", {
        /**
         * Axis of a renderer
         * @return axis Axis
         */
        get: function () {
            return this._axis;
        },
        /**
         * Axis of a renderer
         * @param axis Axis
         */
        set: function (axis) {
            this.setAxis(axis);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * @ignore
    */
    AxisRenderer.prototype.setAxis = function (axis) {
        this._axis = axis;
        this.baseGrid.parent = axis;
        this.line.parent = axis;
        this.gridContainer.bind("opacity", axis);
    };
    /**
     * Called when rendered is attached to an Axis, as well as a property of
     * Axis that might affect the appearance is updated.
     *
     * E.g. `axis.opposite`, `axis.inside`, etc.
     *
     * This method is called **before** draw, so that any related setting
     * changed in this method can be changed.
     *
     * @todo Description (review)
     * @ignore Exclude from docs
     */
    AxisRenderer.prototype.processRenderer = function () {
        this.events.on("sizechanged", this.updateTooltip, this, false);
        this.events.on("positionchanged", this.updateTooltip, this, false);
        this.labels.template.inside = this.inside;
        this.ticks.template.inside = this.inside;
    };
    /**
     * Updates Axis' tooltip.
     *
     * @todo Description (review)
     * @ignore Exclude from docs
     */
    AxisRenderer.prototype.updateTooltip = function () {
        // This is a placeholder method for extending classes to override.
    };
    Object.defineProperty(AxisRenderer.prototype, "axisLength", {
        /**
         * Returns actual length of the Axis, in pixels.
         *
         * @return Length (px)
         */
        get: function () {
            // This is a placeholder method for extending classes to override.
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Re-positions an element to new coordinates.
     *
     * @ignore Exclude from docs
     * @param item   A target element
     * @param point  New coordinates
     */
    AxisRenderer.prototype.positionItem = function (item, point) {
        if (item) {
            item.moveTo(point);
        }
    };
    /**
     * Converts relative position on axis to point coordinates.
     *
     * @param position  Position (0-1)
     * @return Point
     */
    AxisRenderer.prototype.positionToPoint = function (position, position2) {
        // This is a placeholder method for extending classes to override.
        return { x: 0, y: 0 };
    };
    /**
     * Converts relative position on axis to angle.
     *
     * @ignore Exclude from docs
     * @todo Description (review / units)
     * @param position  Position (0-1)
     * @return Angle
     */
    AxisRenderer.prototype.positionToAngle = function (position) {
        // This is a placeholder method for extending classes to override.
        return 0;
    };
    /**
     * Converts relative position (0-1) on axis to a pixel coordinate.
     *
     * @param position  Position (0-1)
     * @return Coordinate (px)
     */
    AxisRenderer.prototype.positionToCoordinate = function (position) {
        var coordinate;
        var axis = this.axis;
        var axisFullLength = axis.axisFullLength;
        if (axis.renderer.inversed) {
            coordinate = (axis.end - position) * axisFullLength;
        }
        else {
            coordinate = (position - axis.start) * axisFullLength;
        }
        return coordinate;
    };
    AxisRenderer.prototype.updateGridContainer = function () {
    };
    AxisRenderer.prototype.getHeight = function () {
        var gridContainer = this.gridContainer;
        if (gridContainer.parent) {
            return gridContainer.parent.pixelHeight;
        }
        return this.gridContainer.pixelHeight || 0;
    };
    AxisRenderer.prototype.getWidth = function () {
        var gridContainer = this.gridContainer;
        if (gridContainer.parent) {
            return gridContainer.parent.pixelWidth;
        }
        return this.gridContainer.pixelWidth || 0;
    };
    /**
     * Converts a coordinate in pixels to a relative position. (0-1)
     *
     * @param coordinate  Coordinate (px)
     * @param coordinate2  Coordinate of a second axis, only needed for complex axes systems, like timeline (px)
     * @return Position (0-1)
     */
    AxisRenderer.prototype.coordinateToPosition = function (coordinate, coordinate2) {
        var position;
        var axis = this.axis;
        var axisFullLength = axis.axisFullLength;
        if (axis.renderer.inversed) {
            position = axis.end - coordinate / axisFullLength;
        }
        else {
            position = coordinate / axisFullLength + axis.start;
        }
        return Math_round(position, 5);
    };
    /**
     * Converts a point at specific coordinates to a relative position (0-1)
     * on the axis.
     *
     * @ignore Exclude from docs
     * @param point  Point
     * @return Position (0-1)
     */
    AxisRenderer.prototype.pointToPosition = function (point) {
        // This is a placeholder method for extending classes to override.
        return 0;
    };
    /**
     * [getPositionRangePath description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param startPosition  Starting position
     * @param endPosition    End position
     * @return SVG path
     */
    AxisRenderer.prototype.getPositionRangePath = function (startPosition, endPosition) {
        return "";
    };
    /**
     * Invalidates all axis data items, effectively causing them re-evaluated.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     */
    AxisRenderer.prototype.invalidateAxisItems = function () {
        var axis = this.axis;
        if (axis) {
            axis.invalidateDataItems();
        }
    };
    /**
     * Updates and positions a grid element.
     *
     * @ignore Exclude from docs
     * @param grid         Grid element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRenderer.prototype.updateGridElement = function (grid, position, endPosition) {
        // This is a placeholder method for extending classes to override.
    };
    /**
     * Updates and positions a tick element.
     *
     * @ignore Exclude from docs
     * @param tick         Tick element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRenderer.prototype.updateTickElement = function (tick, position, endPosition) {
        // This is a placeholder method for extending classes to override.
    };
    /**
     * Updates and positions axis bullet.
     *
     * @ignore Exclude from docs
     * @param bullet       AxisBullet element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRenderer.prototype.updateBullet = function (bullet, position, endPosition) {
        // This is a placeholder method for extending classes to override.
    };
    /**
     * Updates and positions a label element.
     *
     * @ignore Exclude from docs
     * @param label        Label element
     * @param position     Starting position
     * @param endPosition  Ending position
     */
    AxisRenderer.prototype.updateLabelElement = function (label, position, endPosition, location) {
        // This is a placeholder method for extending classes to override.
    };
    /**
     * Updates and positions the axis fill element.
     *
     * @ignore Exclude from docs
     * @param fill         Fill element
     * @param position     Starting position
     * @param endPosition  Ending position
     */
    AxisRenderer.prototype.updateFillElement = function (fill, position, endPosition) {
        fill.startPosition = position;
        fill.endPosition = endPosition;
    };
    /**
     * Updates and positions the axis line element.
     *
     * @ignore Exclude from docs
     */
    AxisRenderer.prototype.updateAxisLine = function () {
        // This is a placeholder method for extending classes to override.
    };
    /**
     * Updates and positions the base grid element.
     *
     * @ignore Exclude from docs
     */
    AxisRenderer.prototype.updateBaseGridElement = function () {
        // This is a placeholder method for extending classes to override.
    };
    /**
     * Updates and positions an axis break element.
     *
     * @ignore Exclude from docs
     * @param axisBreak Break element
     */
    AxisRenderer.prototype.updateBreakElement = function (axisBreak) {
        this.positionItem(axisBreak.startLine, axisBreak.startPoint);
        this.toggleVisibility(axisBreak.startLine, axisBreak.startPosition, 0, 1);
        this.positionItem(axisBreak.endLine, axisBreak.endPoint);
        this.toggleVisibility(axisBreak.endLine, axisBreak.endPosition, 0, 1);
    };
    Object.defineProperty(AxisRenderer.prototype, "minGridDistance", {
        /**
         * @return Min distance (px)
         */
        get: function () {
            return this.getPropertyValue("minGridDistance");
        },
        /**
         * Minimum distance in pixels between grid elements.
         *
         * @param value  Min distance (px)
         */
        set: function (value) {
            if (this.setPropertyValue("minGridDistance", value)) {
                if (this.axis) {
                    this.axis.invalidateDataItems();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRenderer.prototype, "chart", {
        /**
         * @ignore Exclude from docs
         * @return Chart
         */
        get: function () {
            return this._chart.get();
        },
        /**
         * A chart, associated with the Axis.
         *
         * @ignore Exclude from docs
         * @param value  Chart
         */
        set: function (value) {
            this._chart.set(value, null);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Toggles visibility of an element, based on its current position and
     * min/max position settings.
     *
     * E.g. labels based on `minLabelPosition` and `maxLabelPosition`.
     *
     * @ignore Exclude from docs
     * @param sprite       An element to toggle
     * @param position     Elements current position
     * @param minPosition  Min position setting
     * @param maxPosition  Max position setting
     */
    AxisRenderer.prototype.toggleVisibility = function (sprite, position, minPosition, maxPosition) {
        var axis = this.axis;
        var dataItem = sprite.dataItem;
        if (dataItem && dataItem instanceof Axis_AxisDataItem) {
            if (isNumber(dataItem.minPosition)) {
                minPosition = dataItem.minPosition;
            }
            if (isNumber(dataItem.maxPosition)) {
                maxPosition = dataItem.maxPosition;
            }
        }
        var updatedStart = axis.start + (axis.end - axis.start) * (minPosition - 0.0001);
        var updatedEnd = axis.start + (axis.end - axis.start) * (maxPosition + 0.0001);
        if (!sprite.disabled) {
            if (position < updatedStart || position > updatedEnd) {
                sprite.__disabled = true;
            }
            else {
                sprite.__disabled = false;
            }
        }
    };
    /**
     * Creates visual elements for and axis break.
     *
     * @ignore Exclude from docs
     * @param axisBreak Axis break
     */
    AxisRenderer.prototype.createBreakSprites = function (axisBreak) {
        // This is a placeholder method for extending classes to override.
    };
    Object.defineProperty(AxisRenderer.prototype, "axisFills", {
        /**
         * A list of Axis' Fill elements.
         *
         * Those are fill elements that cover the space between every second set
         * of grid lines, and can be configured to create striped charts.
         *
         * Please note that these are disabled by default. To enable them, set
         * template to true.
         *
         * ```TypeScript
         * categoryAxis.renderer.axisFills.template.disabled = false;
         * ```
         * ```JavaScript
         * categoryAxis.renderer.axisFills.template.disabled = false;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "xAxes": [{
         *     // ...
         *     "renderer": {
         *       "axisFills": {
         *         "disabled": false
         *       }
         *     }
         *   }]
         * }
         * ```
         *
         * @see {@link https://www.amcharts.com/docs/v4/tutorials/alternated-axis-fills/} this tutorial for more info.
         * @return Fill elements
         */
        get: function () {
            if (!this._axisFills) {
                var fill = this.createFill(this.axis);
                this._axisFills = new List_ListTemplate(fill);
                fill.applyOnClones = true;
                fill.events.on("enabled", this.invalidateAxisItems, this, false);
                this._disposers.push(new List_ListDisposer(this._axisFills));
                this._disposers.push(this._axisFills.template);
            }
            return this._axisFills;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new fill element, suitable for this Axis Renderer type.
     *
     * @return Fill element
     */
    AxisRenderer.prototype.createFill = function (axis) {
        return new AxisFill_AxisFill(axis);
    };
    Object.defineProperty(AxisRenderer.prototype, "grid", {
        /**
         * A list of Axis' Grid elements.
         *
         * @return Grid elements
         */
        get: function () {
            if (!this._grid) {
                var grid = this.createGrid();
                this._grid = new List_ListTemplate(grid);
                grid.applyOnClones = true;
                grid.events.on("enabled", this.invalidateAxisItems, this, false);
                this._disposers.push(new List_ListDisposer(this._grid));
                this._disposers.push(this._grid.template);
            }
            return this._grid;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new grid element, suitable for this Axis Renderer type.
     *
     * @return Grid element
     */
    AxisRenderer.prototype.createGrid = function () {
        return new Grid_Grid();
    };
    Object.defineProperty(AxisRenderer.prototype, "ticks", {
        /**
         * A list of Axis' Tick elements.
         *
         * Please note that these are disabled by default. To enable them, set
         * template to true.
         *
         * ```TypeScript
         * categoryAxis.renderer.ticks.template.disabled = false;
         * ```
         * ```JavaScript
         * categoryAxis.renderer.ticks.template.disabled = false;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "xAxes": [{
         *     // ...
         *     "renderer": {
         *       "ticks": {
         *         "disabled": false
         *       }
         *     }
         *   }]
         * }
         * ```
         *
         * @return Tick elements
         */
        get: function () {
            if (!this._ticks) {
                var tick = this.createTick();
                tick.applyOnClones = true;
                tick.isMeasured = false;
                tick.events.on("enabled", this.invalidateAxisItems, this, false);
                this._ticks = new List_ListTemplate(tick);
                this._disposers.push(new List_ListDisposer(this._ticks));
                this._disposers.push(this._ticks.template);
            }
            return this._ticks;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new tick element, suitable for this Axis Renderer type.
     *
     * @return Tick element
     */
    AxisRenderer.prototype.createTick = function () {
        return new AxisTick_AxisTick();
    };
    Object.defineProperty(AxisRenderer.prototype, "labels", {
        /**
         * A list of Axis' Label elements.
         *
         * @return Label elements
         */
        get: function () {
            if (!this._labels) {
                var label = this.createLabel();
                this._labels = new List_ListTemplate(label);
                label.applyOnClones = true;
                label.events.on("enabled", this.invalidateAxisItems, this, false);
                this._disposers.push(new List_ListDisposer(this._labels));
                this._disposers.push(this._labels.template);
            }
            return this._labels;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new label element, suitable for this Axis Renderer type.
     *
     * @return Label element
     */
    AxisRenderer.prototype.createLabel = function () {
        return new AxisLabel_AxisLabel();
    };
    Object.defineProperty(AxisRenderer.prototype, "inside", {
        /**
         * @return Labels inside?
         */
        get: function () {
            return this.getPropertyValue("inside");
        },
        /**
         * Indicates whether Axis' labels and ticks should be drawn inside Plot area.
         *
         * Does not work with all renderers, like AxisRendererRadial.
         *
         * @param value  Labels inside?
         */
        set: function (value) {
            if (this.setPropertyValue("inside", value)) {
                if (this.axis) {
                    this.axis.invalidate();
                }
            }
            if (value) {
                this.width = 0;
                this.height = 0;
            }
            else {
                this.width = undefined;
                this.height = undefined;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRenderer.prototype, "opposite", {
        /**
         * @return Draw axis on opposite side?
         */
        get: function () {
            return this.getPropertyValue("opposite");
        },
        /**
         * Indicates whether Axis should be drawn on the opposite side of the plot
         * area than it would normally be drawn based on chart's settings.
         *
         * Does not work with all renderers, like [[AxisRendererRadial]] and
         * [[AxisRenderer Circular].
         *
         * @param value  Draw axis on opposite side?
         */
        set: function (value) {
            this.setPropertyValue("opposite", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRenderer.prototype, "fullWidthTooltip", {
        /**
         * @return Full width tooltip?
         */
        get: function () {
            return this.getPropertyValue("fullWidthTooltip");
        },
        /**
         * Indicates if Axis tooltip should take the whole width of the axis cell.
         * (between two grid lines)
         *
         * NOTE: this setting is ignored on circular axis types.
         *
         * @param value Full width tooltip?
         */
        set: function (value) {
            this.setPropertyValue("fullWidthTooltip", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRenderer.prototype, "tooltipLocation", {
        /**
         * @return Tooltip location
         */
        get: function () {
            return this.getPropertyValue("tooltipLocation");
        },
        /**
         * Location within axis cell to show tooltip on. (0-1)
         *
         * 0 - show at the start
         * 0.5 - show right in the middle
         * 1 - show at the end
         *
         * @param value Tooltip location
         */
        set: function (value) {
            this.setPropertyValue("tooltipLocation", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRenderer.prototype, "tooltipLocation2", {
        /**
         * @return Tooltip location
         */
        get: function () {
            return this.getPropertyValue("tooltipLocation2");
        },
        /**
         * Location within secondary axis cell to show tooltip on. (0-1)
         *
         * 0 - show at the start
         * 0.5 - show right in the middle
         * 1 - show at the end
         *
         * @param value Tooltip location
         */
        set: function (value) {
            this.setPropertyValue("tooltipLocation2", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRenderer.prototype, "cellStartLocation", {
        /**
         * @return Cell start (0-1)
         */
        get: function () {
            return this.getPropertyValue("cellStartLocation");
        },
        /**
         * Location for the cell start.
         *
         * Normally a "cell" is the whole available width in a category.
         *
         * If there are several clustered column-like series available, the whole
         * space is divided between each clustered column, or column stacks.
         *
         * `cellStartLocation` identifies where, within available space, the actual
         * cell starts.
         *
         * This, together with column series' `width` will affect actual width of
         * columns, and thus gaps between them.
         *
         * This will affect category-like axes only, like [[DateAxis]], or
         * [[CategoryAxis]].
         *
         * This is used to limit a space occupied by series like column.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/} for more info.
         * @param value Cell start (0-1)
         */
        set: function (value) {
            if (this.setPropertyValue("cellStartLocation", value)) {
                if (this.axis) {
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRenderer.prototype, "cellEndLocation", {
        /**
         * @return Cell end (0-1)
         */
        get: function () {
            return this.getPropertyValue("cellEndLocation");
        },
        /**
         * Location for the cell end.
         *
         * Normally a "cell" is the whole available width in a category.
         *
         * If there are several clustered column-like series available, the whole
         * space is divided between each clustered column, or column stacks.
         *
         * `cellEndLocation` identifies where, within available space, the actual
         * cell ends.
         *
         * This, together with column series' `width` will affect actual width of
         * columns, and thus gaps between them.
         *
         * This will affect category-like axes only, like [[DateAxis]], or
         * [[CategoryAxis]].
         *
         * This is used to limit a space occupied by series like column.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/} for more info.
         * @param value Cell end (0-1)
         */
        set: function (value) {
            if (this.setPropertyValue("cellEndLocation", value)) {
                if (this.axis) {
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRenderer.prototype, "inversed", {
        /**
         * @return Flip axis?
         */
        get: function () {
            return this.getPropertyValue("inversed");
        },
        /**
         * Indicates if the scale of the axis should be flipped.
         *
         * @param value Flip axis?
         */
        set: function (value) {
            this.setPropertyValue("inversed", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRenderer.prototype, "minLabelPosition", {
        /**
         * @return Min label position (0-1)
         */
        get: function () {
            return this.getPropertyValue("minLabelPosition");
        },
        /**
         * Minimum position along the Axis, for labels.
         *
         * Labels, which have their position closer to the start of the Axis, will be
         * automatically hidden.
         *
         * E.g., setting this to 0.05 (5% of total axis length) would hide labels,
         * that would otherwise be drawn very near start of the Axis.
         *
         * This is especially usefull with `inside = true`, or if the chart hasn't
         * got any extra margins.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/} for more info.
         * @param value  Min label position (0-1)
         */
        set: function (value) {
            this.setPropertyValue("minLabelPosition", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRenderer.prototype, "maxLabelPosition", {
        /**
         * @return Max label position (0-1)
         */
        get: function () {
            return this.getPropertyValue("maxLabelPosition");
        },
        /**
         * Maximum position along the Axis, for labels.
         *
         * Labels, which have their position closer to the and of the Axis, will be
         * automatically hidden.
         *
         * E.g., setting this to 0.95 (95% of total axis length) would hide labels,
         * that would otherwise be drawn very near end of the Axis.
         *
         * This is especially usefull with `inside = true`, or if the chart hasn't
         * got any extra margins.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/} for more info.
         * @param value  Max label position (0-1)
         */
        set: function (value) {
            this.setPropertyValue("maxLabelPosition", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all settings and related items from another object of the same
     * type.
     *
     * @param source  Source object
     */
    AxisRenderer.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.grid.template.copyFrom(source.grid.template);
        this.ticks.template.copyFrom(source.ticks.template);
        this.labels.template.copyFrom(source.labels.template);
        this.axisFills.template.copyFrom(source.axisFills.template);
        this.line.copyFrom(source.line);
        this.baseGrid.copyFrom(source.baseGrid);
    };
    /**
     * @ignore
     */
    AxisRenderer.prototype.toAxisPosition = function (value) {
        return value;
    };
    /**
     * Sets `visibility` property:
     *
     * * `true` - visible
     * * `false` - hidden
     *
     * @param value  true - visible, false - hidden
     * @return Current visibility
     */
    AxisRenderer.prototype.setVisibility = function (value) {
        _super.prototype.setVisibility.call(this, value);
        this.bulletsContainer.visible = value;
    };
    return AxisRenderer;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisRenderer"] = AxisRenderer_AxisRenderer;
//# sourceMappingURL=AxisRenderer.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisBullet.js
/**
 * Axis Bullet module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to draw a positioned bullet (element) on an Axis.
 *
 * ```TypeScript
 * let range = dateAxis.axisRanges.create();
 * range.date = new Date(2018, 0, 5);
 *
 * let flag = new am4plugins_bullets.FlagBullet();
 * flag.label.text = "Hello";
 *
 * range.bullet = flag;
 * ```
 * ```JavaScript
 * var range = dateAxis.axisRanges.create();
 * range.date = new Date(2018, 0, 5);
 *
 * var flag = new am4plugins_bullets.FlagBullet();
 * flag.label.text = "Hello";
 *
 * range.bullet = flag;
 * ```
 * ```JSON
 * {
 *   // ...
 *   "xAxes": [{
 *     "type": "DateAxis",
 *     // ...
 *     "axisRanges": [{
 *       "date": new Date(2018, 0, 5),
 *       "bullet: {
 *         "type": "FlagBullet",
 *         "label": {
 *           "text": "Hello"
 *         }
 *       }
 *     }]
 *   }]
 * }
 * ```
 *
 * @since 4.5.9
 * @see {@link IAxisBulletEvents} for a list of available events
 * @see {@link IAxisBulletAdapters} for a list of available Adapters
 * @important
 */
var AxisBullet_AxisBullet = /** @class */ (function (_super) {
    __extends(AxisBullet, _super);
    function AxisBullet() {
        var _this = _super.call(this) || this;
        _this.className = "AxisBullet";
        _this.location = 0.5;
        _this.isMeasured = false;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(AxisBullet.prototype, "location", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("location");
        },
        /**
         * Relative position within cell/range.
         *
         * Value range is from from `0` (beginning) to `1` (end).
         *
         * NOTE: `location` is relative to the parent axis range's scope, i.e.
         * between its `date` and `endDate` for [[DateAxis]], or `value`/`endValue`
         * ([[ValueAxis]]), or `category`/`endCategory` ([[categoryAxis]]).
         *
         * ```TypeScript
         * let range = dateAxis.axisRanges.create();
         * range.date = new Date(2018, 0, 5);
         * range.endDate = new Date(2018, 0, 6);
         *
         * let bullet = new am4charts.AxisBullet();
         * bullet.location = 1;
         *
         * let flag = bullet.createChild(am4plugins_bullets.FlagBullet);
         * flag.label.text = "Hello";
         * ```
         * ```JavaScript
         * var range = dateAxis.axisRanges.create();
         * range.date = new Date(2018, 0, 5);
         * range.endDate = new Date(2018, 0, 6);
         *
         * var bullet = new am4charts.AxisBullet();
         * bullet.location = 1;
         *
         * var flag = bullet.createChild(am4plugins_bullets.FlagBullet);
         * flag.label.text = "Hello";
         * ```
         * ```JSON
         * {
         *   // ...
         *   "xAxes": [{
         *     "type": "DateAxis",
         *     // ...
         *     "axisRanges": [{
         *       "date": new Date(2018, 0, 5),
         *       "endDate": new Date(2018, 0, 6),
         *       "bullet: {
         *         "type": "AxisBullet",
         *         "location": 1,
         *         "children": [{
         *           "type": "FlagBullet",
         *           "label": {
         *             "text": "Hello"
         *           }
         *         }]
         *       }
         *     }]
         *   }]
         * }
         * ```
         *
         * @default 0.5
         * @param  value  Location (0-1)
         */
        set: function (value) {
            this.setPropertyValue("location", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    AxisBullet.prototype.setDisabled = function (value) {
        var changed = _super.prototype.setDisabled.call(this, value);
        if (this.axis) {
            this.axis.invalidateDataItems();
        }
        return changed;
    };
    return AxisBullet;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisBullet"] = AxisBullet_AxisBullet;
//# sourceMappingURL=AxisBullet.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererY.js
/**
 * Module, defining Axis Renderer for vertical axes.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */











/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A renderer for vertical axis.
 *
 * @see {@link IAxisRendererYEvents} for a list of available events
 * @see {@link IAxisRendererYAdapters} for a list of available Adapters
 */
var AxisRendererY_AxisRendererY = /** @class */ (function (_super) {
    __extends(AxisRendererY, _super);
    /**
     * Constructor.
     *
     * @param axis Related axis
     */
    function AxisRendererY() {
        var _this = _super.call(this) || this;
        _this.className = "AxisRendererY";
        _this.minGridDistance = 40;
        _this.opposite = false;
        _this.height = Percent_percent(100);
        _this.labels.template.verticalCenter = "middle";
        _this.applyTheme();
        return _this;
    }
    /**
    * @ignore
    */
    AxisRendererY.prototype.setAxis = function (axis) {
        _super.prototype.setAxis.call(this, axis);
        axis.layout = "horizontal";
    };
    /**
     * @ignore
     */
    AxisRendererY.prototype.updateGridContainer = function () {
        var axis = this.axis;
        if (axis) {
            var gridContainer = this.gridContainer;
            gridContainer.y = axis.pixelY;
            gridContainer.height = axis.axisLength;
        }
    };
    /**
     * @ignore
     */
    AxisRendererY.prototype.toAxisPosition = function (value) {
        var axis = this.axis;
        if (axis) {
            var inversedPosition = 1 - value;
            var relativePositionSprite = axis.relativePositionSprite;
            var y = axis.pixelY;
            if (relativePositionSprite) {
                y = spritePointToSprite({ x: 0, y: this.pixelY }, this.parent, relativePositionSprite).y;
            }
            else {
                relativePositionSprite = axis.parent;
            }
            if (relativePositionSprite) {
                var relativeY = y / relativePositionSprite.innerHeight;
                var relativeHeight = axis.axisLength / relativePositionSprite.innerHeight;
                return 1 - (inversedPosition - relativeY) / relativeHeight;
            }
        }
        return value;
    };
    /**
     * Called when rendered is attached to an Axis, as well as a property of
     * Axis that might affect the appearance is updated.
     *
     * E.g. `axis.opposite`, `axis.inside`, etc.
     *
     * This method is called **before** draw, so that any related setting
     * changed in this method can be changed.
     *
     * @todo Description (review)
     * @ignore Exclude from docs
     */
    AxisRendererY.prototype.processRenderer = function () {
        _super.prototype.processRenderer.call(this);
        var axis = this.axis;
        if (axis) {
            var title = axis.title;
            title.valign = "middle";
            if (!(axis.height instanceof Percent)) {
                axis.height = Percent_percent(100);
            }
            if (this.opposite) {
                title.rotation = 90;
                this.line.toBack();
                title.toFront();
            }
            else {
                title.rotation = -90;
                title.toBack();
                this.line.toFront();
            }
        }
    };
    /**
     * Updates some of the Axis tooltip's visual properties, related to
     * rendering of the Axis.
     *
     * @todo Description (review)
     * @ignore Exclude from docs
     */
    AxisRendererY.prototype.updateTooltip = function () {
        var axis = this.axis;
        if (axis) {
            var bigNum = 2000;
            var bbx = 0;
            var bby = 0;
            var bbw = bigNum;
            var bbh = this.axisLength;
            // right
            if (this.opposite) {
                if (this.inside) {
                    bbx = -bigNum;
                    bbw = bigNum;
                }
            }
            // left
            else {
                if (!this.inside) {
                    bbx = -bigNum;
                    bbw = bigNum;
                }
            }
            this.axis.updateTooltip("horizontal", { x: bbx, y: bby, width: bbw, height: bbh });
        }
    };
    Object.defineProperty(AxisRendererY.prototype, "axisLength", {
        /**
         * Returns actual length of the Axis, in pixels.
         *
         * @return Length (px)
         */
        get: function () {
            var axis = this.axis;
            return (axis.measuredHeight - axis.pixelPaddingTop - axis.pixelPaddingBottom) || 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts relative position on axis to point coordinates.
     *
     * @param position  Position (0-1)
     * @param position2  Position (0-1) Position on the second axis
     * @return Point
     */
    AxisRendererY.prototype.positionToPoint = function (position, position2) {
        return { x: 0, y: this.positionToCoordinate(position) };
    };
    /**
     * Converts a point at specific coordinates to a relative position (0-1)
     * on the axis.
     *
     * @param point  Point
     * @return Position (0-1)
     */
    AxisRendererY.prototype.pointToPosition = function (point) {
        return this.coordinateToPosition(point.y, point.x);
    };
    /**
     * Converts a coordinate in pixels to a relative position. (0-1)
     *
     * @param coordinate  Coordinate (px)
     * @param coordinate2  Coordinate of a second axis, only needed for complex axes systems, like timeline (px)
     * @return Position (0-1)
     */
    AxisRendererY.prototype.coordinateToPosition = function (coordinate, coordinate2) {
        var position;
        var axis = this.axis;
        var axisFullLength = axis.axisFullLength;
        if (axis.renderer.inversed) {
            position = (1 - axis.start) - coordinate / axisFullLength;
        }
        else {
            position = coordinate / axisFullLength + (1 - axis.end);
        }
        return Math_round(position, 5);
    };
    /**
     * [getPositionRangePath description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param startPosition  Starting position
     * @param endPosition    End position
     * @return SVG path
     */
    AxisRendererY.prototype.getPositionRangePath = function (startPosition, endPosition) {
        var y1 = fitToRange(this.positionToCoordinate(startPosition), 0, this.axisLength);
        var y2 = fitToRange(this.positionToCoordinate(endPosition), 0, this.axisLength);
        var h = Math.abs(y2 - y1);
        var w = this.getWidth();
        var y = Math.min(y1, y2);
        var x = 0;
        return rectToPath({
            x: x,
            y: y,
            width: w,
            height: h
        }, true);
    };
    /**
     * Updates and positions a grid element.
     *
     * @ignore Exclude from docs
     * @param grid         Grid element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererY.prototype.updateGridElement = function (grid, position, endPosition) {
        position = position + (endPosition - position) * grid.location;
        var point = this.positionToPoint(position);
        //	point.y = $utils.spritePointToSprite({ x: 0, y: point.y }, this, this.gridContainer).y;
        grid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: this.getWidth(), y: 0 });
        this.positionItem(grid, point);
        this.toggleVisibility(grid, position, 0, 1);
    };
    /**
     * Updates and positions a tick element.
     *
     * @ignore Exclude from docs
     * @param tick         Tick element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererY.prototype.updateTickElement = function (tick, position, endPosition) {
        position = position + (endPosition - position) * tick.location;
        var point = this.positionToPoint(position);
        var tickLength = tick.length;
        try {
            used(this.axis.title.measuredWidth);
        }
        catch (_a) {
            // void
        }
        point.x = spritePointToSprite({ x: this.line.pixelX, y: 0 }, this.line.parent, this.gridContainer).x;
        if (!this.opposite) {
            tickLength *= (tick.inside ? 1 : -1);
        }
        else {
            tickLength *= (tick.inside ? -1 : 1);
        }
        tick.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: tickLength, y: 0 });
        this.positionItem(tick, point);
        this.toggleVisibility(tick, position, 0, 1);
    };
    /**
     * Updates and positions the axis line element.
     *
     * @ignore Exclude from docs
     */
    AxisRendererY.prototype.updateAxisLine = function () {
        this.line.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: this.axisLength });
    };
    /**
     * Updates and positions the base grid element.
     *
     * @ignore Exclude from docs
     */
    AxisRendererY.prototype.updateBaseGridElement = function () {
        _super.prototype.updateBaseGridElement.call(this);
        var axis = this.axis;
        var w = this.getWidth();
        var h = this.axisLength;
        var y = axis.basePoint.y;
        var baseGrid = this.baseGrid;
        if (y < -0.2 || y > h + 0.2) {
            baseGrid.hide(0);
        }
        else {
            var x = spritePointToSprite({ x: 0, y: 0 }, this.gridContainer, baseGrid.parent).x;
            baseGrid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: w, y: 0 });
            baseGrid.moveTo({ x: x, y: y });
            baseGrid.show(0);
        }
    };
    /**
     * Updates and positions a label element.
     *
     * @ignore Exclude from docs
     * @param label        Label element
     * @param position     Starting position
     * @param endPosition  Ending position
     */
    AxisRendererY.prototype.updateLabelElement = function (label, position, endPosition, location) {
        if (!hasValue(location)) {
            location = label.location;
        }
        position = position + (endPosition - position) * location;
        label.isMeasured = !label.inside;
        var point = this.positionToPoint(position);
        var horizontalCenter;
        var deltaX = 0;
        var maxWidth = this.gridContainer.maxWidth;
        if (this.opposite) {
            if (label.inside) {
                horizontalCenter = "right";
                if (label.align == "left") {
                    deltaX = -maxWidth;
                    horizontalCenter = "left";
                }
                if (label.align == "center") {
                    deltaX = -maxWidth / 2;
                    horizontalCenter = "middle";
                }
            }
            else {
                horizontalCenter = "left";
            }
            point.x = 0 + deltaX;
        }
        else {
            if (label.inside) {
                horizontalCenter = "left";
                if (label.align == "right") {
                    deltaX = maxWidth;
                    horizontalCenter = "right";
                }
                if (label.align == "center") {
                    deltaX = maxWidth / 2;
                    horizontalCenter = "middle";
                }
            }
            else {
                horizontalCenter = "right";
            }
            point.x = this.measuredWidth + deltaX;
        }
        if (label.rotation == 0) {
            // Apply fuzzy logic to verticalCenter only if labels are not rotated
            label.horizontalCenter = horizontalCenter;
        }
        this.positionItem(label, point);
        this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);
    };
    /**
     * Updates and positions an axis break element.
     *
     * @ignore Exclude from docs
     * @param axisBreak Break element
     */
    AxisRendererY.prototype.updateBreakElement = function (axisBreak) {
        _super.prototype.updateBreakElement.call(this, axisBreak);
        var startLine = axisBreak.startLine;
        var endLine = axisBreak.endLine;
        var fillShape = axisBreak.fillShape;
        var startPoint = axisBreak.startPoint;
        var endPoint = axisBreak.endPoint;
        var x1 = axisBreak.pixelMarginLeft;
        var x2 = this.getWidth() - axisBreak.pixelMarginLeft - axisBreak.pixelMarginRight;
        startPoint.y = fitToRange(startPoint.y, -1, this.axisLength + 1);
        endPoint.y = fitToRange(endPoint.y, -1, this.axisLength + 1);
        if (startPoint.y == endPoint.y && (startPoint.y < 0 || startPoint.y > this.axisLength)) {
            axisBreak.fillShape.__disabled = true;
        }
        else {
            axisBreak.fillShape.__disabled = false;
        }
        var w = Math.abs(x2 - x1);
        startLine.x = x1;
        startLine.height = 0;
        startLine.width = w;
        endLine.x = x1;
        endLine.height = 0;
        endLine.width = w;
        fillShape.width = w;
        fillShape.height = Math.abs(endPoint.y - startPoint.y);
        fillShape.x = x1;
        fillShape.y = endPoint.y;
    };
    /**
     * Creates visual elements for and axis break.
     *
     * @ignore Exclude from docs
     * @param axisBreak Axis break
     */
    AxisRendererY.prototype.createBreakSprites = function (axisBreak) {
        axisBreak.startLine = new WavedLine_WavedLine();
        axisBreak.endLine = new WavedLine_WavedLine();
        var wavedRectangle = new WavedRectangle_WavedRectangle();
        wavedRectangle.setWavedSides(true, false, true, false);
        axisBreak.fillShape = wavedRectangle;
    };
    /**
     * Converts a position on the axis to a coordinate in pixels.
     *
     * @ignore Exclude from docs
     * @param position  Position (0-1)
     * @return Coordinate (px)
     */
    AxisRendererY.prototype.positionToCoordinate = function (position) {
        var coordinate;
        var axis = this.axis;
        var axisFullLength = axis.axisFullLength;
        if (!axis.renderer.inversed) {
            coordinate = (axis.end - position) * axisFullLength;
        }
        else {
            coordinate = (position - axis.start) * axisFullLength;
        }
        return Math_round(coordinate, 1);
    };
    /**
     * Updates and positions axis bullets.
     *
     * @ignore Exclude from docs
     * @param bullet       AxisBullet element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererY.prototype.updateBullet = function (bullet, position, endPosition) {
        var location = 0.5;
        if (bullet instanceof AxisBullet_AxisBullet) {
            location = bullet.location;
        }
        position = position + (endPosition - position) * location;
        var point = this.positionToPoint(position);
        point.x = spritePointToSprite({ x: this.line.pixelX, y: 0 }, this.line.parent, this.gridContainer).x;
        this.positionItem(bullet, point);
        this.toggleVisibility(bullet, position, 0, 1);
    };
    return AxisRendererY;
}(AxisRenderer_AxisRenderer));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisRendererY"] = AxisRendererY_AxisRendererY;
/**
 * Add default responsive rules
 */
/**
 * Put labels inside plot area.
 * Disable first and last labels.
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.widthS,
    state: function (target, stateId) {
        if (target instanceof AxisRendererY_AxisRendererY) {
            var state = target.states.create(stateId);
            state.properties.inside = true;
            state.properties.maxLabelPosition = 0.9;
            state.properties.minLabelPosition = 0.1;
            return state;
        }
        return null;
    }
});
/**
 * Disable labels altogather on very small charts
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.widthXS,
    state: function (target, stateId) {
        if (target instanceof AxisRendererY_AxisRendererY) {
            var state = target.states.create(stateId);
            state.properties.disabled = true;
            return state;
        }
        return null;
    }
});
//# sourceMappingURL=AxisRendererY.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/ValueAxisBreak.js
/**
 * A module which defines functionality related to Value Axis Break.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Base class to define "breaks" on value axis.
 *
 * A "break" can be used to "cut out" specific ranges of the axis scale, e.g.
 * when comparing columns with relatively similar values, it would make sense
 * to cut out their mid section, so that their tip differences are more
 * prominent.
 *
 * @see {@link IValueAxisBreakEvents} for a list of available events
 * @see {@link IValueAxisBreakAdapters} for a list of available Adapters
 * @important
 */
var ValueAxisBreak_ValueAxisBreak = /** @class */ (function (_super) {
    __extends(ValueAxisBreak, _super);
    /**
     * Constructor
     */
    function ValueAxisBreak() {
        var _this = _super.call(this) || this;
        _this.className = "ValueAxisBreak";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(ValueAxisBreak.prototype, "startPosition", {
        /**
         * Pixel position of the break's start.
         *
         * @return Position (px)
         * @readonly
         */
        get: function () {
            if (this.axis) {
                return this.axis.valueToPosition(this.adjustedStartValue);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxisBreak.prototype, "endPosition", {
        /**
         * Pixel position of the break's end.
         *
         * @return Position (px)
         * @readonly
         */
        get: function () {
            if (this.axis) {
                return this.axis.valueToPosition(this.adjustedEndValue);
            }
        },
        enumerable: true,
        configurable: true
    });
    return ValueAxisBreak;
}(AxisBreak_AxisBreak));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ValueAxisBreak"] = ValueAxisBreak_ValueAxisBreak;
//# sourceMappingURL=ValueAxisBreak.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/ValueAxis.js
/**
 * Value Axis module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */










/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[ValueAxis]].
 *
 * @see {@link DataItem}
 */
var ValueAxis_ValueAxisDataItem = /** @class */ (function (_super) {
    __extends(ValueAxisDataItem, _super);
    /**
     * Constructor
     */
    function ValueAxisDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "ValueAxisDataItem";
        _this.values.value = {};
        _this.values.endValue = {};
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(ValueAxisDataItem.prototype, "value", {
        /**
         * @return Value
         */
        get: function () {
            return this.values["value"].value;
        },
        /**
         * A data point's numeric value.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("value", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxisDataItem.prototype, "endValue", {
        /**
         * @return Value
         */
        get: function () {
            return this.values["endValue"].value;
        },
        /**
         * Data point's numeric end value.
         *
         * @param value  End value
         */
        set: function (value) {
            this.setValue("endValue", value);
        },
        enumerable: true,
        configurable: true
    });
    return ValueAxisDataItem;
}(Axis_AxisDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to create a value axis for the chart.
 *
 * ```TypeScript
 * // Create the axis
 * let valueAxis = chart.yAxes.push(new am4charts.ValueAxis());
 *
 * // Set settings
 * valueAxis.title.text = "Monthly Sales";
 * ```
 * ```JavaScript
 * // Create the axis
 * var valueAxis = chart.yAxes.push(new am4charts.ValueAxis());
 *
 * // Set settings
 * valueAxis.title.text = "Monthly Sales";
 * ```
 * ```JSON
 * "yAxes": [{
 *   "type": "ValueAxis",
 *   "title": {
 *     "text": "Monthly Sales"
 *   }
 * }]
 * ```
 *
 * @see {@link IValueAxisEvents} for a list of available Events
 * @see {@link IValueAxisAdapters} for a list of available Adapters
 * @important
 */
var ValueAxis_ValueAxis = /** @class */ (function (_super) {
    __extends(ValueAxis, _super);
    /**
     * Constructor
     */
    function ValueAxis() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * [_stepDecimalPlaces description]
         *
         * @todo Description
         */
        _this._stepDecimalPlaces = 0;
        _this._prevStepDecimalPlaces = 0;
        _this._adjustLabelPrecision = true;
        /**
         * Base value for the axis.
         */
        _this._baseValue = 0;
        /**
         * Adjusted start in case we have breaks.
         *
         * @todo Description
         */
        _this._adjustedStart = 0;
        /**
         * Adjusted end in case we have breaks.
         *
         * @todo Description
         */
        _this._adjustedEnd = 1;
        _this._extremesChanged = false;
        _this._deltaMinMax = 1;
        /**
         * As calculating totals is expensive operation and not often needed, we
         * don't do it by default.
         *
         * In case you use `totalPercent` or `total` in your charts, this must be set
         * to `true`.
         *
         * @default false
         * @see {@link https://www.amcharts.com/docs/v4/chart-types/xy-chart/#100_stacks} For using `calculateTotals` for 100% stacked series.
         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/#Placeholders_for_numeric_values} For using `calculateTotals` in labels.
         */
        _this.calculateTotals = false;
        _this.className = "ValueAxis";
        // Set field name
        _this.axisFieldName = "value";
        // Set defaults
        _this.setPropertyValue("maxZoomFactor", 1000);
        _this.setPropertyValue("extraMin", 0);
        _this.setPropertyValue("extraMax", 0);
        _this.setPropertyValue("strictMinMax", false);
        _this.setPropertyValue("maxPrecision", Number.MAX_VALUE);
        _this.setPropertyValue("adjustLabelPrecision", true);
        _this.setPropertyValue("extraTooltipPrecision", 0);
        _this.keepSelection = false;
        _this.includeRangesInMinMax = false;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Holds reference to a function that accepts a DataItem as parameter.
     *
     * It can either return a fill opacity for a fill, or manipulate data item
     * directly, to create various highlighting scenarios.
     */
    ValueAxis.prototype.fillRule = function (dataItem) {
        var value = dataItem.value;
        var axis = dataItem.component;
        if (!dataItem.axisFill.disabled) {
            // rounding in left to solve floating point number
            if (Math_round(value / axis.step / 2, 5) == Math.round(value / axis.step / 2)) {
                dataItem.axisFill.__disabled = true;
            }
            else {
                dataItem.axisFill.__disabled = false;
            }
        }
    };
    /**
     * Returns a new/empty [[DataItem]] of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    ValueAxis.prototype.createDataItem = function () {
        return new ValueAxis_ValueAxisDataItem();
    };
    /**
     * Returns a new/empty [[AxisBreak]] of the appropriate type.
     *
     * @return Axis break
     */
    ValueAxis.prototype.createAxisBreak = function () {
        return new ValueAxisBreak_ValueAxisBreak();
    };
    /**
     * [dataChangeUpdate description]
     *
     * This is a placeholder to override for extending classes.
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    ValueAxis.prototype.dataChangeUpdate = function () {
        this.clearCache();
        if (!this.keepSelection) {
            if (this._start != 0 || this._end != 1) {
                this._start = 0;
                this._end = 1;
                this.dispatchImmediately("startendchanged");
            }
        }
        else {
            if (this._start != 0) {
                this.dispatchImmediately("startchanged");
            }
            if (this._end != 1) {
                this.dispatchImmediately("endchanged");
            }
            if (this._start != 0 || this._end != 1) {
                this.dispatchImmediately("startendchanged");
            }
        }
        this._maxZoomed = this._maxDefined;
        this._minZoomed = this._minDefined;
        this._maxAdjusted = this._maxDefined;
        this._minAdjusted = this._minDefined;
    };
    /**
     * Processes data items of the related Series.
     *
     * @ignore Exclude from docs
     */
    ValueAxis.prototype.processSeriesDataItems = function () {
        // @todo: add some boolean (maybe autodedect) if we need these calculations or not. this place uses a lot of cpu
        if (this.calculateTotals) {
            var series = this.series.getIndex(0);
            var startIndex = series.startIndex;
            if (series.dataItems.length > 0) {
                if (startIndex > 0) {
                    startIndex--;
                }
                var endIndex = series.endIndex;
                if (endIndex < series.dataItems.length) {
                    endIndex++;
                }
                var _loop_1 = function (i) {
                    // This has to be `var` in order to avoid garbage collection
                    var total = {};
                    var sum = {};
                    this_1.series.each(function (series) {
                        if (!series.excludeFromTotal) {
                            var dataItem_1 = series.dataItems.getIndex(i);
                            if (dataItem_1) {
                                Object_each(dataItem_1.values, function (key) {
                                    var value = dataItem_1.values[key].workingValue; // can not use getWorkingValue here!
                                    if (isNumber(value)) {
                                        if (!isNumber(total[key])) {
                                            total[key] = Math.abs(value);
                                        }
                                        else {
                                            total[key] += Math.abs(value);
                                        }
                                        if (!isNumber(sum[key])) {
                                            sum[key] = value;
                                        }
                                        else {
                                            sum[key] += value;
                                        }
                                    }
                                });
                            }
                        }
                    });
                    this_1.series.each(function (series) {
                        if (!series.excludeFromTotal) {
                            var dataItem_2 = series.dataItems.getIndex(i);
                            if (dataItem_2) {
                                Object_each(dataItem_2.values, function (key) {
                                    var value = dataItem_2.values[key].workingValue; // can not use getWorkingValue here!
                                    if (isNumber(value)) {
                                        dataItem_2.setCalculatedValue(key, total[key], "total");
                                        dataItem_2.setCalculatedValue(key, 100 * value / total[key], "totalPercent");
                                        dataItem_2.setCalculatedValue(key, sum[key], "sum");
                                    }
                                });
                            }
                        }
                    });
                };
                var this_1 = this;
                // This has to be `var` in order to avoid garbage collection
                for (var i = startIndex; i < endIndex; ++i) {
                    _loop_1(i);
                }
            }
        }
    };
    /**
     * Validates the whole axis. Causes it to redraw.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     */
    ValueAxis.prototype.validate = function () {
        if (this.axisLength <= 0) {
            return;
        }
        _super.prototype.validate.call(this);
        this.getMinMax();
        this.fixAxisBreaks();
        this.calculateZoom();
        this.validateAxisElements();
        this.validateAxisRanges();
        this.validateBreaks();
        this.hideUnusedDataItems();
        this.renderer.invalidateLayout();
        // hide too close
        //this.hideTooCloseDataItems();
    };
    /**
     * Calculates all positions, related to axis as per current zoom.
     *
     * @ignore Exclude from docs
     */
    ValueAxis.prototype.calculateZoom = function () {
        if (isNumber(this.min) && isNumber(this.max)) {
            var min = this.positionToValue(this.start);
            var max = this.positionToValue(this.end);
            var differece = this.adjustDifference(min, max);
            var minMaxStep = this.adjustMinMax(min, max, differece, this._gridCount, true);
            var stepDecimalPlaces = decimalPlaces(minMaxStep.step);
            this._stepDecimalPlaces = stepDecimalPlaces;
            min = Math_round(min, stepDecimalPlaces);
            max = Math_round(max, stepDecimalPlaces);
            minMaxStep = this.adjustMinMax(min, max, differece, this._gridCount, true);
            var step = minMaxStep.step;
            if (this.syncWithAxis) {
                var calculated = this.getCache(min + "-" + max);
                if (isNumber(calculated)) {
                    step = calculated;
                }
            }
            else {
                min = minMaxStep.min;
                max = minMaxStep.max;
            }
            if (this._minZoomed != min || this._maxZoomed != max || this._step != step) {
                this._minZoomed = min;
                this._maxZoomed = max;
                this._step = step;
                this.dispatchImmediately("selectionextremeschanged");
            }
        }
    };
    /**
     * Validates Axis elements.
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    ValueAxis.prototype.validateAxisElements = function () {
        var _this = this;
        if (isNumber(this.max) && isNumber(this.min)) {
            // first regular items
            var value_1 = this.minZoomed - this._step * 2;
            if (!this.logarithmic) {
                value_1 = Math.floor(value_1 / this._step) * this._step;
            }
            else {
                var differencePower = Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E;
                if (differencePower > 1) {
                    value_1 = Math.pow(10, Math.log(this.min) * Math.LOG10E);
                }
                else {
                    value_1 = Math.floor(this.minZoomed / this._step) * this._step;
                    if (value_1 == 0) {
                        value_1 = this.minZoomed;
                    }
                }
            }
            var maxZoomed = this._maxZoomed + this._step;
            this.resetIterators();
            var dataItemsIterator_1 = this._dataItemsIterator;
            var i = 0;
            var precisionChanged = this._prevStepDecimalPlaces != this._stepDecimalPlaces;
            this._prevStepDecimalPlaces = this._stepDecimalPlaces;
            while (value_1 <= maxZoomed) {
                var axisBreak = this.isInBreak(value_1);
                if (!axisBreak) {
                    var dataItem = dataItemsIterator_1.find(function (x) { return x.value === value_1; });
                    if (dataItem.__disabled) {
                        dataItem.__disabled = false;
                    }
                    //this.processDataItem(dataItem);
                    this.appendDataItem(dataItem);
                    dataItem.axisBreak = undefined;
                    if (dataItem.value != value_1 || precisionChanged) {
                        dataItem.value = value_1;
                        dataItem.text = this.formatLabel(value_1);
                        if (dataItem.label && dataItem.label.invalid) {
                            dataItem.label.validate();
                        }
                        if (dataItem.value >= this.min && dataItem.value <= this.max) {
                            if (dataItem.label) {
                                if ((this.axisLetter == "Y" && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth) || (this.axisLetter == "X" && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight)) {
                                    this.ghostLabel.text = dataItem.label.currentText;
                                    this.ghostLabel.validate();
                                }
                            }
                        }
                    }
                    this.validateDataElement(dataItem);
                }
                i++;
                if (!this.logarithmic) {
                    value_1 += this._step;
                }
                else {
                    var differencePower = Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E;
                    if (differencePower > 1) {
                        value_1 = Math.pow(10, Math.log(this.min) * Math.LOG10E + i);
                    }
                    else {
                        value_1 += this._step;
                    }
                }
                var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(this._step)) * Math.LOG10E));
                if (stepPower < 1) {
                    // exponent is less then 1 too. Count decimals of exponent
                    var decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2;
                    // round value to avoid floating point issues
                    value_1 = Math_round(value_1, decCount);
                }
            }
            var axisBreaks = this._axisBreaks;
            if (axisBreaks) {
                // breaks later
                var renderer_1 = this.renderer;
                Iterator_each(axisBreaks.iterator(), function (axisBreak) {
                    if (axisBreak.breakSize > 0) {
                        // only add grid if gap is bigger then minGridDistance
                        if (getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance) {
                            var breakValue_1 = axisBreak.adjustedMin;
                            while (breakValue_1 <= axisBreak.adjustedMax) {
                                if (breakValue_1 >= axisBreak.adjustedStartValue && breakValue_1 <= axisBreak.adjustedEndValue) {
                                    var dataItem = dataItemsIterator_1.find(function (x) { return x.value === breakValue_1; });
                                    if (dataItem.__disabled) {
                                        dataItem.__disabled = false;
                                    }
                                    //this.processDataItem(dataItem);
                                    _this.appendDataItem(dataItem);
                                    dataItem.axisBreak = axisBreak;
                                    if (dataItem.value != breakValue_1) {
                                        dataItem.value = breakValue_1;
                                        dataItem.text = _this.formatLabel(breakValue_1);
                                        if (dataItem.label && dataItem.label.invalid) {
                                            dataItem.label.validate();
                                        }
                                    }
                                    _this.validateDataElement(dataItem);
                                }
                                breakValue_1 += axisBreak.adjustedStep;
                            }
                        }
                    }
                });
            }
        }
    };
    /**
     * Validates axis data item.
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param dataItem  Data item
     */
    ValueAxis.prototype.validateDataElement = function (dataItem) {
        _super.prototype.validateDataElement.call(this, dataItem);
        //dataItem.__disabled = false;
        dataItem.itemIndex = this._axisItemCount;
        this._axisItemCount++;
        var renderer = this.renderer;
        var value = dataItem.value;
        var endValue = dataItem.endValue;
        var position = this.valueToPosition(value);
        dataItem.position = position;
        var endPosition = position;
        var fillEndPosition = this.valueToPosition(value + this._step);
        if (isNumber(endValue)) {
            endPosition = this.valueToPosition(endValue);
            fillEndPosition = endPosition;
        }
        // this point is needed to calculate distance to satisfy minGridDistance
        dataItem.point = renderer.positionToPoint(position);
        var tick = dataItem.tick;
        if (tick && !tick.disabled) {
            renderer.updateTickElement(tick, position, endPosition);
        }
        var grid = dataItem.grid;
        if (grid && !grid.disabled) {
            renderer.updateGridElement(grid, position, endPosition);
        }
        var label = dataItem.label;
        if (label && !label.disabled) {
            renderer.updateLabelElement(label, position, endPosition);
        }
        var fill = dataItem.axisFill;
        if (fill && !fill.disabled) {
            renderer.updateFillElement(fill, position, fillEndPosition);
            if (!dataItem.isRange) {
                this.fillRule(dataItem);
            }
        }
        if (dataItem.bullet) {
            renderer.updateBullet(dataItem.bullet, position, endPosition);
        }
        var mask = dataItem.mask;
        if (mask) {
            renderer.updateFillElement(mask, position, fillEndPosition);
        }
    };
    /**
     * Formats the value according to axis' own [[NumberFormatter]].
     *
     * @param value  Source value
     * @return Formatted value
     */
    ValueAxis.prototype.formatLabel = function (value) {
        if (this.adjustLabelPrecision && value != 0) {
            return this.numberFormatter.format(value, undefined, this._stepDecimalPlaces);
        }
        else {
            return this.numberFormatter.format(value);
        }
    };
    Object.defineProperty(ValueAxis.prototype, "basePoint", {
        /**
         * Coordinates of the actual axis start.
         *
         * @ignore Exclude from docs
         * @return Base point
         */
        get: function () {
            var baseValue = this.baseValue;
            var position = this.valueToPosition(baseValue);
            var basePoint = this.renderer.positionToPoint(position);
            return basePoint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "baseValue", {
        /**
         * @return base value
         */
        get: function () {
            var baseValue = this._baseValue;
            if (this.logarithmic) {
                baseValue = this.min;
            }
            if (!this._adapterO) {
                return baseValue;
            }
            else {
                return this._adapterO.apply("baseValue", baseValue);
            }
        },
        /**
         * A base value.
         *
         * This is a threshold value that will divide "positive" and "negative"
         * value ranges.
         *
         * Other scale-related functionality also depend on base value. E.g. stacks,
         * value-dependent coloring, etc.
         *
         * @param value Base value
         */
        set: function (value) {
            this._baseValue = value;
            this.invalidateLayout();
            this.invalidateSeries();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts a numeric value to relative position on axis
     *
     * An alias to `valueToPosition()`.
     *
     * @param value  Value
     * @return Position
     */
    ValueAxis.prototype.anyToPosition = function (value) {
        return this.valueToPosition(value);
    };
    /**
     * Converts a numeric value to orientation point (x, y, angle) on axis
     *
     * @param value  Value
     * @return Orientation point
     */
    ValueAxis.prototype.valueToPoint = function (value) {
        var position = this.valueToPosition(value);
        var point = this.renderer.positionToPoint(position);
        var angle = this.renderer.positionToAngle(position);
        return { x: point.x, y: point.y, angle: angle };
    };
    /**
     * Converts a numeric value to orientation (x, y, angle) point on axis
     *
     * @param value  Value
     * @return Orientation point
     */
    ValueAxis.prototype.anyToPoint = function (value) {
        return this.valueToPoint(value);
    };
    /**
     * Converts a numeric value to relative position on axis.
     *
     * @param value  Value
     * @return relative position
     */
    ValueAxis.prototype.valueToPosition = function (value) {
        if (isNumber(value)) {
            // todo: think if possible to take previous value and do not go through all previous breaks
            var min_1 = this.min;
            var max_1 = this.max;
            if (isNumber(min_1) && isNumber(max_1)) {
                var difference = this._difference;
                var axisBreaks = this._axisBreaks;
                if (axisBreaks && axisBreaks.length > 0) {
                    Iterator_eachContinue(axisBreaks.iterator(), function (axisBreak) {
                        var startValue = axisBreak.adjustedStartValue;
                        var endValue = axisBreak.adjustedEndValue;
                        if (isNumber(startValue) && isNumber(endValue)) {
                            if (value < startValue) {
                                return false;
                            }
                            if (intersect({ start: startValue, end: endValue }, { start: min_1, end: max_1 })) { // todo: check this once and set some flag in axisBreak
                                startValue = Math.max(startValue, min_1);
                                endValue = Math.min(endValue, max_1);
                                var breakSize = axisBreak.breakSize;
                                // value to the right of break end
                                if (value > endValue) {
                                    min_1 += (endValue - startValue) * (1 - breakSize); // todo: maybe this can be done differently?
                                }
                                // value to the left of break start
                                else if (value < startValue) {
                                }
                                // value within break
                                else {
                                    value = startValue + (value - startValue) * breakSize;
                                }
                            }
                        }
                        return true;
                    });
                }
                var position = void 0;
                if (!this.logarithmic) {
                    position = (value - min_1) / difference;
                }
                else {
                    position = (Math.log(value) * Math.LOG10E - Math.log(this.min) * Math.LOG10E) / ((Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E));
                }
                //position = $math.round(position, 10);
                return position;
            }
        }
        return 0;
    };
    /**
     * When fontSize of fontFamily changes we need to hard-invalidate all Labels of this container to position them properly.
     */
    ValueAxis.prototype.invalidateLabels = function () {
        _super.prototype.invalidateLabels.call(this);
        if (this.dataItems) {
            this.dataItems.each(function (dataItem) {
                dataItem.value = undefined;
            });
            this.invalidate();
        }
    };
    /**
     * Converts an relative position to a corresponding value within
     * axis' scale.
     *
     * @param position  Position (px)
     * @return Value
     */
    ValueAxis.prototype.positionToValue = function (position) {
        position = Math_round(position, 10);
        var min = this.min;
        var max = this.max;
        if (isNumber(min) && isNumber(max)) {
            var difference_1 = max - min; //no need to adjust!
            var value_2 = null;
            var axisBreaks = this._axisBreaks;
            if (axisBreaks) {
                // in case we have some axis breaks
                if (axisBreaks.length > 0) {
                    Iterator_eachContinue(axisBreaks.iterator(), function (axisBreak) {
                        var breakStartPosition = axisBreak.startPosition;
                        var breakEndPosition = axisBreak.endPosition;
                        var breakStartValue = axisBreak.adjustedStartValue;
                        var breakEndValue = axisBreak.adjustedEndValue;
                        if (isNumber(breakStartValue) && isNumber(breakEndValue)) {
                            if (breakStartValue > max) {
                                return false;
                            }
                            if (intersect({ start: breakStartValue, end: breakEndValue }, { start: min, end: max })) {
                                breakStartValue = Math_max(breakStartValue, min);
                                breakEndValue = Math_min(breakEndValue, max);
                                var breakSize = axisBreak.breakSize;
                                difference_1 -= (breakEndValue - breakStartValue) * (1 - breakSize);
                                // position to the right of break end
                                if (position > breakEndPosition) {
                                    min += (breakEndValue - breakStartValue) * (1 - breakSize);
                                }
                                // position to the left of break start
                                else if (position < breakStartPosition) {
                                }
                                // value within break
                                else {
                                    var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);
                                    value_2 = breakStartValue + breakPosition * (breakEndValue - breakStartValue);
                                    return false;
                                }
                            }
                            return true;
                        }
                    });
                }
            }
            if (!isNumber(value_2)) {
                if (this.logarithmic) {
                    value_2 = Math.pow(Math.E, (position * ((Math.log(this.max) * Math.LOG10E - Math.log(this.min) * Math.LOG10E)) + Math.log(this.min) * Math.LOG10E) / Math.LOG10E);
                }
                else {
                    value_2 = position * difference_1 + min;
                }
            }
            return value_2;
        }
        //}
    };
    /**
     * Converts an X coordinate to a relative value in axis' scale.
     *
     * @param x  X (px)
     * @return Value
     */
    ValueAxis.prototype.xToValue = function (x) {
        return this.positionToValue(this.pointToPosition({ x: x, y: 0 }));
    };
    /**
     * Converts an Y coordinate to a relative value in axis' scale.
     *
     * @param y  Y (px)
     * @return Value
     */
    ValueAxis.prototype.yToValue = function (y) {
        return this.positionToValue(this.pointToPosition({ x: 0, y: y }));
    };
    /**
     * Converts pixel coordinates to a relative position. (0-1)
     *
     * @param point  Coorinates (px)
     * @return Position (0-1)
     */
    ValueAxis.prototype.pointToPosition = function (point) {
        if (this.renderer instanceof AxisRendererY_AxisRendererY) {
            return 1 - this.renderer.pointToPosition(point);
        }
        else {
            return this.renderer.pointToPosition(point);
        }
    };
    /**
     * @ignore
     */
    ValueAxis.prototype.animateMinMax = function (min, max) {
        return this.animate([{ property: "_minAdjusted", from: this._minAdjusted, to: min }, { property: "_maxAdjusted", from: this._maxAdjusted, to: max }], this.rangeChangeDuration, this.rangeChangeEasing);
    };
    /**
     * Calculates smallest and biggest value for the axis scale.
     * @ignore
     * @todo Description (review)
     */
    ValueAxis.prototype.getMinMax = function () {
        var _this = this;
        this.updateGridCount();
        var min = Number.POSITIVE_INFINITY;
        var max = Number.NEGATIVE_INFINITY;
        // only if min and max are not set from outside, we go through min and max influencers
        if (!isNumber(this._minDefined) || !isNumber(this._maxDefined)) {
            this.series.each(function (series) {
                if (!series.ignoreMinMax) {
                    // check min
                    var seriesMin = series.min(_this);
                    if (isNumber(seriesMin) && (seriesMin < min)) {
                        min = seriesMin;
                    }
                    // check max
                    var seriesMax = series.max(_this);
                    if (isNumber(seriesMax) && (seriesMax > max)) {
                        max = seriesMax;
                    }
                }
            });
            if (this.includeRangesInMinMax) {
                this.axisRanges.each(function (range) {
                    if (!range.ignoreMinMax) {
                        var minValue = Math_min(range.value, range.endValue);
                        var maxValue = Math_max(range.value, range.endValue);
                        if (minValue < min || !isNumber(min)) {
                            min = minValue;
                        }
                        if (maxValue > max || !isNumber(max)) {
                            max = maxValue;
                        }
                    }
                });
            }
        }
        if (this.logarithmic) {
            if (min <= 0) {
                this.raiseCriticalError(new Error("Logarithmic value axis can not have values <= 0."), true);
            }
        }
        if (min == 0 && max == 0) {
            max = 0.9;
            min = -0.9;
        }
        // if defined from outside
        if (isNumber(this._minDefined)) {
            min = this._minDefined;
        }
        if (isNumber(this._maxDefined)) {
            max = this._maxDefined;
        }
        if (this._adapterO) {
            min = this._adapterO.apply("min", min);
        }
        if (this._adapterO) {
            max = this._adapterO.apply("max", max);
        }
        if (!isNumber(min) || !isNumber(max)) {
            return;
        }
        this._minReal = min;
        this._maxReal = max;
        if (min == Number.POSITIVE_INFINITY) {
            min = undefined;
        }
        if (max == Number.NEGATIVE_INFINITY) {
            max = undefined;
        }
        var dif = this.adjustDifference(min, max); // previously it was max-min, but not worked well
        min = this.fixMin(min);
        max = this.fixMax(max);
        // this happens if starLocation and endLocation are 0.5 and DateAxis has only one date
        if (max - min <= 1 / Math.pow(10, 15)) {
            if (max - min != 0) {
                this._deltaMinMax = (max - min) / 2;
            }
            else {
                // the number by which we need to raise 10 to get difference
                var exponent = Math.log(Math.abs(max)) * Math.LOG10E;
                // here we find a number which is power of 10 and has the same count of numbers as difference has
                var power = Math.pow(10, Math.floor(exponent));
                // reduce this number by 10 times
                power = power / 10;
                this._deltaMinMax = power;
            }
            min -= this._deltaMinMax;
            max += this._deltaMinMax;
        }
        min -= (max - min) * this.extraMin;
        max += (max - min) * this.extraMax;
        var strict = this.strictMinMax;
        if (isNumber(this._maxDefined)) {
            strict = true;
        }
        var minMaxStep = this.adjustMinMax(min, max, dif, this._gridCount, strict);
        min = minMaxStep.min;
        max = minMaxStep.max;
        dif = max - min; //new
        // do it for the second time (importat!)
        minMaxStep = this.adjustMinMax(min, max, max - min, this._gridCount, true);
        min = minMaxStep.min;
        max = minMaxStep.max;
        // return min max if strict
        if (this.strictMinMax) {
            if (isNumber(this._minDefined)) {
                min = this._minDefined;
            }
            else {
                min = this._minReal;
            }
            if (isNumber(this._maxDefined)) {
                max = this._maxDefined;
            }
            else {
                max = this._maxReal;
            }
            if (max - min <= 0.00000001) {
                min -= this._deltaMinMax;
                max += this._deltaMinMax;
            }
            min -= (max - min) * this.extraMin;
            max += (max - min) * this.extraMax;
        }
        if (this._adapterO) {
            min = this._adapterO.apply("min", min);
        }
        if (this._adapterO) {
            max = this._adapterO.apply("max", max);
        }
        this._step = minMaxStep.step;
        // checking isNumber is good when all series are hidden
        if ((this._minAdjusted != min || this._maxAdjusted != max) && isNumber(min) && isNumber(max)) {
            var animation = this._minMaxAnimation;
            if (this._extremesChanged && isNumber(this._minAdjusted) && isNumber(this._maxAdjusted) && this.inited) {
                if ((animation && !animation.isFinished()) && this._finalMax == max && this._finalMin == min) {
                    return;
                }
                else {
                    this._finalMin = min;
                    this._finalMax = max;
                    animation = this.animateMinMax(min, max);
                    if (animation && !animation.isFinished()) {
                        animation.events.on("animationprogress", this.validateDataItems, this);
                        animation.events.on("animationended", function () {
                            //this.validateDataItems();
                            _this.series.each(function (series) {
                                series.validate();
                            });
                            _this.validateDataItems();
                            _this.handleSelectionExtremesChange();
                        });
                        this._minMaxAnimation = animation;
                    }
                    else {
                        this.series.each(function (series) {
                            series.validate();
                        });
                    }
                    this.validateDataItems();
                    this.dispatchImmediately("extremeschanged");
                    this.handleSelectionExtremesChange();
                }
            }
            else {
                if ((animation && !animation.isFinished()) && this._finalMax == max && this._finalMin == min) {
                    return;
                }
                else {
                    this._minAdjusted = min;
                    this._maxAdjusted = max;
                    this._finalMin = min;
                    this._finalMax = max;
                    this.invalidateDataItems();
                    this.dispatchImmediately("extremeschanged");
                }
            }
        }
        this._extremesChanged = false;
        this._difference = this.adjustDifference(min, max);
    };
    /**
     * Adjusts the minimum value.
     *
     * This is a placeholder method for extending classes to override.
     *
     * For numeric values this does nothing, however for more complex types, like
     * dates, it may be necessary to adjust.
     *
     * @param value  Value
     * @return Adjusted value
     */
    ValueAxis.prototype.fixMin = function (value) {
        return value;
    };
    /**
     * Adjusts the maximum value.
     *
     * This is a placeholder method for extending classes to override.
     *
     * For numeric values this does nothing, however for more complex types, like
     * dates, it may be necessary to adjust.
     *
     * @param value  Value
     * @return Adjusted value
     */
    ValueAxis.prototype.fixMax = function (value) {
        return value;
    };
    /**
     * Adjusts actual min and max scale values so that the axis starts and ends
     * at "nice" values, unless `strictMinMax` is set.
     *
     * The `difference` can be something else than `max - min`, because of the
     * axis breaks.
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param min        [description]
     * @param max        [description]
     * @param difference [description]
     * @param gridCount  [description]
     * @param strictMode [description]
     * @return [description]
     */
    ValueAxis.prototype.adjustMinMax = function (min, max, difference, gridCount, strictMode) {
        // will fail if 0
        if (gridCount <= 1) {
            gridCount = 1;
        }
        gridCount = Math.round(gridCount);
        var initialMin = min;
        var initialMax = max;
        // in case min and max is the same, use max
        if (difference === 0) {
            difference = Math.abs(max);
        }
        // the number by which we need to raise 10 to get difference
        var exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
        // here we find a number which is power of 10 and has the same count of numbers as difference has
        var power = Math.pow(10, Math.floor(exponent));
        // reduce this number by 10 times
        power = power / 10;
        var extra = power;
        if (strictMode) {
            extra = 0;
        }
        if (!this.logarithmic) {
            // round down min
            if (strictMode) {
                min = Math.floor(min / power) * power;
                // round up max
                max = Math.ceil(max / power) * power;
            }
            else {
                min = Math.ceil(min / power) * power - extra;
                // round up max
                max = Math.floor(max / power) * power + extra;
            }
            // don't let min go below 0 if real min is >= 0
            if (min < 0 && initialMin >= 0) {
                min = 0;
            }
            // don't let max go above 0 if real max is <= 0
            if (max > 0 && initialMax <= 0) {
                max = 0;
            }
        }
        else {
            if (min <= 0) {
                //throw Error("Logarithmic value axis can not have values <= 0.");
                min = this.baseValue;
            }
            // @todo: think of a better way or to restrict zooming when no series are selected
            if (min == Infinity) {
                min = 1;
            }
            if (max == -Infinity) {
                max = 10;
            }
            min = Math.pow(10, Math.floor(Math.log(Math.abs(min)) * Math.LOG10E));
            max = Math.pow(10, Math.ceil(Math.log(Math.abs(max)) * Math.LOG10E));
        }
        // repeat diff, exponent and power again with rounded values
        //difference = this.adjustDifference(min, max);
        /*

                if(min > initialMin){
                    min = initialMin;
                }

                if(max < initialMax){
                    max = initialMax;
                }
        */
        exponent = Math.log(Math.abs(difference)) * Math.LOG10E;
        power = Math.pow(10, Math.floor(exponent));
        power = power / 10;
        // approximate difference between two grid lines
        var step = Math.ceil((difference / gridCount) / power) * power;
        var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));
        // TODO: in v3 I had fixStepE here, ommiting it for a while, need to think about other solution
        // the step should divide by  2, 5, and 10.
        var stepDivisor = Math.ceil(step / stepPower); // number 0 - 10
        if (stepDivisor > 5) {
            stepDivisor = 10;
        }
        else if (stepDivisor <= 5 && stepDivisor > 2) {
            stepDivisor = 5;
        }
        // now get real step
        step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;
        if (this.maxPrecision < Number.MAX_VALUE && step != ceil(step, this.maxPrecision)) {
            step = ceil(step, this.maxPrecision);
        }
        var decCount = 0;
        // in case numbers are smaller than 1
        if (stepPower < 1) {
            // exponent is less then 1 too. Count decimals of exponent
            decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1;
            // round step
            step = Math_round(step, decCount);
        }
        if (!this.logarithmic) {
            // final min and max
            var minCount = Math.floor(min / step);
            min = Math_round(step * minCount, decCount);
            var maxCount = void 0;
            if (!strictMode) {
                maxCount = Math.ceil(max / step);
            }
            else {
                maxCount = Math.floor(max / step);
            }
            if (maxCount == minCount) {
                maxCount++;
            }
            max = Math_round(step * maxCount, decCount);
            if (max < initialMax) {
                max = max + step;
            }
            if (min > initialMin) {
                min = min - step;
            }
        }
        return { min: min, max: max, step: step };
    };
    Object.defineProperty(ValueAxis.prototype, "min", {
        /**
         * @return Min value
         */
        get: function () {
            var min = this._minAdjusted;
            if (!isNumber(min)) {
                min = this._minDefined;
            }
            return min;
        },
        /**
         * A minimum value for the axis scale.
         *
         * This value might be auto-adjusted by the Axis in order to accomodate the
         * grid nicely, i.e. plot area is divided by grid in nice equal cells.
         *
         * The above might be overridden by `strictMinMax` which will force exact
         * user-defined min and max values to be used for scale.
         *
         * @param value  Min value
         */
        set: function (value) {
            if (this._minDefined != value) {
                this._minDefined = value;
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "minDefined", {
        /**
         * Min value as defined by user's code, not auto-calculated.
         *
         * @readonly
         * @return Min value
         */
        get: function () {
            return this._minDefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "maxDefined", {
        /**
         * Max value as defined by user's code, not auto-calculated.
         *
         * @readonly
         * @return Man value
         */
        get: function () {
            return this._maxDefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "extraMin", {
        /**
         * @return {number}
         */
        get: function () {
            return this.getPropertyValue("extraMin");
        },
        /**
         * Allows relatively adjusting minimum value of the axis' scale.
         *
         * The value is relative to the actual range of values currently displayed
         * on the axis.
         *
         * E.g.: 0.5 will mean half of the current range. If we have axis displaying
         * from 100 to 200, we will now have axis displaying from 50 to 200 because
         * we asked to expand minimum value by 50% (0.5).
         *
         * @param {number}
         */
        set: function (value) {
            if (this.setPropertyValue("extraMin", value)) {
                this.invalidateDataItems();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "extraMax", {
        /**
         * @return Min multiplier
         */
        get: function () {
            return this.getPropertyValue("extraMax");
        },
        /**
         * Allows relatively adjusting maximum value of the axis' scale.
         *
         * The value is relative to the actual range of values currently displayed
         * on the axis.
         *
         * E.g.: 0.5 will mean half of the current range. If we have axis displaying
         * from 100 to 200, we will now have axis displaying from 100 to 250 because
         * we asked to expand maximum value by 50% (0.5).
         *
         * @param {number}
         */
        set: function (value) {
            if (this.setPropertyValue("extraMax", value)) {
                this.invalidateDataItems();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "step", {
        /**
         * Current calculated delta in values between two adjacent grid lines (step).
         *
         * This is a read-only value and cannot be used to set actual step.
         *
         * @readonly
         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/positioning-axis-elements/#Setting_the_density_of_the_the_grid_labels} For more information about modifying density of labels
         * @return [description]
         */
        get: function () {
            return this._step;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "max", {
        /**
         * @return Max value
         */
        get: function () {
            var max = this._maxAdjusted;
            if (!isNumber(max)) {
                max = this._maxDefined;
            }
            return max;
        },
        /**
         * A maximum value for the axis scale.
         *
         * This value might be auto-adjusted by the Axis in order to accomodate the
         * grid nicely, i.e. plot area is divided by grid in nice equal cells.
         *
         * The above might be overridden by `strictMinMax` which will force exact
         * user-defined min and max values to be used for scale.
         *
         * @param value  Max value
         */
        set: function (value) {
            if (this._maxDefined != value) {
                this._maxDefined = value;
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "adjustLabelPrecision", {
        /**
         * @return Adjust precision
         */
        get: function () {
            return this.getPropertyValue("adjustLabelPrecision");
        },
        /**
         * By default the axis will adjust precision of all numbers to match number
         * of decimals in all its labels, e.g.: `1.0`, `1.5`, `2.0`.
         *
         * To disable set `adjustLabelPrecision` to `false`, to use whatever other
         * precision or number format settings are set.
         *
         * IMPORTANT: This setting will be ignored if your number format uses
         * modifiers, e.g. `"#a"`.
         *
         * @default true
         * @since 4.9.14
         * @param  value  Adjust precision
         */
        set: function (value) {
            if (this.setPropertyValue("adjustLabelPrecision", value)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Used for the Series to register itself as the user of this Axis.
     *
     * This will also decorate both the Series and Axis with event handlers, used
     * to redraw on Axis position/zoom change.
     *
     * A disposer for those events is returned, so that they can be disposed
     * together with Series.
     *
     * @ignore Exclude from docs
     * @param series  Series
     * @return Disposer for events
     */
    ValueAxis.prototype.registerSeries = function (series) {
        return new Disposer_MultiDisposer([
            _super.prototype.registerSeries.call(this, series),
            series.events.on("extremeschanged", this.handleExtremesChange, this, false),
            series.events.on("selectionextremeschanged", this.handleSelectionExtremesChange, this, false),
            this.events.on("extremeschanged", series.invalidate, series, false)
        ]);
    };
    /**
     * Perform tasks after Axis zoom.
     */
    ValueAxis.prototype.handleSelectionExtremesChange = function () {
        var _this = this;
        var selectionMin;
        var selectionMax;
        var allHidden = true;
        Iterator_each(this.series.iterator(), function (series) {
            if (!series.ignoreMinMax && !series.isHidden) {
                if (series.visible && !series.isHiding) {
                    allHidden = false;
                }
                var seriesSelectionMin = series.selectionMin(_this);
                var seriesSelectionMax = series.selectionMax(_this);
                if (isNumber(seriesSelectionMin)) {
                    if (!isNumber(selectionMin) || (seriesSelectionMin < selectionMin)) {
                        selectionMin = seriesSelectionMin;
                    }
                }
                // check max
                if (isNumber(seriesSelectionMax)) {
                    if (!isNumber(selectionMax) || (seriesSelectionMax > selectionMax)) {
                        selectionMax = seriesSelectionMax;
                    }
                }
            }
        });
        if (this.includeRangesInMinMax) {
            this.axisRanges.each(function (range) {
                if (!range.ignoreMinMax) {
                    var minValue = Math_min(range.value, range.endValue);
                    var maxValue = Math_max(range.value, range.endValue);
                    if (minValue < selectionMax) {
                        selectionMax = minValue;
                    }
                    if (maxValue > selectionMax) {
                        selectionMax = maxValue;
                    }
                }
            });
        }
        // this is not good, as if date axis is initially zoomed, selection of y axis is reset to 0, 1 at the end of this method
        //$iter.each(this.series.iterator(), (series) => {
        //	if (!series.appeared) {
        //		allHidden = true;
        //	}
        //})
        if (isNumber(this._minDefined)) {
            if (this.strictMinMax) {
                selectionMin = this._minDefined;
            }
            else {
                selectionMin = this.min;
            }
        }
        else if (this.strictMinMax) {
            selectionMin = this._minReal;
        }
        if (isNumber(this._maxDefined)) {
            if (this.strictMinMax) {
                selectionMax = this._maxDefined;
            }
            else {
                selectionMax = this.max;
            }
        }
        else if (this.strictMinMax) {
            selectionMax = this._maxReal;
        }
        if (selectionMin == selectionMax) {
            selectionMin -= this._deltaMinMax;
            selectionMax += this._deltaMinMax;
            var minMaxStep2 = this.adjustMinMax(selectionMin, selectionMax, 0, this._gridCount, this.strictMinMax);
            selectionMin = minMaxStep2.min;
            selectionMax = minMaxStep2.max;
        }
        var dif = this.adjustDifference(selectionMin, selectionMax);
        var minMaxStep = this.adjustMinMax(selectionMin, selectionMax, dif, this._gridCount);
        selectionMin = minMaxStep.min;
        selectionMax = minMaxStep.max;
        selectionMin -= (selectionMax - selectionMin) * this.extraMin;
        selectionMax += (selectionMax - selectionMin) * this.extraMax;
        selectionMin = fitToRange(selectionMin, this.min, this.max);
        selectionMax = fitToRange(selectionMax, this.min, this.max);
        // do it for the second time !important
        dif = this.adjustDifference(selectionMin, selectionMax);
        minMaxStep = this.adjustMinMax(selectionMin, selectionMax, dif, this._gridCount, true);
        selectionMin = minMaxStep.min;
        selectionMax = minMaxStep.max;
        if (this.strictMinMax) {
            selectionMin = Math_max(selectionMin, this._minDefined);
            selectionMax = Math_min(selectionMax, this._maxDefined);
        }
        var step = minMaxStep.step;
        if (this.syncWithAxis) {
            minMaxStep = this.syncAxes(selectionMin, selectionMax, step);
            selectionMin = minMaxStep.min;
            selectionMax = minMaxStep.max;
            this.invalidate();
        }
        step = minMaxStep.step;
        // needed because of grouping
        this._difference = this.adjustDifference(this.min, this.max);
        var start = this.valueToPosition(selectionMin);
        var end = this.valueToPosition(selectionMax);
        // in case all series are hidden or hiding, full zoomout
        if (allHidden && !this.syncWithAxis) {
            start = 0;
            end = 1;
        }
        var declination = 0;
        if (this.syncWithAxis) {
            declination = 5;
            this.setCache(selectionMin + "-" + selectionMax, step);
        }
        else {
            this._step = step;
            this._minZoomed = selectionMin;
            this._maxZoomed = selectionMax;
        }
        if (!this.keepSelection) {
            this.zoom({ start: start, end: end }, false, false, declination);
        }
    };
    Object.defineProperty(ValueAxis.prototype, "strictMinMax", {
        /**
         * @return Use exact values?
         */
        get: function () {
            return this.getPropertyValue("strictMinMax");
        },
        /**
         * Indicates whether to blindly use exact `min` and `max` values set by user
         * when generating Axis scale.
         *
         * If not set, the Axis might slightly adjust those values to accomodate a
         * better looking grid.
         *
         * NOTE: if `min` and `max` are not set, setting `strictMinMax` to `true`
         * will result in fixing the scale of the axis to actual lowest and highest
         * values in the series within currently selected scope.
         *
         * @default false
         * @param value Use exact values?
         */
        set: function (value) {
            if (this.setPropertyValue("strictMinMax", value)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "logarithmic", {
        /**
         * @return Logarithmic scale?
         */
        get: function () {
            return this.getPropertyValue("logarithmic");
        },
        /**
         * Indicates if this axis should use a logarithmic scale.
         *
         * Please note that logarithmic axis can **only** accommodate values bigger
         * than zero.
         *
         * Having zero or negative values will result in error and failure of the
         * whole chart.
         *
         * @param value Logarithmic scale?
         */
        set: function (value) {
            if (this.setPropertyValue("logarithmic", value)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "keepSelection", {
        /**
         * @return Preseve zoom after data update?
         */
        get: function () {
            return this.getPropertyValue("keepSelection");
        },
        /**
         * Indicates if a current selection (zoom) should be kept across data updates.
         *
         * If your axis is zoomed while chart's data is updated, the axis will try
         * to retain the same start and end values.
         *
         * You can also use this to initially pre-zoom axis:
         *
         * ```TypeScript
         * axis.keepSelection = true;
         * axis.start = 0.5;
         * axis.end = 0.7;
         * ```
         * ```JavaScript
         * axis.keepSelection = true;
         * axis.start = 0.5;
         * axis.end = 0.7;
         * ```
         * ```JSON
         * {
         *   "xAxes": [{
         *     // ...
         *     "keepSelection": true,
         *     "start": 0.5,
         *     "end": 0.7
         *   }]
         * }
         * ```
         *
         * The above will start the chart zoomed from the middle of the actual scope
         * to 70%.
         *
         * @since 4.1.1
         * @default flase
         * @param  value  Preseve zoom after data update?
         */
        set: function (value) {
            this.setPropertyValue("keepSelection", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "includeRangesInMinMax", {
        /**
         * @return Include ranges?
         */
        get: function () {
            return this.getPropertyValue("includeRangesInMinMax");
        },
        /**
         * If set to `true`, values of axis ranges will be included when calculating
         * range of values / scale of the [[ValueAxis]].
         *
         * @default false
         * @since 4.4.9
         * @param  value  Include ranges?
         */
        set: function (value) {
            this.setPropertyValue("includeRangesInMinMax", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "maxPrecision", {
        /**
         * @return max precision
         */
        get: function () {
            return this.getPropertyValue("maxPrecision");
        },
        /**
         * Maximum number of decimals to allow when placing grid lines and labels
         * on axis.
         *
         * Set it to `0` (zero) to force integer-only axis labels.
         *
         * @param {number}
         */
        set: function (value) {
            if (this.setPropertyValue("maxPrecision", value)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "extraTooltipPrecision", {
        /**
         * @return Extra decimals
         */
        get: function () {
            return this.getPropertyValue("extraTooltipPrecision");
        },
        /**
         * This setting allows using bigger precision for numbers displayed in axis
         * tooltip.
         *
         * Please note that this setting indicates additional decimal places to
         * automatically-calculated axis number precision.
         *
         * So if your axis displays numbers like 0.1, 0.2, etc. (one decimal place),
         * and you set `extraTooltipPrecision = 1`, tooltips will display numbers
         * like 0.12, 0.25, etc. (two decimal places).
         *
         * @default 0
         * @since 4.8.3
         * @param  value  Extra decimals
         */
        set: function (value) {
            if (this.setPropertyValue("extraTooltipPrecision", value)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Invalidates axis data items when series extremes change
     */
    ValueAxis.prototype.handleExtremesChange = function () {
        var _this = this;
        this._extremesChanged = true;
        this.getMinMax();
        if (this.ghostLabel) {
            var mw_1 = 0;
            this.dataItems.each(function (dataItem) {
                if (dataItem.label && dataItem.label.pixelWidth > mw_1) {
                    _this.ghostLabel.text = dataItem.label.currentText;
                }
            });
        }
    };
    /**
     * Returns relative position on axis for series' data item's value.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem  Data item
     * @param key       Data field to get value from
     * @param location  Location (0-1)
     * @param stackKey  ?
     * @return X coordinate (px)
     */
    ValueAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {
        return this.renderer.positionToPoint(this.getPositionX(dataItem, key, location, stackKey, range)).x;
    };
    /**
     * Returns the X coordinate for series' data item's value.
     *
     * @since 4.5.14
     * @param  dataItem  Data item
     * @param  key       Data field to get value from
     * @param  location  Location (0-1)
     * @param  stackKey  ?
     * @return           Relative position
     */
    ValueAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {
        var value = dataItem.getWorkingValue(key);
        if (!hasValue(stackKey)) {
            stackKey = "valueX";
        }
        var stack = dataItem.getValue(stackKey, "stack");
        if (!isNumber(value)) {
            value = this.baseValue;
            if (this.logarithmic) {
                if (stack > 0) {
                    value = 0;
                }
            }
        }
        var position = this.valueToPosition(value + stack);
        if (range) {
            position = fitToRange(position, range.start, range.end);
        }
        return position;
    };
    /**
     * Returns the Y coordinate for series' data item's value.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem  Data item
     * @param key       Data field to get value from
     * @param location  Location (0-1)
     * @param stackKey  Stack ID
     * @return Y coordinate (px)
     */
    ValueAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {
        return this.renderer.positionToPoint(this.getPositionY(dataItem, key, location, stackKey, range)).y;
    };
    /**
     * Returns relative position on axis for series' data item's value.
     *
     * @since 4.5.14
     * @param  dataItem  Data item
     * @param  key       Data field to get value from
     * @param  location  Location (0-1)
     * @param  stackKey  Stack ID
     * @return           Relative position
     */
    ValueAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {
        var value = dataItem.getWorkingValue(key);
        if (!hasValue(stackKey)) {
            stackKey = "valueY";
        }
        var stack = dataItem.getValue(stackKey, "stack");
        if (!isNumber(value)) {
            value = this.baseValue;
            if (this.logarithmic) {
                if (stack > 0) {
                    value = 0;
                }
            }
        }
        var position = this.valueToPosition(value + stack);
        if (range) {
            position = fitToRange(position, range.start, range.end);
        }
        return position;
    };
    /**
     * Returns an angle for series data item.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem  Data item
     * @param key       Data field to get value from
     * @param location  Location (0-1)
     * @param stackKey  Stack ID
     * @param range Range to fit in
     * @return Angle
     */
    ValueAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {
        var value = dataItem.getWorkingValue(key);
        var stack = dataItem.getValue(stackKey, "stack");
        if (!isNumber(value)) {
            value = this.baseValue;
        }
        var position = this.valueToPosition(value + stack);
        if (range) {
            position = fitToRange(position, range.start, range.end);
        }
        return this.positionToAngle(position);
    };
    /**
     * [getAnyRangePath description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param start     [description]
     * @param end       [description]
     * @param location  [description]
     * @return [description]
     */
    ValueAxis.prototype.getAnyRangePath = function (start, end, location) {
        var startPosition = this.valueToPosition(start);
        var endPosition = this.valueToPosition(end);
        return this.getPositionRangePath(startPosition, endPosition); // Base class (Axis) gets range shape from AxisRenderer
    };
    /**
     * Returns text to show in a axis tooltip, based on specific position within
     * axis.
     *
     * The label will be formatted as per [[NumberFormatter]] set for the whole
     * chart, or explicitly for this Axis.
     *
     * @ignore Exclude from docs
     * @param position  Position (px)
     * @return Label (numeric value)
     */
    ValueAxis.prototype.getTooltipText = function (position) {
        var value = Math_round(this.positionToValue(position), this._stepDecimalPlaces + this.extraTooltipPrecision);
        var valueStr = this.tooltip.numberFormatter.format(value);
        if (!this._adapterO) {
            return valueStr;
        }
        else {
            return this._adapterO.apply("getTooltipText", valueStr);
        }
    };
    /**
     * Zooms axis to specific values.
     *
     * @param startValue      Start value
     * @param endValue        End value
     * @param skipRangeEvent  Do not invoke events
     * @param instantly       Do not play zoom animations
     */
    ValueAxis.prototype.zoomToValues = function (startValue, endValue, skipRangeEvent, instantly) {
        var start = (startValue - this.min) / (this.max - this.min);
        var end = (endValue - this.min) / (this.max - this.min);
        this.zoom({ start: start, end: end }, skipRangeEvent, instantly);
    };
    Object.defineProperty(ValueAxis.prototype, "minZoomed", {
        /**
         * A smallest value in axis scale within current zoom.
         *
         * @return Min zoom value
         */
        get: function () {
            if (!this.syncWithAxis) {
                return Math_max(this.min, this._minZoomed);
            }
            else {
                return this._minZoomed;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValueAxis.prototype, "maxZoomed", {
        /**
         * A biggest value in axis scale within current zoom.
         * @return [description]
         */
        get: function () {
            if (!this.syncWithAxis) {
                return Math_min(this.max, this._maxZoomed);
            }
            else {
                return this._maxZoomed;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates positioning of Axis breaks after something changes.
     *
     * @ignore Exclude from docs
     */
    ValueAxis.prototype.fixAxisBreaks = function () {
        var _this = this;
        _super.prototype.fixAxisBreaks.call(this);
        var axisBreaks = this._axisBreaks;
        if (axisBreaks && axisBreaks.length > 0) {
            // process breaks
            axisBreaks.each(function (axisBreak) {
                var startValue = axisBreak.adjustedStartValue;
                var endValue = axisBreak.adjustedEndValue;
                // break difference
                var axisBreakDif = endValue - startValue;
                var axisBreakGridCount = Math.ceil(axisBreakDif * axisBreak.breakSize) * _this._gridCount / (_this.max - _this.min);
                // calculate min, max and step for axis break
                var breakMinMaxStep = _this.adjustMinMax(startValue, endValue, axisBreakDif, axisBreakGridCount, true);
                axisBreak.adjustedStep = breakMinMaxStep.step;
                axisBreak.adjustedMin = breakMinMaxStep.min;
                axisBreak.adjustedMax = breakMinMaxStep.max;
            });
        }
        this._difference = this.adjustDifference(this.min, this.max);
    };
    /**
     * Returns value based on position.
     *
     * Please note that `position` represents position within axis which may be
     * zoomed and not correspond to Cursor's `position`.
     *
     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.
     *
     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.
     * @param position  Relative position on axis (0-1)
     * @return Position label
     */
    ValueAxis.prototype.getPositionLabel = function (position) {
        var value = this.positionToValue(position);
        return this.numberFormatter.format(value);
    };
    /**
     * Shows Axis tooltip at specific value
     *
     * @param value Value
     */
    ValueAxis.prototype.showTooltipAt = function (value) {
        this.showTooltipAtPosition(this.valueToPosition(value));
    };
    /**
     * Copies all properties and related data from a different instance of Axis.
     *
     * @param source Source Axis
     */
    ValueAxis.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.min = source.min;
        this.max = source.max;
        this.calculateTotals = source.calculateTotals;
        this._baseValue = source.baseValue;
    };
    Object.defineProperty(ValueAxis.prototype, "syncWithAxis", {
        /**
         * @return Target axis
         */
        get: function () {
            return this.getPropertyValue("syncWithAxis");
        },
        /**
         * Enables syncing of grid with another axis.
         *
         * To enable, set to a reference of the other `ValueAxis`. This axis will try
         * to maintain its scale in such way that its grid matches target axis grid.
         *
         * IMPORTANT #1: At this stage it's an experimental feature. Use it at your
         * own risk, as it may not work in 100% of the scenarios.
         *
         * IMPORTANT #2: `syncWithAxis` is not compatible with `strictMinMax` and
         * `sequencedInterpolation` settings.
         *
         * @since 4.8.1
         * @param  axis  Target axis
         */
        set: function (axis) {
            var _this = this;
            if (this.setPropertyValue("syncWithAxis", axis, true)) {
                if (axis) {
                    this._disposers.push(axis.events.on("extremeschanged", this.handleSelectionExtremesChange, this, false));
                    this._disposers.push(axis.events.on("selectionextremeschanged", this.handleSelectionExtremesChange, this, false));
                    this.events.on("shown", this.handleSelectionExtremesChange, this, false);
                    this.events.on("maxsizechanged", function () {
                        _this.clearCache();
                        _this._disposers.push(registry.events.once("exitframe", function () {
                            _this.handleSelectionExtremesChange();
                        }));
                    }, this, false);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Syncs with a target axis.
     *
     * @param  min  Min
     * @param  max  Max
     * @param  step Step
     */
    ValueAxis.prototype.syncAxes = function (min, max, step) {
        var axis = this.syncWithAxis;
        if (axis) {
            if (!isNumber(min)) {
                min = this.min;
            }
            if (!isNumber(max)) {
                max = this.max;
            }
            if (!isNumber(step)) {
                step = this._step;
            }
            var count = Math.round((axis.maxZoomed - axis.minZoomed) / axis.step);
            var currentCount = Math.round((max - min) / step);
            if (isNumber(count) && isNumber(currentCount)) {
                var synced = false;
                var c = 0;
                var diff = (max - min) * 0.01;
                var omin = min;
                var omax = max;
                var ostep = step;
                while (synced != true) {
                    synced = this.checkSync(omin, omax, ostep, count);
                    c++;
                    if (c > 1000) {
                        synced = true;
                    }
                    if (!synced) {
                        //omin = min - diff * c;
                        if (c / 3 == Math.round(c / 3)) {
                            omin = min - diff * c;
                            if (min >= 0 && omin < 0) {
                                omin = 0;
                            }
                        }
                        else {
                            omax = max + diff * c;
                            if (omax <= 0 && omax > 0) {
                                omax = 0;
                            }
                        }
                        var minMaxStep = this.adjustMinMax(omin, omax, omax - omin, this._gridCount, true);
                        omin = minMaxStep.min;
                        omax = minMaxStep.max;
                        ostep = minMaxStep.step;
                    }
                    else {
                        min = omin;
                        max = omax;
                        step = ostep;
                    }
                }
            }
        }
        return { min: min, max: max, step: step };
    };
    /**
     * Returns `true` if axis needs to be resunced with some other axis.
     */
    ValueAxis.prototype.checkSync = function (min, max, step, count) {
        var currentCount = (max - min) / step;
        for (var i = 1; i < count; i++) {
            if (Math_round(currentCount / i, 1) == count || currentCount * i == count) {
                return true;
            }
        }
        return false;
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    ValueAxis.prototype.processConfig = function (config) {
        if (config) {
            // Set up axes
            if (hasValue(config.syncWithAxis) && isString(config.syncWithAxis)) {
                if (this.map.hasKey(config.syncWithAxis)) {
                    config.syncWithAxis = this.map.getKey(config.syncWithAxis);
                }
                else {
                    this.processingErrors.push("[ValueAxis] No axis with id \"" + config.syncWithAxis + "\" found for `syncWithAxis`");
                    delete config.xAxis;
                }
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    return ValueAxis;
}(Axis_Axis));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ValueAxis"] = ValueAxis_ValueAxis;
registry.registeredClasses["ValueAxisDataItem"] = ValueAxis_ValueAxisDataItem;
//# sourceMappingURL=ValueAxis.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/DateAxisBreak.js
/**
 * DateAxisBreak includes functionality to add breaks on a [[DateAxis]].
 *
 * A "break" can be used to "cut out" specific ranges of the axis scale, e.g.
 * weekends and holidays out of the Date-based axis.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Class used to define breaks for [[DateAxis]].
 *
 * A "break" can be used to "cut out" specific ranges of the axis scale, e.g.
 * weekends and holidays out of the Date-based axis.
 *
 * @see {@link IDateAxisBreakEvents} for a list of available events
 * @see {@link IDateAxisBreakAdapters} for a list of available Adapters
 * @important
 */
var DateAxisBreak_DateAxisBreak = /** @class */ (function (_super) {
    __extends(DateAxisBreak, _super);
    /**
     * Constructor
     */
    function DateAxisBreak() {
        var _this = _super.call(this) || this;
        _this.className = "DateAxisBreak";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(DateAxisBreak.prototype, "startDate", {
        /**
         * @return Start date
         */
        get: function () {
            return this.getPropertyValue("startDate");
        },
        /**
         * Starting date for the break.
         *
         * @param value Start date
         */
        set: function (value) {
            if (this.setPropertyValue("startDate", value)) {
                this.startValue = value.getTime();
                if (this.axis) {
                    this.axis.invalidate();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateAxisBreak.prototype, "endDate", {
        /**
         * @return End date
         */
        get: function () {
            return this.getPropertyValue("endDate");
        },
        /**
         * Ending date for the break.
         *
         * @param value End date
         */
        set: function (value) {
            if (this.setPropertyValue("endDate", value)) {
                this.endValue = value.getTime();
                if (this.axis) {
                    this.axis.invalidate();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    return DateAxisBreak;
}(ValueAxisBreak_ValueAxisBreak));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["DateAxisBreak"] = DateAxisBreak_DateAxisBreak;
//# sourceMappingURL=DateAxisBreak.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/DateAxis.js
/**
 * DateAxis module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */













/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines data item for [[DateAxis]].
 *
 * @see {@link DataItem}
 */
var DateAxis_DateAxisDataItem = /** @class */ (function (_super) {
    __extends(DateAxisDataItem, _super);
    /**
     * Constructor
     */
    function DateAxisDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "DateAxisDataItem";
        _this.applyTheme();
        _this.values.date = {};
        _this.values.endDate = {};
        return _this;
    }
    Object.defineProperty(DateAxisDataItem.prototype, "date", {
        /**
         * @return Date
         */
        get: function () {
            return this.dates["date"];
        },
        /**
         * Date position of the data item.
         *
         * @param date  Date
         */
        set: function (date) {
            this.setDate("date", date);
            this.value = date.getTime();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateAxisDataItem.prototype, "endDate", {
        /**
         * @return End date
         */
        get: function () {
            return this.dates["endDate"];
        },
        /**
         * End date for data item.
         *
         * @param date End date
         */
        set: function (date) {
            this.setDate("endDate", date);
            this.endValue = date.getTime();
        },
        enumerable: true,
        configurable: true
    });
    return DateAxisDataItem;
}(ValueAxis_ValueAxisDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to create a date/time-based axis for the chart.
 *
 * ```TypeScript
 * // Create the axis
 * let xAxis = chart.xAxes.push(new am4charts.DateAxis());
 *
 * // Set settings
 * xAxis.title.text = "Time";
 * ```
 * ```JavaScript
 * // Create the axis
 * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());
 *
 * // Set settings
 * valueAxis.title.text = "Time";
 * ```
 * ```JSON
 * "xAxes": [{
 *   "type": "DateAxis",
 *   "title": {
 *     "text": "Time"
 *   }
 * }]
 * ```
 *
 * @see {@link IDateAxisEvents} for a list of available Events
 * @see {@link IDateAxisAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention
 * @important
 */
var DateAxis_DateAxis = /** @class */ (function (_super) {
    __extends(DateAxis, _super);
    /**
     * Constructor
     */
    function DateAxis() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this._gapBreaks = false;
        /**
         * A list of date/time intervals for Date axis.
         *
         * This define various granularities available for the axis. For example
         * if you have an axis spanning an hour, and space for 6 grid lines / labels
         * the axis will choose the granularity of 10 minutes, displaying a label
         * every 10 minutes.
         *
         * Default intervals:
         *
         * ```JSON
         * [
         *  { timeUnit: "millisecond", count: 1 },
         *  { timeUnit: "millisecond", count: 5 },
         *  { timeUnit: "millisecond", count: 10 },
         *  { timeUnit: "millisecond", count: 50 },
         *  { timeUnit: "millisecond", count: 100 },
         *  { timeUnit: "millisecond", count: 500 },
         *  { timeUnit: "second", count: 1 },
         *  { timeUnit: "second", count: 5 },
         *  { timeUnit: "second", count: 10 },
         *  { timeUnit: "second", count: 30 },
         *  { timeUnit: "minute", count: 1 },
         *  { timeUnit: "minute", count: 5 },
         *  { timeUnit: "minute", count: 10 },
         *  { timeUnit: "minute", count: 30 },
         *  { timeUnit: "hour", count: 1 },
         *  { timeUnit: "hour", count: 3 },
         *  { timeUnit: "hour", count: 6 },
         *  { timeUnit: "hour", count: 12 },
         *  { timeUnit: "day", count: 1 },
         *  { timeUnit: "day", count: 2 },
         *  { timeUnit: "day", count: 3 },
         *  { timeUnit: "day", count: 4 },
         *  { timeUnit: "day", count: 5 },
         *  { timeUnit: "week", count: 1 },
         *  { timeUnit: "month", count: 1 },
         *  { timeUnit: "month", count: 2 },
         *  { timeUnit: "month", count: 3 },
         *  { timeUnit: "month", count: 6 },
         *  { timeUnit: "year", count: 1 },
         *  { timeUnit: "year", count: 2 },
         *  { timeUnit: "year", count: 5 },
         *  { timeUnit: "year", count: 10 },
         *  { timeUnit: "year", count: 50 },
         *  { timeUnit: "year", count: 100 }
         * ]
         * ```
         */
        _this.gridIntervals = new List_List();
        /**
         * If data aggregation is enabled by setting Axis' `groupData = true`, the
         * chart will try to aggregate data items into grouped data items.
         *
         * If there are more data items in selected period than `groupCount`, it will
         * group data items into bigger period.
         *
         * For example seconds might be grouped into 10-second aggregate data items.
         *
         * This setting indicates what group intervals can the chart group to.
         *
         * Default intervals:
         *
         * ```JSON
         * [
         *   { timeUnit: "millisecond", count: 1},
         *   { timeUnit: "millisecond", count: 10 },
         *   { timeUnit: "millisecond", count: 100 },
         *   { timeUnit: "second", count: 1 },
         *   { timeUnit: "second", count: 10 },
         *   { timeUnit: "minute", count: 1 },
         *   { timeUnit: "minute", count: 10 },
         *   { timeUnit: "hour", count: 1 },
         *   { timeUnit: "day", count: 1 },
         *   { timeUnit: "week", count: 1 },
         *   { timeUnit: "month", count: 1 },
         *   { timeUnit: "year", count: 1 }
         * ]
         * ```
         * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.
         *
         * @since 4.7.0
         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.
         */
        _this.groupIntervals = new List_List();
        /**
         * A collection of date formats to use when formatting different time units
         * on Date/time axis.
         *
         * Actual defaults will depend on the language locale set for the chart.
         *
         * To override format for a specific time unit, say days, you need to set
         * the appropriate key to a format string. E.g.:
         *
         * ```TypeScript
         * axis.dateFormats.setKey("day", "MMMM d, yyyy");
         * ```
         * ```JavaScript
         * axis.dateFormats.setKey("day", "MMMM d, yyyy");
         * ```
         * ```JSON
         * "xAxes": [{
         *   "type": "DateAxis",
         *   "dateFormats": {
         *     "day": "MMMM d, yyyy"
         *   }
         * }]
         * ```
         *
         * @see {@link DateFormatter}
         */
        _this.dateFormats = new Dictionary_Dictionary();
        /**
         * These formats are applied to labels that are first in a larger unit.
         *
         * For example, if we have a DateAxis with days on it, the first day of month
         * indicates a break in month - a start of the bigger period.
         *
         * For those labels, `periodChangeDateFormats` are applied instead of
         * `dateFormats`.
         *
         * This allows us implement convenient structures, like instead of:
         *
         * `Jan 1 - Jan 2 - Jan 3 - ...`
         *
         * We can have:
         *
         * `Jan - 1 - 2 - 3 - ...`
         *
         * This can be disabled by setting `markUnitChange = false`.
         */
        _this.periodChangeDateFormats = new Dictionary_Dictionary();
        /**
         * Actual interval (granularity) derived from the actual data.
         */
        _this._baseIntervalReal = { timeUnit: "day", count: 1 };
        /**
         */
        _this._prevSeriesTime = {};
        /**
         * [_minDifference description]
         *
         * @todo Description
         */
        _this._minDifference = {};
        /**
         * @ignore
         */
        _this._firstWeekDay = 1;
        /**
         * A collection of start timestamps to use as axis' min timestamp for
         * particular data item item periods.
         *
         * @since 4.7.0
         * @readonly
         */
        _this.groupMin = {};
        /**
         * A collection of start timestamps to use as axis' max timestamp for
         * particular data item item periods.
         *
         * @since 4.7.0
         * @readonly
         */
        _this.groupMax = {};
        _this.className = "DateAxis";
        _this.setPropertyValue("markUnitChange", true);
        _this.snapTooltip = true;
        _this.tooltipPosition = "pointer";
        _this.setPropertyValue("groupData", false);
        _this.groupCount = 200;
        _this.events.on("parentset", _this.getDFFormatter, _this, false);
        // Translatable defaults are applied in `applyInternalDefaults()`
        // ...
        // Define default intervals
        _this.gridIntervals.pushAll([
            { timeUnit: "millisecond", count: 1 },
            { timeUnit: "millisecond", count: 5 },
            { timeUnit: "millisecond", count: 10 },
            { timeUnit: "millisecond", count: 50 },
            { timeUnit: "millisecond", count: 100 },
            { timeUnit: "millisecond", count: 500 },
            { timeUnit: "second", count: 1 },
            { timeUnit: "second", count: 5 },
            { timeUnit: "second", count: 10 },
            { timeUnit: "second", count: 30 },
            { timeUnit: "minute", count: 1 },
            { timeUnit: "minute", count: 5 },
            { timeUnit: "minute", count: 10 },
            { timeUnit: "minute", count: 15 },
            { timeUnit: "minute", count: 30 },
            { timeUnit: "hour", count: 1 },
            { timeUnit: "hour", count: 3 },
            { timeUnit: "hour", count: 6 },
            { timeUnit: "hour", count: 12 },
            { timeUnit: "day", count: 1 },
            { timeUnit: "day", count: 2 },
            { timeUnit: "day", count: 3 },
            { timeUnit: "day", count: 4 },
            { timeUnit: "day", count: 5 },
            { timeUnit: "week", count: 1 },
            { timeUnit: "month", count: 1 },
            { timeUnit: "month", count: 2 },
            { timeUnit: "month", count: 3 },
            { timeUnit: "month", count: 6 },
            { timeUnit: "year", count: 1 },
            { timeUnit: "year", count: 2 },
            { timeUnit: "year", count: 5 },
            { timeUnit: "year", count: 10 },
            { timeUnit: "year", count: 50 },
            { timeUnit: "year", count: 100 },
            { timeUnit: "year", count: 200 },
            { timeUnit: "year", count: 500 },
            { timeUnit: "year", count: 1000 },
            { timeUnit: "year", count: 2000 },
            { timeUnit: "year", count: 5000 },
            { timeUnit: "year", count: 10000 },
            { timeUnit: "year", count: 100000 }
        ]);
        _this.groupIntervals.pushAll([
            { timeUnit: "millisecond", count: 1 },
            { timeUnit: "millisecond", count: 10 },
            { timeUnit: "millisecond", count: 100 },
            { timeUnit: "second", count: 1 },
            { timeUnit: "second", count: 10 },
            { timeUnit: "minute", count: 1 },
            { timeUnit: "minute", count: 10 },
            { timeUnit: "hour", count: 1 },
            { timeUnit: "day", count: 1 },
            { timeUnit: "week", count: 1 },
            { timeUnit: "month", count: 1 },
            { timeUnit: "year", count: 1 }
        ]);
        // Set field name
        _this.axisFieldName = "date";
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * A function which applies fills to axis cells.
     *
     * Default function fills every second fill. You can set this to a function
     * that follows some other logic.
     *
     * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`
     * property accordingly.
     */
    DateAxis.prototype.fillRule = function (dataItem) {
        var value = dataItem.value;
        var axis = dataItem.component;
        var gridInterval = axis._gridInterval;
        var gridDuration = getDuration(gridInterval.timeUnit, gridInterval.count);
        if (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {
            dataItem.axisFill.__disabled = true;
        }
        else {
            dataItem.axisFill.__disabled = false;
        }
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    DateAxis.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Set default date formats
        if (!this.dateFormats.hasKey("millisecond")) {
            this.dateFormats.setKey("millisecond", this.language.translate("_date_millisecond"));
        }
        if (!this.dateFormats.hasKey("second")) {
            this.dateFormats.setKey("second", this.language.translate("_date_second"));
        }
        if (!this.dateFormats.hasKey("minute")) {
            this.dateFormats.setKey("minute", this.language.translate("_date_minute"));
        }
        if (!this.dateFormats.hasKey("hour")) {
            this.dateFormats.setKey("hour", this.language.translate("_date_hour"));
        }
        if (!this.dateFormats.hasKey("day")) {
            this.dateFormats.setKey("day", this.language.translate("_date_day"));
        }
        if (!this.dateFormats.hasKey("week")) {
            this.dateFormats.setKey("week", this.language.translate("_date_day")); // not a mistake
        }
        if (!this.dateFormats.hasKey("month")) {
            this.dateFormats.setKey("month", this.language.translate("_date_month"));
        }
        if (!this.dateFormats.hasKey("year")) {
            this.dateFormats.setKey("year", this.language.translate("_date_year"));
        }
        if (!this.periodChangeDateFormats.hasKey("millisecond")) {
            this.periodChangeDateFormats.setKey("millisecond", this.language.translate("_date_millisecond"));
        }
        if (!this.periodChangeDateFormats.hasKey("second")) {
            this.periodChangeDateFormats.setKey("second", this.language.translate("_date_second"));
        }
        if (!this.periodChangeDateFormats.hasKey("minute")) {
            this.periodChangeDateFormats.setKey("minute", this.language.translate("_date_minute"));
        }
        if (!this.periodChangeDateFormats.hasKey("hour")) {
            this.periodChangeDateFormats.setKey("hour", this.language.translate("_date_day"));
        }
        if (!this.periodChangeDateFormats.hasKey("day")) {
            this.periodChangeDateFormats.setKey("day", this.language.translate("_date_day"));
        }
        if (!this.periodChangeDateFormats.hasKey("week")) {
            this.periodChangeDateFormats.setKey("week", this.language.translate("_date_day"));
        }
        if (!this.periodChangeDateFormats.hasKey("month")) {
            this.periodChangeDateFormats.setKey("month", this.language.translate("_date_month") + " " + this.language.translate("_date_year"));
        }
    };
    /**
     * Returns a new/empty [[DataItem]] of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    DateAxis.prototype.createDataItem = function () {
        return new DateAxis_DateAxisDataItem();
    };
    /**
     * Returns a new/empty [[AxisBreak]] of the appropriate type.
     *
     * @return Axis break
     */
    DateAxis.prototype.createAxisBreak = function () {
        return new DateAxisBreak_DateAxisBreak();
    };
    /**
     * Validates Axis' data items.
     *
     * @ignore Exclude from docs
     */
    DateAxis.prototype.validateDataItems = function () {
        // allows to keep selection of the same size
        var start = this.start;
        var end = this.end;
        var baseDuration = this.baseDuration;
        var periodCount = (this.max - this.min) / baseDuration;
        this._firstWeekDay = this.getFirstWeekDay();
        this.getDFFormatter();
        _super.prototype.validateDataItems.call(this);
        var mainBaseDuration = getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count);
        this.maxZoomFactor = (this.max - this.min) / mainBaseDuration;
        this._deltaMinMax = this.baseDuration / 2;
        // allows to keep selection of the same size
        var newPeriodCount = (this.max - this.min) / baseDuration;
        start = start + (end - start) * (1 - periodCount / newPeriodCount);
        this.zoom({ start: start, end: end }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor
    };
    /**
     * Handles process after zoom.
     *
     * @ignore Exclude from docs
     * @todo Does nothing?
     */
    DateAxis.prototype.handleSelectionExtremesChange = function () {
    };
    /**
     * Calculates all positions, related to axis as per current zoom.
     *
     * @ignore Exclude from docs
     */
    DateAxis.prototype.calculateZoom = function () {
        var _this = this;
        _super.prototype.calculateZoom.call(this);
        var difference = this.adjustDifference(this._minZoomed, this._maxZoomed);
        var dataSetChanged = false;
        // if data has to be grouped, choose interval and set dataset
        if (this.groupData && hasValue(difference)) {
            var mainBaseInterval = this.mainBaseInterval;
            var modifiedDifference = difference + this.startLocation + (1 - this.endLocation) * this.baseDuration;
            var groupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);
            if (getDuration(groupInterval.timeUnit, groupInterval.count) < getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {
                groupInterval = __assign({}, mainBaseInterval);
            }
            this._groupInterval = groupInterval;
            this._currentDataSetId = groupInterval.timeUnit + groupInterval.count;
            this.series.each(function (series) {
                if (series.baseAxis == _this) {
                    if (series.setDataSet(_this._currentDataSetId)) {
                        dataSetChanged = true;
                    }
                }
            });
        }
        var gridInterval = this.chooseInterval(0, difference, this._gridCount);
        if (getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {
            gridInterval = __assign({}, this.baseInterval);
        }
        this._gridInterval = gridInterval;
        this._nextGridUnit = getNextUnit(gridInterval.timeUnit);
        // the following is needed to avoid grid flickering while scrolling
        this._intervalDuration = getDuration(gridInterval.timeUnit, gridInterval.count);
        this._gridDate = Time_round(new Date(this.minZoomed - getDuration(gridInterval.timeUnit, gridInterval.count)), gridInterval.timeUnit, gridInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min));
        // tell series start/end
        Iterator_each(this.series.iterator(), function (series) {
            if (series.baseAxis == _this) {
                var field_1 = series.getAxisField(_this);
                var minZoomed = Time_round(new Date(_this._minZoomed), _this.baseInterval.timeUnit, _this.baseInterval.count, _this._firstWeekDay, _this._df.utc).getTime();
                var minZoomedStr = minZoomed.toString();
                var startDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(minZoomedStr + series.currentDataSetId);
                var startIndex = 0;
                if (_this.start != 0) {
                    if (startDataItem) {
                        startDataItem = _this.findFirst(startDataItem, minZoomed, field_1);
                        startIndex = startDataItem.index;
                    }
                    else {
                        startIndex = series.dataItems.findClosestIndex(_this._minZoomed, function (x) { return x[field_1]; }, "left");
                    }
                }
                // 1 millisecond is removed so that if only first item is selected, it would not count in the second.
                var baseInterval = _this.baseInterval;
                var maxZoomed = Time_add(Time_round(new Date(_this._maxZoomed), baseInterval.timeUnit, baseInterval.count, _this._firstWeekDay, _this._df.utc), baseInterval.timeUnit, baseInterval.count, _this._df.utc).getTime();
                var maxZoomedStr = maxZoomed.toString();
                var endDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(maxZoomedStr + series.currentDataSetId);
                var endIndex = series.dataItems.length;
                if (_this.end != 1) {
                    if (endDataItem) {
                        endIndex = endDataItem.index;
                    }
                    else {
                        maxZoomed -= 1;
                        endIndex = series.dataItems.findClosestIndex(maxZoomed, function (x) { return x[field_1]; }, "right");
                        if (endIndex < series.dataItems.length) {
                            endIndex++;
                        }
                    }
                }
                series.startIndex = startIndex;
                series.endIndex = endIndex;
                if (!dataSetChanged && series.dataRangeInvalid) {
                    series.validateDataRange();
                }
            }
        });
    };
    DateAxis.prototype.findFirst = function (dataItem, time, key) {
        var index = dataItem.index;
        if (index > 0) {
            var series = dataItem.component;
            var previousDataItem = series.dataItems.getIndex(index - 1);
            var previousDate = previousDataItem[key];
            if (!previousDate || previousDate.getTime() < time) {
                return dataItem;
            }
            else {
                return this.findFirst(previousDataItem, time, key);
            }
        }
        else {
            return dataItem;
        }
    };
    /**
     * (Re)validates data.
     *
     * @ignore Exclude from docs
     */
    DateAxis.prototype.validateData = function () {
        _super.prototype.validateData.call(this);
        if (!isNumber(this.baseInterval.count)) {
            this.baseInterval.count = 1;
        }
    };
    Object.defineProperty(DateAxis.prototype, "minDifference", {
        /**
         * @ignore
         */
        get: function () {
            var _this = this;
            var minDifference = Number.MAX_VALUE;
            this.series.each(function (series) {
                if (minDifference > _this._minDifference[series.uid]) {
                    minDifference = _this._minDifference[series.uid];
                }
            });
            if (minDifference == Number.MAX_VALUE || minDifference == 0) {
                minDifference = getDuration("day");
            }
            return minDifference;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * [dataChangeUpdate description]
     *
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    DateAxis.prototype.seriesDataChangeUpdate = function (series) {
        this._minDifference[series.uid] = Number.MAX_VALUE;
    };
    /**
     * [postProcessSeriesDataItems description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    DateAxis.prototype.postProcessSeriesDataItems = function (series) {
        var _this = this;
        if (series) {
            this.seriesGroupUpdate(series);
        }
        else {
            this.series.each(function (series) {
                _this.seriesGroupUpdate(series);
            });
        }
        this.addEmptyUnitsBreaks();
    };
    DateAxis.prototype.seriesGroupUpdate = function (series) {
        var _this = this;
        if (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {
            series._baseInterval[this.uid] = this.mainBaseInterval;
            series.mainDataSet.each(function (dataItem) {
                _this.postProcessSeriesDataItem(dataItem);
            });
            if (this.groupData) {
                this.groupSeriesData(series);
            }
        }
    };
    /**
     * Calculates series group data.
     *
     * @param  series  Series
     * @ignore
     */
    DateAxis.prototype.groupSeriesData = function (series) {
        var _this = this;
        if (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {
            // make array of intervals which will be used;
            var intervals_1 = [];
            var mainBaseInterval = this.mainBaseInterval;
            var mainIntervalDuration_1 = getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);
            this.groupIntervals.each(function (interval) {
                var intervalDuration = getDuration(interval.timeUnit, interval.count);
                if (intervalDuration > mainIntervalDuration_1 && intervalDuration < (_this.max - _this.min)) {
                    intervals_1.push(interval);
                }
            });
            if (series._dataSets) {
                series._dataSets.each(function (key, dataItems) {
                    dataItems.each(function (dataItem) {
                        dataItem.dispose();
                    });
                    dataItems.clear();
                });
                series._dataSets.clear();
            }
            each(intervals_1, function (interval) {
                //let mainBaseInterval = this._mainBaseInterval;
                var key = "date" + _this.axisLetter;
                // create data set
                var dataSetId = interval.timeUnit + interval.count;
                // todo: check where this clone goes
                var dataSet = new SortedList_OrderedListTemplate(series.mainDataSet.template.clone());
                series.dataSets.setKey(dataSetId, dataSet);
                series.dataGrouped = true;
                var dataItems = series.mainDataSet;
                var previousTime = Number.NEGATIVE_INFINITY;
                var i = 0;
                var newDataItem;
                var dataFields = [];
                Object_each(series.dataFields, function (dfkey, df) {
                    var dfk = dfkey;
                    if (dfk != key && dfk.indexOf("Show") == -1) {
                        dataFields.push(dfk);
                    }
                });
                dataItems.each(function (dataItem) {
                    var date = dataItem.getDate(key);
                    if (date) {
                        var time = date.getTime();
                        var roundedDate = Time_round(new Date(time), interval.timeUnit, interval.count, _this._df.firstDayOfWeek, _this._df.utc);
                        var currentTime = roundedDate.getTime();
                        // changed period								
                        if (previousTime < currentTime) {
                            newDataItem = dataSet.create();
                            newDataItem.dataContext = {};
                            newDataItem.setWorkingLocation("dateX", series.dataItems.template.locations.dateX, 0);
                            newDataItem.setWorkingLocation("openDateX", series.dataItems.template.locations.openDateX, 0);
                            newDataItem.setWorkingLocation("dateY", series.dataItems.template.locations.dateY, 0);
                            newDataItem.setWorkingLocation("openDateY", series.dataItems.template.locations.openDateY, 0);
                            newDataItem.component = series;
                            // other Dates?
                            newDataItem.setDate(key, roundedDate);
                            newDataItem._index = i;
                            i++;
                            each(dataFields, function (vkey) {
                                //let groupFieldName = vkey + "Group";
                                var dvalues = dataItem.values[vkey];
                                if (dvalues) {
                                    var value = dvalues.value;
                                    var values = newDataItem.values[vkey];
                                    if (isNumber(value)) {
                                        values.value = value;
                                        values.workingValue = value;
                                        values.open = value;
                                        values.close = value;
                                        values.low = value;
                                        values.high = value;
                                        values.sum = value;
                                        values.average = value;
                                        values.count = 1;
                                    }
                                    else {
                                        values.count = 0;
                                    }
                                }
                            });
                            _this.postProcessSeriesDataItem(newDataItem, interval);
                            Object_each(series.propertyFields, function (key, fieldValue) {
                                var f = key;
                                var value = dataItem.properties[key];
                                if (hasValue(value)) {
                                    newDataItem.hasProperties = true;
                                    newDataItem.setProperty(f, value);
                                }
                            });
                            newDataItem.groupDataItems = [dataItem];
                            previousTime = currentTime;
                        }
                        else {
                            if (newDataItem) {
                                each(dataFields, function (vkey) {
                                    var groupFieldName = series.groupFields[vkey];
                                    var dvalues = dataItem.values[vkey];
                                    if (dvalues) {
                                        var value = dvalues.value;
                                        if (isNumber(value)) {
                                            var values = newDataItem.values[vkey];
                                            if (!isNumber(values.open)) {
                                                values.open = value;
                                            }
                                            values.close = value;
                                            if (values.low > value || !isNumber(values.low)) {
                                                values.low = value;
                                            }
                                            if (values.high < value || !isNumber(values.high)) {
                                                values.high = value;
                                            }
                                            if (isNumber(values.sum)) {
                                                values.sum += value;
                                            }
                                            else {
                                                values.sum = value;
                                            }
                                            values.count++;
                                            values.average = values.sum / values.count;
                                            if (isNumber(values[groupFieldName])) {
                                                values.value = values[groupFieldName];
                                                values.workingValue = values.value;
                                            }
                                        }
                                    }
                                });
                                Utils_copyProperties(dataItem.properties, newDataItem.properties);
                                Object_each(series.propertyFields, function (key, fieldValue) {
                                    var f = key;
                                    var value = dataItem.properties[key];
                                    if (hasValue(value)) {
                                        newDataItem.hasProperties = true;
                                        newDataItem.setProperty(f, value);
                                    }
                                });
                                newDataItem.groupDataItems.push(dataItem);
                            }
                        }
                    }
                    if (newDataItem) {
                        Utils_copyProperties(dataItem.dataContext, newDataItem.dataContext);
                    }
                });
            });
            this.calculateZoom();
        }
    };
    /**
     * @ignore
     */
    DateAxis.prototype.getDFFormatter = function () {
        this._df = this.dateFormatter;
    };
    /**
     * [postProcessSeriesDataItem description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param dataItem Data item
     */
    DateAxis.prototype.postProcessSeriesDataItem = function (dataItem, interval) {
        var _this = this;
        // we need to do this for all series data items not only added recently, as baseInterval might change
        var intervalID = "";
        if (interval) {
            intervalID = interval.timeUnit + interval.count;
        }
        else {
            interval = this.mainBaseInterval;
        }
        var series = dataItem.component;
        var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);
        Object_each(dataItem.dates, function (key) {
            var date = dataItem.getDate(key);
            var time = date.getTime();
            var startDate = Time_round(new Date(time), interval.timeUnit, interval.count, _this._firstWeekDay, _this._df.utc);
            var startTime = startDate.getTime();
            var endDate = Time_add(new Date(startTime), interval.timeUnit, interval.count, _this._df.utc);
            dataItem.setCalculatedValue(key, startTime, "open");
            dataItem.setCalculatedValue(key, endDate.getTime(), "close");
            dataItemsByAxis.setKey(startTime + intervalID, dataItem);
        });
    };
    /**
     * Collapses empty stretches of date/time scale by creating [[AxisBreak]]
     * elements for them.
     *
     * Can be used to automatically remove strethes without data, like weekends.
     *
     * No, need to call this manually. It will automatically be done if
     * `skipEmptyPeriods = true`.
     *
     * @ignore Exclude from docs
     */
    DateAxis.prototype.addEmptyUnitsBreaks = function () {
        var _this = this;
        if (this.skipEmptyPeriods && isNumber(this.min) && isNumber(this.max)) {
            var timeUnit = this.baseInterval.timeUnit;
            var count = this.baseInterval.count;
            if (this._axisBreaks) {
                this._axisBreaks.clear(); // TODO: what about breaks added by user?
            }
            var date = Time_round(new Date(this.min), timeUnit, count, this._firstWeekDay, this._df.utc);
            var axisBreak = void 0;
            var _loop_1 = function () {
                Time_add(date, timeUnit, count, this_1._df.utc);
                var startTime = date.getTime();
                var startTimeStr = startTime.toString();
                var hasData = contains(this_1.series.iterator(), function (series) {
                    return !!series.dataItemsByAxis.getKey(_this.uid).getKey(startTimeStr + series.currentDataSetId);
                });
                // open break if not yet opened
                if (!hasData) {
                    if (!axisBreak) {
                        axisBreak = this_1.axisBreaks.create();
                        axisBreak.startDate = new Date(startTime);
                        this_1._gapBreaks = true;
                    }
                }
                else {
                    // close if already opened
                    if (axisBreak) {
                        // close at end time minus one millisecond
                        axisBreak.endDate = new Date(startTime - 1);
                        axisBreak = undefined;
                    }
                }
            };
            var this_1 = this;
            while (date.getTime() < this.max - this.baseDuration) {
                _loop_1();
            }
        }
    };
    /**
     * Updates positioning of Axis breaks after something changes.
     *
     * @ignore Exclude from docs
     */
    DateAxis.prototype.fixAxisBreaks = function () {
        var _this = this;
        _super.prototype.fixAxisBreaks.call(this);
        var axisBreaks = this._axisBreaks;
        if (axisBreaks) {
            if (axisBreaks.length > 0) {
                // process breaks
                axisBreaks.each(function (axisBreak) {
                    var breakGridCount = Math.ceil(_this._gridCount * (Math.min(_this.end, axisBreak.endPosition) - Math.max(_this.start, axisBreak.startPosition)) / (_this.end - _this.start));
                    axisBreak.gridInterval = _this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);
                    var gridDate = Time_round(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._firstWeekDay, _this._df.utc);
                    if (gridDate.getTime() > axisBreak.startDate.getTime()) {
                        Time_add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._df.utc);
                    }
                    axisBreak.gridDate = gridDate;
                });
            }
        }
    };
    /**
     * @ignore
     */
    DateAxis.prototype.getFirstWeekDay = function () {
        if (this._df) {
            return this._df.firstDayOfWeek;
        }
        return 1;
    };
    /**
     * [getGridDate description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param date           [description]
     * @param intervalCount  [description]
     * @return [description]
     */
    DateAxis.prototype.getGridDate = function (date, intervalCount) {
        var timeUnit = this._gridInterval.timeUnit;
        var realIntervalCount = this._gridInterval.count;
        // round date
        Time_round(date, timeUnit, 1, this._firstWeekDay, this._df.utc);
        var prevTimestamp = date.getTime();
        var newDate = Time_copy(date);
        // modify date by adding intervalcount
        var timestamp = Time_add(newDate, timeUnit, intervalCount, this._df.utc).getTime();
        // if it's axis break, get first rounded date which is not in a break
        var axisBreak = this.isInBreak(timestamp);
        if (axisBreak && axisBreak.endDate) {
            newDate = new Date(axisBreak.endDate.getTime());
            Time_round(newDate, timeUnit, realIntervalCount, this._firstWeekDay, this._df.utc);
            if (newDate.getTime() < axisBreak.endDate.getTime()) {
                Time_add(newDate, timeUnit, realIntervalCount, this._df.utc);
            }
            timestamp = newDate.getTime();
        }
        // get duration between grid lines with break duration removed
        var durationBreaksRemoved = this.adjustDifference(prevTimestamp, timestamp);
        // calculate how many time units fit to this duration
        var countBreaksRemoved = Math.round(durationBreaksRemoved / getDuration(timeUnit));
        // if less units fit, add one and repeat
        if (countBreaksRemoved < realIntervalCount) {
            return this.getGridDate(date, intervalCount + realIntervalCount);
        }
        return newDate;
    };
    /**
     * [getBreaklessDate description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param axisBreak  [description]
     * @param timeUnit   [description]
     * @param count      [description]
     * @return [description]
     */
    DateAxis.prototype.getBreaklessDate = function (axisBreak, timeUnit, count) {
        var date = new Date(axisBreak.endValue);
        Time_round(date, timeUnit, count, this._firstWeekDay, this._df.utc);
        Time_add(date, timeUnit, count, this._df.utc);
        var timestamp = date.getTime();
        axisBreak = this.isInBreak(timestamp);
        if (axisBreak) {
            return this.getBreaklessDate(axisBreak, timeUnit, count);
        }
        return date;
    };
    /**
     * (Re)validates all Axis elements.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     */
    DateAxis.prototype.validateAxisElements = function () {
        var _this = this;
        if (isNumber(this.max) && isNumber(this.min)) {
            this.calculateZoom();
            // first regular items
            var timestamp = this._gridDate.getTime();
            var timeUnit = this._gridInterval.timeUnit;
            var intervalCount = this._gridInterval.count;
            var prevGridDate = Time_copy(this._gridDate);
            var dataItemsIterator_1 = this._dataItemsIterator;
            this.resetIterators();
            var _loop_2 = function () {
                var date = this_2.getGridDate(Time_copy(prevGridDate), intervalCount);
                timestamp = date.getTime();
                var endDate = Time_copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length
                endDate = Time_add(endDate, timeUnit, intervalCount, this_2._df.utc);
                var format = this_2.dateFormats.getKey(timeUnit);
                if (this_2.markUnitChange && prevGridDate) {
                    if (checkChange(date, prevGridDate, this_2._nextGridUnit, this_2._df.utc)) {
                        if (timeUnit !== "year") {
                            format = this_2.periodChangeDateFormats.getKey(timeUnit);
                        }
                    }
                }
                var text = this_2._df.format(date, format);
                var dataItem = dataItemsIterator_1.find(function (x) { return x.text === text; });
                if (dataItem.__disabled) {
                    dataItem.__disabled = false;
                }
                this_2.appendDataItem(dataItem);
                dataItem.axisBreak = undefined;
                dataItem.date = date;
                dataItem.endDate = endDate;
                dataItem.text = text;
                this_2.validateDataElement(dataItem);
                prevGridDate = date;
            };
            var this_2 = this;
            while (timestamp <= this._maxZoomed) {
                _loop_2();
            }
            // breaks later
            var renderer_1 = this.renderer;
            if (this._axisBreaks) {
                Iterator_each(this._axisBreaks.iterator(), function (axisBreak) {
                    if (axisBreak.breakSize > 0) {
                        var timeUnit_1 = axisBreak.gridInterval.timeUnit;
                        var intervalCount_1 = axisBreak.gridInterval.count;
                        // only add grid if gap is bigger then minGridDistance
                        if (getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance * 4) {
                            var timestamp_1 = axisBreak.gridDate.getTime();
                            var prevGridDate_1;
                            var count = 0;
                            var _loop_3 = function () {
                                var date = Time_copy(axisBreak.gridDate);
                                timestamp_1 = Time_add(date, timeUnit_1, intervalCount_1 * count, _this._df.utc).getTime();
                                count++;
                                if (timestamp_1 > axisBreak.adjustedStartValue && timestamp_1 < axisBreak.adjustedEndValue) {
                                    var endDate = Time_copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length
                                    endDate = Time_add(endDate, timeUnit_1, intervalCount_1, _this._df.utc);
                                    var format = _this.dateFormats.getKey(timeUnit_1);
                                    if (_this.markUnitChange && prevGridDate_1) {
                                        if (checkChange(date, prevGridDate_1, _this._nextGridUnit, _this._df.utc)) {
                                            if (timeUnit_1 !== "year") {
                                                format = _this.periodChangeDateFormats.getKey(timeUnit_1);
                                            }
                                        }
                                    }
                                    var text_1 = _this._df.format(date, format);
                                    var dataItem = dataItemsIterator_1.find(function (x) { return x.text === text_1; });
                                    if (dataItem.__disabled) {
                                        dataItem.__disabled = false;
                                    }
                                    //this.processDataItem(dataItem);
                                    _this.appendDataItem(dataItem);
                                    dataItem.axisBreak = axisBreak;
                                    axisBreak.dataItems.moveValue(dataItem);
                                    dataItem.date = date;
                                    dataItem.endDate = endDate;
                                    dataItem.text = text_1;
                                    prevGridDate_1 = date;
                                    _this.validateDataElement(dataItem);
                                }
                            };
                            while (timestamp_1 <= axisBreak.adjustedMax) {
                                _loop_3();
                            }
                        }
                    }
                });
            }
        }
    };
    /**
     * Validates Axis data item.
     *
     * @ignore Exclude from docs
     * @param dataItem Data item
     */
    DateAxis.prototype.validateDataElement = function (dataItem) {
        dataItem.itemIndex = this._axisItemCount;
        this._axisItemCount++;
        if (isNumber(this.max) && isNumber(this.min)) {
            var renderer = this.renderer;
            var timestamp = dataItem.value;
            var endTimestamp = dataItem.endValue;
            if (!isNumber(endTimestamp)) {
                endTimestamp = timestamp;
            }
            var position = this.valueToPosition(timestamp);
            var endPosition = this.valueToPosition(endTimestamp);
            var fillEndPosition = endPosition;
            if (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {
                endPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);
            }
            dataItem.position = position;
            var tick = dataItem.tick;
            if (tick && !tick.disabled) {
                renderer.updateTickElement(tick, position, endPosition);
            }
            var grid = dataItem.grid;
            if (grid && !grid.disabled) {
                renderer.updateGridElement(grid, position, endPosition);
            }
            var fill = dataItem.axisFill;
            if (fill && !fill.disabled) {
                renderer.updateFillElement(fill, position, fillEndPosition);
                if (!dataItem.isRange) {
                    this.fillRule(dataItem);
                }
            }
            var mask = dataItem.mask;
            if (mask) {
                renderer.updateFillElement(mask, position, endPosition);
            }
            if (dataItem.bullet) {
                renderer.updateBullet(dataItem.bullet, position, endPosition);
            }
            var label = dataItem.label;
            if (label && !label.disabled) {
                var location_1 = label.location;
                if (location_1 == 0) {
                    if (this._gridInterval.count == 1 && this._gridInterval.timeUnit != "week" && !dataItem.isRange) {
                        location_1 = 0.5;
                    }
                    else {
                        location_1 = 0;
                    }
                }
                renderer.updateLabelElement(label, position, endPosition, location_1);
            }
        }
    };
    Object.defineProperty(DateAxis.prototype, "baseDuration", {
        /**
         * A duration in milliseconds of the `baseInterval`.
         *
         * @return Duration (ms)
         */
        get: function () {
            return getDuration(this.baseInterval.timeUnit, this.baseInterval.count);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adjusts min/max values.
     *
     * @ignore Exclude from docs.
     * @todo Description (review)
     * @param min  Min timestamp
     * @param max  Max timestamp
     * @return Adjusted min/max step
     */
    DateAxis.prototype.adjustMinMax = function (min, max) {
        return { min: min, max: max, step: this.baseDuration };
    };
    /**
     * Adjusts the minimum timestamp as per cell start location.
     *
     * @param value  Value
     * @return Adjusted value
     */
    DateAxis.prototype.fixMin = function (value) {
        // like this because months are not equal
        var interval = this.baseInterval;
        var startTime = Time_round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc).getTime();
        var endTime = Time_add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();
        return startTime + (endTime - startTime) * this.startLocation;
    };
    /**
     * Adjusts the maximum timestamp as per cell start location.
     *
     * @param value  Value
     * @return Adjusted value
     */
    DateAxis.prototype.fixMax = function (value) {
        // like this because months are not equal
        var interval = this.baseInterval;
        var startTime = Time_round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc).getTime();
        var endTime = Time_add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();
        return startTime + (endTime - startTime) * this.endLocation;
    };
    /**
     * [chooseInterval description]
     *
     * @ignore Exclude from docs.
     * @todo Description
     * @param index      [description]
     * @param duration   [description]
     * @param gridCount  [description]
     * @return [description]
     */
    DateAxis.prototype.chooseInterval = function (index, duration, gridCount, intervals) {
        if (!intervals) {
            intervals = this.gridIntervals;
        }
        var gridInterval = intervals.getIndex(index);
        var intervalDuration = getDuration(gridInterval.timeUnit, gridInterval.count);
        var lastIndex = intervals.length - 1;
        if (index >= lastIndex) {
            return __assign({}, intervals.getIndex(lastIndex));
        }
        var count = Math.ceil(duration / intervalDuration);
        if (duration < intervalDuration && index > 0) {
            return __assign({}, intervals.getIndex(index - 1));
        }
        if (count <= gridCount) {
            return __assign({}, intervals.getIndex(index));
        }
        else {
            if (index + 1 < intervals.length) {
                return this.chooseInterval(index + 1, duration, gridCount, intervals);
            }
            else {
                return __assign({}, intervals.getIndex(index));
            }
        }
    };
    /**
     * Formats the value according to axis' own [[DateFormatter]].
     *
     * @param value  Source value
     * @return Formatted value
     */
    DateAxis.prototype.formatLabel = function (value) {
        return this._df.format(value);
    };
    /**
     * Converts a Date to an asbolute pixel position within Axis.
     *
     * @param date  Date
     * @return Position (px)
     */
    DateAxis.prototype.dateToPosition = function (date) {
        return this.valueToPosition(date.getTime());
    };
    /**
     * Converts a numeric timestamp or a `Date` to a relative position on axis.
     *
     * @param date  Date or a timestamp
     * @return Relative position
     */
    DateAxis.prototype.anyToPosition = function (date) {
        if (date instanceof Date) {
            return this.dateToPosition(date);
        }
        else {
            return this.valueToPosition(date);
        }
    };
    /**
     * Converts date to orientation point (x, y, angle) on axis
     *
     * @param date Date
     * @return IOrientationPoint
     */
    DateAxis.prototype.dateToPoint = function (date) {
        var position = this.dateToPosition(date);
        var point = this.renderer.positionToPoint(position);
        var angle = this.renderer.positionToAngle(position);
        return { x: point.x, y: point.y, angle: angle };
    };
    /**
     * Converts a numeric value to orientation (x, y, angle) point on axis
     *
     * @param value  Value
     * @return Orientation point
     */
    DateAxis.prototype.anyToPoint = function (date) {
        if (date instanceof Date) {
            return this.dateToPoint(date);
        }
        else {
            return this.valueToPoint(date);
        }
    };
    /**
     * Converts pixel position within Axis to a corresponding Date.
     *
     * @param position  Position (px)
     * @return Date
     */
    DateAxis.prototype.positionToDate = function (position) {
        return new Date(this.positionToValue(position));
    };
    /**
     * Returns the relative position on axis for series' data item's value.
     *
     * @since 4.5.14
     * @param  dataItem  Data item
     * @param  key       Data field to get value from
     * @param  location  Location (0-1)
     * @return           Relative position
     */
    DateAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {
        var value = this.getTimeByLocation(dataItem, key, location);
        //let stack: number = dataItem.getValue("valueX", "stack");
        if (!isNumber(value)) {
            value = this.baseValue;
        }
        var position = this.valueToPosition(value);
        if (range) {
            position = fitToRange(position, range.start, range.end);
        }
        return position;
    };
    /**
     * Returns relative position on axis for series' data item's value.
     *
     * @since 4.5.14
     * @param  dataItem  Data item
     * @param  key       Data field to get value from
     * @param  location  Location (0-1)
     * @return           Relative position
     */
    DateAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {
        var value = this.getTimeByLocation(dataItem, key, location);
        var stack = dataItem.getValue("valueX", "stack");
        if (!isNumber(value)) {
            value = this.baseValue;
        }
        var position = this.valueToPosition(value + stack);
        if (range) {
            position = fitToRange(position, range.start, range.end);
        }
        return position;
    };
    /**
     * Returns an angle for series data item.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem  Data item
     * @param key       Data field to get value from
     * @param location  Location (0-1)
     * @param stackKey  Stack ID
     * @param range Range to fit in
     * @return Angle
     */
    DateAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {
        var value = this.getTimeByLocation(dataItem, key, location);
        var stack = dataItem.getValue(stackKey, "stack");
        if (!isNumber(value)) {
            value = this.baseValue;
        }
        var position = this.valueToPosition(value + stack);
        if (range) {
            position = fitToRange(position, range.start, range.end);
        }
        return this.positionToAngle(position);
    };
    /**
     * [getTimeByLocation description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param dataItem  [description]
     * @param key       [description]
     * @param location  [description]
     * @return [description]
     */
    DateAxis.prototype.getTimeByLocation = function (dataItem, key, location) {
        if (!hasValue(key)) {
            return;
        }
        if (!isNumber(location)) {
            location = dataItem.workingLocations[key];
            if (!isNumber(location)) {
                location = 0;
            }
        }
        var startTime = dataItem.values[key]["open"];
        var endTime = dataItem.values[key]["close"];
        var workingValue = dataItem.values[key].workingValue;
        var value = dataItem.values[key].value;
        var difference = value - workingValue;
        startTime -= difference;
        endTime -= difference;
        if (isNumber(startTime) && isNumber(endTime)) {
            return startTime + (endTime - startTime) * location;
        }
    };
    /**
     * Processes a related series' data item.
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param dataItem  Data item
     */
    DateAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {
        var series = dataItem.component;
        var time;
        var date = dataItem["date" + axisLetter];
        if (isNumber(this.timezoneOffset)) {
            date.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000);
            dataItem.setValue("date" + axisLetter, date.getTime(), 0);
        }
        if (date) {
            time = date.getTime();
        }
        else {
            return;
        }
        var openDate = dataItem["openDate" + axisLetter];
        var prevSeriesTime = this._prevSeriesTime[series.uid];
        var openTime;
        if (openDate) {
            openTime = openDate.getTime();
        }
        if (isNumber(openTime)) {
            var difference = Math.abs(time - openTime);
            if (this._minDifference[series.uid] > difference) {
                this._minDifference[series.uid] = difference;
            }
        }
        var differece = time - prevSeriesTime;
        if (differece > 0) {
            if (this._minDifference[series.uid] > differece) {
                this._minDifference[series.uid] = differece;
            }
        }
        this._prevSeriesTime[series.uid] = time;
        if (series._baseInterval[this.uid]) {
            this.postProcessSeriesDataItem(dataItem);
        }
    };
    /**
     * [updateAxisBySeries description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    DateAxis.prototype.updateAxisBySeries = function () {
        _super.prototype.updateAxisBySeries.call(this);
        var baseInterval = this.chooseInterval(0, this.minDifference, 1);
        // handle short months
        if (this.minDifference >= getDuration("day", 27) && baseInterval.timeUnit == "week") {
            baseInterval.timeUnit = "month";
            baseInterval.count = 1;
        }
        if (baseInterval.timeUnit == "month") {
            if (this.minDifference >= getDuration("day", 29 * 2) && baseInterval.count == 1) {
                baseInterval.count = 2;
            }
            if (this.minDifference >= getDuration("day", 29 * 3) && baseInterval.count == 2) {
                baseInterval.count = 3;
            }
            if (this.minDifference >= getDuration("day", 29 * 6) && baseInterval.count == 5) {
                baseInterval.count = 6;
            }
        }
        // handle daylight saving
        if (this.minDifference >= getDuration("hour", 23) && baseInterval.timeUnit == "hour") {
            baseInterval.timeUnit = "day";
            baseInterval.count = 1;
        }
        if (this.minDifference >= getDuration("week", 1) - getDuration("hour", 1) && baseInterval.timeUnit == "day") {
            baseInterval.timeUnit = "week";
            baseInterval.count = 1;
        }
        if (this.minDifference >= getDuration("year", 1) - getDuration("day", 1.01) && baseInterval.timeUnit == "month") {
            baseInterval.timeUnit = "year";
            baseInterval.count = 1;
        }
        this._baseIntervalReal = baseInterval;
        this._mainBaseInterval = baseInterval;
        // no need to invalidate
    };
    Object.defineProperty(DateAxis.prototype, "baseInterval", {
        /**
         * @return Base interval
         */
        get: function () {
            if (this._groupInterval) {
                return this._groupInterval;
            }
            else if (this._baseInterval) {
                return this._baseInterval;
            }
            else {
                return this._baseIntervalReal;
            }
        },
        /**
         * A base interval (granularity) of data.
         *
         * Used to indicate what are the base units of your data.
         *
         * For example, if you have a data set that has a data point every 5 minutes,
         * you may want to set this to `{ timeUnit: "minute", count: 5 }`.
         *
         * If not set, the Axis will try to determine the setting by its own, looking
         * at actual data.
         *
         * For best results, try to follow these values for `count`:
         *
         * When unit is "month", use 12 / count = round number
         * When unit is "hour", use 24 / count = round number
         * When unit is "second" and "minute", use 60 / count = round number
         *
         * @param timeInterval base interval
         */
        set: function (timeInterval) {
            if (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {
                this._baseInterval = timeInterval;
                this._mainBaseInterval = timeInterval;
                if (!isNumber(timeInterval.count)) {
                    timeInterval.count = 1;
                }
                this.invalidate();
                this.postProcessSeriesDataItems();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateAxis.prototype, "mainBaseInterval", {
        /**
         * Indicates granularity of the data of source (unaggregated) data.
         *
         * @since 4.7.0
         * @return Granularity of the main data set
         */
        get: function () {
            if (this._baseInterval) {
                return this._baseInterval;
            }
            else if (this._mainBaseInterval) {
                return this._mainBaseInterval;
            }
            else {
                return this._baseIntervalReal;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateAxis.prototype, "skipEmptyPeriods", {
        /**
         * @return Remove empty stretches of time?
         */
        get: function () {
            return this.getPropertyValue("skipEmptyPeriods");
        },
        /**
         * If enabled, axis will automatically collapse empty (without data points)
         * periods of time, i.e. weekends.
         *
         * An "empty" period is considered a stretch of time in the length of current
         * `baseInterval` without a single data point in it.
         *
         * For each such empty period, axis will automatically create an
         * [[AxisBreak]]. By default they will be invisible. You can still configure
         * them by accessing `axis.breaks.template`.
         *
         * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).
         *
         * Important notes:
         * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.
         * * Using this feature affects performance. Use only if you need it.
         * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.
         * * Some axis label overlapping might happen.
         * * This setting is not compatible with `groupData = true`.
         *
         * @default false
         * @param value  Remove empty stretches of time?
         */
        set: function (value) {
            if (value) {
                var breakTemplate = this.axisBreaks.template;
                breakTemplate.startLine.disabled = true;
                breakTemplate.endLine.disabled = true;
                breakTemplate.fillShape.disabled = true;
                breakTemplate.breakSize = 0;
            }
            else {
                if (this._gapBreaks) {
                    this.axisBreaks.clear();
                    this._gapBreaks = false;
                }
            }
            if (this.setPropertyValue("skipEmptyPeriods", value)) {
                this.invalidate();
                this.postProcessSeriesDataItems();
                this.invalidateSeries();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateAxis.prototype, "tooltipDateFormat", {
        /**
         * @return Date format
         */
        get: function () {
            return this.getPropertyValue("tooltipDateFormat");
        },
        /**
         * A special date format to apply axis tooltips.
         *
         * Will use same format as for labels, if not set.
         *
         * @param value  Date format
         */
        set: function (value) {
            this.setPropertyValue("tooltipDateFormat", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateAxis.prototype, "markUnitChange", {
        /**
         * @return Use different format for period beginning?
         */
        get: function () {
            return this.getPropertyValue("markUnitChange");
        },
        /**
         * Use `periodChangeDateFormats` to apply different formats to the first
         * label in bigger time unit.
         *
         * @default true
         * @param value  Use different format for period beginning?
         */
        set: function (value) {
            if (this.setPropertyValue("markUnitChange", value)) {
                this.invalidateData();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns text to show in a tooltip, based on specific relative position
     * within axis.
     *
     * The label will be formatted as per [[DateFormatter]] set for the whole
     * chart, or explicitly for this Axis.
     *
     * @ignore Exclude from docs
     * @param position  Position
     * @return Label (formatted date)
     */
    DateAxis.prototype.getTooltipText = function (position) {
        var text;
        var date = this.positionToDate(position);
        date = Time_round(date, this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min));
        this.tooltipDate = date;
        if (hasValue(this.tooltipDateFormat)) {
            text = this._df.format(date, this.tooltipDateFormat);
        }
        else {
            var dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);
            if (dateFormat) {
                text = this._df.format(date, dateFormat);
            }
            else {
                text = this.getPositionLabel(position);
            }
        }
        if (!this._adapterO) {
            return text;
        }
        else {
            return this._adapterO.apply("getTooltipText", text);
        }
    };
    /**
     * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)
     *
     * @ignore Exclude from docs
     * @param position Source position
     * @param location  Location in the cell
     * @return Adjusted position
     */
    DateAxis.prototype.roundPosition = function (position, location, axisLocation) {
        var baseInterval = this.baseInterval;
        var timeUnit = baseInterval.timeUnit;
        var count = baseInterval.count;
        var date = this.positionToDate(position);
        Time_round(date, timeUnit, count, this._firstWeekDay, this._df.utc);
        if (location > 0) {
            Time_add(date, timeUnit, location * count, this._df.utc);
        }
        if (axisLocation > 0 && axisLocation < 1) {
            date.setTime(date.getTime() + this.baseDuration * axisLocation);
        }
        if (this.isInBreak(date.getTime())) {
            while (date.getTime() < this.max) {
                Time_add(date, timeUnit, count, this._df.utc);
                if (!this.isInBreak(date.getTime())) {
                    break;
                }
            }
        }
        return this.dateToPosition(date);
    };
    /**
     * Returns an relative position of the start of the cell (period), that specific position value falls into.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param position  Relative position
     * @return Cell start relative position
     */
    DateAxis.prototype.getCellStartPosition = function (position) {
        return this.roundPosition(position, 0);
    };
    /**
     * Returns an relative position of the end of the cell (period), that specific position value falls into.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param position  Relative position
     * @return Cell end relative position
     */
    DateAxis.prototype.getCellEndPosition = function (position) {
        return this.roundPosition(position, 1);
        //return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));
    };
    /**
     * Returns a Series data item that corresponds to the specific pixel position
     * of the Axis.
     *
     * If `findNearest` (third parameter) is set to `true`, the method will try
     * to locate nearest available data item if none is found directly under
     * `position`.
     *
     * @param series       Series
     * @param position     Position (px)
     * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position
     * @return Data item
     */
    DateAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {
        var value = this.positionToValue(position);
        var date = Time_round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc);
        var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);
        var dataItem = dataItemsByAxis.getKey(date.getTime().toString());
        // todo:  alternatively we can find closiest here
        if (!dataItem && findNearest) {
            var key_1;
            if (this.axisLetter == "Y") {
                key_1 = "dateY";
            }
            else {
                key_1 = "dateX";
            }
            dataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), function (x) {
                if (x[key_1]) {
                    return x[key_1].getTime();
                }
                else {
                    return -Infinity;
                }
            }, "any"));
        }
        return dataItem;
    };
    /**
     * Returns a formatted date based on position in axis scale.
     *
     * Please note that `position` represents position within axis which may be
     * zoomed and not correspond to Cursor's `position`.
     *
     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.
     *
     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.
     * @param position  Relative position on axis (0-1)
     * @return Position label
     */
    DateAxis.prototype.getPositionLabel = function (position) {
        // @todo Better format recognition
        var date = this.positionToDate(position);
        return this._df.format(date, this.getCurrentLabelFormat());
    };
    /**
     * Returns label date format based on currently used time units
     *
     * @return Format
     */
    DateAxis.prototype.getCurrentLabelFormat = function () {
        return this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : "day");
    };
    /**
     * Initializes an Axis renderer.
     *
     * @ignore Exclude from docs
     */
    DateAxis.prototype.initRenderer = function () {
        _super.prototype.initRenderer.call(this);
        var renderer = this.renderer;
        if (renderer) {
            // Set defaults
            renderer.ticks.template.location = 0;
            renderer.grid.template.location = 0;
            renderer.labels.template.location = 0;
            renderer.baseGrid.disabled = true;
        }
    };
    Object.defineProperty(DateAxis.prototype, "basePoint", {
        /**
         * Coordinates of the actual axis start.
         *
         * @ignore Exclude from docs
         * @return Base point
         */
        get: function () {
            return { x: 0, y: 0 };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    DateAxis.prototype.animateMinMax = function (min, max) {
        var _this = this;
        var animation = this.animate([{ property: "_minAdjusted", from: this._minAdjusted, to: min }, { property: "_maxAdjusted", from: this._maxAdjusted, to: max }], this.rangeChangeDuration, this.rangeChangeEasing);
        animation.events.on("animationprogress", function () {
            _this.dispatch("extremeschanged");
        });
        return animation;
    };
    /**
     * Invalidates axis data items when series extremes change
     */
    DateAxis.prototype.handleExtremesChange = function () {
        _super.prototype.handleExtremesChange.call(this);
        if (this.groupData) {
            var id = this.baseInterval.timeUnit + this.baseInterval.count;
            this.groupMin[id] = this._finalMin;
            this.groupMax[id] = this._finalMax;
        }
    };
    /**
     * Zooms axis to specific Dates.
     *
     * @param startDate       Start date
     * @param endValue        End date
     * @param skipRangeEvent  Do not invoke events
     * @param instantly       Do not play zoom animations
     */
    DateAxis.prototype.zoomToDates = function (startDate, endDate, skipRangeEvent, instantly, adjust) {
        startDate = this._df.parse(startDate);
        endDate = this._df.parse(endDate);
        this.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);
    };
    /**
     * Zooms axis to specific values.
     *
     * @param startValue      Start value
     * @param endValue        End value
     * @param skipRangeEvent  Do not invoke events
     * @param instantly       Do not play zoom animations
     */
    DateAxis.prototype.zoomToValues = function (startValue, endValue, skipRangeEvent, instantly, adjust) {
        var _this = this;
        if (!this.groupData) {
            var start = (startValue - this.min) / (this.max - this.min);
            var end = (endValue - this.min) / (this.max - this.min);
            this.zoom({ start: start, end: end }, skipRangeEvent, instantly);
        }
        else {
            var difference = this.adjustDifference(startValue, endValue);
            var isEnd = false;
            if (endValue == this.max) {
                isEnd = true;
            }
            var isStart = false;
            if (startValue == this.min) {
                isStart = true;
            }
            if (hasValue(difference)) {
                var mainBaseInterval = this.mainBaseInterval;
                var groupInterval_1 = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);
                if ((groupInterval_1.timeUnit == mainBaseInterval.timeUnit && groupInterval_1.count < mainBaseInterval.count) || getDuration(groupInterval_1.timeUnit, 1) < getDuration(mainBaseInterval.timeUnit, 1)) {
                    groupInterval_1 = __assign({}, mainBaseInterval);
                }
                var id = groupInterval_1.timeUnit + groupInterval_1.count;
                var min_1 = this.groupMin[id];
                var max_1 = this.groupMax[id];
                if (!isNumber(min_1) || !isNumber(max_1)) {
                    min_1 = Number.POSITIVE_INFINITY;
                    max_1 = Number.NEGATIVE_INFINITY;
                    this.series.each(function (series) {
                        var seriesMin = series.min(_this);
                        var seriesMax = series.max(_this);
                        if (series._dataSets) {
                            var ds = series._dataSets.getKey(groupInterval_1.timeUnit + groupInterval_1.count);
                            if (ds) {
                                var mindi = ds.getIndex(0);
                                var maxdi = ds.getIndex(ds.length - 1);
                                if (mindi) {
                                    if (series.xAxis == _this) {
                                        seriesMin = mindi.dateX.getTime();
                                    }
                                    else if (series.yAxis == _this) {
                                        seriesMin = mindi.dateY.getTime();
                                    }
                                }
                                if (maxdi) {
                                    if (series.xAxis == _this) {
                                        seriesMax = maxdi.dateX.getTime();
                                    }
                                    else if (series.yAxis == _this) {
                                        seriesMax = maxdi.dateY.getTime();
                                    }
                                }
                            }
                        }
                        seriesMax = Time_round(Time_add(new Date(seriesMax), groupInterval_1.timeUnit, 1, _this._df.utc), groupInterval_1.timeUnit, 1, _this._df.firstDayOfWeek, _this._df.utc).getTime();
                        if (seriesMin < min_1) {
                            min_1 = seriesMin;
                        }
                        if (seriesMax > max_1) {
                            max_1 = seriesMax;
                        }
                    });
                    this.groupMin[id] = min_1;
                    this.groupMax[id] = max_1;
                }
                startValue = fitToRange(startValue, min_1, max_1);
                endValue = fitToRange(endValue, min_1, max_1);
                if (adjust) {
                    if (isEnd) {
                        startValue = endValue - difference;
                        startValue = fitToRange(startValue, min_1, max_1);
                    }
                    if (isStart) {
                        endValue = startValue + difference;
                        endValue = fitToRange(endValue, min_1, max_1);
                    }
                }
                var start = (startValue - min_1) / (max_1 - min_1);
                var end = (endValue - min_1) / (max_1 - min_1);
                this.zoom({ start: start, end: end }, skipRangeEvent, instantly);
            }
        }
    };
    /**
     * Adds `baseInterval` to "as is" fields.
     *
     * @param field  Field name
     * @return Assign as is?
     */
    DateAxis.prototype.asIs = function (field) {
        return field == "baseInterval" || _super.prototype.asIs.call(this, field);
    };
    /**
     * Copies all properties and related data from a different instance of Axis.
     *
     * @param source Source Axis
     */
    DateAxis.prototype.copyFrom = function (source) {
        var _this = this;
        _super.prototype.copyFrom.call(this, source);
        this.dateFormats = source.dateFormats;
        this.periodChangeDateFormats = source.periodChangeDateFormats;
        this.groupIntervals.clear();
        source.groupIntervals.each(function (interval) {
            _this.groupIntervals.push(__assign({}, interval));
        });
        this.gridIntervals.clear();
        source.gridIntervals.each(function (interval) {
            _this.gridIntervals.push(__assign({}, interval));
        });
        if (source._baseInterval) {
            this.baseInterval = source._baseInterval;
        }
    };
    /**
     * Shows Axis tooltip at specific relative position within Axis. (0-1)
     *
     * @param position Position (0-1)
     * @param local or global position
     */
    DateAxis.prototype.showTooltipAtPosition = function (position, local) {
        var _this = this;
        if (!local) {
            position = this.toAxisPosition(position);
        }
        if (this.snapTooltip) {
            // rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)
            var actualDate = this.positionToDate(position); //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc);
            var actualTime_1 = actualDate.getTime();
            var closestDate_1;
            this.series.each(function (series) {
                if (series.baseAxis == _this) {
                    var dataItem = _this.getSeriesDataItem(series, position, true);
                    if (dataItem) {
                        var date = void 0;
                        if (series.xAxis == _this) {
                            date = dataItem.dateX;
                        }
                        if (series.yAxis == _this) {
                            date = dataItem.dateY;
                        }
                        if (!closestDate_1) {
                            closestDate_1 = date;
                        }
                        else {
                            if (Math.abs(closestDate_1.getTime() - actualTime_1) > Math.abs(date.getTime() - actualTime_1)) {
                                closestDate_1 = date;
                            }
                        }
                    }
                }
            });
            if (closestDate_1) {
                var closestTime_1 = closestDate_1.getTime();
                closestDate_1 = Time_round(new Date(closestTime_1), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc);
                closestTime_1 = closestDate_1.getTime();
                var tooltipLocation = this.renderer.tooltipLocation;
                if (tooltipLocation == 0) {
                    tooltipLocation = 0.0001;
                }
                closestDate_1 = new Date(closestDate_1.getTime() + this.baseDuration * tooltipLocation);
                position = this.dateToPosition(closestDate_1);
                if (this.chart.cursor && this.chart.cursor.snapToSeries) {
                    //void
                }
                else {
                    this.series.each(function (series) {
                        var dataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(closestTime_1 + series.currentDataSetId);
                        var point = series.showTooltipAtDataItem(dataItem);
                        if (point) {
                            _this.chart._seriesPoints.push({ series: series, point: point });
                        }
                        else {
                            // check, otherwise column tooltip will be hidden
                            if (series.tooltipText || series.tooltipHTML) {
                                series.hideTooltip();
                            }
                        }
                    });
                }
                //this.chart.sortSeriesTooltips(seriesPoints);
            }
        }
        _super.prototype.showTooltipAtPosition.call(this, position, true);
    };
    Object.defineProperty(DateAxis.prototype, "snapTooltip", {
        /**
         * @return Should snap?
         */
        get: function () {
            return this.getPropertyValue("snapTooltip");
        },
        /**
         * Should the nearest tooltip be shown if no data item is found on the
         * current cursor position.
         *
         * @default true
         * @param value  Should snap?
         */
        set: function (value) {
            this.setPropertyValue("snapTooltip", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateAxis.prototype, "groupData", {
        /**
         * @return Group data points?
         */
        get: function () {
            return this.getPropertyValue("groupData");
        },
        /**
         * Indicates if data should be aggregated to composide data items if there
         * are more data items in selected range than `groupCount`.
         *
         * Grouping will occur automatically, based on current selection range, and
         * will change dynamically when user zooms in/out the chart.
         *
         * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].
         *
         * The related [[XYSeries]] also needs to be set up to take advantage of, by
         * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).
         *
         * The group intervals to aggregate data to is defined by `groupIntervals`
         * property.
         *
         * ```TypeScript
         * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());
         * dateAxis.groupData = true;
         *
         * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());
         *
         * let series = chart.series.push(new am4charts.LineSeries());
         * series.dataFields.dateX = "date";
         * series.dataFields.valueY = "value";
         * series.groupFields.valueY = "average";
         * ```
         * ```JavaScript
         * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());
         * dateAxis.groupData = true;
         *
         * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());
         *
         * var series = chart.series.push(new am4charts.LineSeries());
         * series.dataFields.dateX = "date";
         * series.dataFields.valueY = "value";
         * series.groupFields.valueY = "average";
         * ```
         * ```JSON
         * {
         *   // ...
         *   "xAxes": [{
         *     "type": "DateAxis",
         *     "groupData": true
         *   }],
         *   "yAxes": [{
         *     "type": "ValueAxis"
         *   }],
         *   "series": [{
         *     "type": "LineSeries",
         *     "dataFields": {
         *       "dateX": "date",
         *       "valueY": "value"
         *     },
         *     "groupFields": {
         *       "valueY": "average"
         *     }
         *   }]
         * }
         * ```
         *
         * @default false
         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.
         * @since 4.7.0
         * @param  value  Group data points?
         */
        set: function (value) {
            var _this = this;
            if (this.setPropertyValue("groupData", value)) {
                this.series.each(function (series) {
                    series.setDataSet("");
                    if (value && !series.dataGrouped && series.inited) {
                        series._baseInterval[_this.uid] = _this.mainBaseInterval;
                        _this.groupSeriesData(series);
                    }
                });
                this._currentDataSetId = "";
                this._groupInterval = undefined;
                this.invalidate();
                this.invalidateSeries();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateAxis.prototype, "groupCount", {
        /**
         * @return Number of data items
         */
        get: function () {
            return this.getPropertyValue("groupCount");
        },
        /**
         * Indicates threshold of data items in selected range at which to start
         * aggregating data items if `groupData = true`.
         *
         * @default 200
         * @since 4.7.0
         * @param  value  Number of data items
         */
        set: function (value) {
            this.setPropertyValue("groupCount", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateAxis.prototype, "timezoneOffset", {
        /**
         * @todo Timezone offset in minutes
         */
        get: function () {
            return this.getPropertyValue("timezoneOffset");
        },
        /**
         *
         * Indicates by how many minutes the timestamps in your data are offset from GMT.
         * This is useful when you have timestamps as your data and you want all the users to see
         * the same result and not the time which was at users's location at the given timestamp.
         * Note, you do not need to set timezoneOffset both here and on DateFormatter, as this will
         * distort the result.
         *
         * @default undefined
         * @since 4.8.5
         * @param  value Time zone offset in minutes
         */
        set: function (value) {
            this.setPropertyValue("timezoneOffset", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateAxis.prototype, "gridInterval", {
        /**
         * Current grid interval.
         *
         * @return Grid interval
         */
        get: function () {
            return this._gridInterval;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    DateAxis.prototype.makeGap = function (dataItem, previous) {
        var series = dataItem.component;
        if (dataItem && previous) {
            if (!series.connect && isNumber(series.autoGapCount)) {
                if (series.baseAxis == this) {
                    var date = dataItem.dates["date" + this.axisLetter];
                    var prevDate = previous.dates["date" + this.axisLetter];
                    if (date && prevDate) {
                        var time = date.getTime();
                        var prevTime = prevDate.getTime();
                        if (time - prevTime > series.autoGapCount * this.baseDuration) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    };
    Object.defineProperty(DateAxis.prototype, "baseValue", {
        /**
         * @return base value
         */
        get: function () {
            return this.min;
        },
        enumerable: true,
        configurable: true
    });
    return DateAxis;
}(ValueAxis_ValueAxis));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["DateAxis"] = DateAxis_DateAxis;
registry.registeredClasses["DateAxisDataItem"] = DateAxis_DateAxisDataItem;
//# sourceMappingURL=DateAxis.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererX.js
/**
 * Module, defining Axis Renderer for vertical axes.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */











/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A renderer for horizontal axis.
 *
 * @see {@link IAxisRendererEvents} for a list of available events
 * @see {@link IAxisRendererAdapters} for a list of available Adapters
 */
var AxisRendererX_AxisRendererX = /** @class */ (function (_super) {
    __extends(AxisRendererX, _super);
    /**
     * Constructor.
     *
     * @param axis Related axis
     */
    function AxisRendererX() {
        var _this = _super.call(this) || this;
        _this.className = "AxisRendererX";
        _this.minGridDistance = 120;
        _this.opposite = false;
        _this.rotation = 0;
        _this.width = Percent_percent(100);
        _this.labels.template.horizontalCenter = "middle";
        _this.applyTheme();
        return _this;
    }
    /**
    * @ignore
    */
    AxisRendererX.prototype.setAxis = function (axis) {
        _super.prototype.setAxis.call(this, axis);
        axis.layout = "vertical";
    };
    /**
     * @ignore
     */
    AxisRendererX.prototype.updateGridContainer = function () {
        var axis = this.axis;
        if (axis) {
            var gridContainer = this.gridContainer;
            gridContainer.x = axis.pixelX;
            gridContainer.width = axis.axisLength;
        }
    };
    /**
     * Called when rendered is attached to an Axis, as well as a property of
     * Axis that might affect the appearance is updated.
     *
     * E.g. `axis.opposite`, `axis.inside`, etc.
     *
     * This method is called **before** draw, so that any related setting
     * changed in this method can be changed.
     *
     * @todo Description (review)
     * @ignore Exclude from docs
     */
    AxisRendererX.prototype.processRenderer = function () {
        _super.prototype.processRenderer.call(this);
        // can not do this in init, as axis is set later
        var axis = this.axis;
        if (axis) {
            if (!(axis.width instanceof Percent)) {
                axis.width = Percent_percent(100);
            }
            // @todo Is thi sneeded?
            used(this.line);
            var title = axis.title;
            title.rotation = 0;
            title.align = "center";
            if (this.opposite) {
                this.line.toFront();
                title.toBack();
            }
            else {
                title.toFront();
                this.toBack();
                this.line.toBack();
            }
        }
    };
    /**
     * Updates some of the Axis tooltip's visual properties, related to
     * rendering of the Axis.
     *
     * @todo Description (review)
     * @ignore Exclude from docs
     */
    AxisRendererX.prototype.updateTooltip = function () {
        var axis = this.axis;
        if (axis) {
            var bigNum = 1000;
            var bbx = this.line.pixelX;
            var bby = this.line.pixelY;
            var bbw = this.axisLength;
            var bbh = bigNum;
            // top
            if (this.opposite) {
                if (!this.inside) {
                    bby = -bigNum;
                    bbh = bigNum;
                }
            }
            // bottom
            else {
                if (this.inside) {
                    bby = -bigNum;
                    bbh = bigNum;
                }
            }
            this.axis.updateTooltip("vertical", { x: bbx, y: bby, width: bbw, height: bbh });
        }
    };
    /**
     * Updates and positions a label element.
     *
     * @ignore Exclude from docs
     * @param label        Label element
     * @param position     Starting position
     * @param endPosition  Ending position
     */
    AxisRendererX.prototype.updateLabelElement = function (label, position, endPosition, location) {
        if (!hasValue(location)) {
            location = label.location;
        }
        position = position + (endPosition - position) * location;
        var point = this.positionToPoint(position);
        label.isMeasured = !label.inside;
        var deltaY = 0;
        var verticalCenter;
        var maxHeight = this.gridContainer.maxHeight;
        if (this.opposite) {
            if (label.inside) {
                verticalCenter = "top";
                if (label.valign == "bottom") {
                    deltaY = maxHeight;
                    verticalCenter = "bottom";
                }
                if (label.valign == "middle") {
                    deltaY = maxHeight / 2;
                    verticalCenter = "middle";
                }
            }
            else {
                verticalCenter = "bottom";
            }
            point.y = deltaY;
        }
        else {
            if (label.inside) {
                verticalCenter = "bottom";
                if (label.valign == "top") {
                    deltaY = -maxHeight;
                    verticalCenter = "top";
                }
                if (label.valign == "middle") {
                    deltaY = -maxHeight / 2;
                    verticalCenter = "middle";
                }
            }
            else {
                verticalCenter = "top";
            }
            point.y += deltaY;
        }
        if (label.rotation == 0) {
            // Apply fuzzy logic to verticalCenter only if labels are not rotated
            label.verticalCenter = verticalCenter;
        }
        this.positionItem(label, point);
        this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);
    };
    Object.defineProperty(AxisRendererX.prototype, "axisLength", {
        /**
         * Returns actual length of the Axis, in pixels.
         *
         * @return Length (px)
         */
        get: function () {
            var axis = this.axis;
            return (axis.measuredWidth - axis.pixelPaddingRight - axis.pixelPaddingLeft) || 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts relative position on axis to point coordinates.
     *
     * @param position  Position (0-1)
     * @param position2  Position (0-1) Position on the second axis
     * @return Point
     */
    AxisRendererX.prototype.positionToPoint = function (position, position2) {
        return { x: this.positionToCoordinate(position), y: 0 };
    };
    /**
     * Converts a point at specific coordinates to a relative position (0-1)
     * on the axis.
     *
     * @param point  Point
     * @return Position (0-1)
     */
    AxisRendererX.prototype.pointToPosition = function (point) {
        return this.coordinateToPosition(point.x, point.y);
    };
    /**
     * [getPositionRangePath description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param startPosition  Starting position
     * @param endPosition    End position
     * @return SVG path
     */
    AxisRendererX.prototype.getPositionRangePath = function (startPosition, endPosition) {
        var x1 = fitToRange(this.positionToCoordinate(startPosition), 0, this.axisLength);
        var x2 = fitToRange(this.positionToCoordinate(endPosition), 0, this.axisLength);
        var w = Math.abs(x2 - x1);
        var h = this.getHeight();
        var x = Math.min(x1, x2);
        var y = 0;
        return rectToPath({
            x: x,
            y: y,
            width: w,
            height: h
        }, true);
    };
    /**
     * Updates and positions an axis break element.
     *
     * @ignore Exclude from docs
     * @param axisBreak Break element
     */
    AxisRendererX.prototype.updateBreakElement = function (axisBreak) {
        _super.prototype.updateBreakElement.call(this, axisBreak);
        var startLine = axisBreak.startLine;
        var endLine = axisBreak.endLine;
        var fillShape = axisBreak.fillShape;
        var startPoint = axisBreak.startPoint;
        var endPoint = axisBreak.endPoint;
        var y1 = axisBreak.pixelMarginLeft;
        var y2 = this.getHeight() - axisBreak.pixelMarginTop - axisBreak.pixelMarginBottom;
        startPoint.x = fitToRange(startPoint.x, -1, this.axisLength + 1);
        endPoint.x = fitToRange(endPoint.x, -1, this.axisLength + 1);
        if (startPoint.x == endPoint.x && (startPoint.x < 0 || startPoint.x > this.axisLength)) {
            axisBreak.fillShape.__disabled = true;
        }
        else {
            axisBreak.fillShape.__disabled = false;
        }
        startLine.y = y1;
        startLine.width = 0;
        startLine.height = y2;
        endLine.y = y1;
        endLine.width = 0;
        endLine.height = y2;
        fillShape.height = y2;
        fillShape.width = Math.abs(endPoint.x - startPoint.x);
        fillShape.y = y1;
        fillShape.x = startPoint.x;
    };
    /**
     * Updates and positions a grid element.
     *
     * @ignore Exclude from docs
     * @param grid         Grid element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererX.prototype.updateGridElement = function (grid, position, endPosition) {
        position = position + (endPosition - position) * grid.location;
        var point = this.positionToPoint(position);
        //point.x = $utils.spritePointToSprite({x:point.x, y:0}, this, this.gridContainer).x;
        grid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: this.getHeight() });
        this.positionItem(grid, point);
        this.toggleVisibility(grid, position, 0, 1);
    };
    /**
     * Updates and positions a tick element.
     *
     * @ignore Exclude from docs
     * @param tick         Tick element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererX.prototype.updateTickElement = function (tick, position, endPosition) {
        position = position + (endPosition - position) * tick.location;
        var point = this.positionToPoint(position);
        var tickLength = tick.length;
        point.y = spritePointToSprite({ x: 0, y: this.line.pixelY }, this.line.parent, this.gridContainer).y;
        if (this.opposite) {
            tickLength *= (tick.inside ? 1 : -1);
        }
        else {
            tickLength *= (tick.inside ? -1 : 1);
        }
        tick.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: tickLength });
        this.positionItem(tick, point);
        this.toggleVisibility(tick, position, 0, 1);
    };
    /**
     * Updates and positions the axis line element.
     *
     * @ignore Exclude from docs
     */
    AxisRendererX.prototype.updateAxisLine = function () {
        this.line.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: this.axisLength, y: 0 });
    };
    /**
     * Updates and positions the base grid element.
     *
     * @ignore Exclude from docs
     */
    AxisRendererX.prototype.updateBaseGridElement = function () {
        _super.prototype.updateBaseGridElement.call(this);
        var axis = this.axis;
        var h = this.getHeight();
        var w = this.axisLength;
        var baseGrid = this.baseGrid;
        var x = axis.basePoint.x;
        if (x < -0.2 || x > w + 0.2) {
            baseGrid.hide(0);
        }
        else {
            var y = spritePointToSprite({ x: 0, y: 0 }, this.gridContainer, baseGrid.parent).y;
            baseGrid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: h });
            baseGrid.moveTo({ x: x, y: y });
            baseGrid.show(0);
        }
    };
    /**
     * Creates visual elements for and axis break.
     *
     * @ignore Exclude from docs
     * @param axisBreak Axis break
     */
    AxisRendererX.prototype.createBreakSprites = function (axisBreak) {
        axisBreak.startLine = new WavedLine_WavedLine();
        axisBreak.endLine = new WavedLine_WavedLine();
        var wavedRectangle = new WavedRectangle_WavedRectangle();
        wavedRectangle.setWavedSides(false, true, false, true);
        axisBreak.fillShape = wavedRectangle;
    };
    /**
     * @ignore
     */
    AxisRendererX.prototype.toAxisPosition = function (value) {
        var inversedPosition = value;
        var axis = this.axis;
        if (axis) {
            var relativePositionSprite = axis.relativePositionSprite;
            var x = axis.pixelX;
            if (relativePositionSprite) {
                x = spritePointToSprite({ x: this.pixelX, y: 0 }, this.parent, relativePositionSprite).x;
            }
            else {
                relativePositionSprite = axis.parent;
            }
            if (relativePositionSprite) {
                var relativeX = x / relativePositionSprite.innerWidth;
                var relativeWidth = axis.axisLength / relativePositionSprite.innerWidth;
                return (inversedPosition - relativeX) / relativeWidth;
            }
        }
        return value;
    };
    /**
     * Updates and positions axis bullets.
     *
     * @ignore Exclude from docs
     * @param bullet       AxisBullet element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererX.prototype.updateBullet = function (bullet, position, endPosition) {
        var location = 0.5;
        if (bullet instanceof AxisBullet_AxisBullet) {
            location = bullet.location;
        }
        position = position + (endPosition - position) * location;
        var point = this.positionToPoint(position);
        point.y = spritePointToSprite({ x: 0, y: this.line.pixelY }, this.line.parent, this.gridContainer).y;
        this.positionItem(bullet, point);
        this.toggleVisibility(bullet, position, 0, 1);
    };
    return AxisRendererX;
}(AxisRenderer_AxisRenderer));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisRendererX"] = AxisRendererX_AxisRendererX;
/**
 * Add default responsive rules
 */
/**
 * Put labels inside plot area.
 * Disable first and last labels.
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.heightXS,
    state: function (target, stateId) {
        if (target instanceof AxisRendererX_AxisRendererX) {
            var state = target.states.create(stateId);
            state.properties.inside = true;
            state.properties.maxLabelPosition = 0.9;
            state.properties.minLabelPosition = 0.1;
            return state;
        }
        return null;
    }
});
/**
 * Disable labels altogather on very small charts
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.heightXXS,
    state: function (target, stateId) {
        if (target instanceof AxisRendererX_AxisRendererX) {
            var state = target.states.create(stateId);
            state.properties.disabled = true;
            return state;
        }
        return null;
    }
});
//# sourceMappingURL=AxisRendererX.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/CategoryAxisBreak.js
/**
 * A module which defines functionality related to Category Axis Break.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Base class to define "breaks" in axes
 * @see {@link ICategoryAxisBreakEvents} for a list of available events
 * @see {@link ICategoryAxisBreakAdapters} for a list of available Adapters
 */
var CategoryAxisBreak_CategoryAxisBreak = /** @class */ (function (_super) {
    __extends(CategoryAxisBreak, _super);
    /**
     * Constructor
     */
    function CategoryAxisBreak() {
        var _this = _super.call(this) || this;
        _this.className = "CategoryAxisBreak";
        _this.properties.startLocation = 0.5;
        _this.properties.endLocation = 0.5;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(CategoryAxisBreak.prototype, "startPosition", {
        /**
         * Pixel position of the break's start.
         *
         * @return Position (px)
         * @readonly
         */
        get: function () {
            if (this.axis) {
                return this.axis.indexToPosition(this.adjustedStartValue, this.startLocation);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryAxisBreak.prototype, "endPosition", {
        /**
         * Pixel position of the break's end.
         *
         * @return Position (px)
         * @readonly
         */
        get: function () {
            if (this.axis) {
                return this.axis.indexToPosition(this.adjustedEndValue, this.endLocation);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryAxisBreak.prototype, "startCategory", {
        /**
         * @return Start category
         */
        get: function () {
            return this.getPropertyValue("startCategory");
        },
        /**
         * A category break starts on.
         *
         * @param value Start category
         */
        set: function (value) {
            if (this.setPropertyValue("startCategory", value)) {
                if (this.axis) {
                    this.axis.invalidateDataItems();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryAxisBreak.prototype, "endCategory", {
        /**
         * @return End category
         */
        get: function () {
            return this.getPropertyValue("endCategory");
        },
        /**
         * A category break ends on.
         *
         * @param value  End category
         */
        set: function (value) {
            if (this.setPropertyValue("endCategory", value)) {
                if (this.axis) {
                    this.axis.invalidateDataItems();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryAxisBreak.prototype, "startValue", {
        /**
         * @return Value
         */
        get: function () {
            var category = this.getPropertyValue("startCategory");
            if (category) {
                return this.axis.categoryToIndex(category);
            }
            else {
                return this.getPropertyValue("startValue");
            }
        },
        /**
         * An index of start category.
         *
         * @param value  Value
         */
        set: function (value) {
            if (this.setPropertyValue("startValue", value)) {
                if (this.axis) {
                    this.axis.invalidateDataItems();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryAxisBreak.prototype, "endValue", {
        /**
         * @return Value
         */
        get: function () {
            var category = this.getPropertyValue("endCategory");
            if (category) {
                return this.axis.categoryToIndex(category);
            }
            else {
                return this.getPropertyValue("endValue");
            }
        },
        /**
         * An index of end category or a end value.
         *
         * @param value  Value
         */
        set: function (value) {
            if (this.setPropertyValue("endValue", value)) {
                if (this.axis) {
                    this.axis.invalidateDataItems();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryAxisBreak.prototype, "startLocation", {
        /**
         * @return Break start location
         */
        get: function () {
            return this.getPropertyValue("startLocation");
        },
        /**
         * Indicates where within starting category break should begin.
         *
         * Values range from `0` (start) to `1` (end), with default being `0.5` (middle).
         *
         * E.g. if you want to a break to fully encompass start and end categories,
         * you should set `startLocation = 0` and `endLocation = 1`.
         *
         * @since 4.9.17
         * @default 0.5
         * @param  value  Break start location
         */
        set: function (value) {
            if (this.setPropertyValue("startLocation", value)) {
                if (this.axis) {
                    this.axis.invalidateDataItems();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryAxisBreak.prototype, "endLocation", {
        /**
         * @return Break end location
         */
        get: function () {
            return this.getPropertyValue("endLocation");
        },
        /**
         * Indicates where within ending category break should end.
         *
         * Values range from `0` (start) to `1` (end), with default being `0.5` (middle).
         *
         * E.g. if you want to a break to fully encompass start and end categories,
         * you should set `startLocation = 0` and `endLocation = 1`.
         *
         * @since 4.9.17
         * @default 0.5
         * @param  value  Break end location
         */
        set: function (value) {
            if (this.setPropertyValue("endLocation", value)) {
                if (this.axis) {
                    this.axis.invalidateDataItems();
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    return CategoryAxisBreak;
}(AxisBreak_AxisBreak));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["CategoryAxisBreak"] = CategoryAxisBreak_CategoryAxisBreak;
//# sourceMappingURL=CategoryAxisBreak.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/CategoryAxis.js
/**
 * Category axis module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[CategoryAxis]].
 *
 * @see {@link DataItem}
 */
var CategoryAxis_CategoryAxisDataItem = /** @class */ (function (_super) {
    __extends(CategoryAxisDataItem, _super);
    /**
     * Constructor
     */
    function CategoryAxisDataItem() {
        var _this = _super.call(this) || this;
        _this.seriesDataItems = {};
        _this.className = "CategoryAxisDataItem";
        _this.text = "{category}";
        _this.locations.category = 0;
        _this.locations.endCategory = 1;
        _this.deltaPosition = 0;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(CategoryAxisDataItem.prototype, "category", {
        /**
         * @return Category
         */
        get: function () {
            if (this._adapterO) {
                if (this._adapterO.isEnabled("category")) {
                    return this._adapterO.apply("category", this.properties.category);
                }
            }
            return this.properties.category;
        },
        /**
         * Category.
         *
         * @param value  Category
         */
        set: function (value) {
            var oldCategory = this.properties.category;
            this.setProperty("category", value);
            if (hasValue(oldCategory) && oldCategory != value) {
                if (this.component) {
                    this.component.validateDataElement(this);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryAxisDataItem.prototype, "endCategory", {
        /**
         * @return End category
         */
        get: function () {
            return this.properties.endCategory;
        },
        /**
         * End category.
         *
         * Used for items that span several categories, like [[CategoryAxisBreak]].
         *
         * @param value  End category
         */
        set: function (value) {
            this.setProperty("endCategory", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryAxisDataItem.prototype, "deltaPosition", {
        get: function () {
            return this.properties.deltaCoordinate;
        },
        set: function (value) {
            if (value != this.properties.deltaCoordinate) {
                this.setProperty("deltaCoordinate", value);
                if (this.component) {
                    this.component.invalidateDataItems();
                    this.component.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    return CategoryAxisDataItem;
}(Axis_AxisDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to create a category-based axis for the chart.
 *
 * ```TypeScript
 * // Create the axis
 * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());
 *
 * // Set settings
 * xAxis.title.text = "Clients";
 * ```
 * ```JavaScript
 * // Create the axis
 * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());
 *
 * // Set settings
 * valueAxis.title.text = "Clients";
 * ```
 * ```JSON
 * "xAxes": [{
 *   "type": "CategoryAxis",
 *   "title": {
 *     "text": "Clients"
 *   }
 * }]
 * ```
 *
 * @see {@link ICategoryAxisEvents} for a list of available Events
 * @see {@link ICategoryAxisAdapters} for a list of available Adapters
 * @important
 */
var CategoryAxis_CategoryAxis = /** @class */ (function (_super) {
    __extends(CategoryAxis, _super);
    /**
     * Constructor
     */
    function CategoryAxis() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * A collection that holds Axis' data items sorted by each category.
         */
        _this.dataItemsByCategory = new Dictionary_Dictionary();
        _this.className = "CategoryAxis";
        // Set field name
        _this.axisFieldName = "category";
        _this._lastDataItem = _this.createDataItem();
        _this._lastDataItem.component = _this;
        _this._disposers.push(_this._lastDataItem);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Returns a new/empty [[DataItem]] of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    CategoryAxis.prototype.createDataItem = function () {
        return new CategoryAxis_CategoryAxisDataItem();
    };
    /**
     * Returns a new/empty [[AxisBreak]] of the appropriate type.
     *
     * @return Axis break
     */
    CategoryAxis.prototype.createAxisBreak = function () {
        return new CategoryAxisBreak_CategoryAxisBreak();
    };
    /**
     * Processes a related series' data item.
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param dataItem  Data item
     */
    CategoryAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {
        _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);
        var category = dataItem["category" + this.axisLetter];
        if (hasValue(category)) {
            var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);
            if (categoryAxisDataItem) {
                var seriesId = dataItem.component.uid;
                var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];
                if (!seriesDataItems) {
                    seriesDataItems = [];
                    categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;
                }
                seriesDataItems.push(dataItem);
            }
        }
        else {
            dataItem.component.dataItems.remove(dataItem);
        }
    };
    /**
     * Validates the data range.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     */
    CategoryAxis.prototype.validateDataRange = function () {
        var _this = this;
        _super.prototype.validateDataRange.call(this);
        Iterator_each(this._series.iterator(), function (series) {
            if ((series.xAxis instanceof CategoryAxis) && (series.yAxis instanceof CategoryAxis)) {
                series.invalidateDataRange();
            }
            else {
                var startIndex = _this.positionToIndex(_this.start);
                var endIndex = _this.positionToIndex(_this.end);
                if (endIndex >= _this.dataItems.length) {
                    endIndex--;
                }
                var seriesId = series.uid;
                var minIndex = void 0;
                var maxIndex = void 0;
                for (var i = startIndex; i <= endIndex; i++) {
                    var axisDataItem = _this.dataItems.getIndex(i);
                    if (axisDataItem) {
                        var seriesDataItems = axisDataItem.seriesDataItems[seriesId];
                        if (seriesDataItems) {
                            for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {
                                var seriesDataItem = seriesDataItems[i_1];
                                if (seriesDataItem) {
                                    var index = seriesDataItem.index;
                                    if (!isNumber(minIndex) || index < minIndex) {
                                        minIndex = index;
                                    }
                                    if (!isNumber(maxIndex) || index > maxIndex) {
                                        maxIndex = index;
                                    }
                                }
                            }
                        }
                    }
                }
                if (isNumber(minIndex)) {
                    series.startIndex = minIndex;
                }
                else {
                    series.start = _this.start;
                }
                if (isNumber(maxIndex)) {
                    series.endIndex = maxIndex + 1;
                }
                else {
                    series.end = _this.end;
                }
                // range might not change, but axis breaks might.
                if (_this._axisBreaks && _this._axisBreaks.length > 0) {
                    series.invalidateDataRange();
                }
            }
        });
    };
    /**
     * Validates the whole axis. Causes it to redraw.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     */
    CategoryAxis.prototype.validate = function () {
        var _this = this;
        _super.prototype.validate.call(this);
        var dataCount = this.dataItems.length;
        var startIndex = fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);
        var endIndex = fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);
        if (this.renderer.invalid) {
            this.renderer.validate();
        }
        // find frequency at which we'll show items
        var maxCount = this.renderer.axisLength / this.renderer.minGridDistance;
        var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));
        this._startIndex = Math.floor(startIndex / frequency) * frequency;
        this._endIndex = Math.ceil(this.end * dataCount);
        this.fixAxisBreaks();
        if (this._startIndex == this._endIndex) {
            this._endIndex++;
        }
        this._frequency = frequency;
        if (this.axisLength <= 0) {
            return;
        }
        this.maxZoomFactor = this.dataItems.length;
        if (this.dataItems.length <= 0) {
            this.maxZoomFactor = 1;
        }
        this.resetIterators();
        // it's important to use protected variables here, as getters will return 0 - length
        // TODO use iterator instead
        // @ todo: not solved cat axis item fading
        startIndex = Math_max(0, this._startIndex - this._frequency);
        endIndex = Math_min(this.dataItems.length, this._endIndex + this._frequency);
        var itemIndex = 0;
        for (var i = 0; i < startIndex; i++) {
            var dataItem = this.dataItems.getIndex(i);
            dataItem.__disabled = true;
        }
        for (var i = endIndex, len = this.dataItems.length; i < len; i++) {
            var dataItem = this.dataItems.getIndex(i);
            dataItem.__disabled = true;
        }
        for (var i = startIndex; i < endIndex; i++) {
            if (i < this.dataItems.length) {
                var dataItem = this.dataItems.getIndex(i);
                if (i / this._frequency == Math.round(i / this._frequency)) {
                    var axisBreak = this.isInBreak(i);
                    if (!axisBreak) {
                        this.appendDataItem(dataItem);
                        this.validateDataElement(dataItem, itemIndex);
                    }
                    itemIndex++;
                }
                else {
                    //previously we disabled all before, but this is better for cpu
                    //this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items
                    dataItem.__disabled = true;
                }
            }
        }
        this.appendDataItem(this._lastDataItem);
        this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);
        if (this._axisBreaks) {
            var axisBreaks = this._axisBreaks;
            axisBreaks.each(function (axisBreak) {
                var adjustedStartValue = axisBreak.adjustedStartValue;
                var adjustedEndValue = axisBreak.adjustedEndValue;
                if (intersect({ start: adjustedStartValue, end: adjustedEndValue }, { start: _this._startIndex, end: _this._endIndex })) {
                    for (var b = adjustedStartValue; b <= adjustedEndValue; b++) {
                        var dataItem = _this.dataItems.getIndex(b);
                        dataItem.__disabled = true;
                    }
                    var frequency_1 = fitToRange(Math.ceil(_this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);
                    var itemIndex_1 = 0;
                    if (axisBreak.breakSize > 0) {
                        // TODO use iterator instead
                        for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {
                            var dataItem = _this.dataItems.getIndex(b);
                            dataItem.__disabled = false;
                            _this.appendDataItem(dataItem);
                            _this.validateDataElement(dataItem, itemIndex_1);
                            itemIndex_1++;
                        }
                    }
                }
            });
        }
        this.validateBreaks();
        this.validateAxisRanges();
        this.ghostLabel.invalidate(); // solves font issue
        this.renderer.invalidateLayout();
    };
    /**
     * [validateDataElement description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param dataItem   [description]
     * @param itemIndex  [description]
     */
    CategoryAxis.prototype.validateDataElement = function (dataItem, itemIndex, index) {
        _super.prototype.validateDataElement.call(this, dataItem);
        dataItem.itemIndex = this._axisItemCount;
        this._axisItemCount++;
        //dataItem.__disabled = false;
        var renderer = this.renderer;
        if (!isNumber(index)) {
            index = this.categoryToIndex(dataItem.category);
        }
        var endIndex = this.categoryToIndex(dataItem.endCategory);
        if (!isNumber(endIndex)) {
            endIndex = index;
        }
        var position = this.indexToPosition(index, dataItem.locations.category);
        var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);
        dataItem.position = position;
        var fillEndIndex;
        var fillPosition;
        var fillEndPosition;
        if (dataItem.isRange) {
            fillEndIndex = endIndex;
            fillPosition = this.indexToPosition(index, dataItem.locations.category);
            fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);
        }
        dataItem.point = renderer.positionToPoint(position);
        var tick = dataItem.tick;
        if (tick && !tick.disabled) {
            renderer.updateTickElement(tick, position, endPosition);
        }
        var grid = dataItem.grid;
        if (grid && !grid.disabled) {
            renderer.updateGridElement(grid, position, endPosition);
        }
        var label = dataItem.label;
        if (label && !label.disabled) {
            // theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = "custom text" wont' work, which is not intuitive.
            if (!dataItem.isRange || label.text == undefined) {
                dataItem.text = dataItem.text;
            }
            renderer.updateLabelElement(label, position, endPosition);
            if ((renderer instanceof AxisRendererY_AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth) || (renderer instanceof AxisRendererX_AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight)) {
                if (dataItem.label.html) {
                    this.ghostLabel.html = dataItem.label.currentText;
                }
                else {
                    this.ghostLabel.text = dataItem.label.currentText;
                }
            }
        }
        var fill = dataItem.axisFill;
        if (fill && !fill.disabled) {
            if (!dataItem.isRange) {
                fillEndIndex = index + this._frequency;
                fillPosition = this.indexToPosition(index, fill.location);
                fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);
            }
            renderer.updateFillElement(fill, fillPosition, fillEndPosition);
            if (!dataItem.isRange) {
                this.fillRule(dataItem, itemIndex);
            }
        }
        if (dataItem.bullet) {
            renderer.updateBullet(dataItem.bullet, position, endPosition);
        }
        var mask = dataItem.mask;
        if (mask) {
            renderer.updateFillElement(mask, fillPosition, fillEndPosition);
        }
    };
    /**
     * @ignore
     */
    CategoryAxis.prototype.disposeData = function () {
        this.dataItemsByCategory.clear();
        _super.prototype.disposeData.call(this);
    };
    /**
     * Processes the axis data item.
     *
     * @ignore Exclude from docs
     * @param dataItem     Data item
     * @param dataContext  The raw data that corresponds to this data item
     */
    CategoryAxis.prototype.processDataItem = function (dataItem, dataContext) {
        if (dataItem) {
            // creat a collection for fast access
            _super.prototype.processDataItem.call(this, dataItem, dataContext);
            // check if such category already exists
            //let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);
            //if (existingDataItem && existingDataItem != dataItem) {
            //	this.dataItems.remove(existingDataItem);
            //}
            if (hasValue(dataItem.category)) {
                this.dataItemsByCategory.setKey(dataItem.category, dataItem);
            }
        }
    };
    CategoryAxis.prototype.getDataItem = function (dataContext) {
        var category = (dataContext[this.dataFields.category]);
        if (hasValue(category)) {
            var dataItem = this.dataItemsByCategory.getKey(category);
            if (dataItem) {
                return dataItem;
            }
            else {
                return this.dataItems.create();
            }
        }
    };
    /**
     * Converts a category index to an actual screen coordinate on the axis.
     *
     * `location` identifies relative location within category. 0 - beginning,
     * 0.5 - middle, 1 - end, and anything inbetween.
     *
     * @param index     Index
     * @param location  Location (0-1)
     * @return Position (px)
     */
    CategoryAxis.prototype.indexToPosition = function (index, location) {
        if (!isNumber(location)) {
            location = 0.5;
        }
        var startIndex = this.startIndex;
        var endIndex = this.endIndex;
        var difference = this.adjustDifference(startIndex, endIndex);
        var startLocation = this.startLocation;
        var endLocation = this.endLocation;
        difference -= startLocation;
        difference -= (1 - endLocation);
        if (this._axisBreaks) {
            var axisBreaks = this._axisBreaks;
            Iterator_eachContinue(axisBreaks.iterator(), function (axisBreak) {
                var breakStartIndex = axisBreak.adjustedStartValue;
                var breakEndIndex = axisBreak.adjustedEndValue;
                if (index < startIndex || !isNumber(breakStartIndex) || !isNumber(breakEndIndex)) {
                    return false;
                }
                if (intersect({ start: breakStartIndex, end: breakEndIndex }, { start: startIndex, end: endIndex })) {
                    breakStartIndex = Math.max(startIndex, breakStartIndex);
                    breakEndIndex = Math.min(endIndex, breakEndIndex);
                    var breakSize = axisBreak.breakSize;
                    // value to the right of break end
                    if (index > breakEndIndex) {
                        startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);
                    }
                    // value to the left of break start
                    else if (index < breakStartIndex) {
                    }
                    // value within break
                    else {
                        index = breakStartIndex + (index - breakStartIndex) * breakSize;
                    }
                }
                return true;
            });
        }
        var deltaPosition = 0;
        var dataItem = this.dataItems.getIndex(index);
        if (dataItem) {
            deltaPosition = dataItem.deltaPosition;
        }
        return Math_round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);
    };
    /**
     * Converts a string category name to relative position on axis.
     *
     * `location` identifies relative location within category. 0 - beginning,
     * 0.5 - middle, 1 - end, and anything inbetween.
     *
     * @param category  Category name
     * @param location  Location (0-1)
     * @return Position
     */
    CategoryAxis.prototype.categoryToPosition = function (category, location) {
        var index = this.categoryToIndex(category);
        return this.indexToPosition(index, location);
    };
    /**
     * Converts a string category name to a orientation point (x, y, angle) on axis
     *
     * `location` identifies relative location within category. 0 - beginning,
     * 0.5 - middle, 1 - end, and anything inbetween.
     * @param category  Category name
     * @param location  Location (0-1)
     * @return Orientation point
     */
    CategoryAxis.prototype.categoryToPoint = function (category, location) {
        var position = this.categoryToPosition(category, location);
        var point = this.renderer.positionToPoint(position);
        var angle = this.renderer.positionToAngle(position);
        return { x: point.x, y: point.y, angle: angle };
    };
    /**
     * Converts a string category name to a orientation point (x, y, angle) on axis
     *
     * `location` identifies relative location within category. 0 - beginning,
     * 0.5 - middle, 1 - end, and anything inbetween.
     * @param category  Category name
     * @param location  Location (0-1)
     * @return Orientation point
     */
    CategoryAxis.prototype.anyToPoint = function (category, location) {
        return this.categoryToPoint(category, location);
    };
    /**
     * Converts a string category name to relative position on axis.
     *
     * An alias to `categoryToPosition()`.
     *
     * @param category  Category name
     * @param location  Location (0-1)
     * @return Relative position
     */
    CategoryAxis.prototype.anyToPosition = function (category, location) {
        return this.categoryToPosition(category, location);
    };
    /**
     * Converts named category to an index of data item it corresponds to.
     *
     * @param category  Category
     * @return Data item index
     */
    CategoryAxis.prototype.categoryToIndex = function (category) {
        if (hasValue(category)) {
            var dataItem = this.dataItemsByCategory.getKey(category);
            if (dataItem) {
                return dataItem.index;
            }
        }
    };
    /**
     * Zooms the axis to specific named ctaegories.
     *
     * @param startCategory  Start category
     * @param endCategory    End category
     */
    CategoryAxis.prototype.zoomToCategories = function (startCategory, endCategory) {
        this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);
    };
    /**
     * [getAnyRangePath description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param start         [description]
     * @param end           [description]
     * @param startLocation [description]
     * @param endLocation   [description]
     * @return [description]
     */
    CategoryAxis.prototype.getAnyRangePath = function (start, end, startLocation, endLocation) {
        var startPos = this.categoryToPosition(start, startLocation);
        var endPos = this.categoryToPosition(end, endLocation);
        return this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer
    };
    /**
     * Takes an absolute position (px) within axis and adjust it to a specific
     * `location` within category it corresponds to.
     *
     * @param position  Source position (px)
     * @param location  Location within category (0-1)
     * @return Adjusted position (px)
     */
    CategoryAxis.prototype.roundPosition = function (position, location) {
        var index = this.positionToIndex(position);
        return this.indexToPosition(index, location);
    };
    /**
     * Finds and returns first series data item with specific category
     * @param series    Target series
     * @param category  Category
     * @return XYSeriesDataItem data item
     */
    CategoryAxis.prototype.getFirstSeriesDataItem = function (series, category) {
        for (var i = 0; i < series.dataItems.length; i++) {
            var dataItem = series.dataItems.getIndex(i);
            if (series.xAxis == this) {
                if (dataItem.categoryX == category) {
                    return dataItem;
                }
            }
            if (series.yAxis == this) {
                if (dataItem.categoryY == category) {
                    return dataItem;
                }
            }
        }
    };
    /**
     * Finds and returns last series data item with specific category.
     * @param series    Target series
     * @param category  Category
     * @return XYSeriesDataItem data item
     */
    CategoryAxis.prototype.getLastSeriesDataItem = function (series, category) {
        for (var i = series.dataItems.length - 1; i >= 0; i--) {
            var dataItem = series.dataItems.getIndex(i);
            if (series.xAxis == this) {
                if (dataItem.categoryX == category) {
                    return dataItem;
                }
            }
            if (series.yAxis == this) {
                if (dataItem.categoryY == category) {
                    return dataItem;
                }
            }
        }
    };
    // todo: optimize
    CategoryAxis.prototype.getSeriesDataItemByCategory = function (category, series) {
        var _this = this;
        var seriesDataItem;
        series.dataItems.each(function (dataItem) {
            if (series.xAxis == _this) {
                if (dataItem.categoryX == category) {
                    seriesDataItem = dataItem;
                }
            }
            else if (series.yAxis == _this) {
                if (dataItem.categoryY == category) {
                    seriesDataItem = dataItem;
                }
            }
        });
        return seriesDataItem;
    };
    /**
     * Returns a data item from Series that corresponds to a specific absolute
     * position on the Axis.
     *
     * @param series    Target series
     * @param position  Position (px)
     * @return XYSeriesDataItem data item
     */
    CategoryAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {
        var _this = this;
        if (isNumber(position)) {
            var index_1 = this.positionToIndex(position);
            if (index_1 >= this.dataItems.length) {
                index_1--;
            }
            var dataItem = this.dataItems.getIndex(index_1);
            if (dataItem) {
                var category_1 = dataItem.category;
                var sdi_1;
                var seriesDataItem = series.dataItems.getIndex(index_1);
                if (seriesDataItem) {
                    if (series.xAxis == this) {
                        if (seriesDataItem.categoryX == category_1) {
                            return seriesDataItem;
                        }
                    }
                    if (series.yAxis == this) {
                        if (seriesDataItem.categoryY == category_1) {
                            return seriesDataItem;
                        }
                    }
                }
                series.dataItems.each(function (dataItem) {
                    if (series.xAxis == _this) {
                        if (dataItem.categoryX == category_1) {
                            if (!sdi_1) {
                                sdi_1 = dataItem;
                            }
                            if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {
                                sdi_1 = dataItem;
                            }
                        }
                    }
                    if (series.yAxis == _this) {
                        if (dataItem.categoryY == category_1) {
                            if (!sdi_1) {
                                sdi_1 = dataItem;
                            }
                            if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {
                                sdi_1 = dataItem;
                            }
                        }
                    }
                });
                //@todo
                if (findNearest) {
                }
                return sdi_1;
            }
        }
    };
    /**
     * Returns the X coordinate for series' data item.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem  Data item
     * @param key       Category
     * @param location  Location (0-1)
     * @return X coordinate (px)
     */
    CategoryAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {
        var position = this.getPositionX(dataItem, key, location, stackKey, range);
        if (Type_isNaN(position)) {
            return this.basePoint.x;
        }
        else {
            return this.renderer.positionToPoint(position).x;
        }
    };
    /**
     * Returns relative position on axis for series' data item.
     *
     * @since 4.5.14
     * @param  dataItem  Data item
     * @param  key       Category
     * @param  location  Location (0-1)
     * @return           Relative position
     */
    CategoryAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {
        var position;
        if (hasValue(key)) {
            position = this.categoryToPosition(dataItem.categories[key], location);
        }
        if (range) {
            position = fitToRange(position, range.start, range.end);
        }
        return position;
    };
    /**
     * Returns the Y coordinate for series' data item.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem  Data item
     * @param key       Category
     * @param location  Location (0-1)
     * @return Y coordinate (px)
     */
    CategoryAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {
        var position = this.getPositionY(dataItem, key, location, stackKey, range);
        if (Type_isNaN(position)) {
            return this.basePoint.y;
        }
        else {
            return this.renderer.positionToPoint(position).y;
        }
    };
    /**
     * Returns relative position on axis for series' data item.
     *
     * @since 4.5.14
     * @param  dataItem  Data item
     * @param  key       Category
     * @param  location  Location (0-1)
     * @return           Relative position
     */
    CategoryAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {
        var position;
        if (hasValue(key)) {
            position = this.categoryToPosition(dataItem.categories[key], location);
        }
        if (range) {
            position = fitToRange(position, range.start, range.end);
        }
        return position;
    };
    /**
     * Returns an angle for series data item.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param dataItem  Data item
     * @param key       Category
     * @param location  Location (0-1)
     * @param stackKey  Stack key (?)
     * @param range Range to fit in
     * @return Angle
     */
    CategoryAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {
        var position = this.categoryToPosition(dataItem.categories[key], location);
        if (range) {
            position = fitToRange(position, range.start, range.end);
        }
        return this.positionToAngle(position);
    };
    /**
     * Returns an absolute pixel coordinate of the start of the cell (category),
     * that specific position value falls into.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param position  Position (px)
     * @return Cell start position (px)
     */
    CategoryAxis.prototype.getCellStartPosition = function (position) {
        return this.roundPosition(position, 0);
    };
    /**
     * Returns an absolute pixel coordinate of the end of the cell (category),
     * that specific position value falls into.
     *
     * @ignore Exclude from docs
     * @todo Description (review)
     * @param position  Position (px)
     * @return Cell end position (px)
     */
    CategoryAxis.prototype.getCellEndPosition = function (position) {
        return this.roundPosition(position, 1);
    };
    /**
     * Returns text to show in a category tooltip, based on specific position
     * within axis.
     *
     * @ignore Exclude from docs
     * @param position  Position (px)
     * @return Label (category)
     */
    CategoryAxis.prototype.getTooltipText = function (position) {
        var dataItem = this.dataItems.getIndex(this.positionToIndex(position));
        if (dataItem) {
            this.tooltipDataItem = dataItem;
            this.tooltip.dataItem = dataItem;
            if (this.tooltipText) {
                return this.tooltipText;
            }
            if (!this._adapterO) {
                return dataItem.category;
            }
            else {
                return this._adapterO.apply("getTooltipText", dataItem.category);
            }
        }
    };
    /**
     * Returns an index of the category that corresponds to specific pixel
     * position within axis.
     *
     * @param position  Position (px)
     * @return Category index
     */
    CategoryAxis.prototype.positionToIndex = function (position) {
        position = Math_round(position, 10);
        if (position < 0) {
            position = 0;
        }
        if (position > 1) {
            position = 1;
        }
        var startIndex = this.startIndex;
        var endIndex = this.endIndex;
        var difference = endIndex - startIndex - this.startLocation - (1 - this.endLocation);
        position += 1 / difference * this.startLocation;
        var index = null;
        if (this._axisBreaks) {
            var axisBreaks = this._axisBreaks;
            // in case we have some axis breaks
            Iterator_eachContinue(axisBreaks.iterator(), function (axisBreak) {
                var breakStartPosition = axisBreak.startPosition;
                var breakEndPosition = axisBreak.endPosition;
                var breakStartIndex = axisBreak.adjustedStartValue;
                var breakEndIndex = axisBreak.adjustedEndValue;
                breakStartIndex = Math_max(breakStartIndex, startIndex);
                breakEndIndex = Math_min(breakEndIndex, endIndex);
                var breakSize = axisBreak.breakSize;
                difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);
                // position to the right of break end
                if (position > breakEndPosition) {
                    startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);
                }
                // position to the left of break start
                else if (position < breakStartPosition) {
                }
                // value within break
                else {
                    var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);
                    index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));
                    return false;
                }
                return true;
            });
        }
        if (!isNumber(index)) {
            index = Math.floor(position * difference + startIndex);
        }
        if (index >= this.dataItems.length) {
            index = this.dataItems.length - 1;
        }
        // not good, when panning out of bounds, each time one less item gets selected
        //if (index >= endIndex) {
        //	index--;
        //}
        return index;
    };
    /**
     * Returns category based on position.
     *
     * Please note that `position` represents position within axis which may be
     * zoomed and not correspond to Cursor's `position`.
     *
     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.
     *
     * This is a synonim of `getPositionLabel()` implemented here for consistentcy.
     *
     * @since 4.3.8
     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.
     * @param position  Relative position on axis (0-1)
     * @return Position label
     */
    CategoryAxis.prototype.positionToCategory = function (position) {
        return this.getPositionLabel(position);
    };
    /**
     * Returns category based on position.
     *
     * Please note that `position` represents position within axis which may be
     * zoomed and not correspond to Cursor's `position`.
     *
     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.
     *
     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.
     * @param position  Relative position on axis (0-1)
     * @return Position label
     */
    CategoryAxis.prototype.getPositionLabel = function (position) {
        var dataItem = this.dataItems.getIndex(this.positionToIndex(position));
        if (dataItem) {
            return dataItem.category;
        }
    };
    Object.defineProperty(CategoryAxis.prototype, "basePoint", {
        /**
         * Coordinates of the actual axis start.
         *
         * @ignore Exclude from docs
         * @return Base point
         */
        get: function () {
            // This makes base grid to be drawn at the end of the axis and adds extra
            // grid which we need to nicely close the chart.
            return this.renderer.positionToPoint(1);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initializes Axis' renderer.
     *
     * @ignore Exclude from docs
     */
    CategoryAxis.prototype.initRenderer = function () {
        _super.prototype.initRenderer.call(this);
        var renderer = this.renderer;
        renderer.baseGrid.disabled = true;
    };
    Object.defineProperty(CategoryAxis.prototype, "frequency", {
        /**
         * Current frequency of labels of the axis.
         *
         * Normally it would be 1, but when labels start to be hidden due
         * to `minGridDistance` this read-only property will increase.
         *
         * @readonly
         * @since 4.2.0
         * @return Label frequency
         */
        get: function () {
            return this._frequency;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CategoryAxis.prototype, "sortBySeries", {
        /**
         * @return Sort categories?
         */
        get: function () {
            return this.getPropertyValue("sortBySeries");
        },
        /**
         * If set to a reference of [[ColumnSeries]] the categories will be sorted
         * by actual values.
         *
         * The categories are ordered in descending order (from highest values to
         * lowest). To reverse the order, use axis renderer's `inversed` setting.
         * E.g.:
         *
         * ```TypeScript
         * categoryAxis.sortBySeries = series;
         * categoryAxis.renderer.inversed = true;
         * ```
         * ```JavaScript
         * categoryAxis.sortBySeries = series;
         * categoryAxis.renderer.inversed = true;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "xAxes": [{
         *     // ...
         *     "sortBySeries": "s1",
         *     "renderer": {
         *       // ...
         *       "inversed": true
         *     }
         *   }]
         * }
         * ```
         *
         * @since 4.8.7
         * @param  value  Sort categories?
         */
        set: function (value) {
            this.setPropertyValue("sortBySeries", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    CategoryAxis.prototype.processConfig = function (config) {
        if (config) {
            if (hasValue(config.sortBySeries) && isString(config.sortBySeries)) {
                if (this.map.hasKey(config.sortBySeries)) {
                    config.sortBySeries = this.map.getKey(config.sortBySeries);
                }
                else {
                    this.addDelayedMap("sortBySeries", config.sortBySeries);
                    delete config.sortBySeries;
                }
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    return CategoryAxis;
}(Axis_Axis));

/**
 * Register class, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["CategoryAxis"] = CategoryAxis_CategoryAxis;
registry.registeredClasses["CategoryAxisDataItem"] = CategoryAxis_CategoryAxisDataItem;
//# sourceMappingURL=CategoryAxis.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/XYSeries.js
/**
 * XY series module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


















/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[XYSeries]].
 *
 * @see {@link DataItem}
 */
var XYSeries_XYSeriesDataItem = /** @class */ (function (_super) {
    __extends(XYSeriesDataItem, _super);
    /**
     * Constructor
     */
    function XYSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "XYSeriesDataItem";
        _this.values.customValue = {};
        _this.values.valueX = { stack: 0 };
        _this.values.valueY = { stack: 0 };
        _this.values.openValueX = {};
        _this.values.openValueY = {};
        _this.values.dateX = {};
        _this.values.dateY = {};
        _this.values.openDateX = {};
        _this.values.openDateY = {};
        _this.setLocation("dateX", 0.5, 0);
        _this.setLocation("dateY", 0.5, 0);
        _this.setLocation("categoryX", 0.5, 0);
        _this.setLocation("categoryY", 0.5, 0);
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(XYSeriesDataItem.prototype, "valueX", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.valueX.value;
        },
        /**
         * Item's numeric value on X value axis.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("valueX", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "customValue", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.customValue.value;
        },
        /**
         * Item's custom numeric value.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("customValue", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "valueY", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.valueY.value;
        },
        /**
         * Item's numeric value on Y value axis.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("valueY", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "dateX", {
        /**
         * @return Date
         */
        get: function () {
            return this.getDate("dateX");
        },
        /**
         * Item's date value on X date-based axis.
         *
         * @param date  Date
         */
        set: function (date) {
            this.setDate("dateX", date);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "dateY", {
        /**
         * @return Date
         */
        get: function () {
            return this.getDate("dateY");
        },
        /**
         * Item's date value on Y date-based axis.
         *
         * @param date  Date
         */
        set: function (date) {
            this.setDate("dateY", date);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "categoryX", {
        /**
         * @return Category
         */
        get: function () {
            return this.categories.categoryX;
        },
        /**
         * Item's category on X category axis.
         *
         * @param category  Category
         */
        set: function (category) {
            this.setCategory("categoryX", category);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "categoryY", {
        /**
         * @return Category
         */
        get: function () {
            return this.categories.categoryY;
        },
        /**
         * Item's category on Y category axis.
         *
         * @param category  Category
         */
        set: function (category) {
            this.setCategory("categoryY", category);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "openValueX", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.openValueX.value;
        },
        /**
         * Item's open numeric value on X value axis.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("openValueX", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "openValueY", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.openValueY.value;
        },
        /**
         * Item's open numeric value on Y value axis.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("openValueY", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "openDateX", {
        /**
         * @return Date
         */
        get: function () {
            return this.getDate("openDateX");
        },
        /**
         * Item's open date value on X date-based axis.
         *
         * @param date  Date
         */
        set: function (date) {
            this.setDate("openDateX", date);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "openDateY", {
        /**
         * @return Date
         */
        get: function () {
            return this.getDate("openDateY");
        },
        /**
         * Item's open date value on Y date-based axis.
         *
         * @param date  Date
         */
        set: function (date) {
            this.setDate("openDateY", date);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "openCategoryX", {
        /**
         * @return Category
         */
        get: function () {
            return this.categories.openCategoryX;
        },
        /**
         * Item's open category on X category axis.
         *
         * @param category  Category
         */
        set: function (category) {
            this.setCategory("openCategoryX", category);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeriesDataItem.prototype, "openCategoryY", {
        /**
         * @return Category
         */
        get: function () {
            return this.categories.openCategoryY;
        },
        /**
         * Item's open category on Y category axis.
         *
         * @param category  Category
         */
        set: function (category) {
            this.setCategory("openCategoryY", category);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return smallest value out of all item's value fields.
     *
     * @ignore Exclude from docs
     * @param fields      Fields to check in
     * @param working     Include working (temporary) values
     * @param stackValue  If item is in a stack, the value item starts as
     * @return Value
     */
    XYSeriesDataItem.prototype.getMin = function (fields, working, stackValue) {
        var _this = this;
        //if (this.visible) {  // dumped because of non smooth zooming
        var min;
        if (!isNumber(stackValue)) {
            stackValue = 0;
        }
        each(fields, function (field) {
            var value;
            if (working) {
                value = _this.getWorkingValue(field);
            }
            else {
                value = _this.getValue(field);
            }
            value += stackValue;
            if (value < min || !isNumber(min)) {
                min = value;
            }
        });
        return min;
        //}
    };
    /**
     * Return biggest value out of all item's value fields.
     *
     * @ignore Exclude from docs
     * @param fields      Fields to check in
     * @param working     Include working (temporary) values
     * @param stackValue  If item is in a stack, the value item starts as
     * @return Value
     */
    XYSeriesDataItem.prototype.getMax = function (fields, working, stackValue) {
        var _this = this;
        //if (this.visible) { // dumped because of non smooth zooming
        var max;
        if (!isNumber(stackValue)) {
            stackValue = 0;
        }
        each(fields, function (field) {
            var value;
            if (working) {
                value = _this.getWorkingValue(field);
            }
            else {
                value = _this.getValue(field);
            }
            value += stackValue;
            if (value > max || !isNumber(max)) {
                max = value;
            }
        });
        return max;
        //}
    };
    return XYSeriesDataItem;
}(Series_SeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines Series for [[XYChart]].
 *
 * @see {@link IXYSeriesEvents} for a list of available Events
 * @see {@link IXYSeriesAdapters} for a list of available Adapters
 * @important
 */
var XYSeries_XYSeries = /** @class */ (function (_super) {
    __extends(XYSeries, _super);
    /**
     * Constructor
     */
    function XYSeries() {
        var _this = _super.call(this) || this;
        /**
         * Indicates which of the series' `dataFields` to calculate aggregate values
         * for.
         *
         * Available data fields for all [[XYSeries]] are:
         * `valueX`, `valueY`, `openValueX`, and `openValueY`.
         *
         * [[CandlestickSeries]] adds:
         * `lowValueX`, `lowValueY`, `highValueX`, and `highValueY`.
         *
         * Available options:
         * `"open"`, `"close"`, `"low"`, `"high"`, "average", `"sum"`.
         *
         * Defaults are as follows:
         * * `valueX`: `"close"`
         * * `valueY`: `"close"`
         * * `openValueX`: `"open"`
         * * `openValueY`: `"open"`
         * * `lowValueX`: `"low"`
         * * `lowValueY`: `"low"`
         * * `highValueX`: `"high"`
         * * `highValueY`: `"high"`
         *
         * Is required only if data being plotted on a `DateAxis` and
         * its `groupData` is set to `true`.
         *
         * ```TypeScript
         * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());
         * dateAxis.groupData = true;
         *
         * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());
         *
         * let series = chart.series.push(new am4charts.LineSeries());
         * series.dataFields.dateX = "date";
         * series.dataFields.valueY = "value";
         * series.groupFields.valueY = "average";
         * ```
         * ```JavaScript
         * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());
         * dateAxis.groupData = true;
         *
         * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());
         *
         * var series = chart.series.push(new am4charts.LineSeries());
         * series.dataFields.dateX = "date";
         * series.dataFields.valueY = "value";
         * series.groupFields.valueY = "average";
         * ```
         * ```JSON
         * {
         *   // ...
         *   "xAxes": [{
         *     "type": "DateAxis",
         *     "groupData": true
         *   }],
         *   "yAxes": [{
         *     "type": "ValueAxis"
         *   }],
         *   "series": [{
         *     "type": "LineSeries",
         *     "dataFields": {
         *       "dateX": "date",
         *       "valueY": "value"
         *     },
         *     "groupFields": {
         *       "valueY": "average"
         *     }
         *   }]
         * }
         * ```
         *
         * The above setup will ensure, that if there are many data items within
         * selected range, they will be grouped into aggregated data points, using
         * average value of all the values.
         *
         * For example if we have 2 years worth of daily data (~700 data items), when
         * fully zoomed out, the chart would show ~100 data items instead: one for
         * each week in those two years.
         *
         * Grouping will occur automatically, based on current selection range, and
         * will change dynamically when user zooms in/out the chart.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.
         * @since 4.7.0
         */
        _this.groupFields = {};
        /**
         * X axis the series is attached to.
         */
        _this._xAxis = new Disposer_MutableValueDisposer();
        /**
         * Y axis the series is attached to.
         */
        _this._yAxis = new Disposer_MutableValueDisposer();
        /**
         * [_xValueFields description]
         *
         * @todo Description
         */
        _this._xValueFields = [];
        /**
         * [_yValueFields description]
         *
         * @todo Description
         */
        _this._yValueFields = [];
        /**
         * @ignore
         */
        _this._baseInterval = {};
        /**
         * @ignore
         */
        _this.dataGrouped = false;
        /**
         * @ignore
         */
        _this.usesShowFields = false;
        /**
         * @ignore
         */
        _this._dataSetChanged = false;
        _this._maxxX = 100000;
        _this._maxxY = 100000;
        _this._propertiesChanged = false;
        _this.className = "XYSeries";
        _this.isMeasured = false;
        _this.groupFields.valueX = "close";
        _this.groupFields.valueY = "close";
        _this.groupFields.customValue = "close";
        _this.groupFields.openValueX = "open";
        _this.groupFields.openValueY = "open";
        _this.cursorTooltipEnabled = true;
        _this.cursorHoverEnabled = true;
        _this.excludeFromTotal = false;
        _this.mainContainer.mask = new Sprite_Sprite();
        _this.mainContainer.mask.setElement(_this.paper.add("path"));
        _this.stacked = false;
        _this.snapTooltip = false;
        _this._showBullets = false;
        _this.tooltip.pointerOrientation = "horizontal";
        _this.hideTooltipWhileZooming = true;
        _this.setPropertyValue("maskBullets", true);
        _this.tooltip.events.on("hidden", function () {
            _this.returnBulletDefaultState();
        }, undefined, false);
        _this._disposers.push(_this._xAxis);
        _this._disposers.push(_this._yAxis);
        _this.observe(visualProperties, function () {
            if (_this.inited) {
                _this._propertiesChanged = true;
                if (_this.legendDataItem) {
                    _this.legendDataItem.childrenCreated = false;
                }
                if (_this.chart && _this.chart.legend) {
                    _this.chart.legend.invalidateDataItems();
                }
                _this.invalidate();
            }
        }, undefined, false);
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    XYSeries.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("X/Y Series");
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    XYSeries.prototype.createDataItem = function () {
        return new XYSeries_XYSeriesDataItem();
    };
    /**
     * @ignore
     */
    XYSeries.prototype.resetExtremes = function () {
        this._tmin.clear();
        this._tmax.clear();
        this._smin.clear();
        this._smax.clear();
    };
    /**
     * @ignore
     */
    XYSeries.prototype.dataChangeUpdate = function () {
        this.dataGrouped = false;
        this._baseInterval = {};
        this._currentDataSetId = "";
        this.resetExtremes();
        if (this.xAxis) {
            this.xAxis.seriesDataChangeUpdate(this);
        }
        if (this.yAxis) {
            this.yAxis.seriesDataChangeUpdate(this);
        }
    };
    /**
     * (Re)validates the series' data.
     *
     * @ignore Exclude from docs
     */
    XYSeries.prototype.validateData = function () {
        this._baseInterval = {};
        var dataFields = this.dataFields;
        if (dataFields.valueYShow || dataFields.openValueXShow || dataFields.openValueXShow || dataFields.openValueYShow) {
            this.usesShowFields = true;
        }
        else {
            this.usesShowFields = false;
        }
        this.defineFields();
        if (this.data.length > 0) {
            this.dataChangeUpdate();
        }
        _super.prototype.validateData.call(this);
        this.updateItemReaderText();
        if (this.chart) {
            if (!hasValue(this.dataFields[this._xField]) || !hasValue(this.dataFields[this._yField])) {
                throw Error("Data fields for series \"" + (this.name ? this.name : this.uid) + "\" are not properly defined.");
            }
        }
        // 4.7.21 solves 51540
        if (this.inited && this.isHidden) {
            this.hide(0);
        }
        this.dataGrouped = false;
    };
    /**
     * Processes data item.
     *
     * @param dataItem     Data item
     * @param dataContext  Raw data
     * @param index        Index of the data item
     */
    XYSeries.prototype.processDataItem = function (dataItem, dataContext) {
        try {
            _super.prototype.processDataItem.call(this, dataItem, dataContext);
            this.xAxis.processSeriesDataItem(dataItem, "X");
            this.yAxis.processSeriesDataItem(dataItem, "Y");
            this.setInitialWorkingValues(dataItem);
        }
        catch (e) {
            if (this._chart) {
                this._chart.raiseCriticalError(e);
            }
        }
    };
    /**
     *
     * When validating raw data, instead of processing data item, we update it
     *
     * @ignore Exclude from docs
     * @param item
     */
    XYSeries.prototype.updateDataItem = function (dataItem) {
        _super.prototype.updateDataItem.call(this, dataItem);
        //dataItem.events.disable();
        this.xAxis.processSeriesDataItem(dataItem, "X");
        this.yAxis.processSeriesDataItem(dataItem, "Y");
        //dataItem.events.enable();		
    };
    /**
     * Inits data item's working values.
     *
     * @param dataItem  Data item
     * @param index     Data item's index
     */
    XYSeries.prototype.setInitialWorkingValues = function (dataItem) {
    };
    /**
     * @ignore
     */
    XYSeries.prototype.disposeData = function () {
        _super.prototype.disposeData.call(this);
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (xAxis) {
            var dataItemsX = this.dataItemsByAxis.getKey(xAxis.uid);
            if (dataItemsX) {
                dataItemsX.clear();
            }
            if (xAxis instanceof CategoryAxis_CategoryAxis) {
                this.clearCatAxis(xAxis);
            }
        }
        if (yAxis) {
            var dataItemsY = this.dataItemsByAxis.getKey(yAxis.uid);
            if (dataItemsY) {
                dataItemsY.clear();
            }
            if (yAxis instanceof CategoryAxis_CategoryAxis) {
                this.clearCatAxis(yAxis);
            }
        }
    };
    /**
     * @ignore
     */
    XYSeries.prototype.clearCatAxis = function (axis) {
        var uid = this.uid;
        axis.dataItems.each(function (dataItem) {
            if (dataItem.seriesDataItems[uid]) {
                dataItem.seriesDataItems[uid] = [];
            }
        });
    };
    /**
     * Sets up which data fields to use for data access.
     */
    XYSeries.prototype.defineFields = function () {
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (xAxis && yAxis) {
            var xAxisFieldName = xAxis.axisFieldName;
            var xField = (xAxisFieldName + "X");
            var xOpenField = ("open" + capitalize(xAxisFieldName) + "X");
            var yAxisFieldName = yAxis.axisFieldName;
            var yField = (yAxisFieldName + "Y");
            var yOpenField = ("open" + capitalize(yAxisFieldName) + "Y");
            this._xField = xField;
            this._yField = yField;
            if (this.dataFields[xOpenField]) {
                this._xOpenField = xOpenField;
            }
            if (this.dataFields[yOpenField]) {
                this._yOpenField = yOpenField;
            }
            if (!this.dataFields[yOpenField] && this.baseAxis == yAxis) {
                this._yOpenField = yField;
            }
            if (!this.dataFields[xOpenField] && this.baseAxis == xAxis) {
                this._xOpenField = xField;
            }
            if (this.stacked && this.baseAxis == xAxis) {
                this._xOpenField = xField;
            }
            if (this.stacked && this.baseAxis == yAxis) {
                this._yOpenField = yField;
            }
            if ((xAxis instanceof CategoryAxis_CategoryAxis) && (yAxis instanceof CategoryAxis_CategoryAxis)) {
                if (!this._yOpenField) {
                    this._yOpenField = yField;
                }
            }
            this._xValueFields = [];
            this._yValueFields = [];
            this.addValueField(xAxis, this._xValueFields, this._xField);
            this.addValueField(xAxis, this._xValueFields, this._xOpenField);
            this.addValueField(yAxis, this._yValueFields, this._yField);
            this.addValueField(yAxis, this._yValueFields, this._yOpenField);
        }
    };
    /**
     * [axis description]
     *
     * @todo Description
     * @param axis    Axis
     * @param fields  Fields (?)
     * @param field   Field
     */
    XYSeries.prototype.addValueField = function (axis, fields, field) {
        if (axis instanceof ValueAxis_ValueAxis) {
            if (hasValue(this.dataFields[field]) && fields.indexOf(field) == -1) {
                fields.push(field);
            }
        }
    };
    /**
     * Sets category field from the category axis.
     *
     * User might set field for category axis only, but not for series. In such
     * case, we take field value from axis and set it for series.
     *
     * @param field  Field
     * @param axis   Axis
     */
    XYSeries.prototype.setCategoryAxisField = function (field, axis) {
        if (!hasValue(this.dataFields[field])) {
            this.dataFields[field] = axis.dataFields.category;
        }
    };
    /**
     * Sets date field from the date axis.
     *
     * User might set field for category axis only, but not for series. In such
     * case, we take field value from axis and set it for series.
     *
     * @param field  Field
     * @param axis   Axis
     */
    XYSeries.prototype.setDateAxisField = function (field, axis) {
        if (!hasValue(this.dataFields[field])) {
            this.dataFields[field] = axis.dataFields.date;
        }
    };
    /**
     * Performs after-draw tasks, e.g. creates masks.
     */
    XYSeries.prototype.afterDraw = function () {
        _super.prototype.afterDraw.call(this);
        this.createMask();
    };
    /**
     * Create a mask for the series.
     *
     * @ignore Exclude from docs
     */
    XYSeries.prototype.createMask = function () {
        // this mask from which we cut out ranges. does not work well if ranges overlap.
        if (this.mainContainer.mask) {
            var path_1 = this.getMaskPath();
            // @todo: this approach won't work well on circluar or other non x/y axes
            Iterator_each(this.axisRanges.iterator(), function (range) {
                if (range.axisFill.fillPath) {
                    range.axisFill.validate();
                    path_1 += range.axisFill.fillPath;
                }
            });
            this.mainContainer.mask.path = path_1;
        }
    };
    /**
     * Returns an SVG path to use as series mask.
     *
     * @return SVG path
     */
    XYSeries.prototype.getMaskPath = function () {
        if (this.xAxis && this.yAxis) {
            return rectToPath({
                x: 0,
                y: 0,
                width: this.xAxis.axisLength,
                height: this.yAxis.axisLength
            });
        }
        return "";
    };
    /**
     * Returns axis data field to use.
     *
     * @param axis  Axis
     * @return Field name
     */
    XYSeries.prototype.getAxisField = function (axis) {
        if (axis == this.xAxis) {
            return this.xField;
        }
        if (axis == this.yAxis) {
            return this.yField;
        }
    };
    /**
     * Validates data items.
     *
     * @ignore Exclude from docs
     */
    XYSeries.prototype.validateDataItems = function () {
        var chart = this.chart;
        if (chart) {
            this._maxxX = Math_max(100000, chart.plotContainer.maxWidth * 2);
            this._maxxY = Math_max(100000, chart.plotContainer.maxHeight * 2);
        }
        // this helps date axis to check which baseInterval we should use
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (xAxis && yAxis) {
            xAxis.updateAxisBySeries();
            yAxis.updateAxisBySeries();
        }
        _super.prototype.validateDataItems.call(this);
        if (xAxis && yAxis) {
            xAxis.postProcessSeriesDataItems(this);
            yAxis.postProcessSeriesDataItems(this);
        }
    };
    /**
     * Validates data range.
     *
     * @ignore Exclude from docs
     */
    XYSeries.prototype.validateDataRange = function () {
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (xAxis && yAxis) {
            if (xAxis.dataRangeInvalid) {
                xAxis.validateDataRange();
            }
            if (yAxis.dataRangeInvalid) {
                yAxis.validateDataRange();
            }
        }
        _super.prototype.validateDataRange.call(this);
    };
    /**
     * (Re)validates the whole series, effectively causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    XYSeries.prototype.validate = function () {
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (xAxis && yAxis) {
            if (xAxis.invalid) {
                xAxis.validate();
            }
            if (yAxis.invalid) {
                yAxis.validate();
            }
            this.y = yAxis.pixelY;
            this.x = xAxis.pixelX;
            this._showBullets = true;
            var minBulletDistance = this.minBulletDistance;
            if (isNumber(minBulletDistance)) {
                if (this.baseAxis.axisLength / (this.endIndex - this.startIndex) < minBulletDistance) {
                    this._showBullets = false;
                }
            }
        }
        this.updateTooltip();
        _super.prototype.validate.call(this);
        var chart = this.chart;
        var maskBullets = this.maskBullets;
        if (chart && maskBullets) {
            if (chart.className == "XYChart") {
                if (chart.leftAxesContainer.layout == "vertical" || chart.rightAxesContainer.layout == "vertical") {
                    if (this.yAxis) {
                        this.bulletsContainer.mask = this.yAxis.renderer.gridContainer;
                    }
                    else {
                        this.bulletsContainer.mask = undefined;
                    }
                }
                if (chart.topAxesContainer.layout == "horizontal" || chart.bottomAxesContainer.layout == "horizontal") {
                    if (this.xAxis) {
                        this.bulletsContainer.mask = this.xAxis.renderer.gridContainer;
                    }
                    else {
                        this.bulletsContainer.mask = undefined;
                    }
                }
            }
        }
    };
    Object.defineProperty(XYSeries.prototype, "xAxis", {
        /**
         * @return Axis
         */
        get: function () {
            if (this.chart) {
                if (!this._xAxis.get()) {
                    var axis = this.chart.xAxes.getIndex(0);
                    if (!axis) {
                        throw Error("There are no X axes on chart.");
                    }
                    this.xAxis = axis;
                }
                return this._xAxis.get();
            }
        },
        /**
         * X axis the series is attached to.
         *
         * @param axis  Axis
         */
        set: function (axis) {
            this.setXAxis(axis);
        },
        enumerable: true,
        configurable: true
    });
    XYSeries.prototype.setXAxis = function (axis) {
        var oldAxis = this._xAxis.get();
        if (oldAxis != axis) {
            if (oldAxis) {
                this.dataItemsByAxis.removeKey(oldAxis.uid);
                // TODO why is this here ?
                this._xAxis.dispose();
                // temp @todo: why it is not disposed?
                oldAxis.series.removeValue(this);
            }
            this._xAxis.set(axis, axis.registerSeries(this));
            this.dataItemsByAxis.setKey(axis.uid, new Dictionary_Dictionary());
            this.invalidateData();
        }
    };
    Object.defineProperty(XYSeries.prototype, "yAxis", {
        /**
         * @return Axis
         */
        get: function () {
            if (this.chart) {
                if (!this._yAxis.get()) {
                    var axis = this.chart.yAxes.getIndex(0);
                    if (!axis) {
                        throw Error("There are no Y axes on chart.");
                    }
                    this.yAxis = axis;
                }
                return this._yAxis.get();
            }
        },
        /**
         * Y axis the series is attached to.
         *
         * @param axis  Axis
         */
        set: function (axis) {
            this.setYAxis(axis);
        },
        enumerable: true,
        configurable: true
    });
    XYSeries.prototype.setYAxis = function (axis) {
        var oldAxis = this._yAxis.get();
        if (oldAxis != axis) {
            if (oldAxis) {
                this.dataItemsByAxis.removeKey(oldAxis.uid);
                // TODO why is this here ?
                this._yAxis.dispose();
                // temp @todo: why it is not disposed?
                oldAxis.series.removeValue(this);
            }
            this._yAxis.set(axis, axis.registerSeries(this));
            if (axis.chart instanceof XYChart_XYChart) {
                axis.chart.handleYAxisSet(this);
            }
            this.dataItemsByAxis.setKey(axis.uid, new Dictionary_Dictionary());
            this.invalidateData();
        }
    };
    Object.defineProperty(XYSeries.prototype, "baseAxis", {
        /**
         * @return Axis
         */
        get: function () {
            var xAxis = this.xAxis;
            var yAxis = this.yAxis;
            if (!this._baseAxis && xAxis && yAxis) {
                if (yAxis instanceof DateAxis_DateAxis) {
                    this._baseAxis = yAxis;
                }
                if (xAxis instanceof DateAxis_DateAxis) {
                    this._baseAxis = xAxis;
                }
                if (yAxis instanceof CategoryAxis_CategoryAxis) {
                    this._baseAxis = yAxis;
                }
                if (xAxis instanceof CategoryAxis_CategoryAxis) {
                    this._baseAxis = xAxis;
                }
                if (!this._baseAxis) {
                    this._baseAxis = xAxis;
                }
            }
            return this._baseAxis;
        },
        /**
         * The main (base) axis.
         *
         * This is the axis that series fills will go to, or grow animations will
         * happen from.
         *
         * @param value  Axis
         */
        set: function (value) {
            if (this._baseAxis != value) {
                this._baseAxis = value;
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds one or several (array) of data items to the existing data.
     *
     * @param rawDataItem One or many raw data item objects
     */
    XYSeries.prototype.addData = function (rawDataItem, removeCount, skipRaw) {
        _super.prototype.addData.call(this, rawDataItem, removeCount, skipRaw);
        var scrollbarSeries = this.scrollbarSeries;
        if (scrollbarSeries) {
            this.scrollbarSeries.addData(rawDataItem, removeCount, true);
        }
    };
    XYSeries.prototype.setData = function (value) {
        _super.prototype.setData.call(this, value);
        if (this.scrollbarSeries) {
            this.scrollbarSeries.setData(value);
        }
    };
    /**
     * Makes the chart use particular data set.
     *
     * If `id` is not provided or there is no such data set, main data will be
     * used.
     *
     * @ignore
     * @since 4.7.0
     * @param  id  Data set id
     */
    XYSeries.prototype.setDataSet = function (id) {
        var changed = _super.prototype.setDataSet.call(this, id);
        if (changed) {
            this._dataSetChanged = true;
            var dataItems = this.dataItems;
            this.resetExtremes();
            var xAxis = this.xAxis;
            var yAxis = this.yAxis;
            this._prevStartIndex = undefined;
            this._prevEndIndex = undefined;
            this._startIndex = undefined;
            this._endIndex = undefined;
            if (!this.appeared) {
                this.processValues(false); // this will slow down!
            }
            if (xAxis instanceof DateAxis_DateAxis && xAxis == this.baseAxis) {
                this._tmin.setKey(xAxis.uid, dataItems.getIndex(0).dateX.getTime());
                this._tmax.setKey(xAxis.uid, dataItems.getIndex(dataItems.length - 1).dateX.getTime());
                this.dispatch("extremeschanged");
            }
            if (yAxis instanceof DateAxis_DateAxis && yAxis == this.baseAxis) {
                this._tmin.setKey(yAxis.uid, dataItems.getIndex(0).dateY.getTime());
                this._tmax.setKey(yAxis.uid, dataItems.getIndex(dataItems.length - 1).dateY.getTime());
                this.dispatch("extremeschanged");
            }
        }
        return changed;
    };
    /**
     * Processes values after data items' were added.
     *
     * @ignore Exclude from docs
     * @param dataItems  Data items
     */
    XYSeries.prototype.processValues = function (working) {
        _super.prototype.processValues.call(this, working);
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (!xAxis || !yAxis) {
            return;
        }
        var dataItems = this.dataItems;
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        var startIndex = this.startIndex;
        var endIndex = this.endIndex;
        var workingStartIndex = startIndex;
        var workingEndIndex = endIndex;
        if (!working) {
            startIndex = 0;
            endIndex = this.dataItems.length;
        }
        for (var i = startIndex; i < endIndex; i++) {
            var dataItem = dataItems.getIndex(i);
            this.getStackValue(dataItem, working);
            var stackX = dataItem.getValue("valueX", "stack");
            var stackY = dataItem.getValue("valueY", "stack");
            minX = Math_min(dataItem.getMin(this._xValueFields, working, stackX), minX);
            minY = Math_min(dataItem.getMin(this._yValueFields, working, stackY), minY);
            maxX = Math_max(dataItem.getMax(this._xValueFields, working, stackX), maxX);
            maxY = Math_max(dataItem.getMax(this._yValueFields, working, stackY), maxY);
            // if it's stacked, pay attention to stack value
            if (this.stacked) {
                if (this.baseAxis == xAxis) {
                    if (stackY < minY) {
                        minY = stackY;
                    }
                    if (stackY > maxY) {
                        maxY = stackY;
                    }
                }
                if (this.baseAxis == yAxis) {
                    if (stackX < minX) {
                        minX = stackX;
                    }
                    if (stackX > maxX) {
                        maxX = stackX;
                    }
                }
            }
        }
        // this is mainly for value axis to calculate total and perecent.total of each series category
        xAxis.processSeriesDataItems();
        yAxis.processSeriesDataItems();
        var xAxisId = xAxis.uid;
        var yAxisId = yAxis.uid;
        if (this.xAxis instanceof ValueAxis_ValueAxis && (minX == Infinity || maxX == -Infinity)) {
            return;
        }
        if (this.yAxis instanceof ValueAxis_ValueAxis && (minY == Infinity || maxY == -Infinity)) {
            return;
        }
        if (!working) {
            if (this._tmin.getKey(xAxisId) != minX || this._tmax.getKey(xAxisId) != maxX || this._tmin.getKey(yAxisId) != minY || this._tmax.getKey(yAxisId) != maxY) {
                this._tmin.setKey(xAxisId, minX);
                this._tmax.setKey(xAxisId, maxX);
                this._tmin.setKey(yAxisId, minY);
                this._tmax.setKey(yAxisId, maxY);
                var stackedSeries = this.stackedSeries;
                if (stackedSeries) {
                    if (stackedSeries.isDisposed()) {
                        this.stackedSeries = undefined;
                    }
                    else {
                        stackedSeries.processValues(false);
                    }
                }
                this.dispatchImmediately("extremeschanged");
            }
        }
        if (startIndex != workingStartIndex || endIndex != workingEndIndex) {
            minX = Infinity;
            maxX = -Infinity;
            minY = Infinity;
            maxY = -Infinity;
            for (var i = workingStartIndex; i < workingEndIndex; i++) {
                var dataItem = dataItems.getIndex(i);
                this.getStackValue(dataItem, working);
                var stackX = dataItem.getValue("valueX", "stack");
                var stackY = dataItem.getValue("valueY", "stack");
                minX = Math_min(dataItem.getMin(this._xValueFields, working, stackX), minX);
                minY = Math_min(dataItem.getMin(this._yValueFields, working, stackY), minY);
                maxX = Math_max(dataItem.getMax(this._xValueFields, working, stackX), maxX);
                maxY = Math_max(dataItem.getMax(this._yValueFields, working, stackY), maxY);
                // if it's stacked, pay attention to stack value
                if (this.stacked) {
                    if (this.baseAxis == xAxis) {
                        if (stackY < minY) {
                            minY = stackY;
                        }
                        if (stackY > maxY) {
                            maxY = stackY;
                        }
                    }
                    if (this.baseAxis == yAxis) {
                        if (stackX < minX) {
                            minX = stackX;
                        }
                        if (stackX > maxX) {
                            maxX = stackX;
                        }
                    }
                }
            }
        }
        if (this.xAxis instanceof ValueAxis_ValueAxis && (minX == Infinity || maxX == -Infinity)) {
            return;
        }
        if (this.yAxis instanceof ValueAxis_ValueAxis && (minY == Infinity || maxY == -Infinity)) {
            return;
        }
        if (this._smin.getKey(xAxisId) != minX || this._smax.getKey(xAxisId) != maxX || this._smin.getKey(yAxisId) != minY || this._smax.getKey(yAxisId) != maxY) {
            this._smin.setKey(xAxisId, minX);
            this._smax.setKey(xAxisId, maxX);
            this._smin.setKey(yAxisId, minY);
            this._smax.setKey(yAxisId, maxY);
            if (this.appeared || this.start != 0 || this.end != 1 || this.dataItems != this.mainDataSet) {
                /// new, helps to handle issues with change percent
                var changed = false;
                if (yAxis instanceof ValueAxis_ValueAxis && !(yAxis instanceof DateAxis_DateAxis)) {
                    var tmin = this._tmin.getKey(yAxisId);
                    if (!isNumber(tmin) || ((this.usesShowFields || this._dataSetChanged) && minY < tmin) || (this.stackedSeries && !this.isHidden)) {
                        this._tmin.setKey(yAxisId, minY);
                        changed = true;
                    }
                    var tmax = this._tmax.getKey(yAxisId);
                    if (!isNumber(tmax) || ((this.usesShowFields || this._dataSetChanged) && maxY > tmax) || (this.stackedSeries && !this.isHidden)) {
                        this._tmax.setKey(yAxisId, maxY);
                        changed = true;
                    }
                }
                if (xAxis instanceof ValueAxis_ValueAxis && !(xAxis instanceof DateAxis_DateAxis)) {
                    var tmin = this._tmin.getKey(xAxisId);
                    if (!isNumber(tmin) || ((this.usesShowFields || this._dataSetChanged) && minX < tmin) || (this.stackedSeries && !this.isHidden)) {
                        this._tmin.setKey(xAxisId, minX);
                        changed = true;
                    }
                    var tmax = this._tmax.getKey(xAxisId);
                    if (!isNumber(tmax) || ((this.usesShowFields || this._dataSetChanged) && maxX > tmax) || (this.stackedSeries && !this.isHidden)) {
                        this._tmax.setKey(xAxisId, maxX);
                        changed = true;
                    }
                }
                if (changed) {
                    this.dispatchImmediately("extremeschanged");
                }
                if (this.start == 0 && this.end == 1) {
                    // yes, its ok. otherwise min/max won't be updated when zooming out
                    this._dataSetChanged = false;
                }
                this.dispatchImmediately("selectionextremeschanged");
            }
        }
        if (!working && this.stacked) {
            this.processValues(true);
        }
    };
    /**
     * Hides element's [[Tooltip]].
     *
     * @see {@link Tooltip}
     */
    XYSeries.prototype.hideTooltip = function () {
        _super.prototype.hideTooltip.call(this);
        this.returnBulletDefaultState();
        this._prevTooltipDataItem = undefined;
    };
    /**
     * Shows series tooltip at specific position.
     *
     * @param xPosition  X
     * @param yPosition  Y
     */
    XYSeries.prototype.showTooltipAtPosition = function (xPosition, yPosition) {
        var dataItem;
        if (this.visible && !this.isHiding && !this.isShowing) {
            var xAxis = this._xAxis.get();
            var yAxis = this._yAxis.get();
            if (xAxis == this.baseAxis) {
                dataItem = xAxis.getSeriesDataItem(this, xAxis.toAxisPosition(xPosition), this.snapTooltip);
            }
            if (yAxis == this.baseAxis) {
                dataItem = yAxis.getSeriesDataItem(this, yAxis.toAxisPosition(yPosition), this.snapTooltip);
            }
            var point = this.showTooltipAtDataItem(dataItem);
            if (point) {
                return point;
            }
            // so that if tooltip is shown on columns or bullets for it not to be hidden
            if (!this.tooltipText) {
                return;
            }
        }
        this.hideTooltip();
    };
    XYSeries.prototype.getAdjustedXLocation = function (dataItem, field) {
        return dataItem.locations[field];
    };
    XYSeries.prototype.getAdjustedYLocation = function (dataItem, field) {
        return dataItem.locations[field];
    };
    /**
     * Shows series tooltip at specific dataItem.
     *
     * @param dataItem
     */
    XYSeries.prototype.showTooltipAtDataItem = function (dataItem) {
        var e_1, _a;
        var cursor = this.chart.cursor;
        if (cursor && cursor.hideSeriesTooltipsOnSelection && cursor.selection.visible && cursor.downPoint) {
            this.hideTooltip();
            return;
        }
        this.returnBulletDefaultState(dataItem);
        if (dataItem && dataItem.visible) {
            this.updateLegendValue(dataItem);
            if (this.cursorTooltipEnabled) {
                this.tooltipDataItem = dataItem;
                // todo: add tooltipXField and tooltipYField.
                var tooltipXField = this.tooltipXField;
                var tooltipYField = this.tooltipYField;
                if (hasValue(dataItem[tooltipXField]) && hasValue(dataItem[tooltipYField])) {
                    var tooltipPoint = this.getPoint(dataItem, tooltipXField, tooltipYField, this.getAdjustedXLocation(dataItem, tooltipXField), this.getAdjustedYLocation(dataItem, tooltipYField));
                    if (tooltipPoint) {
                        if (this.chart.className == "XYChart" && (tooltipPoint.y < -1 || tooltipPoint.y > this.yAxis.pixelHeight + 1 || tooltipPoint.x < -1 || tooltipPoint.x > this.xAxis.pixelWidth + 1)) {
                            // void
                        }
                        else {
                            this.tooltipX = tooltipPoint.x;
                            this.tooltipY = tooltipPoint.y;
                            if (this._prevTooltipDataItem != dataItem) {
                                this.dispatchImmediately("tooltipshownat", {
                                    type: "tooltipshownat",
                                    target: this,
                                    dataItem: dataItem
                                });
                                this._prevTooltipDataItem = dataItem;
                            }
                            if (this.cursorHoverEnabled) {
                                try {
                                    for (var _b = __values(dataItem.sprites), _c = _b.next(); !_c.done; _c = _b.next()) {
                                        var sprite = _c.value;
                                        if (!sprite.parent.visible || sprite.isHidden || sprite.__disabled || sprite.disabled || sprite.isHiding) {
                                        }
                                        else {
                                            if (!sprite.interactions.isRealHover) {
                                                sprite.dispatchImmediately("over");
                                                sprite.interactions.isRealHover = true;
                                            }
                                            sprite.isHover = true;
                                        }
                                    }
                                }
                                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                                finally {
                                    try {
                                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                    }
                                    finally { if (e_1) throw e_1.error; }
                                }
                            }
                            if (this.showTooltip()) {
                                return spritePointToSvg({ x: tooltipPoint.x, y: tooltipPoint.y }, this);
                            }
                            return;
                        }
                    }
                }
            }
        }
        else {
            this.updateLegendValue(dataItem, true);
        }
    };
    /**
     * Returns default state to bullets when tooltip is shown at some other data
     * item or hidden
     */
    XYSeries.prototype.returnBulletDefaultState = function (dataItem) {
        var e_2, _a;
        if (this._prevTooltipDataItem && this._prevTooltipDataItem != dataItem) {
            try {
                for (var _b = __values(this._prevTooltipDataItem.sprites), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var sprite = _c.value;
                    if (!sprite.isDisposed()) {
                        var fireEvent = sprite.interactions.isRealHover;
                        sprite.isHover = false;
                        if (fireEvent) {
                            sprite.dispatchImmediately("out");
                        }
                    }
                    else {
                        this._prevTooltipDataItem = undefined;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    XYSeries.prototype.shouldCreateBullet = function (dataItem, bulletTemplate) {
        // use series xField/yField if bullet doesn't have fields set
        var xField = bulletTemplate.xField;
        if (!hasValue(xField)) {
            xField = this.xField;
        }
        var yField = bulletTemplate.yField;
        if (!hasValue(yField)) {
            yField = this.yField;
        }
        if ((this.xAxis instanceof ValueAxis_ValueAxis && !dataItem.hasValue([xField])) || (this.yAxis instanceof ValueAxis_ValueAxis && !dataItem.hasValue([yField]))) {
            return false;
        }
        if (bulletTemplate.disabled) {
            var disabledField = bulletTemplate.propertyFields.disabled;
            var dataContext = dataItem.dataContext;
            if (dataContext && dataContext[disabledField] === false) {
                return true;
            }
            else {
                return false;
            }
        }
        return true;
    };
    /**
     * @ignore
     */
    XYSeries.prototype.updateTooltip = function () {
        if (!this.hideTooltipWhileZooming && this.tooltip && !this.tooltip.isHidden && !this.isHiding && !this.isHidden && this.tooltipDataItem) {
            this.showTooltipAtDataItem(this.tooltipDataItem);
        }
    };
    /**
     * @ignore
     */
    XYSeries.prototype.positionBullet = function (bullet) {
        _super.prototype.positionBullet.call(this, bullet);
        var dataItem = bullet.dataItem;
        // use series xField/yField if bullet doesn't have fields set
        var xField = bullet.xField;
        if (!hasValue(xField)) {
            xField = this.xField;
        }
        var yField = bullet.yField;
        if (!hasValue(yField)) {
            yField = this.yField;
        }
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if ((xAxis instanceof ValueAxis_ValueAxis && !dataItem.hasValue([xField])) || (yAxis instanceof ValueAxis_ValueAxis && !dataItem.hasValue([yField]))) {
            bullet.visible = false;
        }
        else {
            var bulletLocationX = this.getBulletLocationX(bullet, xField);
            var bulletLocationY = this.getBulletLocationY(bullet, yField);
            var point = this.getPoint(dataItem, xField, yField, bulletLocationX, bulletLocationY);
            if (point) {
                var xOpenField = this.xOpenField;
                var yOpenField = this.yOpenField;
                var positionX = void 0;
                var positionY = void 0;
                if (xAxis instanceof DateAxis_DateAxis) {
                    if (!isNumber(bulletLocationX)) {
                        bulletLocationX = 0;
                    }
                    var openValue = void 0;
                    var closeValue = dataItem.getWorkingValue(xField);
                    if (!xOpenField) {
                        if (xAxis == this.baseAxis) {
                            openValue = xAxis.baseValue;
                        }
                    }
                    else {
                        openValue = dataItem.getWorkingValue(xOpenField);
                    }
                    if (!isNumber(openValue)) {
                        openValue = closeValue;
                    }
                    var stack = dataItem.getValue("valueX", "stack");
                    openValue += stack;
                    closeValue += stack;
                    if (openValue == closeValue) {
                        var baseInterval = xAxis.baseInterval;
                        var dateFormatter = xAxis.dateFormatter;
                        openValue = Time_round(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.firstDayOfWeek, dateFormatter.utc).getTime();
                        closeValue = Time_add(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.utc).getTime();
                    }
                    var middleValue = void 0;
                    if (xAxis == this.baseAxis) {
                        middleValue = openValue + (closeValue - openValue) * bulletLocationX;
                    }
                    else {
                        middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationX);
                    }
                    positionX = xAxis.valueToPosition(middleValue);
                }
                else if (xAxis instanceof ValueAxis_ValueAxis) {
                    if (!isNumber(bulletLocationX)) {
                        bulletLocationX = 0;
                    }
                    var openValue = void 0;
                    var closeValue = dataItem.getWorkingValue(xField);
                    if (!xOpenField) {
                        openValue = xAxis.baseValue;
                    }
                    else {
                        openValue = dataItem.getWorkingValue(xOpenField);
                    }
                    var stack = dataItem.getValue("valueX", "stack");
                    openValue += stack;
                    closeValue += stack;
                    var middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationX);
                    positionX = xAxis.valueToPosition(middleValue);
                }
                else if (xAxis instanceof CategoryAxis_CategoryAxis) {
                    var rightLocation = this.getAdjustedXLocation(dataItem, xField);
                    var leftLocation = this.getAdjustedXLocation(dataItem, xOpenField);
                    positionX = xAxis.categoryToPosition(dataItem[xField], rightLocation);
                    var openPositionX = void 0;
                    if (xOpenField) {
                        openPositionX = xAxis.categoryToPosition(dataItem[xOpenField], leftLocation);
                    }
                    if (!isNumber(openPositionX)) {
                        openPositionX = 1;
                    }
                    positionX = openPositionX + (positionX - openPositionX) * bulletLocationX;
                }
                if (yAxis instanceof DateAxis_DateAxis) {
                    if (!isNumber(bulletLocationY)) {
                        bulletLocationY = 0;
                    }
                    var openValue = void 0;
                    var closeValue = dataItem.getWorkingValue(yField);
                    if (!yOpenField) {
                        if (yAxis == this.baseAxis) {
                            openValue = yAxis.baseValue;
                        }
                    }
                    else {
                        openValue = dataItem.getWorkingValue(yOpenField);
                    }
                    if (!isNumber(openValue)) {
                        openValue = closeValue;
                    }
                    var stack = dataItem.getValue("valueY", "stack");
                    openValue += stack;
                    closeValue += stack;
                    if (openValue == closeValue) {
                        var baseInterval = yAxis.baseInterval;
                        var dateFormatter = yAxis.dateFormatter;
                        openValue = Time_round(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.firstDayOfWeek, dateFormatter.utc).getTime();
                        closeValue = Time_add(new Date(openValue), baseInterval.timeUnit, baseInterval.count, dateFormatter.utc).getTime();
                    }
                    var middleValue = void 0;
                    if (yAxis == this.baseAxis) {
                        middleValue = openValue + (closeValue - openValue) * bulletLocationY;
                    }
                    else {
                        middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationY);
                    }
                    positionY = yAxis.valueToPosition(middleValue);
                }
                else if (yAxis instanceof ValueAxis_ValueAxis) {
                    if (!isNumber(bulletLocationY)) {
                        bulletLocationY = 0;
                    }
                    var openValue = void 0;
                    var closeValue = dataItem.getWorkingValue(yField);
                    if (!yOpenField) {
                        openValue = yAxis.baseValue;
                    }
                    else {
                        openValue = dataItem.getWorkingValue(yOpenField);
                    }
                    var stack = dataItem.getValue("valueY", "stack");
                    openValue += stack;
                    closeValue += stack;
                    var middleValue = openValue + (closeValue - openValue) * (1 - bulletLocationY);
                    positionY = yAxis.valueToPosition(middleValue);
                }
                else if (yAxis instanceof CategoryAxis_CategoryAxis) {
                    positionY = yAxis.categoryToPosition(dataItem[yField], bulletLocationY);
                    var topLocation = this.getAdjustedYLocation(dataItem, yField);
                    var bottomLocation = this.getAdjustedYLocation(dataItem, yOpenField);
                    positionY = yAxis.categoryToPosition(dataItem[yField], topLocation);
                    var openPositionY = void 0;
                    if (yOpenField) {
                        openPositionY = yAxis.categoryToPosition(dataItem[yOpenField], bottomLocation);
                    }
                    if (!isNumber(openPositionY)) {
                        openPositionY = 1;
                    }
                    positionY = openPositionY + (positionY - openPositionY) * bulletLocationY;
                }
                bullet.visible = true;
                this.positionBulletReal(bullet, positionX, positionY);
            }
            else {
                bullet.visible = false;
            }
        }
    };
    XYSeries.prototype.positionBulletReal = function (bullet, positionX, positionY) {
        bullet.x = this.xAxis.renderer.positionToPoint(positionX, positionY).x;
        bullet.y = this.yAxis.renderer.positionToPoint(positionY, positionX).y;
    };
    /**
     * returns bullet x location
     * @ignore
     */
    XYSeries.prototype.getBulletLocationX = function (bullet, field) {
        var bulletLocation = bullet.locationX;
        var dataItem = bullet.dataItem;
        if (!isNumber(bulletLocation)) {
            bulletLocation = dataItem.workingLocations[field];
        }
        return bulletLocation;
    };
    /**
     * Returns bullet x location
     * @ignore
     */
    XYSeries.prototype.getBulletLocationY = function (bullet, field) {
        var bulletLocation = bullet.locationY;
        var dataItem = bullet.dataItem;
        if (!isNumber(bulletLocation)) {
            bulletLocation = dataItem.workingLocations[field];
        }
        return bulletLocation;
    };
    /**
     * This method must be called if you update Series' data fields that might
     * affect stacking of the series.
     *
     * Since individual `dataField` changes are not being monitored, you need
     * todo it manually for changes to take affect.
     *
     * @since 4.7.21
     */
    XYSeries.prototype.updateStacking = function () {
        var _this = this;
        this.invalidateDataItems();
        if (this.chart) {
            this.chart.series.each(function (series) {
                if (series.baseAxis == _this.baseAxis) {
                    series.stackedSeries = undefined;
                    series.invalidateDataItems();
                    series.invalidateProcessedData();
                }
            });
        }
    };
    Object.defineProperty(XYSeries.prototype, "stacked", {
        /**
         * @return Can be stacked?
         */
        get: function () {
            return this.getPropertyValue("stacked");
        },
        /**
         * Can items from this series be included into stacks?
         *
         * Note: proper stacking is only possible if series have the same number
         * of data items. To ensure this, don't set data directly on series
         * but do this on chart instead.
         *
         * @default false
         * @param stacked  Can be stacked?
         */
        set: function (stacked) {
            if (this.setPropertyValue("stacked", stacked, true)) {
                this.updateStacking();
                var xAxis = this.xAxis;
                var yAxis = this.yAxis;
                if (!stacked) {
                    var field_1;
                    if (xAxis != this.baseAxis && xAxis instanceof ValueAxis_ValueAxis) {
                        field_1 = this.xField;
                    }
                    if (yAxis != this.baseAxis && yAxis instanceof ValueAxis_ValueAxis) {
                        field_1 = this.yField;
                    }
                    if (field_1) {
                        this.dataItems.each(function (dataItem) {
                            dataItem.setCalculatedValue(field_1, 0, "stack");
                        });
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeries.prototype, "snapTooltip", {
        /**
         * @return Should snap?
         */
        get: function () {
            return this.getPropertyValue("snapTooltip");
        },
        /**
         * Should the nearest tooltip be shown if no data item is found on the
         * current cursor position? In order this to work, you should set snapTooltip = false on the series baseAxis.
         *
         * @default false
         * @param value  Should snap?
         */
        set: function (value) {
            this.setPropertyValue("snapTooltip", value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows hidden series.
     *
     * @param duration  Duration of reveal animation (ms)
     * @return Animation
     */
    XYSeries.prototype.show = function (duration) {
        var _this = this;
        var fields;
        if (this.xAxis instanceof ValueAxis_ValueAxis && this.xAxis != this.baseAxis) {
            fields = this._xValueFields;
        }
        if (this.yAxis instanceof ValueAxis_ValueAxis && this.yAxis != this.baseAxis) {
            fields = this._yValueFields;
        }
        var startIndex = this.startIndex;
        var endIndex = this.endIndex;
        var delay = 0;
        var interpolationDuration = this.defaultState.transitionDuration;
        if (isNumber(duration)) {
            interpolationDuration = duration;
        }
        if (!Options_options.animationsEnabled) {
            interpolationDuration = 0;
        }
        var anim;
        Iterator_each(indexed(this.dataItems.iterator()), function (a) {
            var i = a[0];
            var dataItem = a[1];
            var realDuration = interpolationDuration;
            if (i < _this.startIndex - 10 || i > _this.endIndex + 10) {
                realDuration = 0;
                delay = 0;
            }
            if (_this.sequencedInterpolation && realDuration > 0) {
                delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);
            }
            anim = dataItem.show(realDuration, delay, fields);
        });
        // other data sets
        this.dataSets.each(function (key, dataSet) {
            if (dataSet != _this.dataItems) {
                dataSet.each(function (dataItem) {
                    dataItem.events.disable();
                    dataItem.show(0, 0, fields);
                    dataItem.events.enable();
                });
            }
        });
        if (this.mainDataSet != this.dataItems) {
            this.mainDataSet.each(function (dataItem) {
                dataItem.events.disable();
                dataItem.show(0, 0, fields);
                dataItem.events.enable();
            });
        }
        var animation = _super.prototype.show.call(this, duration);
        if (anim && !anim.isFinished()) {
            animation = anim;
        }
        if (this.hidden) {
            this.dispatchImmediately("selectionextremeschanged");
            this.hidden = false;
        }
        return animation;
    };
    /**
     * Hides series.
     *
     * @param duration  Duration of hiding animation (ms)
     * @return Animation
     */
    XYSeries.prototype.hide = function (duration) {
        var _this = this;
        var fields;
        var value;
        var xAxis = this.xAxis;
        if (xAxis instanceof ValueAxis_ValueAxis && xAxis != this.baseAxis) {
            fields = this._xValueFields;
            // animate to zero if 0 is within zoomMin/zoomMax
            if (this.stacked || (xAxis.minZoomed < xAxis.baseValue && xAxis.maxZoomed > xAxis.baseValue) || this.stackedSeries) {
                value = xAxis.baseValue;
            }
            else {
                value = xAxis.min;
            }
        }
        var yAxis = this.yAxis;
        if (yAxis instanceof ValueAxis_ValueAxis && yAxis != this.baseAxis) {
            fields = this._yValueFields;
            // animate to zero if 0 is within zoomMin/zoomMax
            if (this.stacked || (yAxis.minZoomed < yAxis.baseValue && yAxis.maxZoomed > yAxis.baseValue) || this.stackedSeries) {
                value = yAxis.baseValue;
            }
            else {
                value = yAxis.min;
            }
        }
        //if ($type.hasValue(fields)) {
        var startIndex = this.startIndex;
        var endIndex = this.endIndex;
        var interpolationDuration = this.hiddenState.transitionDuration;
        if (isNumber(duration)) {
            interpolationDuration = duration;
        }
        if (!Options_options.animationsEnabled) {
            interpolationDuration = 0;
        }
        var delay = 0;
        var anim;
        Iterator_each(indexed(this.dataItems.iterator()), function (a) {
            var i = a[0];
            var dataItem = a[1];
            var realDuration = interpolationDuration;
            if (i < _this.startIndex - 10 || i > _this.endIndex + 10) {
                realDuration = 0;
            }
            if (realDuration == 0) {
                dataItem.hide(0, 0, value, fields);
            }
            else {
                if (_this.sequencedInterpolation && realDuration > 0) {
                    delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);
                }
                anim = dataItem.hide(realDuration, delay, value, fields);
            }
        });
        var animation = _super.prototype.hide.call(this, interpolationDuration);
        if (animation && !animation.isFinished()) {
            animation.delay(delay);
        }
        if (anim && !anim.isFinished()) {
            animation = anim;
        }
        // helps to avoid flicker. otherwise columns will show up at full size and only on next frame will animate from 0
        this.validateDataElements();
        //}
        return animation;
    };
    /**
     * [handleDataItemWorkingValueChange description]
     *
     * @ignore Exclude from docs
     */
    XYSeries.prototype.handleDataItemWorkingValueChange = function (dataItem, name) {
        _super.prototype.handleDataItemWorkingValueChange.call(this, dataItem, name);
        // to calculate stack values
        var axisSeries = this.baseAxis.series;
        Iterator_each(axisSeries.iterator(), function (series) {
            if (series.stacked || series.stackedSeries) {
                series.invalidateProcessedData();
            }
        });
    };
    /**
     * [getStackValue description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param dataItem  Data item
     */
    XYSeries.prototype.getStackValue = function (dataItem, working) {
        // todo: here wer stack x and y values only. question is - what should we do with other values, like openX, openY?
        // if this series is not stacked or new stack begins, return.
        var _this = this;
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (!this.stacked || !xAxis || !yAxis) {
            return;
        }
        else {
            // it might seem that it's better to go through base axis series, but we do not maintain the same order as in chart.series there.
            var chart = this.chart;
            var index = chart.series.indexOf(this);
            var field_2;
            if (xAxis != this.baseAxis && xAxis instanceof ValueAxis_ValueAxis) {
                field_2 = this.xField;
            }
            if (yAxis != this.baseAxis && yAxis instanceof ValueAxis_ValueAxis) {
                field_2 = this.yField;
            }
            if (!field_2) {
                return;
            }
            //this is good for removing series, otherwise stack values will remain the same and chart won't pay atention when adding/removing series			
            dataItem.setCalculatedValue(field_2, 0, "stack");
            Iterator_eachContinue(chart.series.range(0, index).backwards().iterator(), function (prevSeries) {
                // stacking is only possible if both axes are the same
                if (prevSeries.xAxis == xAxis && prevSeries.yAxis == yAxis) {
                    // saving value
                    prevSeries.stackedSeries = _this;
                    var prevDataItem = prevSeries.dataItems.getIndex(dataItem.index); // indexes should match
                    if (prevDataItem && prevDataItem.hasValue(_this._xValueFields) && prevDataItem.hasValue(_this._yValueFields)) {
                        var value = dataItem.getValue(field_2);
                        var prevValue = void 0;
                        var prevRealValue = prevDataItem.getValue(field_2) + prevDataItem.getValue(field_2, "stack");
                        if (working) {
                            prevValue = prevDataItem.getWorkingValue(field_2) + prevDataItem.getValue(field_2, "stack");
                        }
                        else {
                            prevValue = prevDataItem.getValue(field_2) + prevDataItem.getValue(field_2, "stack");
                        }
                        if ((value >= 0 && prevRealValue >= 0) || (value < 0 && prevRealValue < 0)) {
                            //dataItem.events.disable();
                            dataItem.setCalculatedValue(field_2, prevValue, "stack");
                            //dataItem.events.enable();
                            return false;
                        }
                    }
                    else if (!prevSeries.stacked) {
                        return false;
                    }
                }
                return true;
            });
        }
    };
    Object.defineProperty(XYSeries.prototype, "xField", {
        /**
         * [xField description]
         *
         * @ignore Exclude from docs
         * @todo Description
         * @return [description]
         */
        get: function () {
            return this._xField;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeries.prototype, "yField", {
        /**
         * [yField description]
         *
         * @ignore Exclude from docs
         * @todo Description
         * @return [description]
         */
        get: function () {
            return this._yField;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeries.prototype, "xOpenField", {
        /**
         * [xOpenField description]
         *
         * @ignore Exclude from docs
         * @todo Description
         * @return [description]
         */
        get: function () {
            return this._xOpenField;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeries.prototype, "yOpenField", {
        /**
         * [yOpenField description]
         *
         * @ignore Exclude from docs
         * @todo Description
         * @return [description]
         */
        get: function () {
            return this._yOpenField;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeries.prototype, "tooltipXField", {
        /**
         * @ignore Exclude from docs
         * @todo Description
         * @return [description]
         */
        get: function () {
            if (this._tooltipXField) {
                return this._tooltipXField;
            }
            return this._xField;
        },
        /**
         * [tooltipXField description]
         *
         * @ignore Exclude from docs
         * @todo Description
         * @param value [description]
         */
        set: function (value) {
            this._tooltipXField = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeries.prototype, "tooltipYField", {
        /**
         * @ignore Exclude from docs
         * @todo Description
         * @return [description]
         */
        get: function () {
            if (this._tooltipYField) {
                return this._tooltipYField;
            }
            return this._yField;
        },
        /**
         * [tooltipYField description]
         *
         * @ignore Exclude from docs
         * @todo Description
         * @param value [description]
         */
        set: function (value) {
            this._tooltipYField = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns lowest value in the series for the specific axis.
     *
     * @ignore Exclude from docs
     * @param axis  Axis
     * @return value
     */
    XYSeries.prototype.min = function (axis) {
        return this._tmin.getKey(axis.uid);
    };
    /**
     * Returns highest value in the series for the specific axis.
     *
     * @ignore Exclude from docs
     * @param axis  Axis
     * @return value
     */
    XYSeries.prototype.max = function (axis) {
        return this._tmax.getKey(axis.uid);
    };
    /**
     * Returns lowest value in the series for the specific axis within current
     * selection.
     *
     * @ignore Exclude from docs
     * @param axis  Axis
     * @return value
     */
    XYSeries.prototype.selectionMin = function (axis) {
        var value = this._smin.getKey(axis.uid);
        if (!isNumber(value)) {
            value = this.min(axis);
        }
        return value;
    };
    /**
     * Returns highest value in the series for the specific axis within current
     * selection.
     *
     * @ignore Exclude from docs
     * @param axis  Axis
     * @return value
     */
    XYSeries.prototype.selectionMax = function (axis) {
        var value = this._smax.getKey(axis.uid);
        if (!isNumber(value)) {
            value = this.max(axis);
        }
        return value;
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    XYSeries.prototype.processConfig = function (config) {
        if (config) {
            // Set up base axes
            if (hasValue(config.baseAxis) && isString(config.baseAxis)) {
                if (this.map.hasKey(config.baseAxis)) {
                    config.baseAxis = this.map.getKey(config.baseAxis);
                }
                else {
                    this.processingErrors.push("[XYSeries (" + (this.name || "unnamed") + ")] No axis with id \"" + config.baseAxis + "\" found for `baseAxis`.");
                    delete config.baseAxis;
                }
            }
            // Set up axes
            if (hasValue(config.xAxis) && isString(config.xAxis)) {
                if (this.map.hasKey(config.xAxis)) {
                    config.xAxis = this.map.getKey(config.xAxis);
                }
                else {
                    this.processingErrors.push("[XYSeries (" + (this.name || "unnamed") + ")] No axis with id \"" + config.xAxis + "\" found for `xAxis`.");
                    delete config.xAxis;
                }
            }
            if (hasValue(config.yAxis) && isString(config.yAxis)) {
                if (this.map.hasKey(config.yAxis)) {
                    config.yAxis = this.map.getKey(config.yAxis);
                }
                else {
                    this.processingErrors.push("[XYSeries (" + (this.name || "unnamed") + ")] No axis with id \"" + config.yAxis + "\" found for `yAxis`.");
                    delete config.yAxis;
                }
            }
            // Set up axis ranges
            if (hasValue(config.axisRanges) && isArray(config.axisRanges)) {
                for (var i = 0, len = config.axisRanges.length; i < len; i++) {
                    var range = config.axisRanges[i];
                    if (!hasValue(range.type)) {
                        range.type = "AxisDataItem";
                    }
                    if (hasValue(range.axis) && isString(range.axis) && this.map.hasKey(range.axis)) {
                        range.component = this.map.getKey(range.axis);
                    }
                    else if (hasValue(range.component) && isString(range.component) && this.map.hasKey(range.component)) {
                        range.component = this.map.getKey(range.component);
                    }
                }
            }
            // Parse date fields based on the series fields
            if (!hasValue(config.dataFields) || !isObject(config.dataFields)) {
                this.processingErrors.push("`dataFields` is not set for series [" + (this.name || "unnamed") + "]");
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    /**
     * Returns an [[IPoint]] coordinates of the specific Serie's data point.
     *
     * @param    dataItem   Data item
     * @param    xKey       Name of X data field
     * @param    yKey       Name of Y data field
     * @param    locationX  X location
     * @param    locationY  Y location
     * @param    stackKeyX  ?
     * @param    stackKeyY  ?
     * @returns             Coordinates
     */
    XYSeries.prototype.getPoint = function (dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {
        if (this.xAxis && this.yAxis) {
            var x = this.xAxis.getX(dataItem, xKey, locationX);
            var y = this.yAxis.getY(dataItem, yKey, locationY);
            x = fitToRange(x, -this._maxxX, this._maxxX); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.
            y = fitToRange(y, -this._maxxY, this._maxxY); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.
            return { x: x, y: y };
        }
    };
    /**
     * Updates item reader text based on the type and set up of axis.
     */
    XYSeries.prototype.updateItemReaderText = function () {
        // We do not want to overwrite this if `itemReaderText` was changed by
        // user code.
        if (this._itemReaderTextChanged) {
            return;
        }
        var text = "";
        Object_each(this.dataFields, function (key, val) {
            text += "{" + key + "} ";
        });
        this.itemReaderText = text;
        this._itemReaderTextChanged = false;
    };
    Object.defineProperty(XYSeries.prototype, "cursorTooltipEnabled", {
        /**
         * @return Display tooltip?
         */
        get: function () {
            return this.getPropertyValue("cursorTooltipEnabled");
        },
        /**
         * Indicates if series should display a tooltip for chart's cursor.
         *
         * If set to `true` (default), the tooltips set for all series item's
         * elements like columns and bullets will be automatically shown
         * when [[XYCursor]] passes over category/date, even if its not hovered
         * directly over the item.
         *
         * Set this to `false` to disable such behavior and display item-specific
         * tooltips only when hovered directly over them
         *
         * @default true
         * @param value Display tooltip?
         */
        set: function (value) {
            this.setPropertyValue("cursorTooltipEnabled", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeries.prototype, "cursorHoverEnabled", {
        /**
         * @return Hover enabled?
         */
        get: function () {
            return this.getPropertyValue("cursorHoverEnabled");
        },
        /**
         * Indicates if series should apply hover state on bullets/columns/etc when
         * cursor is over the data item.
         *
         * If set to `true` (default) and chart cursor is enabled on th chart,
         * hovering over date/category will trigger hover states on related Series
         * items like bullets and columns.
         *
         * @default true
         * @since 4.2.2
         * @param  value  Hover enabled?
         */
        set: function (value) {
            this.setPropertyValue("cursorHoverEnabled", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeries.prototype, "excludeFromTotal", {
        /**
         * @return Exclude from totals?
         */
        get: function () {
            return this.getPropertyValue("excludeFromTotal");
        },
        /**
         * Indicates if series' values should be excluded when calculating totals.
         *
         * @default false
         * @since 4.4.9
         * @param  value  Exclude from totals?
         */
        set: function (value) {
            this.setPropertyValue("excludeFromTotal", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeries.prototype, "hideTooltipWhileZooming", {
        /**
         * @return Hide tooltip while zooming?
         */
        get: function () {
            return this.getPropertyValue("hideTooltipWhileZooming");
        },
        /**
         * Indicates if series' tooltip should be hidden while series axis range is
         * animating (zooming).
         *
         * @default true
         * @since 4.7.16
         * @param  value  Hide tooltip while zooming?
         */
        set: function (value) {
            this.setPropertyValue("hideTooltipWhileZooming", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYSeries.prototype, "maskBullets", {
        /**
         * @return Mask bullets?
         */
        get: function () {
            return this.getPropertyValue("maskBullets");
        },
        /**
         * Indicates if series' bullets should be masked.
         *
         * @default true
         * @since 4.7.17
         * @param  value  Mask bullets?
         */
        set: function (value) {
            this.setPropertyValue("maskBullets", value);
            var chart = this.chart;
            if (chart) {
                if (value) {
                    this.bulletsContainer.parent = chart.bulletsContainer;
                }
                else {
                    this.bulletsContainer.parent = chart.axisBulletsContainer;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all properties from another instance of [[Series]].
     *
     * @param source  Source series
     */
    XYSeries.prototype.copyFrom = function (source) {
        this.groupFields = Utils_copyProperties(source.groupFields, {});
        _super.prototype.copyFrom.call(this, source);
    };
    /**
     * Destroys this object and all related data.
     */
    XYSeries.prototype.dispose = function () {
        if (this.scrollbarSeries) {
            this.scrollbarSeries.dispose();
        }
        _super.prototype.dispose.call(this);
    };
    return XYSeries;
}(Series_Series));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["XYSeries"] = XYSeries_XYSeries;
registry.registeredClasses["XYSeriesDataItem"] = XYSeries_XYSeriesDataItem;
//# sourceMappingURL=XYSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/XYChartScrollbar.js
/**
 * A module with functionality for buildin a scrollbar with an XY graph in it.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */
















/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A special version of the Scrollbar that has an XY chart in it.
 *
 * Used mainly as an advanced scrollbar with a preview for other XY charts.
 *
 * However, can be used as standalone element.
 *
 * @see {@link IXYChartScrollbarEvents} for a list of available events
 * @see {@link IXYChartScrollbarAdapters} for a list of available Adapters
 * @important
 */
var XYChartScrollbar_XYChartScrollbar = /** @class */ (function (_super) {
    __extends(XYChartScrollbar, _super);
    /**
     * Constructor
     */
    function XYChartScrollbar() {
        var _this = _super.call(this) || this;
        /**
         * A chart element Scrollbar is for.
         */
        _this._chart = new Disposer_MutableValueDisposer();
        _this.className = "XYChartScrollbar";
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.padding(0, 0, 0, 0);
        var scrollbarChart = _this.createChild(XYChart_XYChart);
        scrollbarChart.shouldClone = false;
        scrollbarChart.margin(0, 0, 0, 0);
        scrollbarChart.padding(0, 0, 0, 0);
        scrollbarChart.interactionsEnabled = false;
        _this._scrollbarChart = scrollbarChart;
        if (!isIE()) {
            var filter = new DesaturateFilter_DesaturateFilter();
            filter.filterUnits = "userSpaceOnUse";
            scrollbarChart.plotContainer.filters.push(filter);
        }
        _this._disposers.push(_this._scrollbarChart);
        _this.minHeight = 60;
        _this.minWidth = 60;
        var unselectedOverlay = _this.createChild(Sprite_Sprite);
        unselectedOverlay.shouldClone = false;
        unselectedOverlay.setElement(_this.paper.add("path"));
        unselectedOverlay.fill = interfaceColors.getFor("background");
        unselectedOverlay.fillOpacity = 0.8;
        unselectedOverlay.interactionsEnabled = false;
        unselectedOverlay.isMeasured = false;
        unselectedOverlay.toBack();
        _this._unselectedOverlay = unselectedOverlay;
        _this._disposers.push(_this._unselectedOverlay);
        scrollbarChart.toBack();
        _this.background.cornerRadius(0, 0, 0, 0);
        var thumbBackground = _this.thumb.background;
        thumbBackground.cornerRadius(0, 0, 0, 0);
        thumbBackground.fillOpacity = 0;
        thumbBackground.fill = interfaceColors.getFor("background");
        var hoverState = thumbBackground.states.getKey("hover");
        if (hoverState) {
            hoverState.properties.fillOpacity = 0.2;
        }
        var downState = thumbBackground.states.getKey("down");
        if (downState) {
            downState.properties.fillOpacity = 0.4;
        }
        _this._disposers.push(_this._chart);
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(XYChartScrollbar.prototype, "series", {
        /**
         * A list of series that are used to draw graph(s) on the scrollbar.
         *
         * @readonly
         * @return Series
         */
        get: function () {
            if (!this._series) {
                this._series = new List_List();
                this._disposers.push(this._series.events.on("inserted", this.handleSeriesAdded, this, false));
                this._disposers.push(this._series.events.on("removed", this.handleSeriesRemoved, this, false));
            }
            return this._series;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Decorates a new series when they are pushed into a `series` list.
     *
     * @param event Event
     */
    XYChartScrollbar.prototype.handleSeriesAdded = function (event) {
        var _this = this;
        var sourceSeries = event.newValue;
        if (!sourceSeries.xAxis || !sourceSeries.yAxis) {
            return;
        }
        var scrollbarChart = this.scrollbarChart;
        scrollbarChart.zoomOutButton.disabled = true;
        this.chart = sourceSeries.chart;
        // Ensure that scrollbar chart shares the same locale as parent chart
        scrollbarChart.language.locale = this.chart.language.locale;
        var addXAxis = true;
        var addYAxis = true;
        // check if we haven't added clone of x or y axis before
        Iterator_each(this.series.iterator(), function (series) {
            if (series != sourceSeries) {
                if (series.xAxis == sourceSeries.xAxis && _this.scrollbarChart.xAxes.length > 0) {
                    addXAxis = false;
                }
                if (series.yAxis == sourceSeries.yAxis && _this.scrollbarChart.yAxes.length > 0) {
                    addYAxis = false;
                }
            }
        });
        sourceSeries.events.on("beforedisposed", function () {
            _this.series.removeValue(sourceSeries);
        });
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        var series = sourceSeries.clone();
        if (isIE()) {
            series.stroke = Color_color("#aaaaaa");
            series.fill = series.stroke;
            series.propertyFields.fill = undefined;
            series.propertyFields.stroke = undefined;
        }
        sourceSeries.scrollbarSeries = series;
        if (addXAxis) {
            var xAxis = sourceSeries.xAxis.clone();
            scrollbarChart.xAxes.moveValue(xAxis);
            xAxis.title.disabled = true;
            xAxis.rangeChangeDuration = 0;
            //xAxis.id = sourceSeries.uid;
            var renderer = xAxis.renderer;
            renderer.ticks.template.disabled = true;
            renderer.inside = true;
            renderer.labels.template.inside = true;
            renderer.line.strokeOpacity = 0;
            renderer.minLabelPosition = 0.02;
            renderer.maxLabelPosition = 0.98;
            renderer.line.disabled = true;
            renderer.axisFills.template.disabled = true;
            renderer.baseGrid.disabled = true;
            renderer.grid.template.strokeOpacity = 0.05;
            renderer.minWidth = undefined;
            renderer.minHeight = undefined;
            renderer.padding(0, 0, 0, 0);
            renderer.chart = scrollbarChart;
            renderer.margin(0, 0, 0, 0);
            xAxis.width = Percent_percent(100);
            var labelsTemplate = renderer.labels.template;
            labelsTemplate.fillOpacity = 0.5;
            xAxis.maxZoomCount = undefined;
            xAxis.minZoomCount = undefined;
            if (xAxis instanceof DateAxis_DateAxis) {
                var vAxis_1 = xAxis;
                var sourceAxis = sourceSeries.xAxis;
                vAxis_1.groupCount = sourceAxis.groupCount * 5;
                vAxis_1.min = undefined;
                vAxis_1.max = undefined;
                this._disposers.push(vAxis_1.clonedFrom.events.on("extremeschanged", function () {
                    if (isNumber(vAxis_1.clonedFrom.minDefined)) {
                        vAxis_1.min = vAxis_1.clonedFrom.minDefined;
                    }
                    if (isNumber(vAxis_1.clonedFrom.maxDefined)) {
                        vAxis_1.max = vAxis_1.clonedFrom.maxDefined;
                    }
                }, undefined, false));
            }
            else if (xAxis instanceof ValueAxis_ValueAxis) {
                var vAxis_2 = xAxis;
                vAxis_2.min = undefined;
                vAxis_2.max = undefined;
                if (!isNumber(vAxis_2.clonedFrom.minDefined)) {
                    vAxis_2.min = undefined;
                }
                if (!isNumber(vAxis_2.clonedFrom.maxDefined)) {
                    vAxis_2.max = undefined;
                }
                this._disposers.push(vAxis_2.clonedFrom.events.on("extremeschanged", function () {
                    if (isNumber(vAxis_2.clonedFrom.minDefined)) {
                        vAxis_2.min = vAxis_2.clonedFrom.min;
                    }
                    if (isNumber(vAxis_2.clonedFrom.maxDefined)) {
                        vAxis_2.max = vAxis_2.clonedFrom.max;
                    }
                }, undefined, false));
            }
            series.xAxis = xAxis;
        }
        else {
            this.scrollbarChart.xAxes.each(function (xAxis) {
                if (xAxis.clonedFrom == sourceSeries.xAxis) {
                    series.xAxis = xAxis;
                }
            });
        }
        if (addYAxis) {
            var yAxis = sourceSeries.yAxis.clone();
            scrollbarChart.yAxes.moveValue(yAxis);
            yAxis.title.disabled = true;
            yAxis.rangeChangeDuration = 0;
            var renderer = yAxis.renderer;
            renderer.ticks.template.disabled = true;
            renderer.inside = true;
            renderer.labels.template.inside = true;
            renderer.line.strokeOpacity = 0;
            renderer.minLabelPosition = 0.02;
            renderer.maxLabelPosition = 0.98;
            renderer.line.disabled = true;
            renderer.axisFills.template.disabled = true;
            renderer.grid.template.stroke = interfaceColors.getFor("background");
            renderer.baseGrid.disabled = true;
            renderer.grid.template.strokeOpacity = 0.05;
            renderer.minWidth = undefined;
            renderer.minHeight = undefined;
            renderer.chart = scrollbarChart;
            renderer.padding(0, 0, 0, 0);
            renderer.margin(0, 0, 0, 0);
            yAxis.height = Percent_percent(100);
            var labelsTemplate = renderer.labels.template;
            labelsTemplate.fillOpacity = 0.5;
            series.yAxis = yAxis;
            yAxis.maxZoomCount = undefined;
            yAxis.minZoomCount = undefined;
            if (yAxis instanceof DateAxis_DateAxis) {
                var vAxis_3 = yAxis;
                vAxis_3.min = undefined;
                vAxis_3.max = undefined;
                var sourceAxis = sourceSeries.yAxis;
                yAxis.groupCount = sourceAxis.groupCount * 5;
                this._disposers.push(vAxis_3.clonedFrom.events.on("extremeschanged", function () {
                    if (isNumber(vAxis_3.clonedFrom.minDefined)) {
                        vAxis_3.min = vAxis_3.clonedFrom.minDefined;
                    }
                    if (isNumber(vAxis_3.clonedFrom.maxDefined)) {
                        vAxis_3.max = vAxis_3.clonedFrom.maxDefined;
                    }
                }));
            }
            else if (yAxis instanceof ValueAxis_ValueAxis) {
                var vAxis_4 = yAxis;
                vAxis_4.min = undefined;
                vAxis_4.max = undefined;
                if (!isNumber(vAxis_4.clonedFrom.minDefined)) {
                    vAxis_4.min = undefined;
                }
                if (!isNumber(vAxis_4.clonedFrom.maxDefined)) {
                    vAxis_4.max = undefined;
                }
                this._disposers.push(vAxis_4.clonedFrom.events.on("extremeschanged", function () {
                    if (isNumber(vAxis_4.clonedFrom.minDefined)) {
                        vAxis_4.min = vAxis_4.clonedFrom.minDefined;
                    }
                    if (isNumber(vAxis_4.clonedFrom.maxDefined)) {
                        vAxis_4.max = vAxis_4.clonedFrom.maxDefined;
                    }
                }));
            }
        }
        else {
            this.scrollbarChart.yAxes.each(function (yAxis) {
                if (yAxis.clonedFrom == sourceSeries.yAxis) {
                    series.yAxis = yAxis;
                }
            });
        }
        series.rangeChangeDuration = 0;
        series.interpolationDuration = 0;
        series.defaultState.transitionDuration = 0;
        series.showOnInit = false;
        this._disposers.push(series.events.on("validated", this.zoomOutAxes, this, false));
        // data might be set drectly on series
        this._disposers.push(sourceSeries.events.on("datavalidated", function () {
            if (series.data != sourceSeries.data) { // data setter doesn't check this
                series.data = sourceSeries.data;
            }
        }, undefined, false));
        series.defaultState.properties.visible = true;
        scrollbarChart.series.push(series);
        this.updateByOrientation();
    };
    /**
     * @ignore
     */
    XYChartScrollbar.prototype.updateByOrientation = function () {
        var _this = this;
        if (this._scrollbarChart) {
            Iterator_each(this._scrollbarChart.xAxes.iterator(), function (xAxis) {
                var renderer = xAxis.renderer;
                if (_this.orientation == "vertical") {
                    renderer.grid.template.disabled = true;
                    renderer.labels.template.disabled = true;
                    renderer.minGridDistance = 10;
                }
                else {
                    renderer.grid.template.disabled = false;
                    renderer.labels.template.disabled = false;
                    renderer.minGridDistance = xAxis.clonedFrom.renderer.minGridDistance;
                }
            });
            Iterator_each(this._scrollbarChart.yAxes.iterator(), function (yAxis) {
                var renderer = yAxis.renderer;
                if (_this.orientation == "horizontal") {
                    renderer.grid.template.disabled = true;
                    renderer.labels.template.disabled = true;
                    renderer.minGridDistance = 10;
                }
                else {
                    renderer.grid.template.disabled = false;
                    renderer.labels.template.disabled = false;
                    renderer.minGridDistance = yAxis.clonedFrom.renderer.minGridDistance;
                }
            });
        }
    };
    /**
     * Cleans up after series are removed from Scrollbar.
     *
     * @param event  Event
     */
    XYChartScrollbar.prototype.handleSeriesRemoved = function (event) {
        var sourceSeries = event.oldValue;
        var scrollbarChart = this.scrollbarChart;
        scrollbarChart.series.each(function (series) {
            if (series && series.clonedFrom == sourceSeries) {
                scrollbarChart.series.removeValue(series);
            }
        });
        if (scrollbarChart.series.length == 0) {
            scrollbarChart.xAxes.clear();
            scrollbarChart.yAxes.clear();
        }
        try {
            sourceSeries.events.off("validated", this.zoomOutAxes, this);
        }
        catch (err) {
        }
    };
    Object.defineProperty(XYChartScrollbar.prototype, "scrollbarChart", {
        /**
         * A chart element that is used to display graphs in the Scrollbar.
         *
         * This is not the same as `chart`. It's a totally independent instance of
         * [[XYChart]] with separate config, series, etc.
         *
         * It can be configured just like any other [[XYChart]].
         *
         * @readonly
         * @return Scrollbar's internal chart
         */
        get: function () {
            return this._scrollbarChart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYChartScrollbar.prototype, "chart", {
        /**
         * @return Chart
         */
        get: function () {
            return this._chart.get();
        },
        /**
         * A chart that Scrollbar belongs to.
         *
         * @param chart  Chart
         */
        set: function (chart) {
            if (this._chart.get() !== chart) {
                this._chart.set(chart, chart.events.on("datavalidated", this.handleDataChanged, this, false));
                this.handleDataChanged();
                this._scrollbarChart.dataProvider = chart; // this makes scrollbar chart do not validate data untill charts' data is validated
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYChartScrollbar.prototype, "unselectedOverlay", {
        /**
         * A [[Sprite]] object representing overlay that is used to dim area of the
         * scrollbar that is currently not selected.
         *
         * Use its `fillOpacity` to set opacity of the fill, with `0` (zero)
         * completely disabling the dimming, and `1` making unselected area completely
         * blank.
         *
         * @since 4.6.1
         * @readonly
         * @return Unselected area curtain element
         */
        get: function () {
            return this._unselectedOverlay;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates Scrollbar's internal chart's data when the main chart's data
     * changes.
     *
     * @ignore Exclude from docs
     */
    XYChartScrollbar.prototype.handleDataChanged = function () {
        if (this.chart.data != this.scrollbarChart.data) {
            this.scrollbarChart.data = this.chart.data;
        }
        else {
            // add data is handled in XYChart
            // invalidating all data caused the problem: https://github.com/amcharts/amcharts4/issues/2096
            this.scrollbarChart.invalidateRawData();
        }
    };
    /**
     * Zooms out all axes on the internal chart.
     */
    XYChartScrollbar.prototype.zoomOutAxes = function () {
        var scrollbarChart = this.scrollbarChart;
        Iterator_each(scrollbarChart.xAxes.iterator(), function (x) {
            x.zoom({ start: 0, end: 1 }, true, true);
        });
        Iterator_each(scrollbarChart.yAxes.iterator(), function (y) {
            y.zoom({ start: 0, end: 1 }, true, true);
        });
    };
    /**
     * Updates scrollbar thumb.
     */
    XYChartScrollbar.prototype.updateThumb = function () {
        _super.prototype.updateThumb.call(this);
        if (this._unselectedOverlay) {
            var thumb = this.thumb;
            var x = thumb.pixelX || 0;
            var y = thumb.pixelY || 0;
            var w = thumb.pixelWidth || 0;
            var h = thumb.pixelHeight || 0;
            var path = "";
            if (this.orientation == "horizontal") {
                path = rectToPath({
                    x: -1,
                    y: 0,
                    width: x,
                    height: h
                });
                path += rectToPath({
                    x: x + w,
                    y: 0,
                    width: (this.pixelWidth || 0) - x - w,
                    height: h
                });
            }
            else {
                path = rectToPath({
                    x: 0,
                    y: 0,
                    width: w,
                    height: y
                });
                path += rectToPath({
                    x: 0,
                    y: y + h,
                    width: w,
                    height: (this.pixelHeight || 0) - y - h
                });
            }
            this._unselectedOverlay.path = path;
        }
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    XYChartScrollbar.prototype.processConfig = function (config) {
        if (config) {
            if (hasValue(config.series) && isArray(config.series)) {
                for (var i = 0, len = config.series.length; i < len; i++) {
                    var series = config.series[i];
                    if (hasValue(series) && isString(series)) {
                        if (this.map.hasKey(series)) {
                            config.series[i] = this.map.getKey(series);
                        }
                        else {
                            throw Error("XYChartScrollbar error: Series with id `" + series + "` does not exist.");
                        }
                    }
                }
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    return XYChartScrollbar;
}(Scrollbar_Scrollbar));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["XYChartScrollbar"] = XYChartScrollbar_XYChartScrollbar;
//# sourceMappingURL=XYChartScrollbar.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/XYChart.js
/**
 * XY Chart module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






















/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[XYChart]].
 *
 * @see {@link DataItem}
 */
var XYChart_XYChartDataItem = /** @class */ (function (_super) {
    __extends(XYChartDataItem, _super);
    /**
     * Constructor
     */
    function XYChartDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "XYChartDataItem";
        _this.applyTheme();
        return _this;
    }
    return XYChartDataItem;
}(SerialChart_SerialChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates an XY chart, and any derivative chart, like Serial, Date-based, etc.
 *
 * Basically this is a chart type, that is used to display any chart
 * information in a square plot area.
 *
 * The horizontal and vertical scale is determined by the type of Axis.
 *
 * The plot types are determined by type of Series.
 *
 * ```TypeScript
 * // Includes
 * import * as am4core from "@amcharts/amcharts4/core";
 * import * as am4charts from "@amcharts/amcharts4/charts";
 *
 * // Create chart
 * let chart = am4core.create("chartdiv", am4charts.XYChart);
 *
 * // Add Data
 * chart.data = [{
 * "country": "USA",
 * "visits": 3025
 * }, {
 * 	"country": "China",
 * 	"visits": 1882
 * }, {
 * 	"country": "Japan",
 * 	"visits": 1809
 * }];
 *
 * // Add category axis
 * let categoryAxis = chart.xAxes.push(new am4charts.CategoryAxis());
 * categoryAxis.dataFields.category = "country";
 *
 * // Add value axis
 * let valueAxis = chart.yAxes.push(new am4charts.ValueAxis());
 *
 * // Add series
 * let series = chart.series.push(new am4charts.ColumnSeries());
 * series.name = "Web Traffic";
 * series.dataFields.categoryX = "country";
 * series.dataFields.valueY = "visits";
 * ```
 * ```JavaScript
 * // Create chart
 * var chart = am4core.create("chartdiv", am4charts.XYChart);
 *
 * // The following would work as well:
 * // var chart = am4core.create("chartdiv", "XYChart");
 *
 * // Add Data
 * chart.data = [{
 * "country": "USA",
 * "visits": 3025
 * }, {
 * 	"country": "China",
 * 	"visits": 1882
 * }, {
 * 	"country": "Japan",
 * 	"visits": 1809
 * }];
 *
 * // Add category axis
 * var categoryAxis = chart.xAxes.push(new am4charts.CategoryAxis());
 * categoryAxis.dataFields.category = "country";
 *
 * // Add value axis
 * var valueAxis = chart.yAxes.push(new am4charts.ValueAxis());
 *
 * // Add series
 * var series = chart.series.push(new am4charts.ColumnSeries());
 * series.name = "Web Traffic";
 * series.dataFields.categoryX = "country";
 * series.dataFields.valueY = "visits";
 * ```
 * ```JSON
 * var chart = am4core.createFromConfig({
 *
 * 	// Category axis
 * 	"xAxes": [{
 * 		"type": "CategoryAxis",
 * 		"dataFields": {
 * 			"category": "country"
 * 		}
 * 	}],
 *
 * 	// Value axis
 * 	"yAxes": [{
 * 		"type": "ValueAxis"
 * 	}],
 *
 * 	// Series
 * 	"series": [{
 * 		"type": "ColumnSeries",
 * 		"dataFields": {
 * 			"categoryX": "country",
 * 			"valueY": "visits"
 * 		},
 * 		"name": "Web Traffic"
 * 	}],
 *
 * 	// Cursor
 * 	"cursor": {},
 *
 * 	// Data
 * 	"data": [{
 * 		"country": "USA",
 * 		"visits": 3025
 * 	}, {
 * 		"country": "China",
 * 		"visits": 1882
 * 	}, {
 * 		"country": "Japan",
 * 		"visits": 1809
 * 	}]
 *
 * }, "chartdiv", "XYChart");
 * ```
 *
 *
 * @see {@link IXYChartEvents} for a list of available Events
 * @see {@link IXYChartAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/xy-chart/} for documentation
 * @important
 */
var XYChart_XYChart = /** @class */ (function (_super) {
    __extends(XYChart, _super);
    /**
     * Constructor
     */
    function XYChart() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Defines the type of horizontal axis rederer.
         */
        _this._axisRendererX = AxisRendererX_AxisRendererX;
        /**
         * Defines the type of vertical axis rederer.
         */
        _this._axisRendererY = AxisRendererY_AxisRendererY;
        /**
         * @ignore
         */
        _this._seriesPoints = [];
        _this.className = "XYChart";
        // Set defaults
        //this.margin(10, 10, 10, 10);
        _this.maskBullets = true;
        _this.arrangeTooltips = true;
        // Create main chart container
        var chartContainer = _this.chartContainer;
        chartContainer.layout = "vertical";
        _this.padding(15, 15, 15, 15);
        // Create top axes container
        var topAxesCont = chartContainer.createChild(Container_Container);
        topAxesCont.shouldClone = false;
        topAxesCont.layout = "vertical";
        topAxesCont.width = Percent_percent(100);
        topAxesCont.zIndex = 1;
        _this.topAxesContainer = topAxesCont;
        // Create vertical axes and plot area container
        // Plot area and vertical axes share the whole width of the chart,
        // so we need to put then into a separate container so that layouting
        // engine takes care of the positioning
        var yAxesAndPlotCont = chartContainer.createChild(Container_Container);
        yAxesAndPlotCont.shouldClone = false;
        yAxesAndPlotCont.layout = "horizontal";
        yAxesAndPlotCont.width = Percent_percent(100);
        yAxesAndPlotCont.height = Percent_percent(100);
        yAxesAndPlotCont.zIndex = 0;
        _this.yAxesAndPlotContainer = yAxesAndPlotCont;
        // Create a container for bottom axes
        var bottomAxesCont = chartContainer.createChild(Container_Container);
        bottomAxesCont.shouldClone = false;
        bottomAxesCont.width = Percent_percent(100);
        bottomAxesCont.layout = "vertical";
        bottomAxesCont.zIndex = 1;
        _this.bottomAxesContainer = bottomAxesCont;
        // Create a container for left-side axes
        var leftAxesCont = yAxesAndPlotCont.createChild(Container_Container);
        leftAxesCont.shouldClone = false;
        leftAxesCont.layout = "horizontal";
        leftAxesCont.height = Percent_percent(100);
        leftAxesCont.contentAlign = "right";
        leftAxesCont.events.on("transformed", _this.updateXAxesMargins, _this, false);
        leftAxesCont.zIndex = 1;
        _this.leftAxesContainer = leftAxesCont;
        // Create a container for plot area
        var plotCont = yAxesAndPlotCont.createChild(Container_Container);
        plotCont.shouldClone = false;
        plotCont.height = Percent_percent(100);
        plotCont.width = Percent_percent(100);
        // Create transparend background for plot container so that hover works
        // on all of it
        plotCont.background.fillOpacity = 0;
        _this.plotContainer = plotCont;
        // must go below plot container
        _this.mouseWheelBehavior = "none";
        _this._cursorContainer = plotCont;
        // Create a container for right-side axes
        var rightAxesCont = yAxesAndPlotCont.createChild(Container_Container);
        rightAxesCont.shouldClone = false;
        rightAxesCont.layout = "horizontal";
        rightAxesCont.height = Percent_percent(100);
        rightAxesCont.zIndex = 1;
        rightAxesCont.events.on("transformed", _this.updateXAxesMargins, _this, false);
        _this.rightAxesContainer = rightAxesCont;
        _this.seriesContainer.parent = plotCont;
        _this.bulletsContainer.parent = plotCont;
        var zoomOutButton = plotCont.createChild(ZoomOutButton_ZoomOutButton);
        zoomOutButton.shouldClone = false;
        zoomOutButton.align = "right";
        zoomOutButton.valign = "top";
        zoomOutButton.zIndex = Number.MAX_SAFE_INTEGER;
        zoomOutButton.marginTop = 5;
        zoomOutButton.marginRight = 5;
        zoomOutButton.hide(0);
        _this.zoomOutButton = zoomOutButton;
        // Create a container for bullets
        var axisBulletsContainer = _this.plotContainer.createChild(Container_Container);
        axisBulletsContainer.shouldClone = false;
        axisBulletsContainer.width = Percent_percent(100);
        axisBulletsContainer.height = Percent_percent(100);
        axisBulletsContainer.isMeasured = false;
        axisBulletsContainer.zIndex = 4;
        axisBulletsContainer.layout = "none";
        _this.axisBulletsContainer = axisBulletsContainer;
        _this._bulletMask = _this.plotContainer;
        _this.events.on("beforedatavalidated", function () {
            _this.series.each(function (series) {
                series.dataGrouped = false;
                series._baseInterval = {};
            });
        }, _this, false);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    XYChart.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        this.zoomOutButton.exportable = false;
        // Add a default screen reader title for accessibility
        // This will be overridden in screen reader if there are any `titles` set
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("X/Y chart");
        }
    };
    /**
     * Draws the chart.
     *
     * @ignore Exclude from docs
     */
    XYChart.prototype.draw = function () {
        _super.prototype.draw.call(this);
        this.seriesContainer.toFront();
        this.bulletsContainer.toFront();
        if (this.maskBullets) {
            this.bulletsContainer.mask = this._bulletMask;
        }
        this.updateSeriesLegend();
    };
    /**
     * Triggers a redrawing of all chart's series.
     *
     * @ignore Exclude from docs
     */
    XYChart.prototype.updatePlotElements = function () {
        Iterator_each(this.series.iterator(), function (series) {
            series.invalidate();
        });
    };
    /**
     * Triggers data (re)validation which in turn can cause a redraw of the
     * whole chart or just aprticular series / elements.
     *
     * @ignore Exclude from docs
     */
    XYChart.prototype.validateData = function () {
        // tell axes that data changed
        if (this._parseDataFrom == 0) {
            Iterator_each(this.xAxes.iterator(), function (axis) {
                axis.dataChangeUpdate();
            });
            Iterator_each(this.yAxes.iterator(), function (axis) {
                axis.dataChangeUpdate();
            });
            Iterator_each(this.series.iterator(), function (series) {
                series.dataChangeUpdate();
            });
        }
        _super.prototype.validateData.call(this);
    };
    /**
     * Updates margins for horizontal axes based on settings and available space.
     *
     * @ignore Exclude from docs
     */
    XYChart.prototype.updateXAxesMargins = function () {
        var leftAxesWidth = this.leftAxesContainer.measuredWidth;
        var rightAxesWidth = this.rightAxesContainer.measuredWidth;
        var bottomAxesCont = this.bottomAxesContainer;
        if (bottomAxesCont.paddingLeft != leftAxesWidth || bottomAxesCont.paddingRight != rightAxesWidth) {
            bottomAxesCont.paddingLeft = leftAxesWidth;
            bottomAxesCont.paddingRight = rightAxesWidth;
        }
        var topAxesCont = this.topAxesContainer;
        if (topAxesCont.paddingLeft != leftAxesWidth || topAxesCont.paddingRight != rightAxesWidth) {
            topAxesCont.paddingLeft = leftAxesWidth;
            topAxesCont.paddingRight = rightAxesWidth;
        }
    };
    /**
     * Triggers a re-initialization of this element.
     *
     * Will result in complete redrawing of the element.
     *
     * @ignore Exclude from docs
     */
    XYChart.prototype.reinit = function () {
        _super.prototype.reinit.call(this);
        this.series.each(function (series) {
            series.appeared = false;
        });
    };
    /**
     * Triggers an update on the horizontal axis when one of its properties
     * change.
     *
     * @ignore Exclude from docs
     * @param event An event object
     */
    XYChart.prototype.handleXAxisChange = function (event) {
        this.updateXAxis(event.target);
    };
    /**
     * Triggers an update on the vertical axis when one of its properties
     * change.
     *
     * @ignore Exclude from docs
     * @param event An event object
     */
    XYChart.prototype.handleYAxisChange = function (event) {
        this.updateYAxis(event.target);
    };
    /**
     * Sets up a new horizontal (X) axis when it is added to the chart.
     *
     * @ignore Exclude from docs
     * @param event  Axis insert event
     */
    XYChart.prototype.processXAxis = function (event) {
        var axis = event.newValue;
        axis.chart = this;
        if (!axis.renderer) {
            axis.renderer = new this._axisRendererX();
            axis.renderer.observe(["opposite", "inside", "inversed", "minGridDistance"], this.handleXAxisChange, this, false);
        }
        axis.axisLetter = "X";
        axis.events.on("startendchanged", this.handleXAxisRangeChange, this, false);
        //axis.events.on("endchanged", this.handleXAxisRangeChange, this, false);
        // Although axis does not use data directly, we set dataProvider here
        // (but not add to chart data users) to hold up rendering before data
        // is parsed (system handles this)
        axis.dataProvider = this;
        this.updateXAxis(axis.renderer);
        this.processAxis(axis);
    };
    /**
     * Sets up a new vertical (Y) axis when it is added to the chart.
     *
     * @ignore Exclude from docs
     * @param event Axis insert event
     */
    XYChart.prototype.processYAxis = function (event) {
        var axis = event.newValue;
        axis.chart = this;
        if (!axis.renderer) {
            axis.renderer = new this._axisRendererY();
            axis.renderer.observe(["opposite", "inside", "inversed", "minGridDistance"], this.handleYAxisChange, this, false);
        }
        axis.axisLetter = "Y";
        axis.events.on("startendchanged", this.handleYAxisRangeChange, this, false);
        //axis.events.on("endchanged", this.handleYAxisRangeChange, this, false);
        // Although axis does not use data directly, we set dataProvider here
        // (but not add to chart data users) to hold up rendering before data
        // is parsed (system handles this)
        axis.dataProvider = this;
        this.updateYAxis(axis.renderer);
        this.processAxis(axis);
    };
    /**
     * Updates horizontal (X) scrollbar and other horizontal axis whenever axis'
     * value range changes.
     */
    XYChart.prototype.handleXAxisRangeChange = function () {
        var range = this.getCommonAxisRange(this.xAxes);
        if (this.scrollbarX) {
            this.zoomAxes(this.xAxes, range, true);
        }
        this.toggleZoomOutButton();
        this.updateScrollbar(this.scrollbarX, range);
    };
    /**
     * Shows or hides the Zoom Out button depending on whether the chart is fully
     * zoomed out or not.
     */
    XYChart.prototype.toggleZoomOutButton = function () {
        if (this.zoomOutButton) {
            var show_1 = false;
            Iterator_eachContinue(this.xAxes.iterator(), function (axis) {
                if (axis.toggleZoomOutButton) {
                    if (axis.maxZoomCount > 0) {
                        var minZoomFactor = axis.maxZoomFactor / axis.maxZoomCount;
                        if (Math_round(axis.end - axis.start, 3) < 1 / minZoomFactor) {
                            show_1 = true;
                            return false;
                        }
                    }
                    else {
                        if (Math_round(axis.start, 3) > 0 || Math_round(axis.end, 3) < 1) {
                            show_1 = true;
                            return false;
                        }
                    }
                }
                return true;
            });
            Iterator_eachContinue(this.yAxes.iterator(), function (axis) {
                if (axis.toggleZoomOutButton) {
                    if (axis.maxZoomCount > 0) {
                        var minZoomFactor = axis.maxZoomFactor / axis.maxZoomCount;
                        if (Math_round(axis.end - axis.start, 3) < 1 / minZoomFactor) {
                            show_1 = true;
                            return false;
                        }
                    }
                    else {
                        if (Math_round(axis.start, 3) > 0 || Math_round(axis.end, 3) < 1) {
                            show_1 = true;
                            return false;
                        }
                    }
                    return true;
                }
            });
            if (!this.seriesAppeared) {
                show_1 = false;
            }
            if (show_1) {
                this.zoomOutButton.show();
            }
            else {
                this.zoomOutButton.hide();
            }
        }
    };
    /**
     * @ignore
     * moved this check to a separate method so that we could override it in TreeMapSeries
     */
    XYChart.prototype.seriesAppeared = function () {
        var appeared = false;
        Iterator_each(this.series.iterator(), function (series) {
            if (!series.appeared) {
                appeared = false;
                return false;
            }
        });
        return appeared;
    };
    /**
     * Updates vertical (Y) scrollbar and other horizontal axis whenever axis'
     * value range changes.
     */
    XYChart.prototype.handleYAxisRangeChange = function () {
        var range = this.getCommonAxisRange(this.yAxes);
        if (this.scrollbarY) {
            this.zoomAxes(this.yAxes, range, true);
        }
        this.toggleZoomOutButton();
        this.updateScrollbar(this.scrollbarY, range);
    };
    /**
     * Updates a relative scrollbar whenever data range of the axis changes.
     *
     * @param scrollbar  Scrollbar instance
     * @param range      New data (values) range of the axis
     */
    XYChart.prototype.updateScrollbar = function (scrollbar, range) {
        if (scrollbar) {
            scrollbar.skipRangeEvents();
            scrollbar.start = range.start;
            scrollbar.end = range.end;
        }
    };
    /**
     * Returns a common range of values between a list of axes.
     *
     * This is used to synchronize the zoom between multiple axes.
     *
     * @ignore Exclude from docs
     * @param axes  A list of axes
     * @return Common value range
     */
    XYChart.prototype.getCommonAxisRange = function (axes) {
        var start;
        var end;
        Iterator_each(axes.iterator(), function (axis) {
            var axisStart = axis.start;
            var axisEnd = axis.end;
            if (axis.renderer.inversed) {
                axisStart = 1 - axis.end;
                axisEnd = 1 - axis.start;
            }
            if (!isNumber(start) || (axisStart < start)) {
                start = axisStart;
            }
            if (!isNumber(end) || (axisEnd > end)) {
                end = axisEnd;
            }
        });
        return { start: start, end: end };
    };
    /**
     * Triggers (re)rendering of the horizontal (X) axis.
     *
     * @ignore Exclude from docs
     * @param axis  Axis
     */
    XYChart.prototype.updateXAxis = function (renderer) {
        var axis = renderer.axis;
        if (renderer.opposite) {
            axis.parent = this.topAxesContainer;
            axis.toFront();
        }
        else {
            axis.parent = this.bottomAxesContainer;
            axis.toBack();
        }
        if (axis.renderer) {
            axis.renderer.processRenderer();
        }
    };
    /**
     * Triggers (re)rendering of the vertical (Y) axis.
     *
     * @ignore Exclude from docs
     * @param axis  Axis
     */
    XYChart.prototype.updateYAxis = function (renderer) {
        var axis = renderer.axis;
        if (renderer.opposite) {
            axis.parent = this.rightAxesContainer;
            axis.toBack();
        }
        else {
            axis.parent = this.leftAxesContainer;
            axis.toFront();
        }
        if (axis.renderer) {
            axis.renderer.processRenderer();
        }
    };
    /**
     * Decorates an Axis for use with this chart, e.g. sets proper renderer
     * and containers for placement.
     *
     * @param axis  Axis
     */
    XYChart.prototype.processAxis = function (axis) {
        var _this = this;
        // Value axis does not use data directly, only category axis does
        if (axis instanceof CategoryAxis_CategoryAxis) {
            this._dataUsers.moveValue(axis);
        }
        var renderer = axis.renderer;
        renderer.gridContainer.parent = this.plotContainer;
        renderer.gridContainer.toBack();
        renderer.breakContainer.parent = this.plotContainer;
        renderer.breakContainer.toFront();
        renderer.breakContainer.zIndex = 10;
        axis.addDisposer(new Disposer(function () {
            _this.dataUsers.removeValue(axis);
        }));
        renderer.bulletsContainer.parent = this.axisBulletsContainer;
        this._disposers.push(axis.events.on("positionchanged", function () {
            var point = spritePointToSprite({ x: 0, y: 0 }, axis, _this.axisBulletsContainer);
            if (axis.renderer instanceof AxisRendererY_AxisRendererY) {
                renderer.bulletsContainer.y = point.y;
            }
            if (axis.renderer instanceof AxisRendererX_AxisRendererX) {
                renderer.bulletsContainer.x = point.x;
            }
        }, undefined, false));
        this.plotContainer.events.on("maxsizechanged", function () {
            if (_this.inited) {
                axis.invalidateDataItems();
                _this.updateSeriesMasks();
            }
        }, axis, false);
    };
    /**
     * This is done because for some reason IE doesn't change mask if path of a
     * mask changes.
     */
    XYChart.prototype.updateSeriesMasks = function () {
        if (isIE()) {
            this.series.each(function (series) {
                var mask = series.mainContainer.mask;
                series.mainContainer.mask = undefined;
                series.mainContainer.mask = mask;
            });
        }
    };
    XYChart.prototype.handleSeriesRemoved = function (event) {
        var series = event.oldValue;
        if (series) {
            if (series.xAxis) {
                series.xAxis.series.removeValue(series);
                series.xAxis.invalidateProcessedData();
            }
            if (series.yAxis) {
                series.yAxis.series.removeValue(series);
                series.yAxis.invalidateProcessedData();
            }
            // otherwise extremes won't change
            this.series.each(function (series) {
                series.resetExtremes();
            });
        }
        _super.prototype.handleSeriesRemoved.call(this, event);
    };
    Object.defineProperty(XYChart.prototype, "xAxes", {
        /**
         * A list of horizontal (X) axes.
         *
         * @return List of axes
         */
        get: function () {
            if (!this._xAxes) {
                this._xAxes = new List_List();
                this._xAxes.events.on("inserted", this.processXAxis, this, false);
                this._xAxes.events.on("removed", this.handleAxisRemoval, this, false);
                this._disposers.push(new List_ListDisposer(this._xAxes, false));
            }
            return this._xAxes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    XYChart.prototype.handleAxisRemoval = function (event) {
        var axis = event.oldValue;
        this.dataUsers.removeValue(axis); // need to remove, as it might not be disposed
        if (axis.autoDispose) {
            axis.dispose();
        }
    };
    Object.defineProperty(XYChart.prototype, "yAxes", {
        /**
         * A list of vertical (Y) axes.
         *
         * @return List of axes
         */
        get: function () {
            if (!this._yAxes) {
                this._yAxes = new List_List();
                this._yAxes.events.on("inserted", this.processYAxis, this, false);
                this._yAxes.events.on("removed", this.handleAxisRemoval, this, false);
                this._disposers.push(new List_ListDisposer(this._yAxes, false));
            }
            return this._yAxes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Decorates a new [[XYSeries]] object with required parameters when it is
     * added to the chart.
     *
     * @ignore Exclude from docs
     * @param event  Event
     */
    XYChart.prototype.handleSeriesAdded = function (event) {
        try {
            _super.prototype.handleSeriesAdded.call(this, event);
            var series = event.newValue;
            if (this.xAxes.length == 0 || this.yAxes.length == 0) {
                registry.removeFromInvalidComponents(series);
                series.dataInvalid = false;
            }
            used(series.xAxis); // this is enough to get axis, handled in getter
            used(series.yAxis); // this is enough to get axis, handled in getter
            series.maskBullets = series.maskBullets;
            if (series.fill == undefined) {
                if (this.patterns) {
                    if (!hasValue(series.stroke)) {
                        series.stroke = this.colors.next();
                    }
                    series.fill = this.patterns.next();
                    if (hasValue(series.fillOpacity)) {
                        series.fill.backgroundOpacity = series.fillOpacity;
                    }
                    if (series.stroke instanceof Color_Color) {
                        series.fill.stroke = series.stroke;
                        series.fill.fill = series.stroke;
                    }
                }
                else {
                    series.fill = this.colors.next();
                }
            }
            if (!hasValue(series.stroke)) {
                series.stroke = series.fill;
            }
        }
        catch (e) {
            this.raiseCriticalError(e);
        }
    };
    Object.defineProperty(XYChart.prototype, "cursor", {
        /**
         * @return Cursor
         */
        get: function () {
            return this._cursor;
        },
        /**
         * Chart's [[Cursor]].
         *
         * @param cursor  Cursor
         */
        set: function (cursor) {
            if (this._cursor != cursor) {
                if (this._cursor) {
                    this.removeDispose(this._cursor);
                }
                this._cursor = cursor;
                if (cursor) {
                    // TODO this is wrong, fix it
                    this._disposers.push(cursor);
                    cursor.chart = this;
                    cursor.shouldClone = false;
                    cursor.parent = this._cursorContainer;
                    cursor.events.on("cursorpositionchanged", this.handleCursorPositionChange, this, false);
                    cursor.events.on("zoomstarted", this.handleCursorZoomStart, this, false);
                    cursor.events.on("zoomended", this.handleCursorZoomEnd, this, false);
                    cursor.events.on("panstarted", this.handleCursorPanStart, this, false);
                    cursor.events.on("panning", this.handleCursorPanning, this, false);
                    cursor.events.on("panended", this.handleCursorPanEnd, this, false);
                    cursor.events.on("behaviorcanceled", this.handleCursorCanceled, this, false);
                    cursor.events.on("hidden", this.handleHideCursor, this, false);
                    cursor.zIndex = Number.MAX_SAFE_INTEGER - 1;
                    if (this.tapToActivate) {
                        // We need this in order to setup cursor properly
                        this.setTapToActivate(this.tapToActivate);
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Performs tasks when the cursor's position changes, e.g. shows proper
     * tooltips on axes and series.
     *
     * @ignore Exclude from docs
     */
    XYChart.prototype.handleCursorPositionChange = function () {
        var cursor = this.cursor;
        if (cursor.visible && !cursor.isHiding) {
            var xPosition_1 = this.cursor.xPosition;
            var yPosition_1 = this.cursor.yPosition;
            this.showSeriesTooltip({
                x: xPosition_1,
                y: yPosition_1
            });
            var exceptAxes_1 = [];
            var snapToSeries = cursor.snapToSeries;
            if (snapToSeries && !cursor.downPoint) {
                if (snapToSeries instanceof XYSeries_XYSeries) {
                    snapToSeries = [snapToSeries];
                }
                var dataItems_1 = [];
                each(snapToSeries, function (snpSeries) {
                    var xAxis = snpSeries.xAxis;
                    var yAxis = snpSeries.yAxis;
                    if (xAxis instanceof ValueAxis_ValueAxis && !(xAxis instanceof DateAxis_DateAxis) && yAxis instanceof ValueAxis_ValueAxis && !(yAxis instanceof DateAxis_DateAxis)) {
                        snpSeries.dataItems.each(function (dataItem) {
                            dataItems_1.push(dataItem);
                        });
                        move(exceptAxes_1, snpSeries.yAxis);
                        move(exceptAxes_1, snpSeries.xAxis);
                    }
                    else {
                        if (snpSeries.baseAxis == snpSeries.xAxis) {
                            move(exceptAxes_1, snpSeries.yAxis);
                            dataItems_1.push(xAxis.getSeriesDataItem(snpSeries, xAxis.toAxisPosition(xPosition_1), true));
                        }
                        if (snpSeries.baseAxis == snpSeries.yAxis) {
                            move(exceptAxes_1, snpSeries.xAxis);
                            dataItems_1.push(yAxis.getSeriesDataItem(snpSeries, yAxis.toAxisPosition(yPosition_1), true));
                        }
                    }
                });
                var closestDataItem_1 = this.getClosest(dataItems_1, xPosition_1, yPosition_1);
                if (closestDataItem_1) {
                    this.series.each(function (series) {
                        var closestSeries = closestDataItem_1.component;
                        if (series != closestSeries) {
                            series.hideTooltip();
                            if (series.xAxis != closestSeries.xAxis) {
                                series.xAxis.hideTooltip();
                            }
                            if (series.yAxis != closestSeries.yAxis) {
                                series.yAxis.hideTooltip();
                            }
                        }
                    });
                    closestDataItem_1.component.showTooltipAtDataItem(closestDataItem_1);
                    cursor.handleSnap(closestDataItem_1.component);
                }
            }
            //}
            this._seriesPoints = [];
            if (this._cursorXPosition != xPosition_1) {
                this.showAxisTooltip(this.xAxes, xPosition_1, exceptAxes_1);
            }
            if (this._cursorYPosition != yPosition_1) {
                this.showAxisTooltip(this.yAxes, yPosition_1, exceptAxes_1);
            }
            if (this.arrangeTooltips) {
                this.sortSeriesTooltips(this._seriesPoints);
            }
            if (this.legend) {
                this.legend.afterDraw();
            }
        }
    };
    XYChart.prototype.getClosest = function (dataItems, xPosition, yPosition) {
        var minDistance = Infinity;
        var closestDataItem;
        eachContinue(dataItems, function (dataItem) {
            if (dataItem) {
                var xAxis = dataItem.component.xAxis;
                var yAxis = dataItem.component.yAxis;
                var xPos = xAxis.positionToCoordinate(xAxis.toGlobalPosition(xAxis.toAxisPosition(xPosition)));
                var yPos = yAxis.positionToCoordinate(yAxis.toGlobalPosition(yAxis.toAxisPosition(yPosition)));
                var xField = dataItem.component.xField;
                var yField = dataItem.component.yField;
                if (xAxis instanceof ValueAxis_ValueAxis && !isNumber(dataItem.getValue(xField))) {
                    return true;
                }
                if (yAxis instanceof ValueAxis_ValueAxis && !isNumber(dataItem.getValue(yField))) {
                    return true;
                }
                var dxPosition = xAxis.positionToCoordinate(xAxis.toGlobalPosition(xAxis.getPositionX(dataItem, xField, dataItem.locations[xField], "valueX")));
                var dyPosition = yAxis.positionToCoordinate(yAxis.toGlobalPosition(yAxis.getPositionY(dataItem, yField, dataItem.locations[yField], "valueY")));
                var distance = Math.sqrt(Math.pow(xPos - dxPosition, 2) + Math.pow(yPos - dyPosition, 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    closestDataItem = dataItem;
                }
                return true;
            }
        });
        return closestDataItem;
    };
    /**
     * Hides all cursor-related tooltips when the cursor itself is hidden.
     *
     * @ignore Exclude from docs
     */
    XYChart.prototype.handleHideCursor = function () {
        this.hideObjectTooltip(this.xAxes);
        this.hideObjectTooltip(this.yAxes);
        this.hideObjectTooltip(this.series);
        this._cursorXPosition = undefined;
        this._cursorYPosition = undefined;
        this.updateSeriesLegend();
    };
    /**
     * Updates values for each series' legend item.
     *
     * @ignore Exclude from docs
     */
    XYChart.prototype.updateSeriesLegend = function () {
        Iterator_each(this.series.iterator(), function (series) {
            series.updateLegendValue();
        });
    };
    /**
     * Hides a tooltip for a list of objects.
     *
     * @ignore Exclude from docs
     * @param sprites  A list of sprites to hide tooltip for
     */
    XYChart.prototype.hideObjectTooltip = function (sprites) {
        Iterator_each(sprites.iterator(), function (sprite) {
            sprite.hideTooltip(0);
        });
    };
    /**
     * Shows a tooltip for all chart's series, using specific coordinates as a
     * reference point.
     *
     * The tooltip might be shown at different coordinates depending on the
     * actual data point's position, overlapping with other tooltips, etc.
     *
     * @ignore Exclude from docs
     * @param position  Reference point
     */
    XYChart.prototype.showSeriesTooltip = function (position) {
        var _this = this;
        if (!position) {
            this.series.each(function (series) {
                series.hideTooltip();
            });
            return;
        }
        var seriesPoints = [];
        this.series.each(function (series) {
            //if (series.tooltipText || series.tooltipHTML) { // not good, bullets are not hovered then
            if ((series.xAxis instanceof DateAxis_DateAxis && series.xAxis.snapTooltip) || (series.yAxis instanceof DateAxis_DateAxis && series.yAxis.snapTooltip)) {
                // void
            }
            else {
                var point = series.showTooltipAtPosition(position.x, position.y);
                if (point) {
                    series.tooltip.setBounds(spriteRectToSvg({ x: 0, y: 0, width: _this.pixelWidth, height: _this.pixelHeight }, _this));
                    seriesPoints.push({ series: series, point: point });
                }
            }
            //}
        });
        if (this.arrangeTooltips) {
            this.sortSeriesTooltips(seriesPoints);
        }
    };
    /**
     * @ignore
     */
    XYChart.prototype.sortSeriesTooltips = function (seriesPoints) {
        if (seriesPoints.length > 0) {
            var cursor_1 = this.cursor;
            if (cursor_1 && isNumber(cursor_1.maxTooltipDistance)) {
                var cursorPoint_1 = spritePointToSvg({ x: cursor_1.point.x, y: cursor_1.point.y }, cursor_1);
                var nearestSeries_1;
                var nearestPoint_1;
                var smallestDistance_1 = Infinity;
                each(seriesPoints, function (seriesPoint) {
                    var series = seriesPoint.series;
                    var fixedPoint = seriesPoint.point;
                    if (fixedPoint) {
                        var point = { x: fixedPoint.x, y: fixedPoint.y };
                        var distance = Math.abs(getDistance(point, cursorPoint_1));
                        if (distance < smallestDistance_1) {
                            nearestPoint_1 = point;
                            smallestDistance_1 = distance;
                            nearestSeries_1 = series;
                        }
                    }
                });
                var newSeriesPoints_1 = [];
                if (nearestSeries_1) {
                    each(seriesPoints, function (seriesPoint) {
                        if (Math.abs(getDistance(seriesPoint.point, nearestPoint_1)) <= Math.abs(cursor_1.maxTooltipDistance)) {
                            newSeriesPoints_1.push({ series: seriesPoint.series, point: seriesPoint.point });
                        }
                        else {
                            var tooltipDataItem = seriesPoint.series.tooltipDataItem;
                            if (tooltipDataItem) {
                                each(tooltipDataItem.sprites, function (sprite) {
                                    sprite.isHover = false;
                                    sprite.handleOutReal(); // to avoid flicker
                                });
                            }
                            seriesPoint.series.tooltip.hide(0);
                        }
                    });
                    if (cursor_1.maxTooltipDistance < 0) {
                        if (newSeriesPoints_1.length > 0) {
                            each(newSeriesPoints_1, function (np) {
                                if (nearestSeries_1 != np.series) {
                                    np.series.tooltip.hide(0);
                                }
                            });
                        }
                        newSeriesPoints_1 = [{ series: nearestSeries_1, point: nearestPoint_1 }];
                    }
                }
                seriesPoints = newSeriesPoints_1;
            }
            var topLeft_1 = spritePointToSvg({ x: -0.5, y: -0.5 }, this.plotContainer);
            var bottomRight_1 = spritePointToSvg({ x: this.plotContainer.pixelWidth + 0.5, y: this.plotContainer.pixelHeight + 0.5 }, this.plotContainer);
            var sum_1 = 0;
            var filteredSeriesPoints_1 = [];
            each(seriesPoints, function (seriesPoint) {
                var point = seriesPoint.point;
                if (point && isInRectangle(point, { x: topLeft_1.x, y: topLeft_1.y, width: bottomRight_1.x - topLeft_1.x, height: bottomRight_1.y - topLeft_1.y })) {
                    filteredSeriesPoints_1.push({ point: point, series: seriesPoint.series });
                    sum_1 += point.y;
                }
            });
            seriesPoints = filteredSeriesPoints_1;
            var firstSeries = this.series.getIndex(0);
            var inversed = false;
            if (firstSeries && firstSeries.yAxis && firstSeries.yAxis.renderer.inversed) {
                inversed = true;
            }
            if (inversed) {
                seriesPoints.sort(function (a, b) { return Number_order(a.point.y, b.point.y); });
            }
            else {
                seriesPoints.sort(function (a, b) { return Number_order(b.point.y, a.point.y); });
                seriesPoints.reverse();
            }
            var averageY = sum_1 / seriesPoints.length;
            var maxY = svgPointToDocument({ x: 0, y: 0 }, this.svgContainer.SVGContainer).y;
            if (seriesPoints.length > 0) {
                var top_1 = topLeft_1.y;
                var bottom = bottomRight_1.y;
                // TODO is this needed ?
                spritePointToDocument({ x: 0, y: top_1 }, this);
                var dropped = false;
                if (averageY > top_1 + (bottom - top_1) / 2) {
                    var nextHeight = bottom;
                    for (var i = seriesPoints.length - 1; i >= 0; i--) {
                        var series = seriesPoints[i].series;
                        var tooltip = series.tooltip;
                        var pointY = seriesPoints[i].point.y;
                        tooltip.setBounds({ x: 0, y: -maxY, width: this.pixelWidth, height: nextHeight + maxY });
                        if (tooltip.invalid) {
                            tooltip.validate();
                        }
                        tooltip.toBack();
                        nextHeight = spritePointToSvg({ x: 0, y: tooltip.label.pixelY - tooltip.pixelY + pointY - tooltip.pixelMarginTop }, tooltip).y;
                        if (nextHeight < -maxY) {
                            dropped = true;
                            break;
                        }
                    }
                }
                if (averageY <= top_1 + (bottom - top_1) / 2 || dropped) {
                    var nextY = top_1;
                    for (var i = 0, len = seriesPoints.length; i < len; i++) {
                        var series = seriesPoints[i].series;
                        var pointY = seriesPoints[i].point.y;
                        var tooltip = series.tooltip;
                        tooltip.setBounds({ x: 0, y: nextY, width: this.pixelWidth, height: bottom });
                        if (tooltip.invalid) {
                            tooltip.validate();
                        }
                        tooltip.toBack();
                        nextY = spritePointToSvg({ x: 0, y: tooltip.label.pixelY + tooltip.label.measuredHeight - tooltip.pixelY + pointY + tooltip.pixelMarginBottom }, tooltip).y;
                    }
                }
            }
        }
    };
    /**
     * Shows tooltips for a list of axes at specific position.
     *
     * Position might be X coordinate for horizontal axes, and Y coordinate for
     * vertical axes.
     *
     * @ignore Exclude from docs
     * @param axes      List of axes to show tooltip on
     * @param position  Position (px)
     */
    XYChart.prototype.showAxisTooltip = function (axes, position, except) {
        var _this = this;
        Iterator_each(axes.iterator(), function (axis) {
            if (!except || except.indexOf(axis) == -1) {
                if (_this.dataItems.length > 0 || axis.dataItems.length > 0) {
                    axis.showTooltipAtPosition(position);
                }
            }
        });
    };
    /**
     * Recalculates the value range for the axis taking into account zoom level & inversed.
     *
     * @param axis   Axis
     * @param range  Range
     * @return Modified range
     */
    XYChart.prototype.getUpdatedRange = function (axis, range) {
        if (!axis) {
            return;
        }
        var start;
        var end;
        var inversed = axis.renderer.inversed;
        if (inversed) {
            invertRange(range);
            start = 1 - axis.end;
            end = 1 - axis.start;
        }
        else {
            start = axis.start;
            end = axis.end;
        }
        var difference = end - start;
        return {
            start: start + range.start * difference,
            end: start + range.end * difference
        };
    };
    /**
     * Performs zoom and other operations when user finishes zooming using chart
     * cursor, e.g. zooms axes.
     *
     * @param event Cursor's event
     */
    XYChart.prototype.handleCursorZoomEnd = function (event) {
        var cursor = this.cursor;
        var behavior = cursor.behavior;
        if (behavior == "zoomX" || behavior == "zoomXY") {
            var xRange = cursor.xRange;
            if (xRange && this.xAxes.length > 0) {
                xRange = this.getUpdatedRange(this.xAxes.getIndex(0), xRange);
                xRange.priority = "start";
                this.zoomAxes(this.xAxes, xRange);
            }
        }
        if (behavior == "zoomY" || behavior == "zoomXY") {
            var yRange = cursor.yRange;
            if (yRange && this.yAxes.length > 0) {
                yRange = this.getUpdatedRange(this.yAxes.getIndex(0), yRange);
                yRange.priority = "start";
                this.zoomAxes(this.yAxes, yRange);
            }
        }
        this.handleHideCursor();
    };
    /**
     * Performs zoom and other operations when user is panning chart plot using chart cursor.
     *
     * @param event Cursor's event
     */
    XYChart.prototype.handleCursorPanStart = function (event) {
        var xAxis = this.xAxes.getIndex(0);
        if (xAxis) {
            this._panStartXRange = { start: xAxis.start, end: xAxis.end };
        }
        var yAxis = this.yAxes.getIndex(0);
        if (yAxis) {
            this._panStartYRange = { start: yAxis.start, end: yAxis.end };
        }
    };
    /**
     * Performs zoom and other operations when user ends panning
     *
     * @param event Cursor's event
     */
    XYChart.prototype.handleCursorPanEnd = function (event) {
        var cursor = this.cursor;
        var behavior = cursor.behavior;
        if (this._panEndXRange && (behavior == "panX" || behavior == "panXY")) {
            var panEndRange = this._panEndXRange;
            var delta = 0;
            if (panEndRange.start < 0) {
                delta = panEndRange.start;
            }
            if (panEndRange.end > 1) {
                delta = panEndRange.end - 1;
            }
            this.zoomAxes(this.xAxes, { start: panEndRange.start - delta, end: panEndRange.end - delta }, false, true);
            this._panEndXRange = undefined;
            this._panStartXRange = undefined;
        }
        if (this._panEndYRange && (behavior == "panY" || behavior == "panXY")) {
            var panEndRange = this._panEndYRange;
            var delta = 0;
            if (panEndRange.start < 0) {
                delta = panEndRange.start;
            }
            if (panEndRange.end > 1) {
                delta = panEndRange.end - 1;
            }
            this.zoomAxes(this.yAxes, { start: panEndRange.start - delta, end: panEndRange.end - delta }, false, true);
            this._panEndYRange = undefined;
            this._panStartYRange = undefined;
        }
    };
    XYChart.prototype.handleCursorCanceled = function () {
        this._panEndXRange = undefined;
        this._panStartXRange = undefined;
    };
    /**
     * Performs zoom and other operations when user is panning chart plot using chart cursor.
     *
     * @param event Cursor's event
     */
    XYChart.prototype.handleCursorPanning = function (event) {
        var cursor = this.cursor;
        var behavior = cursor.behavior;
        var maxPanOut = cursor.maxPanOut;
        if (this._panStartXRange && (behavior == "panX" || behavior == "panXY")) {
            var panStartRange = this._panStartXRange;
            var range = cursor.xRange;
            var axisRange = this.getCommonAxisRange(this.xAxes);
            var difference = (panStartRange.end - panStartRange.start);
            var delta = range.start * (axisRange.end - axisRange.start);
            var newStart = Math.max(-maxPanOut, delta + panStartRange.start);
            var newEnd = Math.min(delta + panStartRange.end, 1 + maxPanOut);
            if (newStart <= 0) {
                newEnd = newStart + difference;
            }
            if (newEnd >= 1) {
                newStart = newEnd - difference;
            }
            var newRange = {
                start: newStart,
                end: newEnd
            };
            this._panEndXRange = newRange;
            this.zoomAxes(this.xAxes, newRange, false, false, cursor.maxPanOut);
        }
        if (this._panStartYRange && (behavior == "panY" || behavior == "panXY")) {
            var panStartRange = this._panStartYRange;
            var range = cursor.yRange;
            var axisRange = this.getCommonAxisRange(this.yAxes);
            var difference = panStartRange.end - panStartRange.start;
            var delta = range.start * (axisRange.end - axisRange.start);
            var newStart = Math.max(-maxPanOut, delta + panStartRange.start);
            var newEnd = Math.min(delta + panStartRange.end, 1 + maxPanOut);
            if (newStart <= 0) {
                newEnd = newStart + difference;
            }
            if (newEnd >= 1) {
                newStart = newEnd - difference;
            }
            var newRange = {
                start: newStart,
                end: newEnd
            };
            this._panEndYRange = newRange;
            this.zoomAxes(this.yAxes, newRange, false, false, cursor.maxPanOut);
        }
        this.handleHideCursor();
    };
    /**
     * @ignore
     */
    XYChart.prototype.handleYAxisSet = function (series) {
    };
    /**
     * Performs zoom and other operations when user starts zooming using chart
     * cursor, e.g. zooms axes.
     *
     * @param event Cursor's event
     */
    XYChart.prototype.handleCursorZoomStart = function (event) {
        // Nothing here
        // This method is here only as a "placeholder" for extending classes to
        // override if necessary
    };
    Object.defineProperty(XYChart.prototype, "scrollbarX", {
        /**
         * @return Scrollbar
         */
        get: function () {
            return this._scrollbarX;
        },
        /**
         * Horizontal (X) scrollbar.
         *
         * @param scrollbar Scrollbar
         */
        set: function (scrollbar) {
            var _this = this;
            if (this._scrollbarX) {
                this.removeDispose(this._scrollbarX);
            }
            this._scrollbarX = scrollbar;
            if (scrollbar) {
                this._disposers.push(scrollbar);
                scrollbar.parent = this.topAxesContainer;
                scrollbar.shouldClone = false;
                scrollbar.startGrip.exportable = false;
                scrollbar.endGrip.exportable = false;
                scrollbar.toBack();
                scrollbar.orientation = "horizontal";
                scrollbar.events.on("rangechanged", this.handleXScrollbarChange, this, false);
                // accessibility related
                scrollbar.adapter.add("positionValue", function (arg) {
                    var xAxis = _this.xAxes.getIndex(0);
                    if (xAxis) {
                        arg.value = xAxis.getPositionLabel(xAxis.renderer.inversed
                            ? 1 - arg.position
                            : arg.position);
                    }
                    return arg;
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYChart.prototype, "scrollbarY", {
        /**
         * @return Scrollbar
         */
        get: function () {
            return this._scrollbarY;
        },
        /**
         * Vertical (Y) scrollbar.
         *
         * @param scrollbar Scrollbar
         */
        set: function (scrollbar) {
            var _this = this;
            if (this._scrollbarY) {
                this.removeDispose(this._scrollbarY);
            }
            this._scrollbarY = scrollbar;
            if (scrollbar) {
                this._disposers.push(scrollbar);
                scrollbar.parent = this.rightAxesContainer;
                scrollbar.startGrip.exportable = false;
                scrollbar.shouldClone = false;
                scrollbar.endGrip.exportable = false;
                scrollbar.toFront();
                scrollbar.orientation = "vertical";
                scrollbar.events.on("rangechanged", this.handleYScrollbarChange, this, false);
                // accessibility related
                scrollbar.adapter.add("positionValue", function (arg) {
                    var yAxis = _this.yAxes.getIndex(0);
                    if (yAxis) {
                        arg.value = yAxis.getPositionLabel(arg.position);
                    }
                    return arg;
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Zooms axes affected by the horizontal (X) scrollbar when the selection
     * on it changes.
     *
     * @param event Scrollbar range change event
     */
    XYChart.prototype.handleXScrollbarChange = function (event) {
        if (this.inited) {
            var scrollbar = event.target;
            var range = scrollbar.range;
            if (range.start == 0) {
                range.priority = "start";
            }
            if (range.end == 1) {
                range.priority = "end";
            }
            range = this.zoomAxes(this.xAxes, range);
            scrollbar.fixRange(range);
        }
    };
    /**
     * Zooms axes affected by the vertical (Y) scrollbar when the selection
     * on it changes.
     *
     * @param event Scrollbar range change event
     */
    XYChart.prototype.handleYScrollbarChange = function (event) {
        if (this.inited) {
            var scrollbar = event.target;
            var range = scrollbar.range;
            if (range.end == 1) {
                range.priority = "end";
            }
            if (range.start == 0) {
                range.priority = "start";
            }
            range = this.zoomAxes(this.yAxes, range);
            scrollbar.fixRange(range);
        }
    };
    /**
     * Zooms axes that are affected by to specific relative range.
     *
     * @param axes       List of axes to zoom
     * @param range      Range of values to zoom to (0-1)
     * @param instantly  If set to `true` will skip zooming animation
     * @return Recalculated range that is common to all involved axes
     */
    XYChart.prototype.zoomAxes = function (axes, range, instantly, round, declination) {
        var realRange = { start: 0, end: 1 };
        this.showSeriesTooltip(); // hides
        if (!this.dataInvalid) {
            Iterator_each(axes.iterator(), function (axis) {
                if (axis.renderer.inversed) {
                    range = invertRange(range);
                }
                axis.hideTooltip(0);
                if (round) {
                    //let diff = range.end - range.start;
                    if (axis instanceof CategoryAxis_CategoryAxis) {
                        var cellWidth = axis.getCellEndPosition(0) - axis.getCellStartPosition(0);
                        range.start = axis.roundPosition(range.start + cellWidth / 2 - (axis.startLocation) * cellWidth, axis.startLocation);
                        range.end = axis.roundPosition(range.end - cellWidth / 2 + (1 - axis.endLocation) * cellWidth, axis.endLocation);
                    }
                    else {
                        range.start = axis.roundPosition(range.start + 0.0001, 0, axis.startLocation);
                        range.end = axis.roundPosition(range.end + 0.0001, 0, axis.endLocation);
                    }
                }
                var axisRange = axis.zoom(range, instantly, instantly, declination);
                if (axis.renderer.inversed) {
                    axisRange = invertRange(axisRange);
                }
                realRange = axisRange;
            });
        }
        return realRange;
    };
    Object.defineProperty(XYChart.prototype, "maskBullets", {
        /**
         * @return Mask bullet container?
         */
        get: function () {
            return this.getPropertyValue("maskBullets");
        },
        /**
         * Indicates if bullet container is masked.
         *
         * If it is set to `true`, any bullets that do not fit into bullet container
         * will be clipped off. Settting to `false` will allow bullets to "spill out"
         * of the plot area so they are not cut off.
         *
         * @param value Mask bullet container?
         */
        set: function (value) {
            if (this.setPropertyValue("maskBullets", value, true) && this.bulletsContainer) {
                if (value) {
                    this.bulletsContainer.mask = this._bulletMask;
                }
                else {
                    this.bulletsContainer.mask = undefined;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYChart.prototype, "arrangeTooltips", {
        /**
         * @return Arrange tooltips?
         */
        get: function () {
            return this.getPropertyValue("arrangeTooltips");
        },
        /**
         * Indicates if chart should arrange series tooltips so that they would not
         * overlap.
         *
         * If set to `true` (default), the chart will adjust vertical positions of
         * all simultaneously shown tooltips to avoid overlapping.
         *
         * However, if you have a vertically-arranged chart, it might not make sense,
         * because tooltips would most probably not be aligned horizontally. In this
         * case it would probably be a good idea to set this setting to `false`.
         *
         * @default true
         * @param value Arrange tooltips?
         */
        set: function (value) {
            this.setPropertyValue("arrangeTooltips", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handles mouse wheel event.
     *
     * @param event  Original event
     */
    XYChart.prototype.handleWheel = function (event) {
        var plotContainer = this.plotContainer;
        var svgPoint = documentPointToSvg(event.point, this.htmlContainer, this.svgContainer.cssScale);
        var plotPoint = svgPointToSprite(svgPoint, plotContainer);
        var shift = event.shift.y;
        this.handleWheelReal(shift, this.mouseWheelBehavior, plotPoint);
    };
    /**
     * Handles mouse wheel event.
     *
     * @param event  Original event
     */
    XYChart.prototype.handleHorizontalWheel = function (event) {
        var plotContainer = this.plotContainer;
        var svgPoint = documentPointToSvg(event.point, this.htmlContainer, this.svgContainer.cssScale);
        var plotPoint = svgPointToSprite(svgPoint, plotContainer);
        this.handleWheelReal(event.shift.x, this.horizontalMouseWheelBehavior, plotPoint);
    };
    /**
     * @ignore
     */
    XYChart.prototype.handleWheelReal = function (shift, mouseWheelBehavior, plotPoint) {
        if (shift != 0) {
            var plotContainer = this.plotContainer;
            var rangeX = this.getCommonAxisRange(this.xAxes);
            var rangeY = this.getCommonAxisRange(this.yAxes);
            var shiftStep = 0.1;
            var maxPanOut = 0;
            if (mouseWheelBehavior == "panX" || mouseWheelBehavior == "panXY") {
                var differenceX = rangeX.end - rangeX.start;
                var newStartX = Math.max(-maxPanOut, rangeX.start + shiftStep * shift / 100 * (rangeX.end - rangeX.start));
                var newEndX = Math.min(rangeX.end + shiftStep * shift / 100 * (rangeX.end - rangeX.start), 1 + maxPanOut);
                if (newStartX <= 0) {
                    newEndX = newStartX + differenceX;
                }
                if (newEndX >= 1) {
                    newStartX = newEndX - differenceX;
                }
                this.zoomAxes(this.xAxes, { start: newStartX, end: newEndX });
            }
            if (mouseWheelBehavior == "panY" || mouseWheelBehavior == "panXY") {
                shift *= -1;
                var differenceY = rangeY.end - rangeY.start;
                var newStartY = Math.max(-maxPanOut, rangeY.start + shiftStep * shift / 100 * (rangeY.end - rangeY.start));
                var newEndY = Math.min(rangeY.end + shiftStep * shift / 100 * (rangeY.end - rangeY.start), 1 + maxPanOut);
                if (newStartY <= 0) {
                    newEndY = newStartY + differenceY;
                }
                if (newEndY >= 1) {
                    newStartY = newEndY - differenceY;
                }
                this.zoomAxes(this.yAxes, { start: newStartY, end: newEndY });
            }
            if (mouseWheelBehavior == "zoomX" || mouseWheelBehavior == "zoomXY") {
                var locationX = plotPoint.x / plotContainer.maxWidth;
                var location2X = this.xAxes.getIndex(0).toAxisPosition(locationX);
                var newStartX = Math.max(-maxPanOut, rangeX.start - shiftStep * (rangeX.end - rangeX.start) * shift / 100 * locationX);
                newStartX = Math.min(newStartX, location2X);
                var newEndX = Math.min(rangeX.end + shiftStep * (rangeX.end - rangeX.start) * shift / 100 * (1 - locationX), 1 + maxPanOut);
                newEndX = Math.max(newEndX, location2X);
                this.zoomAxes(this.xAxes, { start: newStartX, end: newEndX });
            }
            if (mouseWheelBehavior == "zoomY" || mouseWheelBehavior == "zoomXY") {
                var locationY = plotPoint.y / plotContainer.maxHeight;
                var location2Y = this.yAxes.getIndex(0).toAxisPosition(locationY);
                var newStartY = Math.max(-maxPanOut, rangeY.start - shiftStep * (rangeY.end - rangeY.start) * shift / 100 * (1 - locationY));
                newStartY = Math.min(newStartY, location2Y);
                var newEndY = Math.min(rangeY.end + shiftStep * shift / 100 * locationY * (rangeY.end - rangeY.start), 1 + maxPanOut);
                newEndY = Math.max(newEndY, location2Y);
                this.zoomAxes(this.yAxes, { start: newStartY, end: newEndY });
            }
        }
    };
    Object.defineProperty(XYChart.prototype, "mouseWheelBehavior", {
        /**
         * @return Mouse wheel behavior
         */
        get: function () {
            return this.getPropertyValue("mouseWheelBehavior");
        },
        /**
         * Specifies action for when mouse wheel is used when over the chart.
         *
         * Options: Options: `"zoomX"`, `"zoomY"`, `"zoomXY"`, `"panX"`, `"panY"`,`"panXY"`, `"none"` (default).
         *
         * You can control sensitivity of wheel zooming via `mouseOptions`.
         *
         * @default "none"
         * @see {@link https://www.amcharts.com/docs/v4/reference/sprite/#mouseOptions_property} More information about `mouseOptions`
         * @param mouse wheel behavior
         */
        set: function (value) {
            if (this.setPropertyValue("mouseWheelBehavior", value)) {
                if (value != "none") {
                    this._mouseWheelDisposer = this.plotContainer.events.on("wheel", this.handleWheel, this, false);
                    this._disposers.push(this._mouseWheelDisposer);
                }
                else {
                    if (this._mouseWheelDisposer) {
                        this.plotContainer.wheelable = false;
                        this.plotContainer.hoverable = false;
                        this._mouseWheelDisposer.dispose();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYChart.prototype, "horizontalMouseWheelBehavior", {
        /**
         * @return Horizontal mouse wheel behavior
         */
        get: function () {
            return this.getPropertyValue("horizontalMouseWheelBehavior");
        },
        /**
         * Specifies action for when horizontal mouse wheel is used when over the chart.
         *
         * Options: Options: `"zoomX"`, `"zoomY"`, `"zoomXY"`, `"panX"`, `"panY"`, `"panXY"`, `"none"` (default).
         *
         * @default "none"
         * @see {@link https://www.amcharts.com/docs/v4/reference/sprite/#mouseOptions_property} More information about `mouseOptions`
         * @param mouse wheel behavior
         */
        set: function (value) {
            if (this.setPropertyValue("horizontalMouseWheelBehavior", value)) {
                if (value != "none") {
                    this._mouseWheelDisposer2 = this.plotContainer.events.on("wheel", this.handleHorizontalWheel, this, false);
                    this._disposers.push(this._mouseWheelDisposer2);
                }
                else {
                    if (this._mouseWheelDisposer2) {
                        this.plotContainer.wheelable = false;
                        this.plotContainer.hoverable = false;
                        this._mouseWheelDisposer2.dispose();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This function is called by the [[DataSource]]'s `dateFields` adapater
     * so that particular chart types can popuplate this setting with their
     * own type-specific data fields so they are parsed properly.
     *
     * @param fields  Array of date fields
     * @return Array of date fields populated with chart's date fields
     */
    XYChart.prototype.dataSourceDateFields = function (fields) {
        var _this = this;
        // Process parent
        fields = _super.prototype.dataSourceDateFields.call(this, fields);
        // Check if we have any series with date-fields
        Iterator_each(this.series.iterator(), function (series) {
            fields = _this.populateDataSourceFields(fields, series.dataFields, ["dateX", "dateY", "openDateX", "openDateY"]);
        });
        return fields;
    };
    /**
     * This function is called by the [[DataSource]]'s `numberFields` adapater
     * so that particular chart types can popuplate this setting with their
     * own type-specific data fields so they are parsed properly.
     *
     * @param value  Array of number fields
     * @return Array of number fields populated with chart's number fields
     */
    XYChart.prototype.dataSourceNumberFields = function (fields) {
        var _this = this;
        fields = _super.prototype.dataSourceDateFields.call(this, fields);
        // Check if we have any series with date-fields
        Iterator_each(this.series.iterator(), function (series) {
            fields = _this.populateDataSourceFields(fields, series.dataFields, ["valueX", "valueY", "openValueX", "openValueY"]);
        });
        return fields;
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    XYChart.prototype.processConfig = function (config) {
        if (config) {
            // Save axis ranges for later processing
            var xAxes = [];
            var yAxes = [];
            // Set up axes
            if (hasValue(config.xAxes) && isArray(config.xAxes)) {
                for (var i = 0, len = config.xAxes.length; i < len; i++) {
                    if (!config.xAxes[i].type) {
                        throw Error("[XYChart error] No type set for xAxes[" + i + "].");
                    }
                    else if (hasValue(config.xAxes[i]["axisRanges"])) {
                        // Maybe convert string dates?
                        for (var x = 0, len_1 = config.xAxes[i]["axisRanges"].length; x < len_1; x++) {
                            var range = config.xAxes[i]["axisRanges"][x];
                            if (hasValue(range.date) && isString(range.date)) {
                                range.date = this.dateFormatter.parse(range.date);
                            }
                            if (hasValue(range.endDate) && isString(range.endDate)) {
                                range.endDate = this.dateFormatter.parse(range.endDate);
                            }
                        }
                        xAxes.push({
                            axisRanges: config.xAxes[i]["axisRanges"],
                            index: i
                        });
                        delete (config.xAxes[i]["axisRanges"]);
                    }
                }
            }
            if (hasValue(config.yAxes) && isArray(config.yAxes)) {
                for (var i = 0, len = config.yAxes.length; i < len; i++) {
                    if (!config.yAxes[i].type) {
                        throw Error("[XYChart error] No type set for yAxes[" + i + "].");
                    }
                    else if (hasValue(config.yAxes[i]["axisRanges"])) {
                        // Maybe convert string dates?
                        for (var x = 0, len_2 = config.yAxes[i]["axisRanges"].length; x < len_2; x++) {
                            var range = config.yAxes[i]["axisRanges"][x];
                            if (hasValue(range.date) && isString(range.date)) {
                                range.date = this.dateFormatter.parse(range.date);
                            }
                            if (hasValue(range.endDate) && isString(range.endDate)) {
                                range.endDate = this.dateFormatter.parse(range.endDate);
                            }
                        }
                        yAxes.push({
                            axisRanges: config.yAxes[i]["axisRanges"],
                            index: i
                        });
                        delete (config.yAxes[i]["axisRanges"]);
                    }
                }
            }
            // Set up series
            if (hasValue(config.series) && isArray(config.series)) {
                for (var i = 0, len = config.series.length; i < len; i++) {
                    config.series[i].type = config.series[i].type || "LineSeries";
                }
            }
            // Set up cursor
            if (hasValue(config.cursor) && !hasValue(config.cursor.type)) {
                config.cursor.type = "XYCursor";
            }
            // Set up scrollbars
            if (hasValue(config.scrollbarX) && !hasValue(config.scrollbarX.type)) {
                config.scrollbarX.type = "Scrollbar";
            }
            if (hasValue(config.scrollbarY) && !hasValue(config.scrollbarY.type)) {
                config.scrollbarY.type = "Scrollbar";
            }
            _super.prototype.processConfig.call(this, config);
            // Finish up with ranges.
            // We need to do this here because series are processed last in JSON
            // config. Therefore their respective objects are not yet are available
            // when axis (and respectively their ranges) are being processed.
            if (yAxes.length) {
                for (var i = 0, len = yAxes.length; i < len; i++) {
                    this.yAxes.getIndex(yAxes[i].index).config = {
                        axisRanges: yAxes[i].axisRanges
                    };
                }
            }
            if (xAxes.length) {
                for (var i = 0, len = xAxes.length; i < len; i++) {
                    this.xAxes.getIndex(xAxes[i].index).config = {
                        axisRanges: xAxes[i].axisRanges
                    };
                }
            }
        }
    };
    /**
     * This function is used to sort element's JSON config properties, so that
     * some properties that absolutely need to be processed last, can be put at
     * the end.
     *
     * @ignore Exclude from docs
     * @param a  Element 1
     * @param b  Element 2
     * @return Sorting number
     */
    XYChart.prototype.configOrder = function (a, b) {
        if (a == b) {
            return 0;
        }
        // Must come last
        else if (a == "scrollbarX") {
            return 1;
        }
        else if (b == "scrollbarX") {
            return -1;
        }
        else if (a == "scrollbarY") {
            return 1;
        }
        else if (b == "scrollbarY") {
            return -1;
        }
        else if (a == "cursor") {
            return 1;
        }
        else if (b == "cursor") {
            return -1;
        }
        else if (a == "series") {
            return 1;
        }
        else if (b == "series") {
            return -1;
        }
        else {
            return _super.prototype.configOrder.call(this, a, b);
        }
    };
    /**
     * Creates a new Series of type suitable for this chart.
     *
     * @return New series
     */
    XYChart.prototype.createSeries = function () {
        return new XYSeries_XYSeries();
    };
    Object.defineProperty(XYChart.prototype, "zoomOutButton", {
        /**
         * @return Zoom out button
         */
        get: function () {
            return this._zoomOutButton;
        },
        /**
         * A [[Button]] element that is used for zooming out the chart.
         *
         * This button appears only when chart is zoomed in, and disappears
         * autoamatically when it is zoome dout.
         *
         * @param button  Zoom out button
         */
        set: function (button) {
            var _this = this;
            this._zoomOutButton = button;
            if (button) {
                button.events.on("hit", function () {
                    _this.zoomAxes(_this.xAxes, { start: 0, end: 1 });
                    _this.zoomAxes(_this.yAxes, { start: 0, end: 1 });
                }, undefined, false);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all parameters from another [[XYChart]].
     *
     * @param source Source XYChart
     */
    XYChart.prototype.copyFrom = function (source) {
        var _this = this;
        source.xAxes.each(function (axis) {
            _this.xAxes.push(axis.clone());
        });
        source.yAxes.each(function (axis) {
            _this.yAxes.push(axis.clone());
        });
        //this.xAxes.copyFrom(source.xAxes);
        //this.yAxes.copyFrom(source.yAxes);
        _super.prototype.copyFrom.call(this, source);
        //this.zoomOutButton.copyFrom(source.zoomOutButton);
        if (source.cursor) {
            this.cursor = source.cursor.clone();
        }
        if (source.scrollbarX) {
            this.scrollbarX = source.scrollbarX.clone();
        }
        if (source.scrollbarY) {
            this.scrollbarY = source.scrollbarY.clone();
        }
        //@todo copy all container properties
    };
    /**
     * @ignore
     */
    XYChart.prototype.disposeData = function () {
        _super.prototype.disposeData.call(this);
        var scrollbarX = this.scrollbarX;
        if (scrollbarX && scrollbarX instanceof XYChartScrollbar_XYChartScrollbar) {
            scrollbarX.scrollbarChart.disposeData();
        }
        var scrollbarY = this.scrollbarY;
        if (scrollbarY && scrollbarY instanceof XYChartScrollbar_XYChartScrollbar) {
            scrollbarY.scrollbarChart.disposeData();
        }
        this.xAxes.each(function (axis) {
            axis.disposeData();
        });
        this.yAxes.each(function (axis) {
            axis.disposeData();
        });
    };
    /**
     * Adds one or several (array) of data items to the existing data.
     *
     * @param rawDataItem One or many raw data item objects
     */
    XYChart.prototype.addData = function (rawDataItem, removeCount) {
        if (this.scrollbarX instanceof XYChartScrollbar_XYChartScrollbar) {
            this.addScrollbarData(this.scrollbarX, removeCount);
        }
        if (this.scrollbarY instanceof XYChartScrollbar_XYChartScrollbar) {
            this.addScrollbarData(this.scrollbarY, removeCount);
        }
        _super.prototype.addData.call(this, rawDataItem, removeCount);
    };
    /**
     * @ignore
     */
    XYChart.prototype.addScrollbarData = function (scrollbar, removeCount) {
        var chart = scrollbar.scrollbarChart;
        chart._parseDataFrom = chart.data.length;
        chart.invalidateData();
    };
    /**
     * @ignore
     */
    XYChart.prototype.removeScrollbarData = function (scrollbar, removeCount) {
        var chart = scrollbar.scrollbarChart;
        if (isNumber(removeCount)) {
            while (removeCount > 0) {
                var dataItem = this.dataItems.getIndex(0);
                if (dataItem) {
                    chart.dataItems.remove(dataItem);
                }
                chart.dataUsers.each(function (dataUser) {
                    var dataItem = dataUser.dataItems.getIndex(0);
                    if (dataItem) {
                        dataUser.dataItems.remove(dataItem);
                    }
                });
                chart._parseDataFrom--;
                removeCount--;
            }
            chart.invalidateData();
        }
    };
    /**
     * Removes elements from the beginning of data
     *
     * @param count number of elements to remove
     */
    XYChart.prototype.removeData = function (count) {
        if (this.scrollbarX instanceof XYChartScrollbar_XYChartScrollbar) {
            this.removeScrollbarData(this.scrollbarX, count);
        }
        if (this.scrollbarY instanceof XYChartScrollbar_XYChartScrollbar) {
            this.removeScrollbarData(this.scrollbarY, count);
        }
        _super.prototype.removeData.call(this, count);
    };
    /**
     * @param  value  Tap to activate?
     */
    XYChart.prototype.setTapToActivate = function (value) {
        _super.prototype.setTapToActivate.call(this, value);
        if (this.cursor) {
            this.cursor.interactions.isTouchProtected = value;
            this.plotContainer.interactions.isTouchProtected = value;
        }
    };
    XYChart.prototype.handleTapToActivate = function () {
        _super.prototype.handleTapToActivate.call(this);
        if (this.cursor) {
            this.cursor.interactions.isTouchProtected = false;
            this.plotContainer.interactions.isTouchProtected = false;
        }
    };
    XYChart.prototype.handleTapToActivateDeactivation = function () {
        _super.prototype.handleTapToActivateDeactivation.call(this);
        if (this.cursor) {
            this.cursor.interactions.isTouchProtected = true;
            this.plotContainer.interactions.isTouchProtected = true;
        }
    };
    return XYChart;
}(SerialChart_SerialChart));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["XYChart"] = XYChart_XYChart;
/**
 * Add default responsive rules
 */
/**
 * Remove horizontal scrollbar on narrow charts.
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.maybeXS,
    state: function (target, stateId) {
        if (target instanceof XYChart_XYChart && target.scrollbarX) {
            var state = target.states.create(stateId);
            var sbstate = target.scrollbarX.states.create(stateId);
            sbstate.properties.disabled = true;
            return state;
        }
        return null;
    }
});
/**
 * Remove vertical scrollbar on short charts.
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.maybeXS,
    state: function (target, stateId) {
        if (target instanceof XYChart_XYChart && target.scrollbarY) {
            var state = target.states.create(stateId);
            var sbstate = target.scrollbarY.states.create(stateId);
            sbstate.properties.disabled = true;
            return state;
        }
        return null;
    }
});
//# sourceMappingURL=XYChart.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/LineSeriesSegment.js
/**
 * Line series segment module.
 * @todo Add description about what this is
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Represents a line series segment.
 *
 * A line segment can be used to apply different properties to a part of the
 * line series, between two data points.
 *
 * @see {@link ILineSeriesSegmentEvents} for a list of available events
 * @see {@link ILineSeriesSegmentAdapters} for a list of available Adapters
 * @todo Example
 */
var LineSeriesSegment_LineSeriesSegment = /** @class */ (function (_super) {
    __extends(LineSeriesSegment, _super);
    /**
     * Constructor
     */
    function LineSeriesSegment() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "LineSeriesSegment";
        // Set defaults
        _this.isMeasured = false;
        _this.interactionsEnabled = false;
        _this.layout = "none";
        // Create fill element
        var fillSprite = _this.createChild(Sprite_Sprite);
        _this.fillSprite = fillSprite;
        fillSprite.shouldClone = false;
        fillSprite.setElement(_this.paper.add("path"));
        fillSprite.isMeasured = false;
        _this._disposers.push(fillSprite);
        // Create line element
        var strokeSprite = _this.createChild(Sprite_Sprite);
        _this.strokeSprite = strokeSprite;
        strokeSprite.shouldClone = false;
        strokeSprite.fill = Color_color();
        strokeSprite.setElement(_this.paper.add("path"));
        strokeSprite.isMeasured = false;
        _this._disposers.push(strokeSprite);
        return _this;
    }
    /**
     * Draws the series segment.
     *
     * @ignore Exclude from docs
     * @param points       Points to connect
     * @param closePoints  ?
     * @param smoothnessX  Horizontal bezier setting (?)
     * @param smoothnessY  Vertical bezier setting (?)
     */
    LineSeriesSegment.prototype.drawSegment = function (points, closePoints, smoothnessX, smoothnessY) {
        if (!this.disabled) {
            if (points.length > 0 && closePoints.length > 0) {
                // first moveTo helps to avoid Chrome straight line in the mask bug.
                var path = moveTo({ x: points[0].x - 0.2, y: points[0].y - 0.2 }) + moveTo(points[0]) + new Smoothing_Tension(smoothnessX, smoothnessY).smooth(points);
                if (this.strokeOpacity == 0 || this.strokeSprite.strokeOpacity == 0) {
                    // like this and not if != 0, otherwise ranges stroke won't be drawn.
                }
                else {
                    this.strokeSprite.path = path;
                }
                if (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) { // helps to avoid drawing fill object if fill is not visible
                    path += lineTo(closePoints[0]) + new Smoothing_Tension(smoothnessX, smoothnessY).smooth(closePoints);
                    path += lineTo(points[0]);
                    path += closePath();
                    this.fillSprite.path = path;
                }
            }
            else {
                this.fillSprite.path = "";
                this.strokeSprite.path = "";
            }
        }
    };
    /**
     * Copies properties from a [[Sprite]] to both line and fill elements.
     *
     * @param source Source [[Sprite]] to copy properties from
     */
    LineSeriesSegment.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        var lineElement = this.strokeSprite;
        copyProperties(source, lineElement.properties, visualProperties);
        lineElement.events.copyFrom(source.strokeSprite.events);
        lineElement.fillOpacity = 0;
        var fillElement = this.fillSprite;
        copyProperties(source, fillElement.properties, visualProperties);
        fillElement.events.copyFrom(source.fillSprite.events);
        fillElement.strokeOpacity = 0;
    };
    return LineSeriesSegment;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["LineSeriesSegment"] = LineSeriesSegment_LineSeriesSegment;
//# sourceMappingURL=LineSeriesSegment.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/DurationAxis.js
/**
 * DurationAxis module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines data item for [[DurationAxis]].
 *
 * @see {@link DataItem}
 */
var DurationAxis_DurationAxisDataItem = /** @class */ (function (_super) {
    __extends(DurationAxisDataItem, _super);
    /**
     * Constructor
     */
    function DurationAxisDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "DurationAxisDataItem";
        _this.applyTheme();
        return _this;
    }
    return DurationAxisDataItem;
}(ValueAxis_ValueAxisDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Used to create an axis that shows time durations.
 *
 * ```TypeScript
 * // Create the axis
 * let xAxis = chart.xAxes.push(new am4charts.DurationAxis());
 *
 * // Set settings
 * xAxis.title.text = "Time";
 * ```
 * ```JavaScript
 * // Create the axis
 * var valueAxis = chart.xAxes.push(new am4charts.DurationAxis());
 *
 * // Set settings
 * valueAxis.title.text = "Time";
 * ```
 * ```JSON
 * "xAxes": [{
 *   "type": "DurationAxis",
 *   "title": {
 *     "text": "Time"
 *   }
 * }]
 * ```
 *
 * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/} for mor information about duration formatters.
 * @see {@link IDurationAxisEvents} for a list of available Events
 * @see {@link IDurationAxisAdapters} for a list of available Adapters
 * @important
 */
var DurationAxis_DurationAxis = /** @class */ (function (_super) {
    __extends(DurationAxis, _super);
    /**
     * Constructor
     */
    function DurationAxis() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * A base unit (granularity) of data.
         *
         * Used to indicate what are the base units of your data.
         */
        _this._baseUnit = "second";
        _this.className = "DurationAxis";
        _this.setPropertyValue("maxZoomFactor", 1000000);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Formats the value according to axis' own [[DurationFormatter]].
     *
     * @param value  Source value
     * @return Formatted value
     */
    DurationAxis.prototype.formatLabel = function (value, format) {
        return this.durationFormatter.format(value, format || this.axisDurationFormat);
    };
    /**
     * Adjusts actual min and max scale values so that the axis starts and ends
     * at "nice" values, unless `strictMinMax` is set.
     *
     * The `difference` can be something else than `max - min`, because of the
     * axis breaks.
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param min        [description]
     * @param max        [description]
     * @param difference [description]
     * @param gridCount  [description]
     * @param strictMode [description]
     * @return [description]
     */
    DurationAxis.prototype.adjustMinMax = function (min, max, difference, gridCount, strictMode) {
        var e_1, _a;
        var minMaxStep;
        var timeUnit = this.baseUnit;
        // we don't allow to go to smaller units, setting so to avoid invalidation
        this.setPropertyValue("maxPrecision", 0);
        if (timeUnit == "millisecond" || timeUnit == "second" || timeUnit == "minute" || timeUnit == "hour") {
            // will fail if 0
            if (gridCount <= 1) {
                gridCount = 1;
            }
            gridCount = Math.round(gridCount);
            var initialMin = min;
            var initialMax = max;
            // in case min and max is the same, use max
            if (difference === 0) {
                difference = Math.abs(max);
            }
            var step = difference / gridCount;
            var divisors = [60, 30, 20, 15, 10, 2, 1];
            var realDivisor = 1;
            if (timeUnit == "hour") {
                divisors = [24, 12, 6, 4, 2, 1];
            }
            try {
                for (var divisors_1 = __values(divisors), divisors_1_1 = divisors_1.next(); !divisors_1_1.done; divisors_1_1 = divisors_1.next()) {
                    var divisor = divisors_1_1.value;
                    if (difference / divisor > gridCount) {
                        realDivisor = divisor;
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (divisors_1_1 && !divisors_1_1.done && (_a = divisors_1.return)) _a.call(divisors_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var count = Math.ceil(((max - min) / realDivisor) / gridCount);
            var exponent = Math.log(Math.abs(count)) * Math.LOG10E;
            var power = Math.pow(10, Math.floor(exponent)) / 10;
            var reducedCount = count / power;
            // find closest to divisor
            var closest = Math_closest(divisors, reducedCount);
            count = closest * power;
            step = realDivisor * count;
            // TODO can this be removed ?
            this.durationFormatter.getValueUnit(step, this.baseUnit);
            min = Math.floor(min / step) * step;
            max = Math.ceil(max / step) * step;
            if (strictMode) {
                min -= step;
                if (min < 0 && initialMin >= 0) {
                    min = 0;
                }
                max += step;
                if (max > 0 && initialMax <= 0) {
                    max = 0;
                }
            }
            minMaxStep = { min: min, max: max, step: step };
        }
        else {
            minMaxStep = _super.prototype.adjustMinMax.call(this, min, max, difference, gridCount, strictMode);
        }
        // choose duration formatter based on step
        this.axisDurationFormat = this.durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, this.baseUnit);
        return minMaxStep;
    };
    Object.defineProperty(DurationAxis.prototype, "tooltipDurationFormat", {
        /**
         * @return Duration format for axis labels
         */
        get: function () {
            return this._tooltipDurationFormat;
        },
        /**
         * A special duration format to apply axis tooltips.
         *
         * Will use same format as for labels, if not set.
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/} for mor information.
         * @param value  Duration format for axis labels
         */
        set: function (value) {
            this._tooltipDurationFormat = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns text to show in a axis tooltip, based on specific position within
     * axis.
     *
     * The label will be formatted as per [[NumberFormatter]] set for the whole
     * chart, or explicitly for this Axis.
     *
     * @ignore Exclude from docs
     * @param position  Position (px)
     * @return Label (numeric value)
     */
    DurationAxis.prototype.getTooltipText = function (position) {
        var value = Math_round(this.positionToValue(position), this._stepDecimalPlaces);
        var valueStr = this.formatLabel(value, this.tooltipDurationFormat);
        if (!this._adapterO) {
            return valueStr;
        }
        else {
            return this._adapterO.apply("getTooltipText", valueStr);
        }
    };
    Object.defineProperty(DurationAxis.prototype, "baseUnit", {
        /**
         * @return Base unit
         */
        get: function () {
            return this._baseUnit;
        },
        /**
         * A base unit (granularity) of data.
         *
         * Used to indicate what are the base units of your data.
         *
         * Available options: "millisecond", "second" (default), "minute", "hour",
         * "day", "week", "month", "year".
         *
         * @default "second"
         * @param timeUnit
         */
        set: function (timeUnit) {
            if (this._baseUnit != timeUnit) {
                this._baseUnit = timeUnit;
                this.durationFormatter.baseUnit = timeUnit;
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all properties and related data from a different instance of Axis.
     *
     * @param source Source Axis
     */
    DurationAxis.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.baseUnit = source.baseUnit;
    };
    return DurationAxis;
}(ValueAxis_ValueAxis));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["DurationAxis"] = DurationAxis_DurationAxis;
registry.registeredClasses["DurationAxisDataItem"] = DurationAxis_DurationAxisDataItem;
//# sourceMappingURL=DurationAxis.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/LineSeries.js
/**
 * Line series module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


















/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[LineSeries]].
 *
 * @see {@link DataItem}
 */
var LineSeries_LineSeriesDataItem = /** @class */ (function (_super) {
    __extends(LineSeriesDataItem, _super);
    /**
     * Constructor
     */
    function LineSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "LineSeriesDataItem";
        return _this;
    }
    return LineSeriesDataItem;
}(XYSeries_XYSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a line graph.
 *
 * @see {@link ILineSeriesEvents} for a list of available Events
 * @see {@link ILineSeriesAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var LineSeries_LineSeries = /** @class */ (function (_super) {
    __extends(LineSeries, _super);
    /**
     * Constructor
     */
    function LineSeries() {
        var _this = _super.call(this) || this;
        /**
         * Minimum distance in pixels between two adjacent points.
         *
         * If the distance is less than this setting, a point is skipped.
         *
         * This allows acceptable performance with huge amounts of data points.
         *
         * @default 0.5
         */
        _this.minDistance = 0.5;
        _this.segments = new List_ListTemplate(_this.createSegment());
        _this.segments.template.applyOnClones = true;
        _this._disposers.push(new List_ListDisposer(_this.segments));
        _this._disposers.push(_this.segments.template);
        _this._segmentsIterator = new Iterator_ListIterator(_this.segments, function () { return _this.segments.create(); });
        _this._segmentsIterator.createNewItems = true;
        _this.className = "LineSeries";
        _this.strokeOpacity = 1;
        _this.fillOpacity = 0;
        _this.connect = true;
        _this.tensionX = 1;
        _this.tensionY = 1;
        _this.autoGapCount = 1.1;
        _this.segmentsContainer = _this.mainContainer.createChild(Container_Container);
        _this.segmentsContainer.isMeasured = false;
        // line series might have multiple segments and it has a separate sprite for fill and stroke for each segment. So we need to observe all the changes on series and set them on the segments
        // todo: we need list here, otherwise everything will be redrawn event on change of properties like tooltipX or similar.
        // this.addEventListener(SpriteEvent.PROPERTY_CHANGED, this.validateDataElements, false, this);
        _this.bulletsContainer.toFront();
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    LineSeries.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Line Series");
        }
    };
    /**
     * @ignore
     */
    LineSeries.prototype.createSegment = function () {
        return new LineSeriesSegment_LineSeriesSegment();
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    LineSeries.prototype.createDataItem = function () {
        return new LineSeries_LineSeriesDataItem();
    };
    /**
     * Inits data item's working values.
     *
     * @param dataItem  Data item
     * @param index     Data item's index
     */
    LineSeries.prototype.setInitialWorkingValues = function (dataItem) {
        // this makes data items animate when added
        var yAxis = this._yAxis.get();
        var xAxis = this._xAxis.get();
        if (this.appeared && this.visible) {
            var previousDataItem = this.dataItems.getIndex(dataItem.index - 1);
            dataItem.component = this; // as these values are set before, we don't know component yet
            if (this.baseAxis == xAxis) {
                if (yAxis instanceof ValueAxis_ValueAxis) {
                    var initialY = yAxis.minZoomed;
                    if (previousDataItem) {
                        initialY = previousDataItem.values["valueY"].workingValue;
                    }
                    // this makes line animate from previous point to newly added point
                    dataItem.setWorkingValue("valueY", initialY, 0);
                    dataItem.setWorkingValue("valueY", dataItem.values.valueY.value);
                    if (xAxis instanceof DateAxis_DateAxis) {
                        dataItem.setWorkingLocation("dateX", dataItem.locations.dateX - 1, 0); // instantly move it to previous
                        dataItem.setWorkingLocation("dateX", dataItem.locations.dateX); // animate to it's location
                    }
                    else if (xAxis instanceof DurationAxis_DurationAxis) {
                        if (previousDataItem) {
                            var value = dataItem.valueX;
                            dataItem.setWorkingValue("valueX", previousDataItem.valueX, 0); // instantly move it to previous
                            dataItem.setWorkingValue("valueX", value); // animate to new value
                        }
                    }
                }
            }
            if (this.baseAxis == yAxis) {
                if (xAxis instanceof ValueAxis_ValueAxis) {
                    var initialX = xAxis.minZoomed;
                    if (previousDataItem) {
                        initialX = previousDataItem.values["valueX"].workingValue;
                    }
                    dataItem.setWorkingValue("valueX", initialX, 0);
                    dataItem.setWorkingValue("valueX", dataItem.values.valueX.value);
                    if (yAxis instanceof DateAxis_DateAxis) {
                        dataItem.setWorkingLocation("dateY", dataItem.locations.dateX - 1, 0); // instantly move it to previous
                        dataItem.setWorkingLocation("dateY", dataItem.locations.dateY); // animate to it's location
                    }
                    else if (yAxis instanceof DurationAxis_DurationAxis) {
                        if (previousDataItem) {
                            var value = dataItem.valueY;
                            dataItem.setWorkingValue("valueY", previousDataItem.valueY, 0); // instantly move it to previous
                            dataItem.setWorkingValue("valueY", value); // animate to new value
                        }
                    }
                }
            }
        }
        else {
            if (this.baseAxis == xAxis) {
                if (yAxis instanceof ValueAxis_ValueAxis) {
                    if (xAxis instanceof DateAxis_DateAxis) {
                        dataItem.setWorkingLocation("dateX", dataItem.locations.dateX);
                    }
                    if (xAxis instanceof CategoryAxis_CategoryAxis) {
                        dataItem.setWorkingLocation("categoryX", dataItem.locations.categoryX);
                    }
                }
            }
            if (this.baseAxis == yAxis) {
                if (xAxis instanceof ValueAxis_ValueAxis) {
                    if (yAxis instanceof DateAxis_DateAxis) {
                        dataItem.setWorkingLocation("dateY", dataItem.locations.dateY);
                    }
                    if (yAxis instanceof CategoryAxis_CategoryAxis) {
                        dataItem.setWorkingLocation("categoryY", dataItem.locations.categoryY);
                    }
                }
            }
        }
    };
    /**
     * Updates corresponding legend data item with current values.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    LineSeries.prototype.updateLegendValue = function (dataItem, notRange) {
        _super.prototype.updateLegendValue.call(this, dataItem, notRange);
        //This is hack to save some methos, used to set tooltip color source only
        if (dataItem && dataItem.segment) {
            this.tooltipColorSource = dataItem.segment;
        }
    };
    /**
     * (Re)validates the whole series, effectively causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    LineSeries.prototype.validate = function () {
        var _this = this;
        _super.prototype.validate.call(this);
        if (this.xAxis && this.yAxis) {
            this._segmentsIterator.reset();
            this.openSegmentWrapper(this._adjustedStartIndex);
            Iterator_each(this.axisRanges.iterator(), function (range) {
                _this.openSegmentWrapper(_this._adjustedStartIndex, range);
            });
            Iterator_each(this._segmentsIterator.iterator(), function (segment) {
                segment.__disabled = true;
            });
        }
    };
    /**
     * [sliceData description]
     *
     * @todo Description
     */
    LineSeries.prototype.sliceData = function () {
        var startIndex = this.startIndex;
        var endIndex = this.endIndex;
        // we need extra one item to both sides with values for line series, otherwise the line will not continue out of bounds of the chart while scrolling
        // find first to the left
        // TODO use iterator instead
        for (var i = this.startIndex - 1; i >= 0; i--) {
            var dataItem = this.dataItems.getIndex(i);
            if (dataItem && dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {
                startIndex = i;
                break;
            }
        }
        this._adjustedStartIndex = this.findAdjustedIndex(startIndex, ["stroke", "strokeWidth", "strokeDasharray", "strokeOpacity", "fill", "fillOpacity", "opacity"]);
        // find first to the right
        // TODO use iterator instead
        for (var i = this.endIndex, len = this.dataItems.length; i < len; i++) {
            var dataItem = this.dataItems.getIndex(i);
            if (dataItem && dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {
                endIndex = i + 1;
                break;
            }
        }
        this._workingStartIndex = startIndex;
        this._workingEndIndex = endIndex;
    };
    /**
     * @ignore
     */
    LineSeries.prototype.findAdjustedIndex = function (adjustedIndex, properties) {
        var _this = this;
        var propertyFields = this.propertyFields;
        var startIndex = adjustedIndex;
        each(properties, function (property) {
            if (hasValue(propertyFields[property])) {
                for (var i = startIndex; i >= 0; i--) {
                    var dataItem = _this.dataItems.getIndex(i);
                    if (dataItem) {
                        if (hasValue(dataItem.properties[property])) {
                            if (adjustedIndex > i) {
                                adjustedIndex = i;
                            }
                            break;
                        }
                    }
                }
            }
        });
        return adjustedIndex;
    };
    /**
     * Wraps openSegment call with iterative solution to prevent stack overflow
     *
     * @param openIndex  Index
     * @param axisRange  Range
     */
    LineSeries.prototype.openSegmentWrapper = function (openIndex, axisRange) {
        var params = {
            "index": openIndex,
            "axisRange": axisRange
        };
        do {
            params = this.openSegment(params.index, params.axisRange);
        } while (params);
    };
    LineSeries.prototype.getSegment = function () {
        var segment = this._segmentsIterator.getFirst();
        if (segment.isDisposed()) {
            this.segments.removeValue(segment);
            return this.getSegment();
        }
        return segment;
    };
    /**
     * [openSegment description]
     *
     * @todo Description
     * @param openIndex  [description]
     * @param axisRange  [description]
     */
    LineSeries.prototype.openSegment = function (openIndex, axisRange) {
        var addToClose = false;
        var points = [];
        openIndex = Math.min(openIndex, this.dataItems.length);
        var endIndex = Math.min(this._workingEndIndex, this.dataItems.length);
        this._workingEndIndex = Math.min(this._workingEndIndex, this.dataItems.length);
        var closeIndex;
        var propertiesChanged = false;
        var segment = this.getSegment();
        segment.__disabled = false;
        if (axisRange) {
            segment.parent = axisRange.contents;
            copyProperties(axisRange.contents, segment, visualProperties);
        }
        else {
            copyProperties(this, segment, visualProperties);
            segment.filters.clear();
            segment.parent = this.segmentsContainer;
        }
        this.group.node.removeAttribute("fill");
        var connect = this.connect;
        var valuesFound = false; // some flag to avoid multiple closes if no values found
        for (var i = openIndex; i < endIndex; i++) {
            var dataItem = this.dataItems.getIndex(i);
            dataItem.segment = segment;
            if (dataItem.hasProperties) {
                // if this is first item of segment
                if (i == openIndex) {
                    this.updateSegmentProperties(dataItem.properties, segment);
                }
                else {
                    // this time we only need to know if properties changed, so we don't pass segment
                    propertiesChanged = this.updateSegmentProperties(dataItem.properties, segment, true);
                }
            }
            if (dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) {
                this.addPoints(points, dataItem, this.xField, this.yField);
                valuesFound = true;
            }
            else {
                // if no values in first data item, go to next
                if (i == openIndex) {
                    continue;
                }
                else {
                    // stop cycle
                    if (!connect && valuesFound) {
                        closeIndex = i;
                        break;
                    }
                }
            }
            closeIndex = i;
            if (this.baseAxis instanceof DateAxis_DateAxis) {
                var next = this.dataItems.getIndex(i + 1);
                if (next && this.baseAxis.makeGap(next, dataItem)) {
                    addToClose = true;
                    break;
                }
            }
            if (propertiesChanged) {
                break;
            }
        }
        return this.closeSegment(segment, points, openIndex, closeIndex, axisRange, addToClose);
    };
    /**
     * [addPoints description]
     *
     * @todo Description
     * @param points    [description]
     * @param dataItem  [description]
     * @param xField    [description]
     * @param yField    [description]
     * @param backwards [description]
     */
    LineSeries.prototype.addPoints = function (points, dataItem, xField, yField, backwards) {
        var point = this.getPoint(dataItem, xField, yField, dataItem.workingLocations[xField], dataItem.workingLocations[yField]);
        if (!backwards) {
            dataItem.point = point;
        }
        points.push(point);
    };
    /**
     * [closeSegment description]
     *
     * @todo Description
     * @param segment    [description]
     * @param points     [description]
     * @param openIndex  [description]
     * @param closeIndex [description]
     * @param axisRange  [description]
     */
    LineSeries.prototype.closeSegment = function (segment, points, openIndex, closeIndex, axisRange, add) {
        var closePoints = [];
        if (this.dataFields[this._xOpenField] ||
            this.dataFields[this._yOpenField] ||
            this.stacked) {
            for (var i = closeIndex; i >= openIndex; i--) {
                var dataItem = this.dataItems.getIndex(i);
                if (dataItem.hasValue(this._xValueFields) && dataItem.hasValue(this._yValueFields)) { // not sure, this means that open point will only be added if value is also set for this point, but maybe it's ok.
                    this.addPoints(closePoints, dataItem, this.xOpenField, this.yOpenField, true);
                }
            }
        }
        else {
            var baseAxis = this.baseAxis;
            var count = points.length;
            var xAxis = this.xAxis;
            var yAxis = this.yAxis;
            if (count > 0) {
                if (baseAxis == xAxis) {
                    closePoints.push({ x: points[count - 1].x, y: yAxis.basePoint.y }); // last x
                    closePoints.push({ x: points[0].x, y: yAxis.basePoint.y }); // first x
                }
                else {
                    closePoints.push({ x: xAxis.basePoint.x, y: points[count - 1].y }); // last y
                    closePoints.push({ x: xAxis.basePoint.x, y: points[0].y }); // first y
                }
            }
        }
        this.drawSegment(segment, points, closePoints);
        if (add) {
            closeIndex++;
        }
        if (closeIndex < this._workingEndIndex - 1) {
            return { "index": closeIndex, "axisRange": axisRange };
        }
        else {
            return null;
        }
    };
    /**
     * Draws the line segment.
     *
     * @param segment     Segment
     * @param points      Segment points
     * @param closePoints Segment close points
     */
    LineSeries.prototype.drawSegment = function (segment, points, closePoints) {
        segment.drawSegment(points, closePoints, this.tensionX, this.tensionY);
    };
    /**
     * Segement will get its colors from `this.dataItem`, as thats how
     * `getPropertyValue()` method works.
     *
     * We pass `lineSeriesDataItem.properties` as item here each time when a flag
     * `hasProperties` is set to `true` on data item (this means it can contain
     * some properties set).
     *
     * @param itemProperties  Item properties
     * @param segment         Segment
     * @return Properties changed?
     */
    LineSeries.prototype.updateSegmentProperties = function (itemProperties, segment, checkOnly) {
        var changed = false;
        Object_each(itemProperties, function (propertyName, value) {
            // some value must be defined
            if (hasValue(value)) {
                var currentValue = segment[propertyName];
                var currentValueStr = void 0;
                // current value can be Color, number, anything. So we check if it has toString, otherwise just do String().
                // toString() will return hex if it's color. The only problem is that it will return lowercased hex and if we have uppercase in data, it will think that it changed
                if (currentValue) {
                    if (currentValue.toString) {
                        currentValueStr = currentValue.toString();
                    }
                    else {
                        currentValueStr = currentValue; // not doing String(currentValue) as this will make all Objects the same
                    }
                }
                var valueStr = void 0;
                if (value) {
                    if (value.toString) {
                        valueStr = value.toString();
                    }
                    else {
                        valueStr = value; // not doing String(currentValue) as this will make all Objects the same
                    }
                }
                if (currentValue == value || (currentValueStr != undefined && valueStr != undefined && currentValueStr == valueStr)) {
                    // void
                }
                else {
                    if (!checkOnly) {
                        segment[propertyName] = value;
                    }
                    changed = true;
                }
            }
        });
        return changed;
    };
    Object.defineProperty(LineSeries.prototype, "connect", {
        /**
         * @return Connect?
         */
        get: function () {
            return this.getPropertyValue("connect");
        },
        /**
         * Connect the lines over empty data points?
         *
         * If set to `true` the line will connect two adjacent data points by a
         * straight line. Even if there are data points with missing values
         * in-between.
         *
         * If you set this to `false`, the line will break when there are missing
         * values.
         *
         * @see {@link https://www.amcharts.com/docs/v4/chart-types/xy-chart/#Line_series_with_gaps} for more information about this feature
         * @default true
         * @param value  Connect?
         */
        set: function (value) {
            if (this.setPropertyValue("connect", value)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSeries.prototype, "tensionX", {
        /**
         * @return Horizontal tension (0-1)
         */
        get: function () {
            return this.getPropertyValue("tensionX");
        },
        /**
         * Horizontal tension setting of the line (0-1).
         *
         * Can be used to create smoothed lines. It works like this:
         *
         * Accepted values are in the range between 0 and 1. The biggest value (1)
         * will mean that the "tension" is very high, so the line is maximally
         * attracted to the points it connects, hence the straight line.
         *
         * Using smaller numbers will "relax" the tension, creating some curving.
         *
         * The smaller the tension setting, the more relaxed the line and the more
         * wide the curve.
         *
         * This setting is for horizontal tension, meaning the curve will bend in
         * such way that it never goes below or above connecting points. To enable
         * vertical bending as well, use `tensionY`.
         *
         * IMPORTANT: line smoothing works best when data items are placed at regular
         * intervals. For setups where data items are spaced erratically, enabling
         * smoothing might result in awkwardly looking lines.
         *
         * @default 1
         * @param value  Horizontal tension (0-1)
         */
        set: function (value) {
            this.setPropertyValue("tensionX", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSeries.prototype, "tensionY", {
        /**
         * @return Vertical tension (0-1)
         */
        get: function () {
            return this.getPropertyValue("tensionY");
        },
        /**
         * Can be used to create smoothed lines. It works like this:
         *
         * Accepted values are in the range between 0 and 1. The biggest value (1)
         * will mean that the "tension" is very high, so the line is maximally
         * attracted to the points it connects, hence the straight line.
         *
         * Using smaller numbers will "relax" the tension, creating some curving.
         *
         * The smaller the tension setting, the more relaxed the line and the more
         * wide the curve.
         *
         * This setting is for vertical tension, meaning the curve might bend in
         * such way that it will go below or above connected points.
         *
         * Combine this setting with `tensionX` to create beautifully looking
         * smoothed line series.
         *
         * @default 1
         * @param value  Vertical tension (0-1)
         */
        set: function (value) {
            this.setPropertyValue("tensionY", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates elements in related legend container, that mimics the look of this
     * Series.
     *
     * @ignore Exclude from docs
     * @param marker  Legend item container
     */
    LineSeries.prototype.createLegendMarker = function (marker) {
        var _this = this;
        var w = marker.pixelWidth;
        var h = marker.pixelHeight;
        marker.disposeChildren();
        var line = marker.createChild(Line_Line);
        line.shouldClone = false;
        //line.copyFrom(<any>this); coppies events which is not good
        copyProperties(this, line, visualProperties);
        line.x2 = w;
        line.y = h / 2;
        line.y2 = 0.00001;
        line.visible = true;
        if (this.fillOpacity > 0) {
            var fill = marker.createChild(Rectangle_Rectangle);
            //fill.copyFrom(<any>this); coppies events which is not good
            copyProperties(this, fill, visualProperties);
            fill.width = w;
            fill.height = h;
            fill.y = 0;
            fill.strokeOpacity = 0;
            fill.visible = true;
            line.y = 0;
        }
        var legendDataItem = marker.dataItem;
        legendDataItem.color = this.stroke;
        legendDataItem.colorOrig = this.fill;
        Iterator_eachContinue(this.bullets.iterator(), function (bullet) {
            if ((bullet instanceof Bullet_Bullet) && !bullet.copyToLegendMarker) {
                return false;
            }
            var hasLabels = false;
            if (bullet instanceof Container_Container) {
                // do not copy bullets with labels
                Iterator_each(bullet.children.iterator(), function (child) {
                    if (child instanceof Label_Label) {
                        hasLabels = true;
                        return true;
                    }
                });
            }
            if (!hasLabels) {
                var clone = bullet.clone();
                clone.parent = marker;
                clone.isMeasured = true;
                clone.tooltipText = undefined;
                clone.x = w / 2;
                if (_this.fillOpacity > 0) {
                    clone.y = 0;
                }
                else {
                    clone.y = h / 2;
                }
                clone.visible = true;
                // otherwise will not transit to color after hiding
                if (!hasValue(clone.fill)) {
                    clone.fill = _this.fill;
                }
                if (!hasValue(clone.stroke)) {
                    clone.stroke = _this.stroke;
                }
                return false;
            }
        });
    };
    /**
     * @ignore
     */
    LineSeries.prototype.disposeData = function () {
        _super.prototype.disposeData.call(this);
        this.segments.clear();
    };
    Object.defineProperty(LineSeries.prototype, "autoGapCount", {
        /**
         * @return Gap count
         */
        get: function () {
            return this.getPropertyValue("autoGapCount");
        },
        /**
         * If `connect = false` and distance between two data points is bigger
         * than `baseInterval * autoGapCount`, a line will break automatically.
         *
         * @since 4.2.4
         * @param  value  Gap count
         */
        set: function (value) {
            this.setPropertyValue("autoGapCount", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return LineSeries;
}(XYSeries_XYSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["LineSeries"] = LineSeries_LineSeries;
registry.registeredClasses["LineSeriesDataItem"] = LineSeries_LineSeriesDataItem;
//# sourceMappingURL=LineSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/RadarSeries.js
/**
 * Radar series module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




//import { AxisRendererCircular } from "../axes/AxisRendererCircular";
//import { Sprite } from "../../core/Sprite";
/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[RadarSeries]].
 *
 * @see {@link DataItem}
 */
var RadarSeries_RadarSeriesDataItem = /** @class */ (function (_super) {
    __extends(RadarSeriesDataItem, _super);
    /**
     * Constructor
     */
    function RadarSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "RadarSeriesDataItem";
        _this.setLocation("dateX", 0, 0);
        _this.setLocation("dateY", 0, 0);
        _this.setLocation("categoryX", 0, 0);
        _this.setLocation("categoryY", 0, 0);
        _this.applyTheme();
        return _this;
    }
    return RadarSeriesDataItem;
}(LineSeries_LineSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a radar graph.
 *
 * @see {@link IRadarSeriesEvents} for a list of available Events
 * @see {@link IRadarSeriesAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var RadarSeries_RadarSeries = /** @class */ (function (_super) {
    __extends(RadarSeries, _super);
    /**
     * Constructor
     */
    function RadarSeries() {
        var _this = _super.call(this) || this;
        _this.className = "RadarSeries";
        _this.connectEnds = true;
        _this.applyTheme();
        return _this;
    }
    /**
     * (Re)validates the whole series, effectively causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    RadarSeries.prototype.validate = function () {
        // so that radius would be updated
        if (this.chart.invalid) {
            this.chart.validate();
        }
        _super.prototype.validate.call(this);
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    RadarSeries.prototype.createDataItem = function () {
        return new RadarSeries_RadarSeriesDataItem();
    };
    /**
     * Returns an [[IPoint]] coordinates of the specific Serie's data point.
     *
     * @param    dataItem   Data item
     * @param    xKey       Name of X data field
     * @param    yKey       Name of Y data field
     * @param    locationX  X location
     * @param    locationY  Y location
     * @param    stackKeyX  ?
     * @param    stackKeyY  ?
     * @returns             Coordinates
     */
    RadarSeries.prototype.getPoint = function (dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {
        if (!stackKeyX) {
            stackKeyX = "valueX";
        }
        if (!stackKeyY) {
            stackKeyY = "valueY";
        }
        var x = this.yAxis.getX(dataItem, yKey, locationY, stackKeyY);
        var y = this.yAxis.getY(dataItem, yKey, locationY, stackKeyY);
        var radius = getDistance({ x: x, y: y });
        // hack to be able to determine angle later
        if (radius == 0) {
            radius = 0.00001;
        }
        var angle = this.xAxis.getAngle(dataItem, xKey, locationX, stackKeyX);
        var startAngle = this.chart.startAngle;
        var endAngle = this.chart.endAngle;
        //		angle = $math.fitToRange(angle, startAngle, endAngle);
        if (angle < startAngle || angle > endAngle) {
            return undefined;
        }
        else {
            return { x: radius * Math_cos(angle), y: radius * Math_sin(angle) };
        }
    };
    /**
     * [addPoints description]
     *
     * @todo Description
     * @param points    [description]
     * @param dataItem  [description]
     * @param xField    [description]
     * @param yField    [description]
     * @param backwards [description]
     */
    RadarSeries.prototype.addPoints = function (points, dataItem, xField, yField, backwards) {
        var point = this.getPoint(dataItem, xField, yField, dataItem.locations[xField], dataItem.locations[yField]);
        if (point) {
            points.push(point);
        }
    };
    /**
     * Returns an SVG path to be used as a mask for the series.
     *
     * @return SVG path
     */
    RadarSeries.prototype.getMaskPath = function () {
        var renderer = this.yAxis.renderer;
        return Path_arc(renderer.startAngle, renderer.endAngle - renderer.startAngle, renderer.pixelRadius, renderer.pixelInnerRadius);
    };
    /**
     * [drawSegment description]
     *
     * @todo Description
     * @param segment      [description]
     * @param points       [description]
     * @param closePoints  [description]
     */
    RadarSeries.prototype.drawSegment = function (segment, points, closePoints) {
        var axis = this.yAxis;
        var renderer = axis.renderer;
        if (this.connectEnds && Math.abs(renderer.endAngle - renderer.startAngle) == 360) {
            // adds one point to the beginning of closePoints array, if needed
            if (this.dataFields[this._xOpenField] ||
                this.dataFields[this._yOpenField] ||
                this.stacked) {
                points.push(points[0]);
                if (closePoints.length > 0) {
                    closePoints.unshift(closePoints[closePoints.length - 1]);
                }
            }
        }
        _super.prototype.drawSegment.call(this, segment, points, closePoints);
    };
    Object.defineProperty(RadarSeries.prototype, "connectEnds", {
        /**
         * @return Connect?
         */
        get: function () {
            return this.getPropertyValue("connectEnds");
        },
        /**
         * Should the last and and first data points be connected, forming a complete
         * closed circle?
         *
         * @default true
         * @param value  Connect?
         */
        set: function (value) {
            this.setPropertyValue("connectEnds", value, true);
        },
        enumerable: true,
        configurable: true
    });
    RadarSeries.prototype.positionBulletReal = function (bullet, positionX, positionY) {
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (positionX < xAxis.start || positionX > xAxis.end || positionY < yAxis.start || positionY > yAxis.end) {
            bullet.visible = false;
        }
        bullet.moveTo(this.xAxis.renderer.positionToPoint(positionX, positionY));
    };
    RadarSeries.prototype.setXAxis = function (axis) {
        _super.prototype.setXAxis.call(this, axis);
        this.updateRendererRefs();
    };
    RadarSeries.prototype.setYAxis = function (axis) {
        _super.prototype.setYAxis.call(this, axis);
        this.updateRendererRefs();
    };
    RadarSeries.prototype.updateRendererRefs = function () {
        var rendererX = this.xAxis.renderer;
        var rendererY = this.yAxis.renderer;
        rendererX.axisRendererY = rendererY;
    };
    return RadarSeries;
}(LineSeries_LineSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["RadarSeries"] = RadarSeries_RadarSeries;
registry.registeredClasses["RadarSeriesDataItem"] = RadarSeries_RadarSeriesDataItem;
//# sourceMappingURL=RadarSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisFillCircular.js

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Provides fill element functionality for circular Axes.
 *
 * @see {@link IAxisFillCircularEvents} for a list of available events
 * @see {@link IAxisFillCircularAdapters} for a list of available Adapters
 * @todo Needs description
 */
var AxisFillCircular_AxisFillCircular = /** @class */ (function (_super) {
    __extends(AxisFillCircular, _super);
    /**
     * Constructor.
     *
     * @param axis Axis
     */
    function AxisFillCircular(axis) {
        var _this = _super.call(this, axis) || this;
        _this.className = "AxisFillCircular";
        _this.element = _this.paper.add("path");
        _this.radius = Percent_percent(100);
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the fill element.
     *
     * @ignore Exclude from docs
     */
    AxisFillCircular.prototype.draw = function () {
        _super.prototype.draw.call(this);
        if (this.__disabled || this.disabled) {
            return;
        }
        if (this.axis) {
            var renderer = this.axis.renderer;
            this.fillPath = renderer.getPositionRangePath(this.startPosition, this.endPosition, this.radius, hasValue(this.innerRadius) ? this.innerRadius : renderer.innerRadius, this.cornerRadius);
            this.path = this.fillPath;
        }
    };
    Object.defineProperty(AxisFillCircular.prototype, "innerRadius", {
        /**
         * @return Inner radius
         */
        get: function () {
            return this.getPropertyValue("innerRadius");
        },
        /**
         * Inner radius of the fill. Relative ([[Percent]]) or absolute (pixels).
         *
         * @param value  Inner radius
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisFillCircular.prototype, "radius", {
        /**
         * @return Outer radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Outer radius of the fill. Relative ([[Percent]]) or absolute (pixels).
         *
         * @param value  Outer radius
         */
        set: function (value) {
            this.setPercentProperty("radius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisFillCircular.prototype, "cornerRadius", {
        /**
         * @return Corner radius (px)
         */
        get: function () {
            return this.getPropertyValue("cornerRadius");
        },
        /**
         * Corner radius for the fill. In pixels.
         *
         * @param value  Corner radius (px)
         */
        set: function (value) {
            this.setPropertyValue("cornerRadius", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return AxisFillCircular;
}(AxisFill_AxisFill));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisFillCircular"] = AxisFillCircular_AxisFillCircular;
//# sourceMappingURL=AxisFillCircular.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/GridCircular.js
/**
 * A module defining functionality for circular axis grid elements.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a circular grid element for circular-type axis.
 *
 * @see {@link IGridCircularEvents} for a list of available events
 * @see {@link IGridCircularAdapters} for a list of available Adapters
 * @todo Review: container is better, as we'll be able to attach something to the GridCircular, also with 3d charts we might need some additional elements
 */
var GridCircular_GridCircular = /** @class */ (function (_super) {
    __extends(GridCircular, _super);
    /**
     * Constructor
     */
    function GridCircular() {
        var _this = _super.call(this) || this;
        _this.className = "GridCircular";
        _this.pixelPerfect = false;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(GridCircular.prototype, "innerRadius", {
        /**
         * @return Inner radius
         */
        get: function () {
            return this.getPropertyValue("innerRadius");
        },
        /**
         * Inner radius of the circular grid. (absolute or relative)
         *
         * @param value Inner radius
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GridCircular.prototype, "radius", {
        /**
         * @return Outer radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Outer radius of the circular grid. (absolute or relative)
         *
         * @param value Outer radius
         */
        set: function (value) {
            this.setPercentProperty("radius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    return GridCircular;
}(Grid_Grid));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["GridCircular"] = GridCircular_GridCircular;
//# sourceMappingURL=GridCircular.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisLabelCircular.js
/**
 * Axis Label module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Use to create labels on circular axis.
 *
 * @see {@link IAxisLabelCircularEvents} for a list of available events
 * @see {@link IAxisLabelCircularAdapters} for a list of available Adapters
 */
var AxisLabelCircular_AxisLabelCircular = /** @class */ (function (_super) {
    __extends(AxisLabelCircular, _super);
    /**
     * Constructor
     */
    function AxisLabelCircular() {
        var _this = _super.call(this) || this;
        /**
         *
         * @ignore
         */
        _this.fdx = 0;
        /**
         *
         * @ignore
         */
        _this.fdy = 0;
        _this.className = "AxisLabelCircular";
        _this.padding(0, 0, 0, 0);
        _this.location = 0.5;
        _this.locationOnPath = 0.5;
        _this.radius = 0;
        _this.isMeasured = false;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(AxisLabelCircular.prototype, "relativeRotation", {
        /**
         * @return Rotation angle
         */
        get: function () {
            return this.getPropertyValue("relativeRotation");
        },
        /**
         * Relative rotation of the label.
         *
         * It is an angle to circle. In case 90, labels will be positioned like rays
         * of light, if 0 - positioned along the circle.
         *
         * @param value Rotation angle
         */
        set: function (value) {
            this.setPropertyValue("relativeRotation", value, true);
            if (!hasValue(value)) {
                this.rotation = undefined;
                var dataItem = this.dataItem;
                if (dataItem && dataItem.component) {
                    dataItem.component.invalidateDataItems();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisLabelCircular.prototype, "radius", {
        /**
         * @return Distance (px)
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Distance from axis circle to label in pixels or percent.
         *
         * @param value Distance (px or percent)
         */
        set: function (value) {
            this.setPercentProperty("radius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisLabelCircular.prototype, "bent", {
        /**
         * @return Bent?
         */
        get: function () {
            return this.getPropertyValue("bent");
        },
        /**
         * Specifies if label should be bent along the circle.
         *
         * IMPORTANT: Use this with caution, since it is quite CPU-greedy.
         *
         * @since 4.1.2
         * @default false
         * @param  value  Bent?
         */
        set: function (value) {
            this.setPropertyValue("bent", value, true);
            this.setPropertyValue("wrap", false);
            this.setPropertyValue("horizontalCenter", "none");
            this.setPropertyValue("verticalCenter", "none");
            if (value) {
                this.setPropertyValue("dx", 0);
                this.setPropertyValue("dy", 0);
                this.setPropertyValue("x", 0);
                this.setPropertyValue("y", 0);
                this.setPropertyValue("rotation", 0);
                //this.setPropertyValue("relativeRotation", undefined);
                this.fdx = 0;
                this.fdy = 0;
                this.textAlign = "middle";
            }
            else {
                if (this.textPathElement) {
                    this.textPathElement.dispose();
                    this.textPathElement = undefined;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns label radius in pixels.
     *
     * @param   axisRadius  Radius
     * @return              Pixel radius
     */
    AxisLabelCircular.prototype.pixelRadius = function (axisRadius) {
        var sign = 1;
        if (this.inside) {
            sign = -1;
        }
        return relativeToValue(this.radius, axisRadius) * sign;
    };
    /**
     * Returns label horizontal radius in pixels.
     *
     * @param   axisRadius   Radius
     * @param   axisRadiusY  Vertical radius
     * @return               Radius
     */
    AxisLabelCircular.prototype.pixelRadiusY = function (axisRadius, axisRadiusY) {
        var sign = 1;
        if (this.inside) {
            sign = -1;
        }
        var radius = this.radius;
        if (isNumber(radius)) {
            radius *= axisRadiusY / axisRadius;
            return relativeToValue(radius, axisRadius) * sign;
        }
        else {
            return relativeToValue(radius, axisRadiusY) * sign;
        }
    };
    /**
     * [fixPosition description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param point       Label affixation point
     * @param axisRadius  Distance from point (px)
     */
    AxisLabelCircular.prototype.fixPosition = function (angle, axisRadius, axisRadiusY, dx, dy) {
        if (!isNumber(axisRadiusY)) {
            axisRadiusY = axisRadius;
        }
        if (!isNumber(dx)) {
            dx = 0;
        }
        if (!isNumber(dy)) {
            dy = 0;
        }
        var point = { x: axisRadius * Math_cos(angle), y: axisRadiusY * Math_sin(angle) };
        if (this.invalid) {
            this.validate(); //@todo" check if we need this
        }
        var isNegative = false;
        var realRadius = this.radius;
        if (realRadius instanceof Percent && realRadius.value < 0) {
            isNegative = true;
        }
        else if (realRadius < 0) {
            isNegative = true;
        }
        var relativeRotation = this.relativeRotation;
        var labelRadius = this.pixelRadius(axisRadius);
        if (this.bent) {
            var point_1 = { x: (axisRadius + labelRadius) * Math_cos(angle + 180), y: (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * Math_sin(angle + 180) };
            this.path = moveTo(point_1) + arcTo(angle + 180, 360, axisRadius + labelRadius, axisRadiusY + labelRadius * axisRadiusY / axisRadius);
            if (this.textPathElement) {
                this.textPathElement.attr({ "startOffset": (this.locationOnPath * 100) + "%" });
            }
            return;
        }
        // WHEN ROTATED
        if (isNumber(relativeRotation)) {
            this.horizontalCenter = "none";
            this.verticalCenter = "none";
            angle = fitAngleToRange(angle, -180, 180);
            var pixelWidth = this.bbox.width;
            var pixelHeight = this.bbox.height;
            var pixelPaddingBottom = this.pixelPaddingBottom;
            var pixelPaddingTop = this.pixelPaddingTop;
            var pixelPaddingLeft = this.pixelPaddingLeft;
            var pixelPaddingRight = this.pixelPaddingRight;
            if (angle > 90 || angle < -90) {
                if (relativeRotation == -90) {
                    relativeRotation = 90;
                    pixelWidth = 0;
                }
            }
            else {
                if (relativeRotation == -90) {
                    pixelHeight = -pixelHeight;
                }
                if (relativeRotation == 90) {
                    relativeRotation = -90;
                    pixelWidth = -pixelPaddingLeft - pixelPaddingRight;
                    pixelHeight = -pixelHeight - pixelPaddingTop - pixelPaddingBottom;
                }
            }
            this.rotation = relativeRotation + angle + 90;
            var dH = Math_sin(relativeRotation) / 2;
            var dW = Math_cos(relativeRotation) / 2;
            var rotation = this.rotation;
            this.dx = pixelHeight * dH * Math_sin(rotation) - pixelWidth * dW * Math_cos(rotation);
            this.dy = -pixelHeight * dH * Math_cos(rotation) - pixelWidth * dW * Math_sin(rotation);
            if (!this.inside) {
                labelRadius += (pixelHeight + pixelPaddingBottom + pixelPaddingTop) * Math_cos(relativeRotation) + (pixelWidth + pixelPaddingLeft + pixelPaddingRight) * Math_sin(relativeRotation);
            }
            else {
                if (angle > 90 || angle < -90) {
                    labelRadius -= (pixelPaddingBottom + pixelPaddingTop) * Math_cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight) * Math_sin(relativeRotation);
                }
                else {
                    labelRadius += (pixelPaddingBottom + this.bbox.height + pixelPaddingTop) * Math_cos(relativeRotation) + (pixelPaddingLeft + pixelPaddingRight + this.bbox.width) * Math_sin(relativeRotation);
                }
            }
            point.x += Math_cos(angle) * labelRadius;
            point.y += Math_sin(angle) * labelRadius * axisRadiusY / axisRadius;
        }
        else {
            // END OF ROTATED
            this.horizontalCenter = "middle";
            this.verticalCenter = "middle";
            if (isNegative) {
                this.dx = 0;
                this.dy = 0;
                point.x = (axisRadius + labelRadius) * Math_cos(angle);
                point.y = (axisRadiusY + labelRadius * axisRadiusY / axisRadius) * Math_sin(angle);
            }
            else {
                // we don't use valign for labels because then they would jump while animating. instead we modify dy depending on a y position
                // this math makes dy to be 1 at the top of the circle, 0.5 at the middle and 1 at the bottom
                // @todo with this math doesn't work well with inside = true
                this.dy = this._measuredHeight / 2 * Math_sin(angle); //(1 - (point.y + axisRadiusY) / (2 * axisRadiusY));
                // simmilar with dx
                this.dx = this._measuredWidth / 2 * Math_cos(angle); //(1 - (point.x + axisRadius) / (2 * axisRadius));
                point.x += Math_cos(angle) * labelRadius;
                point.y += Math_sin(angle) * labelRadius * axisRadiusY / axisRadius;
            }
        }
        point.x += dx;
        point.y += dy;
        this.fdx = this.dx;
        this.fdy = this.dy;
        this.moveTo(point);
    };
    return AxisLabelCircular;
}(AxisLabel_AxisLabel));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisLabelCircular"] = AxisLabelCircular_AxisLabelCircular;
//# sourceMappingURL=AxisLabelCircular.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererCircular.js
/**
 * Module, defining Axis Renderer for circular axes.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */











/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A renderer for circular axis.
 */
var AxisRendererCircular_AxisRendererCircular = /** @class */ (function (_super) {
    __extends(AxisRendererCircular, _super);
    /**
     * Constructor.
     *
     * @param axis Related axis
     */
    function AxisRendererCircular() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * @ignore
         */
        _this.pixelRadiusReal = 0;
        // axis.layout = "none"; // does not trigger redraw when size changes
        _this.layout = "none";
        _this.className = "AxisRendererCircular";
        _this.isMeasured = false;
        _this.startAngle = -90;
        _this.endAngle = 270;
        _this.useChartAngles = true;
        _this.radius = Percent_percent(100);
        _this.isMeasured = false;
        _this.grid.template.location = 0;
        _this.labels.template.location = 0;
        _this.labels.template.radius = 15;
        _this.ticks.template.location = 0;
        _this.ticks.template.pixelPerfect = false;
        _this.tooltipLocation = 0;
        _this.line.strokeOpacity = 0;
        _this.applyTheme();
        return _this;
    }
    /**
    * @ignore
    */
    AxisRendererCircular.prototype.setAxis = function (axis) {
        var _this = this;
        _super.prototype.setAxis.call(this, axis);
        axis.isMeasured = false;
        // modify x and y so that tooltip would always be on circle
        var tooltip = axis.tooltip;
        tooltip.adapter.add("dx", function (x, target) {
            var point = svgPointToSprite({ x: target.pixelX, y: target.pixelY }, _this);
            return _this.pixelRadius * Math.cos(Math.atan2(point.y, point.x)) - point.x;
        });
        tooltip.adapter.add("dy", function (y, target) {
            var point = svgPointToSprite({ x: target.pixelX, y: target.pixelY }, _this);
            return _this.pixelRadius * Math.sin(Math.atan2(point.y, point.x)) - point.y;
        });
    };
    /**
     * Validates Axis renderer.
     *
     * @ignore Exclude from docs
     */
    AxisRendererCircular.prototype.validate = function () {
        // so that radius would be updated
        if (this.chart && this.chart.invalid) {
            this.chart.validate();
        }
        _super.prototype.validate.call(this);
    };
    Object.defineProperty(AxisRendererCircular.prototype, "axisLength", {
        /**
         * Returns actual length of the Axis, in pixels.
         *
         * @return Length (px)
         */
        get: function () {
            return 2 * Math.PI * this.pixelRadius;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererCircular.prototype, "radius", {
        /**
         * @return Outer radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Outer radius of the axis.
         *
         * Can be absolute (px) or relative ([[Percent]]).
         *
         * @param value  Outer radius
         */
        set: function (value) {
            if (this.setPercentProperty("radius", value, false, false, 10, false)) {
                if (this.axis) {
                    this.axis.invalidate();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererCircular.prototype, "pixelRadius", {
        /**
         * Outer radius in pixels.
         *
         * @return Outer radius (px)
         */
        get: function () {
            return relativeRadiusToValue(this.radius, this.pixelRadiusReal) || 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererCircular.prototype, "innerRadius", {
        /**
         * @return Inner radius
         */
        get: function () {
            var chart = this.chart;
            var innerRadius = this.getPropertyValue("innerRadius");
            if (!hasValue(innerRadius)) {
                innerRadius = chart.innerRadius;
                if (innerRadius instanceof Percent && chart) {
                    innerRadius = Percent_percent(innerRadius.value * chart.innerRadiusModifyer * 100);
                }
            }
            else {
                if (innerRadius instanceof Percent && chart) {
                    var mr = chart.mr;
                    var value = innerRadius.value;
                    value = Math.max(mr * value, mr - Math.min(chart.plotContainer.innerHeight, chart.plotContainer.innerWidth)) / mr;
                    innerRadius = Percent_percent(value * 100);
                }
            }
            return innerRadius;
        },
        /**
         * Inner radius of the axis.
         *
         * Can be absolute (px) or relative ([[Percent]]).
         *
         * @param value  Inner radius
         */
        set: function (value) {
            if (this.setPercentProperty("innerRadius", value, false, false, 10, false)) {
                if (this.axis) {
                    this.axis.invalidate();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererCircular.prototype, "useChartAngles", {
        /**
         * @return Use chart angles
         */
        get: function () {
            return this.getPropertyValue("useChartAngles");
        },
        /**
         * Specifies if axis should use its own `startAngle` and `endAngle` or
         * inherit them from relative properties from chart.
         *
         * @default false
         * @param value  Use chart's angles
         */
        set: function (value) {
            this.setPropertyValue("useChartAngles", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererCircular.prototype, "pixelInnerRadius", {
        /**
         * Inner radius in pixels.
         *
         * @return Inner radius (px)
         */
        get: function () {
            return relativeRadiusToValue(this.innerRadius, this.pixelRadiusReal) || 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts relative position on axis to point coordinates.
     *
     * @param position  Position (0-1)
     * @param position2  Position (0-1) Position on the second axis
     * @return Point
     */
    AxisRendererCircular.prototype.positionToPoint = function (position, position2) {
        if (!isNumber(position2)) {
            position2 = 1;
        }
        var coordinate = this.positionToCoordinate(position);
        var angle = this.startAngle + (this.endAngle - this.startAngle) * coordinate / this.axisLength;
        var radius = this.pixelRadius;
        var innerRadius = this.pixelInnerRadius;
        if (this.axisRendererY) {
            var realRadius = fitToRange(this.axisRendererY.positionToCoordinate(position2), 0, Infinity);
            var point = { x: realRadius * Math_cos(angle), y: realRadius * Math_sin(angle) };
            return point;
        }
        return { x: Math_cos(angle) * innerRadius + (radius - innerRadius) * Math_cos(angle) * position2, y: Math_sin(angle) * innerRadius + (radius - innerRadius) * Math_sin(angle) * position2 };
    };
    /**
     * Converts relative position (0-1) on axis to angle in degrees (0-360).
     *
     * @param position  Position (0-1)
     * @return Angle (0-360)
     */
    AxisRendererCircular.prototype.positionToAngle = function (position) {
        var axis = this.axis;
        var arc = (this.endAngle - this.startAngle) / (axis.end - axis.start);
        var angle;
        if (axis.renderer.inversed) {
            angle = this.startAngle + (axis.end - position) * arc;
        }
        else {
            angle = this.startAngle + (position - axis.start) * arc;
        }
        return Math_round(angle, 3);
    };
    /**
     * Converts angle on axis to relative position(0-1).
     *
     * @param angle Angle in degrees
     * @return Position (0-1)
     */
    AxisRendererCircular.prototype.angleToPosition = function (angle) {
        var axis = this.axis;
        var arc = (this.endAngle - this.startAngle) / (axis.end - axis.start);
        var position;
        if (axis.renderer.inversed) {
            position = axis.end - (angle - this.startAngle) / arc;
        }
        else {
            position = (angle - this.startAngle) / arc + axis.start;
        }
        return Math_round(position, 5);
    };
    /**
     * Updates and positions the axis line element.
     *
     * @ignore Exclude from docs
     */
    AxisRendererCircular.prototype.updateAxisLine = function () {
        var radius = this.pixelRadius;
        var startAngle = this.startAngle;
        var endAngle = this.endAngle;
        var arc = endAngle - startAngle;
        this.line.path = moveTo({ x: radius * Math_cos(startAngle), y: radius * Math_sin(startAngle) }) + arcTo(startAngle, arc, radius, radius);
    };
    /**
     * Updates and positions a grid element.
     *
     * @ignore Exclude from docs
     * @param grid         Grid element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererCircular.prototype.updateGridElement = function (grid, position, endPosition) {
        position = position + (endPosition - position) * grid.location;
        var point = this.positionToPoint(position);
        if (isNumber(point.x) && isNumber(point.y) && grid.element) {
            var angle = DEGREES * Math.atan2(point.y, point.x);
            var radius = relativeRadiusToValue(hasValue(grid.radius) ? grid.radius : Percent_percent(100), this.pixelRadius);
            var gridInnerRadius = relativeRadiusToValue(grid.innerRadius, this.pixelRadius);
            grid.zIndex = 0;
            var innerRadius = relativeRadiusToValue(isNumber(gridInnerRadius) ? gridInnerRadius : this.innerRadius, this.pixelRadiusReal, true);
            grid.path = moveTo({ x: innerRadius * Math_cos(angle), y: innerRadius * Math_sin(angle) }) + lineTo({ x: radius * Math_cos(angle), y: radius * Math_sin(angle) });
        }
        this.toggleVisibility(grid, position, 0, 1);
    };
    /**
     * Updates and positions a tick element.
     *
     * @ignore Exclude from docs
     * @param tick         Tick element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererCircular.prototype.updateTickElement = function (tick, position, endPosition) {
        position = position + (endPosition - position) * tick.location;
        var point = this.positionToPoint(position);
        if (tick.element) {
            var radius = this.pixelRadius;
            var angle = DEGREES * Math.atan2(point.y, point.x);
            var tickLength = tick.length;
            if (tick.inside) {
                tickLength = -tickLength;
            }
            tick.zIndex = 1;
            tick.path = moveTo({ x: radius * Math_cos(angle), y: radius * Math_sin(angle) }) + lineTo({ x: (radius + tickLength) * Math_cos(angle), y: (radius + tickLength) * Math_sin(angle) });
        }
        this.toggleVisibility(tick, position, 0, 1);
    };
    /**
     * Updates and positions axis bullet.
     *
     * @ignore Exclude from docs
     * @param bullet       AxisBullet element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererCircular.prototype.updateBullet = function (bullet, position, endPosition) {
        var location = 0.5;
        if (bullet instanceof AxisBullet_AxisBullet) {
            location = bullet.location;
        }
        position = position + (endPosition - position) * location;
        var point = this.positionToPoint(position);
        var radius = this.pixelRadius;
        var angle = DEGREES * Math.atan2(point.y, point.x);
        point = { x: radius * Math_cos(angle), y: radius * Math_sin(angle) };
        this.positionItem(bullet, point);
        this.toggleVisibility(bullet, position, 0, 1);
    };
    /**
     * Updates and positions a label element.
     *
     * @ignore Exclude from docs
     * @param label        Label element
     * @param position     Starting position
     * @param endPosition  Ending position
     */
    AxisRendererCircular.prototype.updateLabelElement = function (label, position, endPosition, location) {
        if (!hasValue(location)) {
            location = label.location;
        }
        position = position + (endPosition - position) * location;
        label.fixPosition(this.positionToAngle(position), this.pixelRadius);
        label.zIndex = 2;
        this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);
    };
    /**
     * Checks if point is within bounds of a container.
     *
     * @ignore Exclude from docs
     * @param point Point coordinates
     * @return Fits?
     */
    AxisRendererCircular.prototype.fitsToBounds = function (point) {
        return true;
    };
    Object.defineProperty(AxisRendererCircular.prototype, "startAngle", {
        /**
         * @return Start angle
         */
        get: function () {
            return this.getPropertyValue("startAngle");
        },
        /**
         * Start angle of the axis in degrees (0-360).
         *
         * @param value  Start angle
         */
        set: function (value) {
            // do not normalize angel here!
            if (this.setPropertyValue("startAngle", value)) {
                this.invalidateAxisItems();
                if (this.axis) {
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererCircular.prototype, "endAngle", {
        /**
         * @return End angle
         */
        get: function () {
            return this.getPropertyValue("endAngle");
        },
        /**
         * End angle of the axis in degrees (0-360).
         *
         * @param value  End angle
         */
        set: function (value) {
            // do not normalize angel here!
            if (this.setPropertyValue("endAngle", value)) {
                this.invalidateAxisItems();
                if (this.axis) {
                    this.axis.invalidateSeries();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * [getPositionRangePath description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param startPosition  Starting position
     * @param endPosition    End position
     * @return SVG path
     */
    AxisRendererCircular.prototype.getPositionRangePath = function (startPosition, endPosition, radius, innerRadius, cornerRadius) {
        var path = "";
        if (isNumber(startPosition) && isNumber(endPosition)) {
            if (!hasValue(radius)) {
                radius = this.radius;
            }
            startPosition = Math_max(startPosition, this.axis.start);
            endPosition = Math_min(endPosition, this.axis.end);
            if (endPosition < startPosition) {
                endPosition = startPosition;
            }
            var pixelRadius = relativeRadiusToValue(radius, this.pixelRadius);
            var pixelInnerRadius = relativeRadiusToValue(innerRadius, this.pixelRadius, true);
            var startAngle = this.positionToAngle(startPosition);
            var endAngle = this.positionToAngle(endPosition);
            var arc = endAngle - startAngle;
            path = Path_arc(startAngle, arc, pixelRadius, pixelInnerRadius, pixelRadius, cornerRadius);
        }
        return path;
    };
    /**
     * Returns a new grid element, suitable for this Axis Renderer type.
     *
     * @return Grid element
     */
    AxisRendererCircular.prototype.createGrid = function () {
        return new GridCircular_GridCircular();
    };
    /**
     * Returns a new fill element, suitable for this Axis Renderer type.
     *
     * @return Fill element
     */
    AxisRendererCircular.prototype.createFill = function (axis) {
        return new AxisFillCircular_AxisFillCircular(axis);
    };
    /**
     * Returns a new label element, suitable for this Axis Renderer type.
     *
     * @return Label element
     */
    AxisRendererCircular.prototype.createLabel = function () {
        return new AxisLabelCircular_AxisLabelCircular();
    };
    /**
     * Converts a point at specific coordinates to a relative position (0-1)
     * on the axis.
     *
     * @param point  Point
     * @return Position (0-1)
     */
    AxisRendererCircular.prototype.pointToPosition = function (point) {
        var angle = fitAngleToRange(getAngle(point), this.startAngle, this.endAngle);
        return this.coordinateToPosition((angle - this.startAngle) / 360 * this.axisLength);
    };
    return AxisRendererCircular;
}(AxisRenderer_AxisRenderer));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisRendererCircular"] = AxisRendererCircular_AxisRendererCircular;
//# sourceMappingURL=AxisRendererCircular.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererRadial.js
/**
 * Module, defining Axis Renderer for radial axes.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */











/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A renderer for radial axis.
 */
var AxisRendererRadial_AxisRendererRadial = /** @class */ (function (_super) {
    __extends(AxisRendererRadial, _super);
    /**
     * Constructor.
     *
     * @param axis Related axis
     */
    function AxisRendererRadial() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * A related chart.
         */
        _this._chart = new Disposer_MutableValueDisposer();
        /**
         * @ignore
         */
        _this.pixelRadiusReal = 0;
        _this.className = "AxisRendererRadial";
        _this.isMeasured = false;
        _this.startAngle = -90;
        _this.endAngle = 270;
        _this.minGridDistance = 30;
        _this.gridType = "circles";
        _this.axisAngle = -90;
        _this.isMeasured = false;
        _this.layout = "none";
        _this.radius = Percent_percent(100);
        _this.line.strokeOpacity = 0;
        _this.labels.template.horizontalCenter = "middle";
        _this._disposers.push(_this._chart);
        _this.applyTheme();
        return _this;
    }
    /**
     * Validates Axis renderer.
     *
     * @ignore Exclude from docs
     */
    AxisRendererRadial.prototype.validate = function () {
        // so that radius would be updated
        if (this.chart && this.chart.invalid) {
            this.chart.validate();
        }
        _super.prototype.validate.call(this);
    };
    Object.defineProperty(AxisRendererRadial.prototype, "axisLength", {
        /**
         * Returns actual length of the Axis, in pixels.
         *
         * @return Length (px)
         */
        get: function () {
            return this.pixelRadius - this.pixelInnerRadius;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererRadial.prototype, "radius", {
        /**
         * @return Outer radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Outer radius of the axis.
         *
         * Can be absolute (px) or relative ([[Percent]]).
         *
         * @param value  Outer radius
         */
        set: function (value) {
            this.setPercentProperty("radius", value, false, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererRadial.prototype, "pixelRadius", {
        /**
         * Outer radius in pixels.
         *
         * @return Outer radius (px)
         */
        get: function () {
            return relativeRadiusToValue(this.radius, this.pixelRadiusReal) || 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererRadial.prototype, "innerRadius", {
        /**
         * @return Inner radius
         */
        get: function () {
            var chart = this.chart;
            var innerRadius = this.getPropertyValue("innerRadius");
            if (!hasValue(innerRadius)) {
                innerRadius = chart.innerRadius;
                if (innerRadius instanceof Percent && chart) {
                    innerRadius = Percent_percent(innerRadius.value * chart.innerRadiusModifyer * 100);
                }
            }
            else {
                if (innerRadius instanceof Percent && chart) {
                    var mr = chart.mr;
                    var value = innerRadius.value;
                    value = Math.max(mr * value, mr - Math.min(chart.plotContainer.innerHeight, chart.plotContainer.innerWidth)) / mr;
                    innerRadius = Percent_percent(value * 100);
                }
            }
            return innerRadius;
        },
        /**
         * Inner radius of the axis.
         *
         * Can be absolute (px) or relative ([[Percent]]).
         *
         * @param value  Outer radius
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, false, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererRadial.prototype, "pixelInnerRadius", {
        /**
         * Inner radius in pixels.
         *
         * @return Inner radius (px)
         */
        get: function () {
            return relativeRadiusToValue(this.innerRadius, this.pixelRadiusReal) || 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts relative position on axis to point coordinates.
     *
     * @param position  Position (0-1)
     * @param position2  Position (0-1) Position on the second axis
     * @return Point
     */
    AxisRendererRadial.prototype.positionToPoint = function (position, position2) {
        var radius = fitToRange(this.positionToCoordinate(position), 0, Infinity);
        return { x: radius * Math_cos(this.axisAngle), y: radius * Math_sin(this.axisAngle) };
    };
    /**
     * Updates and positions the axis line element.
     *
     * @ignore Exclude from docs
     */
    AxisRendererRadial.prototype.updateAxisLine = function () {
        this.line.path = moveTo({ x: this.pixelInnerRadius * Math_cos(this.axisAngle), y: this.pixelInnerRadius * Math_sin(this.axisAngle) }) + lineTo({ x: this.pixelRadius * Math_cos(this.axisAngle), y: this.pixelRadius * Math_sin(this.axisAngle) });
        var title = this.axis.title;
        title.valign = "none";
        title.horizontalCenter = "middle";
        title.verticalCenter = "bottom";
        title.y = -this.axisLength / 2;
        var rotation = 90;
        if (this.opposite) {
            if (!this.inside) {
                rotation = -90;
            }
        }
        else {
            if (this.inside) {
                rotation = -90;
            }
        }
        title.rotation = rotation;
    };
    /**
     * Updates and positions a grid element.
     *
     * @ignore Exclude from docs
     * @param grid         Grid element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererRadial.prototype.updateGridElement = function (grid, position, endPosition) {
        position = position + (endPosition - position) * grid.location;
        var point = this.positionToPoint(position);
        var path;
        var radius = getDistance(point);
        var startAngle = this.startAngle;
        var endAngle = this.endAngle;
        if (isNumber(radius) && grid.element) {
            var chart = this.chart;
            var xAxis = chart.xAxes.getIndex(0);
            var count = 0;
            var series = chart.series.getIndex(0);
            if (series) {
                count = series.dataItems.length;
            }
            // polygons are only possible if x axis is present
            // @todo: review this
            if (this.gridType == "polygons" && count > 0 && series && xAxis && xAxis instanceof CategoryAxis_CategoryAxis) {
                var gridLocation = xAxis.renderer.grid.template.location;
                var angle = xAxis.getAngle(series.dataItems.getIndex(0), "categoryX", gridLocation);
                path = moveTo({ x: radius * Math_cos(angle), y: radius * Math_sin(angle) });
                for (var i = 1; i < count; i++) {
                    angle = xAxis.getAngle(series.dataItems.getIndex(i), "categoryX", gridLocation);
                    path += lineTo({ x: radius * Math_cos(angle), y: radius * Math_sin(angle) });
                }
                angle = xAxis.getAngle(series.dataItems.getIndex(count - 1), "categoryX", xAxis.renderer.cellEndLocation);
                path += lineTo({ x: radius * Math_cos(angle), y: radius * Math_sin(angle) });
            }
            else {
                path = moveTo({ x: radius * Math_cos(startAngle), y: radius * Math_sin(startAngle) }) + arcTo(startAngle, endAngle - startAngle, radius, radius);
            }
            grid.path = path;
        }
        this.toggleVisibility(grid, position, 0, 1);
    };
    /**
     * Updates and positions a label element.
     *
     * @ignore Exclude from docs
     * @param label        Label element
     * @param position     Starting position
     * @param endPosition  Ending position
     */
    AxisRendererRadial.prototype.updateLabelElement = function (label, position, endPosition, location) {
        if (!hasValue(location)) {
            location = label.location;
        }
        position = position + (endPosition - position) * location;
        var point = this.positionToPoint(position);
        this.positionItem(label, point);
        this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);
    };
    /**
     * Updates and positions the base grid element.
     *
     * @ignore Exclude from docs
     */
    AxisRendererRadial.prototype.updateBaseGridElement = function () {
        // @todo? zero grid for radar chart, is it needed?
    };
    /**
     * Checks if point is within bounds of a container.
     *
     * @ignore Exclude from docs
     * @param point Point coordinates
     * @return Fits?
     */
    AxisRendererRadial.prototype.fitsToBounds = function (point) {
        return true;
    };
    Object.defineProperty(AxisRendererRadial.prototype, "startAngle", {
        /**
         * @return Start angle
         */
        get: function () {
            return this.getPropertyValue("startAngle");
        },
        /**
         * Start angle of the axis in degrees. (0-360)
         *
         * @param value  Start angle
         */
        set: function (value) {
            // do not normalize angle here!
            if (this.setPropertyValue("startAngle", value)) {
                this.invalidateAxisItems();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererRadial.prototype, "endAngle", {
        /**
         * @return End angle
         */
        get: function () {
            return this.getPropertyValue("endAngle");
        },
        /**
         * End angle of the axis in degrees. (0-360)
         *
         * @param value  End angle
         */
        set: function (value) {
            // do not normalize angel here!
            if (this.setPropertyValue("endAngle", value)) {
                this.invalidateAxisItems();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererRadial.prototype, "axisAngle", {
        /**
         * @return Axis angle
         */
        get: function () {
            return this.getPropertyValue("axisAngle");
            //return $math.fitToRange(this.getPropertyValue("axisAngle"), this.startAngle, this.endAngle); // no good, as less flexible
        },
        /**
         * Angle of the radial axis in degrees. (0-360)
         *
         * @param value  Axis angle
         */
        set: function (value) {
            this.setPropertyValue("axisAngle", normalizeAngle(value));
            this.invalidateAxisItems();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AxisRendererRadial.prototype, "gridType", {
        /**
         * Grid type
         */
        get: function () {
            var axis = this.chart.xAxes.getIndex(0);
            if (axis instanceof CategoryAxis_CategoryAxis) {
                return this.getPropertyValue("gridType");
            }
            else {
                return "circles";
            }
        },
        // polygons grid type is only possible under these conditions: xAxis is available and it is CategoryAxis, also at least one series should be added to a chart
        /**
         * Grid type for radial axis.
         *
         * A grid on radia axis can either be perfect circles ("circles"), or
         * straight lines ("polygons").
         *
         * @default "circles"
         * @param value  Grid type
         */
        set: function (value) {
            this.setPropertyValue("gridType", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * [getPositionRangePath description]
     *
     * @ignore Exclude from docs
     * @todo Description
     * @param startPosition  Starting position
     * @param endPosition    End position
     * @return SVG path
     */
    AxisRendererRadial.prototype.getPositionRangePath = function (startPosition, endPosition) {
        var pixelInnerRadius = this.pixelInnerRadius;
        var pixelRadius = this.axisLength + pixelInnerRadius;
        var innerRadius = fitToRange(this.positionToCoordinate(startPosition), pixelInnerRadius, pixelRadius);
        var radius = fitToRange(this.positionToCoordinate(endPosition), pixelInnerRadius, pixelRadius);
        //let angleCount: number = this.angleCount;
        var startAngle = this.startAngle;
        var endAngle = this.endAngle;
        var arc = endAngle - startAngle;
        var path;
        var chart = this.chart;
        var xAxis = chart.xAxes.getIndex(0);
        var series = chart.series.getIndex(0);
        var count = 0;
        if (series) {
            count = series.dataItems.length;
        }
        // polygons are only possible if x axis is present
        // @todo: review this
        if (this.gridType == "polygons" && count > 0 && series && xAxis && xAxis instanceof CategoryAxis_CategoryAxis) {
            var gridLocation = xAxis.renderer.grid.template.location;
            var angle = xAxis.getAngle(series.dataItems.getIndex(0), "categoryX", gridLocation);
            path = moveTo({ x: radius * Math_cos(angle), y: radius * Math_sin(angle) });
            for (var i = 1; i < count; i++) {
                angle = xAxis.getAngle(series.dataItems.getIndex(i), "categoryX", gridLocation);
                path += lineTo({ x: radius * Math_cos(angle), y: radius * Math_sin(angle) });
            }
            angle = xAxis.getAngle(series.dataItems.getIndex(count - 1), "categoryX", xAxis.renderer.cellEndLocation);
            path += lineTo({ x: radius * Math_cos(angle), y: radius * Math_sin(angle) });
            path += moveTo({ x: innerRadius * Math_cos(angle), y: innerRadius * Math_sin(angle) });
            for (var i = count - 1; i >= 0; i--) {
                angle = xAxis.getAngle(series.dataItems.getIndex(i), "categoryX", gridLocation);
                path += lineTo({ x: innerRadius * Math_cos(angle), y: innerRadius * Math_sin(angle) });
            }
        }
        else {
            path = Path_arc(startAngle, arc, radius, innerRadius);
        }
        return path;
    };
    /**
     * Updates and positions an axis break element.
     *
     * @ignore Exclude from docs
     * @param axisBreak Break element
     */
    AxisRendererRadial.prototype.updateBreakElement = function (axisBreak) {
        // @todo: someday we might need axis break when gridType is polygons
        var startLine = axisBreak.startLine;
        var endLine = axisBreak.endLine;
        var fillShape = axisBreak.fillShape;
        var startPoint = axisBreak.startPoint;
        var endPoint = axisBreak.endPoint;
        startLine.radius = Math.abs(startPoint.y);
        endLine.radius = Math.abs(endPoint.y);
        fillShape.radius = Math.abs(endPoint.y);
        fillShape.innerRadius = Math.abs(startPoint.y);
    };
    /**
     * Creates visual elements for and axis break.
     *
     * @ignore Exclude from docs
     * @param axisBreak Axis break
     */
    AxisRendererRadial.prototype.createBreakSprites = function (axisBreak) {
        axisBreak.startLine = new WavedCircle_WavedCircle();
        axisBreak.endLine = new WavedCircle_WavedCircle();
        axisBreak.fillShape = new WavedCircle_WavedCircle();
    };
    /**
     * Updates some of the Axis tooltip's visual properties, related to
     * rendering of the Axis.
     *
     * @todo Description (review)
     * @ignore Exclude from docs
     */
    AxisRendererRadial.prototype.updateTooltip = function () {
        var axis = this.axis;
        if (axis) {
            var bigNum = 4000;
            var bbx = -4000;
            var bby = -4000;
            var bbw = bigNum * 2;
            var bbh = bigNum * 2;
            var axisAngle = this.axisAngle;
            if (axisAngle < 0) {
                axisAngle += 360;
            }
            var tooltipOrientation = "vertical";
            if ((axisAngle > 45 && axisAngle < 135) || (axisAngle > 225 && axisAngle < 315)) {
                tooltipOrientation = "horizontal";
            }
            this.axis.updateTooltip(tooltipOrientation, { x: bbx, y: bby, width: bbw, height: bbh });
        }
    };
    /**
     * Updates and positions a tick element.
     *
     * @ignore Exclude from docs
     * @param tick      Tick element
     * @param position  Position
     */
    AxisRendererRadial.prototype.updateTickElement = function (tick, position, endPosition) {
        position = position + (endPosition - position) * tick.location;
        var point = this.positionToPoint(position);
        if (tick.element) {
            var angle = normalizeAngle(this.axisAngle + 90);
            if (angle / 90 != Math.round(angle / 90)) {
                tick.pixelPerfect = false;
            }
            else {
                tick.pixelPerfect = true;
            }
            var tickLength = -tick.length;
            if (tick.inside) {
                tickLength *= -1;
            }
            tick.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: tickLength * Math_cos(angle), y: tickLength * Math_sin(angle) });
        }
        this.positionItem(tick, point);
        this.toggleVisibility(tick, position, 0, 1);
    };
    /**
     * Updates and positions axis bullet.
     *
     * @ignore Exclude from docs
     * @param bullet       AxisBullet element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererRadial.prototype.updateBullet = function (bullet, position, endPosition) {
        var location = 0.5;
        if (bullet instanceof AxisBullet_AxisBullet) {
            location = bullet.location;
        }
        position = position + (endPosition - position) * location;
        var point = this.positionToPoint(position);
        this.positionItem(bullet, point);
        this.toggleVisibility(bullet, position, 0, 1);
    };
    /**
     * Converts a position on the axis to a coordinate in pixels.
     *
     * @ignore Exclude from docs
     * @param position  Position (0-1)
     * @return Coordinate (px)
     */
    AxisRendererRadial.prototype.positionToCoordinate = function (position) {
        var coordinate;
        var axis = this.axis;
        var axisFullLength = axis.axisFullLength;
        var innerRadius = this.pixelInnerRadius;
        if (axis.renderer.inversed) {
            coordinate = (axis.end - position) * axisFullLength + innerRadius;
        }
        else {
            coordinate = (position - axis.start) * axisFullLength + innerRadius;
        }
        return Math_round(coordinate, 1);
    };
    /**
     * Converts a point at specific coordinates to a relative position (0-1)
     * on the axis.
     *
     * @param point  Point
     * @return Position (0-1)
     */
    AxisRendererRadial.prototype.pointToPosition = function (point) {
        var coordinate = (getDistance(point) - this.pixelInnerRadius);
        return this.coordinateToPosition(coordinate);
    };
    Object.defineProperty(AxisRendererRadial.prototype, "chart", {
        /**
         * @ignore Exclude from docs
         * @return Chart
         */
        get: function () {
            return this._chart.get();
        },
        /**
         * A chart, associated with the Axis.
         *
         * @ignore Exclude from docs
         * @param value  Chart
         */
        set: function (value) {
            this._chart.set(value, null);
        },
        enumerable: true,
        configurable: true
    });
    return AxisRendererRadial;
}(AxisRendererY_AxisRendererY));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisRendererRadial"] = AxisRendererRadial_AxisRendererRadial;
//# sourceMappingURL=AxisRendererRadial.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/RadarChart.js
/**
 * Radar chart module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */













/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[RadarChart]].
 *
 * @see {@link DataItem}
 */
var RadarChart_RadarChartDataItem = /** @class */ (function (_super) {
    __extends(RadarChartDataItem, _super);
    /**
     * Constructor
     */
    function RadarChartDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "RadarChartDataItem";
        _this.applyTheme();
        return _this;
    }
    return RadarChartDataItem;
}(XYChart_XYChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a Radar chart.
 *
 * @see {@link IRadarChartEvents} for a list of available Events
 * @see {@link IRadarChartAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/radar-chart/} for documentation
 * @important
 */
var RadarChart_RadarChart = /** @class */ (function (_super) {
    __extends(RadarChart, _super);
    /**
     * Constructor
     */
    function RadarChart() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Defines X axis renderer type.
         */
        _this._axisRendererX = AxisRendererCircular_AxisRendererCircular;
        /**
         * Defines Y axis renderer type.
         */
        _this._axisRendererY = AxisRendererRadial_AxisRendererRadial;
        /**
         * used by cursor. We adjust innerradius if start and end angle are close to each other
         * @ignore Exclude from docs
         */
        _this.innerRadiusModifyer = 1;
        _this.className = "RadarChart";
        _this.startAngle = -90;
        _this.endAngle = 270;
        _this.radius = Percent_percent(80);
        _this.innerRadius = 0;
        var radarContainer = _this.plotContainer.createChild(Container_Container);
        radarContainer.shouldClone = false;
        radarContainer.layout = "absolute";
        radarContainer.align = "center";
        radarContainer.valign = "middle";
        _this.seriesContainer.parent = radarContainer;
        _this.radarContainer = radarContainer;
        _this.bulletsContainer.parent = radarContainer;
        _this.axisBulletsContainer = radarContainer;
        _this._cursorContainer = radarContainer;
        _this.chartContainer.events.on("maxsizechanged", _this.invalidate, _this, false); // need this for the chart to change radius if legend is removed/disabled
        _this._bulletMask = radarContainer.createChild(Circle_Circle);
        _this._bulletMask.shouldClone = false;
        _this._bulletMask.element = _this.paper.add("path");
        _this._bulletMask.opacity = 0;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    RadarChart.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Add a default screen reader title for accessibility
        // This will be overridden in screen reader if there are any `titles` set
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Radar chart");
        }
    };
    /**
     * Decorates Axis with required properties for this chart.
     *
     * @param axis  Axis
     */
    RadarChart.prototype.processAxis = function (axis) {
        _super.prototype.processAxis.call(this, axis);
        var renderer = axis.renderer;
        renderer.gridContainer.parent = renderer;
        renderer.breakContainer.parent = renderer;
        axis.parent = this.radarContainer;
        renderer.toBack();
    };
    /**
     * Updates all X axes after range change event.
     */
    RadarChart.prototype.handleXAxisRangeChange = function () {
        _super.prototype.handleXAxisRangeChange.call(this);
        Iterator_each(this.yAxes.iterator(), function (axis) {
            axis.invalidate();
        });
    };
    /**
     * Updates all Y axes after range change event.
     */
    RadarChart.prototype.handleYAxisRangeChange = function () {
        _super.prototype.handleYAxisRangeChange.call(this);
        Iterator_each(this.xAxes.iterator(), function (axis) {
            axis.invalidate();
        });
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    RadarChart.prototype.processConfig = function (config) {
        if (config) {
            // Set up cursor
            if (hasValue(config.cursor) && !hasValue(config.cursor.type)) {
                config.cursor.type = "RadarCursor";
            }
            // Set up series
            if (hasValue(config.series) && isArray(config.series)) {
                for (var i = 0, len = config.series.length; i < len; i++) {
                    config.series[i].type = config.series[i].type || "RadarSeries";
                }
            }
            // Set up axes
            /*if ($type.hasValue(config.xAxes) && $type.isArray(config.xAxes)) {
                for (let i = 0, len = config.xAxes.length; i < len; i++) {
                    config.xAxes[i].type = config.xAxes[i].type || "AxisRendererCircular";
                }
            }
            if ($type.hasValue(config.yAxes) && $type.isArray(config.yAxes)) {
                for (let i = 0, len = config.yAxes.length; i < len; i++) {
                    config.yAxes[i].type = config.yAxes[i].type || "AxisRendererRadial";
                }
            }*/
        }
        _super.prototype.processConfig.call(this, config);
    };
    /**
     * Does calculations before drawing the chart.
     */
    RadarChart.prototype.beforeDraw = function () {
        _super.prototype.beforeDraw.call(this);
        var plotContainer = this.plotContainer;
        var rect = getArcRect(this.startAngle, this.endAngle, 1);
        var innerRect = { x: 0, y: 0, width: 0, height: 0 };
        var wr = plotContainer.innerWidth / rect.width;
        var hr = plotContainer.innerHeight / rect.height;
        var innerRadius = this.innerRadius;
        if (innerRadius instanceof Percent) {
            var value = innerRadius.value;
            var mr = Math.min(wr, hr);
            this.mr = mr;
            value = Math.max(mr * value, mr - Math.min(plotContainer.innerHeight, plotContainer.innerWidth)) / mr;
            innerRect = getArcRect(this.startAngle, this.endAngle, value);
            this.innerRadiusModifyer = value / innerRadius.value;
            innerRadius = Percent_percent(value * 100);
        }
        // @todo handle this when innerRadius set in pixels (do it for pie also)
        rect = getCommonRectangle([rect, innerRect]);
        var maxRadius = Math.min(plotContainer.innerWidth / rect.width, plotContainer.innerHeight / rect.height);
        var diameter = relativeRadiusToValue(this.radius, maxRadius) * 2 || 0;
        var radius = diameter / 2;
        var startAngle = this.startAngle;
        var endAngle = this.endAngle;
        this._pixelInnerRadius = relativeRadiusToValue(innerRadius, radius);
        this._bulletMask.path = Path_arc(startAngle, endAngle - startAngle, radius, this._pixelInnerRadius);
        Iterator_each(this.xAxes.iterator(), function (axis) {
            if (axis.renderer.useChartAngles) {
                axis.renderer.startAngle = startAngle;
                axis.renderer.endAngle = endAngle;
            }
            axis.width = diameter;
            axis.height = diameter;
            //axis.renderer.width = diameter;
            //axis.renderer.height = diameter;
            axis.renderer.pixelRadiusReal = radius;
            //axis.renderer.innerRadius = innerRadius;
        });
        Iterator_each(this.yAxes.iterator(), function (axis) {
            axis.renderer.startAngle = startAngle;
            axis.renderer.endAngle = endAngle;
            axis.width = diameter;
            axis.height = diameter;
            //axis.renderer.width = diameter;
            //axis.renderer.height = diameter;
            axis.renderer.pixelRadiusReal = radius;
            //axis.renderer.innerRadius = innerRadius;
        });
        var cursor = this.cursor;
        if (cursor) {
            cursor.width = diameter;
            cursor.height = diameter;
            cursor.startAngle = startAngle;
            cursor.endAngle = endAngle;
        }
        this.radarContainer.definedBBox = { x: radius * rect.x, y: radius * rect.y, width: radius * rect.width, height: radius * rect.height };
        this.radarContainer.validatePosition();
    };
    /**
     * Creates and returns a new Series, suitable for RadarChart.
     *
     * @return New Series
     */
    RadarChart.prototype.createSeries = function () {
        return new RadarSeries_RadarSeries();
    };
    Object.defineProperty(RadarChart.prototype, "startAngle", {
        /**
         * @return Start angle (degrees)
         */
        get: function () {
            return this.getPropertyValue("startAngle");
        },
        /**
         * Starting angle of the Radar face. (degrees)
         *
         * Normally, a circular radar face begins (the radial axis is drawn) at the
         * top center. (at -90 degrees)
         *
         * You can use `startAngle` to change this setting.
         *
         * E.g. setting this to 0 will make the radial axis start horizontally to
         * the right, as opposed to vertical.
         *
         * For a perfect circle the absolute sum of `startAngle` and `endAngle`
         * needs to be 360.
         *
         * However, it's **not** necessary to do so. You can set those to lesser
         * numbers, to create semi-circles.
         *
         * E.g. `startAngle = -90` with `endAngle = 0` will create a radar face that
         * looks like a quarter of a circle.
         *
         * @default -90
         * @param value  Start angle (degrees)
         */
        set: function (value) {
            this.setPropertyValue("startAngle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadarChart.prototype, "endAngle", {
        /**
         * @return End angle (degrees)
         */
        get: function () {
            return this.getPropertyValue("endAngle");
        },
        /**
         * Starting angle of the Radar face. (degrees)
         *
         * Normally, a circular radar face ends (the radial axis is drawn) exactly
         * where it has started, forming a full 360 circle. (at 270 degrees)
         *
         * You can use `endAngle` to end the circle somewhere else.
         *
         * E.g. setting this to 180 will make the radar face end at horizontal line
         * to the left off the center.
         *
         * For a perfect circle the absolute sum of `startAngle` and `endAngle`
         * needs to be 360.
         *
         * However, it's **not** necessary to do so. You can set those to lesser
         * numbers, to create semi-circles.
         *
         * E.g. `startAngle = -90` with `endAngle = 0` will create a radar face that
         * looks like a quarter of a circle.
         *
         * @default -90
         * @param value  End angle (degrees)
         */
        set: function (value) {
            this.setPropertyValue("endAngle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadarChart.prototype, "radius", {
        /**
         * @return Outer radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Outer radius of the Radar face.
         *
         * This can either be in absolute pixel value, or relative [[Percent]].
         *
         * @param value  Outer radius
         */
        set: function (value) {
            this.setPercentProperty("radius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadarChart.prototype, "pixelInnerRadius", {
        /**
         * @return Inner radius in pixels
         */
        get: function () {
            return this._pixelInnerRadius;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadarChart.prototype, "innerRadius", {
        /**
         * @return Inner radius
         */
        get: function () {
            return this.getPropertyValue("innerRadius");
        },
        /**
         * Inner radius of the radar face.
         *
         * This can either be in absolute pixel value, or relative [[Percent]].
         *
         * If set in Percent, it will be relative to `radius`. (outer radius)
         *
         * @param value Inner radius
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Triggers (re)rendering of the horizontal (X) axis.
     *
     * @ignore Exclude from docs
     * @param axis Axis
     */
    RadarChart.prototype.updateXAxis = function (renderer) {
        //do not call super!
        if (renderer) {
            renderer.processRenderer();
        }
    };
    /**
     * Triggers (re)rendering of the vertical (Y) axis.
     *
     * @ignore Exclude from docs
     * @param axis Axis
     */
    RadarChart.prototype.updateYAxis = function (renderer) {
        // do not call super!
        if (renderer) {
            renderer.processRenderer();
        }
    };
    return RadarChart;
}(XYChart_XYChart));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["RadarChart"] = RadarChart_RadarChart;
//# sourceMappingURL=RadarChart.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/ClockHand.js
/**
 * Functionality for drawing simple ClockHands
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * ClockHand class is capable of drawing a simple pointy shape with optionally
 * rounderd corners and an icon.
 *
 * @see {@link IClockHandEvents} for a list of available events
 * @see {@link IClockHandAdapters} for a list of available Adapters
 * @todo Improve
 * @important
 */
var ClockHand_ClockHand = /** @class */ (function (_super) {
    __extends(ClockHand, _super);
    /**
     * Constructor
     */
    function ClockHand() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * An Axis hand is related to.
         */
        _this._axis = new Disposer_MutableValueDisposer();
        _this.className = "ClockHand";
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.fill = interfaceColors.getFor("alternativeBackground");
        _this.stroke = _this.fill;
        var pin = new Circle_Circle();
        pin.radius = 5;
        _this.pin = pin;
        _this.isMeasured = false;
        _this.startWidth = 5;
        _this.endWidth = 1;
        _this.width = Percent_percent(100);
        _this.height = Percent_percent(100);
        _this.radius = Percent_percent(100);
        _this.innerRadius = Percent_percent(0);
        var hand = new Trapezoid_Trapezoid();
        _this.hand = hand;
        _this._disposers.push(_this._axis);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Re(validates) the clock hand, effectively redrawing it.
     *
     * @ignore Exclude from docs
     */
    ClockHand.prototype.validate = function () {
        _super.prototype.validate.call(this);
        var hand = this.hand;
        hand.width = this.pixelWidth;
        var h = Math.max(this.startWidth, this.endWidth);
        hand.height = h;
        hand.leftSide = Percent_percent(this.startWidth / h * 100);
        hand.rightSide = Percent_percent(this.endWidth / h * 100);
        if (this.axis) {
            var renderer = this.axis.renderer;
            var x0 = relativeRadiusToValue(this.innerRadius, renderer.pixelRadius);
            var x1 = relativeRadiusToValue(this.radius, renderer.pixelRadius);
            hand.x = x0;
            hand.y = -h / 2;
            hand.width = x1 - x0;
        }
    };
    Object.defineProperty(ClockHand.prototype, "pin", {
        /**
         * @return Pin element
         */
        get: function () {
            return this._pin;
        },
        /**
         * A circle element used as hand's base. (pin)
         *
         * @param pin  Pin element
         */
        set: function (pin) {
            if (this._pin) {
                this.removeDispose(this._pin);
            }
            if (pin) {
                this._pin = pin;
                pin.parent = this;
                this._disposers.push(pin);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClockHand.prototype, "hand", {
        /**
         * @return Hand element
         */
        get: function () {
            return this._hand;
        },
        /**
         * A trapezoid shape used for hand itself.
         *
         * The shape of the trapezoid is controlled by ClockHand's `startWidth` and
         * `endWidth` properties.
         *
         * Set `endWidth` to 1 (px) to make it pointy.
         *
         * @param hand  Hand element
         */
        set: function (hand) {
            if (this._hand) {
                this.removeDispose(this._hand);
            }
            if (hand) {
                this._hand = hand;
                hand.parent = this;
                this._disposers.push(hand);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClockHand.prototype, "radius", {
        /**
         * @return Radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Radius of the hand's outer end. (tip)
         *
         * Absolute (px) or relative ([[Percent]]).
         *
         * @default Percent(0)
         * @param value  Radius
         */
        set: function (value) {
            this.setPercentProperty("radius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClockHand.prototype, "innerRadius", {
        /**
         * @return Radius
         */
        get: function () {
            return this.getPropertyValue("innerRadius");
        },
        /**
         * Radius of the hand's inner end. (base)
         *
         * Absolute (px) or relative ([[Percent]]).
         *
         * @default Percent(0)
         * @param value  Radius
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClockHand.prototype, "startWidth", {
        /**
         * @return Width (px)
         */
        get: function () {
            return this.getPropertyValue("startWidth");
        },
        /**
         * Width, in pixels, of the clock hand's inner end. (base)
         *
         * @default 5
         * @param value  Width (px)
         */
        set: function (value) {
            this.setPropertyValue("startWidth", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClockHand.prototype, "endWidth", {
        /**
         * @return Width (px)
         */
        get: function () {
            return this.getPropertyValue("endWidth");
        },
        /**
         * Width, in pixels, of the clock hand's outer end. (tip)
         *
         * @default 1
         * @param value  Width (px)
         */
        set: function (value) {
            this.setPropertyValue("endWidth", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClockHand.prototype, "rotationDirection", {
        /**
         * @return rotationDirection
         */
        get: function () {
            return this.getPropertyValue("rotationDirection");
        },
        /**
         * Rotation direction
         *
         * @default any
         * @param value
         */
        set: function (value) {
            this.setPropertyValue("rotationDirection", value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Moves clock hand to particular value.
     *
     * If `duration` is set to a number in milliseconds, the hand will move
     * to the new position gracefully, rather than jumping rigth to it.
     *
     * Alternatively, you can also set `value` directly.
     *
     * @param value     New value
     * @param duration  Animation duration (ms)
     * @param easing  Animation easing function
     */
    ClockHand.prototype.showValue = function (value, duration, easing) {
        this._value = value;
        if (value != undefined) {
            if (!isNumber(duration)) {
                duration = 0;
            }
            if (this.axis) {
                var renderer = this.axis.renderer;
                var newAngle = renderer.positionToAngle(this.axis.anyToPosition(value));
                var currentAngle = this.rotation;
                if (this.rotationDirection == "clockWise") {
                    if (newAngle < currentAngle) {
                        this.rotation = currentAngle - 360;
                    }
                }
                if (this.rotationDirection == "counterClockWise") {
                    if (newAngle > currentAngle) {
                        this.rotation = currentAngle + 360;
                    }
                }
                this.animate({ property: "rotation", to: newAngle }, duration, easing);
            }
        }
    };
    Object.defineProperty(ClockHand.prototype, "currentPosition", {
        /**
         * Returns hand's relative position on axis
         */
        get: function () {
            if (this.axis) {
                var renderer = this.axis.renderer;
                return renderer.angleToPosition(this.rotation);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClockHand.prototype, "value", {
        /**
         * @return Value
         */
        get: function () {
            return this._value;
        },
        /**
         * A current value clock hand is pointing to.
         *
         * @param value  Value
         */
        set: function (value) {
            this.showValue(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClockHand.prototype, "axis", {
        /**
         * @return Axis
         */
        get: function () {
            return this._axis.get();
        },
        /**
         * An Axis clock hand is associated with.
         *
         * Hand's `value` relates to values on the Axis.
         *
         * @param axis  Axis
         */
        set: function (axis) {
            if (this.axis != axis) {
                this._axis.set(axis, new Disposer_MultiDisposer([
                    axis.events.on("datavalidated", this.updateValue, this, false),
                    axis.events.on("datarangechanged", this.updateValue, this, false),
                    axis.events.on("dataitemsvalidated", this.updateValue, this, false),
                    axis.events.on("propertychanged", this.invalidate, this, false)
                ]));
            }
            if (axis) {
                var chart = axis.chart;
                if (chart) {
                    this.rotation = chart.startAngle;
                }
            }
            this.parent = axis.renderer;
            this.zIndex = 5;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Triggers `value` accessor, so that Hand animates to new position, in case
     * value has changed.
     *
     * @ignore Exclude from docs
     */
    ClockHand.prototype.updateValue = function () {
        this.value = this.value;
    };
    /**
 * Processes JSON-based config before it is applied to the object.
 *
 * @ignore Exclude from docs
 * @param config  Config
 */
    ClockHand.prototype.processConfig = function (config) {
        if (config) {
            // Connect clock hands with axes
            if (hasValue(config.axis) && isString(config.axis) && this.map.hasKey(config.axis)) {
                config.axis = this.map.getKey(config.axis);
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    return ClockHand;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ClockHand"] = ClockHand_ClockHand;
//# sourceMappingURL=ClockHand.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/GaugeChart.js
/**
 * Module for building Gauge charts.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[GaugeChart]].
 *
 * @see {@link DataItem}
 */
var GaugeChart_GaugeChartDataItem = /** @class */ (function (_super) {
    __extends(GaugeChartDataItem, _super);
    /**
     * Constructor
     */
    function GaugeChartDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "GaugeChartDataItem";
        _this.applyTheme();
        return _this;
    }
    return GaugeChartDataItem;
}(RadarChart_RadarChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a Gauge chart.
 *
 * @see {@link IGaugeChartEvents} for a list of available Events
 * @see {@link IGaugeChartAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/gauge-chart/} for documentation
 * @important
 */
var GaugeChart_GaugeChart = /** @class */ (function (_super) {
    __extends(GaugeChart, _super);
    /**
     * Constructor
     */
    function GaugeChart() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "GaugeChart";
        _this.startAngle = 180;
        _this.endAngle = 360;
        _this.hands = new List_ListTemplate(new ClockHand_ClockHand());
        _this.hands.events.on("inserted", _this.processHand, _this, false);
        _this._disposers.push(new List_ListDisposer(_this.hands));
        _this._disposers.push(_this.hands.template);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    GaugeChart.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Add a default screen reader title for accessibility
        // This will be overridden in screen reader if there are any `titles` set
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Gauge chart");
        }
    };
    /**
     * Decorates a [[ClockHand]] when it is added to the chart.
     *
     * @param event  Event
     */
    GaugeChart.prototype.processHand = function (event) {
        var hand = event.newValue;
        if (!hand.axis) {
            hand.axis = this.xAxes.getIndex(0);
        }
    };
    /**
     * This function is used to sort element's JSON config properties, so that
     * some properties that absolutely need to be processed last, can be put at
     * the end.
     *
     * @ignore Exclude from docs
     * @param a  Element 1
     * @param b  Element 2
     * @return Sorting number
     */
    GaugeChart.prototype.configOrder = function (a, b) {
        if (a == b) {
            return 0;
        }
        // Must come last
        else if (a == "hands") {
            return 1;
        }
        else if (b == "hands") {
            return -1;
        }
        else {
            return _super.prototype.configOrder.call(this, a, b);
        }
    };
    return GaugeChart;
}(RadarChart_RadarChart));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["GaugeChart"] = GaugeChart_GaugeChart;
//# sourceMappingURL=GaugeChart.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/PercentSeries.js
/**
 * Defines Percent Chart Series.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */














/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
//@todo: sequenced?
/**
 * Defines a [[DataItem]] for [[PercentSeries]].
 *
 * @see {@link DataItem}
 */
var PercentSeries_PercentSeriesDataItem = /** @class */ (function (_super) {
    __extends(PercentSeriesDataItem, _super);
    /**
     * Constructor
     */
    function PercentSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "PercentSeriesDataItem";
        _this.applyTheme();
        return _this;
    }
    /**
     * Adds an `id` attribute the the slice element and returns its id.
     *
     * @ignore Exclude from docs
     */
    PercentSeriesDataItem.prototype.uidAttr = function () {
        return this.slice.uidAttr();
    };
    /**
     * Hide the data item (and corresponding visual elements).
     *
     * @param duration  Duration (ms)
     * @param delay     Delay hiding (ms)
     * @param toValue   Target value for animation
     * @param fields    Fields to animate while hiding
     */
    PercentSeriesDataItem.prototype.hide = function (duration, delay, toValue, fields) {
        if (!fields) {
            fields = ["value"];
        }
        return _super.prototype.hide.call(this, duration, delay, 0, fields);
    };
    /**
     * Sets visibility of the Data Item.
     *
     * @param value Data Item
     */
    PercentSeriesDataItem.prototype.setVisibility = function (value, noChangeValues) {
        if (!noChangeValues) {
            if (value) {
                this.setWorkingValue("value", this.values["value"].value, 0, 0);
            }
            else {
                this.setWorkingValue("value", 0, 0, 0);
            }
        }
        _super.prototype.setVisibility.call(this, value, noChangeValues);
    };
    /**
     * Show hidden data item (and corresponding visual elements).
     *
     * @param duration  Duration (ms)
     * @param delay     Delay hiding (ms)
     * @param fields    Fields to animate while hiding
     */
    PercentSeriesDataItem.prototype.show = function (duration, delay, fields) {
        if (!fields) {
            fields = ["value"];
        }
        return _super.prototype.show.call(this, duration, delay, fields);
    };
    Object.defineProperty(PercentSeriesDataItem.prototype, "category", {
        /**
         * @return Category
         */
        get: function () {
            return this.properties.category;
        },
        /**
         * Category.
         *
         * @param value  Category
         */
        set: function (value) {
            this.setProperty("category", value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a marker used in the legend for this slice.
     *
     * @ignore Exclude from docs
     * @param marker  Marker container
     */
    PercentSeriesDataItem.prototype.createLegendMarker = function (marker) {
        this.component.createLegendMarker(marker, this);
    };
    Object.defineProperty(PercentSeriesDataItem.prototype, "legendDataItem", {
        /**
         * @return Legend data item
         */
        get: function () {
            return this._legendDataItem;
        },
        /**
         * A legend's data item, that corresponds to this data item.
         *
         * @param value  Legend data item
         */
        set: function (value) {
            this._legendDataItem = value;
            if (value.label) {
                value.label.dataItem = this;
            }
            if (value.valueLabel) {
                value.valueLabel.dataItem = this;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PercentSeriesDataItem.prototype, "tick", {
        /**
         * A Tick element, related to this data item. (slice)
         *
         * @readonly
         * @return Tick element
         */
        get: function () {
            var _this = this;
            if (!this._tick) {
                var tick_1 = this.component.ticks.create();
                this._tick = tick_1;
                this.addSprite(tick_1);
                this._disposers.push(tick_1);
                tick_1.parent = this.component.ticksContainer;
                this._disposers.push(new Disposer(function () {
                    if (_this.component) {
                        _this.component.ticks.removeValue(tick_1);
                    }
                }));
                tick_1.visible = this.visible;
            }
            return this._tick;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PercentSeriesDataItem.prototype, "label", {
        /**
         * A Label element, related to this data item. (slice)
         *
         * @readonly
         * @return Label element
         */
        get: function () {
            var _this = this;
            if (!this._label) {
                var label_1 = this.component.labels.create();
                this.addSprite(label_1);
                this._label = label_1;
                this._disposers.push(label_1);
                label_1.parent = this.component.labelsContainer;
                this._disposers.push(new Disposer(function () {
                    if (_this.component) {
                        _this.component.labels.removeValue(label_1);
                    }
                }));
                label_1.visible = this.visible;
            }
            return this._label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PercentSeriesDataItem.prototype, "slice", {
        /**
         * An element, related to this data item. (slice)
         *
         * @readonly
         * @return Slice element
         */
        get: function () {
            var _this = this;
            if (!this._slice) {
                var component_1 = this.component;
                var slice_1 = component_1.slices.create();
                this.addSprite(slice_1);
                this._slice = slice_1;
                this._disposers.push(slice_1);
                slice_1.parent = component_1.slicesContainer;
                this._disposers.push(new Disposer(function () {
                    component_1.slices.removeValue(slice_1);
                }));
                slice_1.visible = this.visible;
                // Apply accessibility
                if (component_1.itemsFocusable()) {
                    this.component.role = "menu";
                    slice_1.role = "menuitem";
                    slice_1.focusable = true;
                }
                else {
                    this.component.role = "list";
                    slice_1.role = "listitem";
                    slice_1.focusable = false;
                }
                // Apply screen reader label
                if (slice_1.focusable) {
                    slice_1.events.on("focus", function (ev) {
                        slice_1.readerTitle = component_1.populateString(component_1.itemReaderText, _this);
                    }, undefined, false);
                    slice_1.events.on("blur", function (ev) {
                        slice_1.readerTitle = "";
                    }, undefined, false);
                }
                if (slice_1.hoverable) {
                    slice_1.events.on("over", function (ev) {
                        slice_1.readerTitle = component_1.populateString(component_1.itemReaderText, _this);
                    }, undefined, false);
                    slice_1.events.on("out", function (ev) {
                        slice_1.readerTitle = "";
                    }, undefined, false);
                }
            }
            return this._slice;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PercentSeriesDataItem.prototype, "hiddenInLegend", {
        /**
         * @return Disabled in legend?
         */
        get: function () {
            return this.properties.hiddenInLegend;
        },
        /**
         * Should dataItem (slice) be hidden in legend?
         *
         * @param value Visible in legend?
         */
        set: function (value) {
            this.setProperty("hiddenInLegend", value);
        },
        enumerable: true,
        configurable: true
    });
    return PercentSeriesDataItem;
}(Series_SeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[PercentSeries]] which is a base class for [[PieSeries]],
 * [[FunnelSeries]], and [[PyramidSeries]].
 *
 * @see {@link IPercentSeriesEvents} for a list of available Events
 * @see {@link IPercentSeriesAdapters} for a list of available Adapters
 */
var PercentSeries_PercentSeries = /** @class */ (function (_super) {
    __extends(PercentSeries, _super);
    /**
     * Constructor
     */
    function PercentSeries() {
        var _this = _super.call(this) || this;
        _this.className = "PercentSeries";
        _this._addAllDataItems = false;
        _this.colors = new ColorSet_ColorSet();
        _this.colors.step = 1;
        _this.isMeasured = true;
        _this.calculatePercent = true;
        var slicesContainer = _this.createChild(Container_Container);
        slicesContainer.shouldClone = false;
        slicesContainer.isMeasured = false;
        _this.slicesContainer = slicesContainer;
        var ticksContainer = _this.createChild(Container_Container);
        ticksContainer.shouldClone = false;
        ticksContainer.isMeasured = false;
        ticksContainer.layout = "none";
        _this.ticksContainer = ticksContainer;
        var labelsContainer = _this.createChild(Container_Container);
        labelsContainer.shouldClone = false;
        labelsContainer.isMeasured = false;
        labelsContainer.layout = "none";
        _this.labelsContainer = labelsContainer;
        _this.alignLabels = false;
        _this.bulletsContainer.toFront();
        // Make all slices focusable
        _this.skipFocusThreshold = 50;
        var defaultState = _this.defaultState;
        defaultState.transitionEasing = sinOut;
        // Accessibility
        _this.itemReaderText = "{category}: {value.percent.formatNumber('#.#')}%";
        _this.applyTheme();
        return _this;
    }
    /**
     * Creates a slice element.
     *
     * @return Slice
     */
    PercentSeries.prototype.createSlice = function () {
        return new Sprite_Sprite();
    };
    /**
     * Creates a tick element.
     *
     * @return Tick
     */
    PercentSeries.prototype.createTick = function () {
        return new Tick_Tick();
    };
    /**
     * Sreates label element.
     *
     * @return label
     */
    PercentSeries.prototype.createLabel = function () {
        return new Label_Label();
    };
    Object.defineProperty(PercentSeries.prototype, "slices", {
        /**
         * A list of slice elements for the series.
         *
         * Use its `template` to configure look and behavior of the slices. E.g.:
         *
         * ```TypeScript
         * series.slices.template.stroke = am4core.color("#fff");
         * series.slices.template.strokeWidth = 2;
         * ```
         * ```JavaScript
         * series.slices.template.stroke = am4core.color("#fff");
         * series.slices.template.strokeWidth = 2;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": [{
         *     // ...
         *     "slices": {
         *       "stroke": "#fff",
         *       "strokeWidth": 2
         *     }
         *   }]
         * }
         * ```
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/list-templates/} for more information about list templates
         * @return Slices
         */
        get: function () {
            if (!this._slices) {
                var slice = this.createSlice();
                slice.applyOnClones = true;
                this._disposers.push(slice);
                this.initSlice(slice);
                this._slices = new List_ListTemplate(slice);
                this._disposers.push(new List_ListDisposer(this._slices));
            }
            return this._slices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PercentSeries.prototype, "ticks", {
        /**
         * A list of tick elements for the series. Ticks connect slice to its label.
         *
         * Use its `template` to configure look and behavior of the ticks. E.g.:
         *
         * ```TypeScript
         * series.ticks.template.strokeWidth = 2;
         * ```
         * ```JavaScript
         * series.ticks.template.strokeWidth = 2;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": [{
         *     // ...
         *     "ticks": {
         *       "strokeWidth": 2
         *     }
         *   }]
         * }
         * ```
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/list-templates/} for more information about list templates
         * @return Ticks
         */
        get: function () {
            if (!this._ticks) {
                var tick = this.createTick();
                tick.applyOnClones = true;
                this._disposers.push(tick);
                this.initTick(tick);
                this._ticks = new List_ListTemplate(tick);
                this._disposers.push(new List_ListDisposer(this._ticks));
            }
            return this._ticks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PercentSeries.prototype, "labels", {
        /**
         * A list of slice label elements for the series.
         *
         * Use its `template` to configure look and behavior of the labels. E.g.:
         *
         * ```TypeScript
         * series.labels.template.fill = am4core.color("#c00");
         * series.labels.template.fontSize = 20;
         * ```
         * ```JavaScript
         * series.labels.template.fill = am4core.color("#c00");
         * series.labels.template.fontSize = 20;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": [{
         *     // ...
         *     "labels": {
         *       "stroke": "#c00",
         *       "fontSize": 20
         *     }
         *   }]
         * }
         * ```
         *
         * @see {@link https://www.amcharts.com/docs/v4/concepts/list-templates/} for more information about list templates
         * @return Labels
         */
        get: function () {
            if (!this._labels) {
                var label = this.createLabel();
                label.applyOnClones = true;
                this._disposers.push(label);
                this.initLabel(label);
                this._labels = new List_ListTemplate(label);
                this._disposers.push(new List_ListDisposer(this._labels));
            }
            return this._labels;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    PercentSeries.prototype.createDataItem = function () {
        return new PercentSeries_PercentSeriesDataItem();
    };
    /**
     * Creates and returns a new slice element.
     *
     * @param sliceType  Type of the slice element
     * @return Slice
     */
    PercentSeries.prototype.initSlice = function (slice) {
    };
    PercentSeries.prototype.initLabel = function (label) {
        label.text = "{category}: {value.percent.formatNumber('#.0')}%";
        label.isMeasured = false;
        label.padding(5, 5, 5, 5);
    };
    PercentSeries.prototype.initTick = function (label) {
    };
    /**
     * Validates (processes) data items.
     *
     * @ignore Exclude from docs
     */
    PercentSeries.prototype.validateDataItems = function () {
        this.colors.reset();
        if (this.patterns) {
            this.patterns.reset();
        }
        _super.prototype.validateDataItems.call(this);
    };
    /**
     * Validates data item's element, effectively redrawing it.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    PercentSeries.prototype.validateDataElement = function (dataItem) {
        var slice = dataItem.slice;
        if (slice) {
            if (slice.fill == undefined) {
                if (this.patterns) {
                    if (!hasValue(slice.stroke)) {
                        slice.stroke = this.colors.next();
                    }
                    slice.fill = this.patterns.next();
                    if (hasValue(slice.fillOpacity)) {
                        slice.fill.backgroundOpacity = slice.fillOpacity;
                    }
                    if (slice.stroke instanceof Color_Color) {
                        slice.fill.stroke = slice.stroke;
                        slice.fill.fill = slice.stroke;
                    }
                }
                else {
                    slice.fill = this.colors.next();
                }
            }
            else {
                this.colors.currentStep += this.colors.step;
            }
            if (slice.stroke == undefined) {
                slice.stroke = slice.fill;
            }
        }
        // do this at the end, otherwise bullets won't be positioned properly
        _super.prototype.validateDataElement.call(this, dataItem);
        if (slice) {
            dataItem.bullets.each(function (key, bullet) {
                if (bullet.fill == undefined) {
                    bullet.fill = slice.fill;
                }
                if (bullet.stroke == undefined) {
                    bullet.stroke = slice.stroke;
                }
            });
        }
        this.updateLegendValue(dataItem);
    };
    /**
     * Validates (processes) data.
     *
     * @ignore Exclude from docs
     */
    PercentSeries.prototype.validateData = function () {
        _super.prototype.validateData.call(this);
        if (this.chart) {
            this.chart.feedLegend();
        }
    };
    /**
     * Arranges slice labels according to position settings.
     *
     * @ignore Exclude from docs
     * @param dataItems  Data items
     */
    PercentSeries.prototype.arrangeLabels = function (dataItems) {
        for (var i = 0, len = dataItems.length; i < len; i++) {
            var dataItem = dataItems[i];
            var label = dataItem.label;
            if (label) {
                if (label.invalid) {
                    label.validate();
                }
                var lh = label.measuredHeight;
                if (!label.visible) {
                    lh = 0;
                }
                if (label.pixelY - lh / 2 < -this.maxHeight / 2) {
                    label.y = -this.maxHeight / 2 + lh / 2;
                }
                var nextLabel = this.getNextLabel(i + 1, dataItems);
                var bottom = label.pixelY + lh;
                if (nextLabel) {
                    if (nextLabel.y < bottom) {
                        nextLabel.y = bottom;
                    }
                }
            }
        }
    };
    PercentSeries.prototype.arrangeLabels2 = function (dataItems) {
        var previousTop = this.maxHeight / 2;
        for (var i = dataItems.length - 1; i >= 0; i--) {
            var dataItem = dataItems[i];
            var label = dataItem.label;
            if (label) {
                if (label.invalid) {
                    label.validate();
                }
                var lh = label.measuredHeight;
                if (!label.visible) {
                    lh = 0;
                }
                if (i == dataItems.length - 1) {
                    previousTop += lh / 2;
                }
                if (label.pixelY + lh > previousTop) {
                    label.y = previousTop - lh;
                    previousTop = label.y;
                }
            }
        }
    };
    /**
     * Returns the next label according to `index`.
     *
     * @param index      Current index
     * @param dataItems  Data items
     * @return Label element
     */
    PercentSeries.prototype.getNextLabel = function (index, dataItems) {
        if (dataItems.length >= index) {
            var nextDataItem = dataItems[index];
            if (nextDataItem) {
                if (nextDataItem.label) {
                    if (nextDataItem.visible) {
                        return nextDataItem.label;
                    }
                    else {
                        return this.getNextLabel(index + 1, dataItems);
                    }
                }
                else {
                    return this.getNextLabel(index + 1, dataItems);
                }
            }
        }
    };
    Object.defineProperty(PercentSeries.prototype, "colors", {
        /**
         * @return Color set
         */
        get: function () {
            return this.getPropertyValue("colors");
        },
        /**
         * A color set to be used for slices.
         *
         * For each new subsequent slice, the chart will assign the next color in
         * this set.
         *
         * @param value  Color set
         */
        set: function (value) {
            this.setPropertyValue("colors", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PercentSeries.prototype, "patterns", {
        /**
         * @return Pattern set
         */
        get: function () {
            return this.getPropertyValue("patterns");
        },
        /**
         * A [[PatternSet]] to use when creating patterned fills for slices.
         *
         * @since 4.7.5
         * @param value  Pattern set
         */
        set: function (value) {
            this.setPropertyValue("patterns", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Binds related legend data item's visual settings to this series' visual
     * settings.
     *
     * @ignore Exclude from docs
     * @param marker    Container
     * @param dataItem  Data item
     */
    PercentSeries.prototype.createLegendMarker = function (marker, dataItem) {
        Iterator_each(marker.children.iterator(), function (child) {
            var slice = dataItem.slice;
            child.defaultState.properties.fill = slice.fill;
            child.defaultState.properties.stroke = slice.stroke;
            child.defaultState.properties.fillOpacity = slice.fillOpacity;
            child.defaultState.properties.strokeOpacity = slice.strokeOpacity;
            child.fill = slice.fill;
            child.stroke = slice.stroke;
            child.fillOpacity = slice.fillOpacity;
            child.strokeOpacity = slice.strokeOpacity;
            if (child.fill == undefined) {
                child.__disabled = true;
            }
            var legendDataItem = marker.dataItem;
            legendDataItem.color = slice.fill;
            legendDataItem.colorOrig = slice.fill;
            child.addDisposer(slice.events.on("propertychanged", function (ev) {
                if (ev.property == "fill") {
                    child.__disabled = false;
                    if (!child.isActive) {
                        child.fill = slice.fill;
                    }
                    child.defaultState.properties.fill = slice.fill;
                    legendDataItem.color = slice.fill;
                    legendDataItem.colorOrig = slice.fill;
                }
                if (ev.property == "stroke") {
                    if (!child.isActive) {
                        child.stroke = slice.stroke;
                    }
                    child.defaultState.properties.stroke = slice.stroke;
                }
            }, undefined, false));
        });
    };
    /**
     * Repositions bullets when slice's size changes.
     *
     * @ignore Exclude from docs
     * @param event  Event
     */
    PercentSeries.prototype.handleSliceScale = function (event) {
        var _this = this;
        var slice = event.target;
        var dataItem = slice.dataItem;
        Iterator_each(dataItem.bullets.iterator(), function (a) {
            var value = a[1];
            _this.positionBullet(value);
        });
    };
    /**
     * Repositions bullet and labels when slice moves.
     *
     * @ignore Exclude from docs
     * @param event  Event
     */
    PercentSeries.prototype.handleSliceMove = function (event) {
    };
    /**
     * Copies all properties from another instance of [[PercentSeries]].
     *
     * @param source  Source series
     */
    PercentSeries.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.slices.template.copyFrom(source.slices.template);
        this.labels.template.copyFrom(source.labels.template);
        this.ticks.template.copyFrom(source.ticks.template);
        this.colors = source.colors.clone();
    };
    Object.defineProperty(PercentSeries.prototype, "alignLabels", {
        /**
         * @return Align labels?
         */
        get: function () {
            return this.getPropertyValue("alignLabels");
        },
        /**
         * Align labels into nice vertical columns?
         *
         * This will ensure that labels never overlap with each other.
         *
         * Arranging labels into columns makes them more readble, and better user
         * experience.
         *
         * If set to `false` labels will be positioned at `label.radius` distance,
         * and may, in some cases, overlap.
         *
         * @default true
         * @param value  Align labels?
         */
        set: function (value) {
            this.setAlignLabels(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    PercentSeries.prototype.setAlignLabels = function (value) {
        this.setPropertyValue("alignLabels", value, true);
    };
    Object.defineProperty(PercentSeries.prototype, "ignoreZeroValues", {
        /**
         * @return Ignore zero values
         */
        get: function () {
            return this.getPropertyValue("ignoreZeroValues");
        },
        /**
         * If set to `true` the chart will not show slices with zero values.
         *
         * @default false
         * @since 4.7.9
         * @param  value  Ignore zero values
         */
        set: function (value) {
            this.setPropertyValue("ignoreZeroValues", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates corresponding legend data item with current values.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    PercentSeries.prototype.updateLegendValue = function (dataItem) {
        if (dataItem) {
            var legendDataItem = dataItem.legendDataItem;
            var legendSettings = dataItem.legendSettings;
            if (legendDataItem && legendSettings) {
                if (legendSettings) {
                    if (legendSettings.labelText) {
                        legendDataItem.label.text = legendSettings.labelText;
                    }
                    if (legendSettings.itemLabelText) {
                        legendDataItem.label.text = legendSettings.itemLabelText;
                    }
                    if (legendSettings.valueText) {
                        legendDataItem.valueLabel.text = legendSettings.valueText;
                    }
                    if (legendSettings.itemValueText) {
                        legendDataItem.valueLabel.text = legendSettings.itemValueText;
                    }
                }
            }
        }
    };
    return PercentSeries;
}(Series_Series));

/**
 * bboxter class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["PercentSeries"] = PercentSeries_PercentSeries;
registry.registeredClasses["PercentSeriesDataItem"] = PercentSeries_PercentSeriesDataItem;
/**
 * Add default responsive rules
 */
/**
 * Disable labels and ticks.
 */
defaultRules.push({
    relevant: ResponsiveBreakpoints.maybeXS,
    state: function (target, stateId) {
        if (target instanceof PercentSeries_PercentSeries) {
            var state = target.states.create(stateId);
            var labelState = target.labels.template.states.create(stateId);
            labelState.properties.disabled = true;
            var tickState = target.ticks.template.states.create(stateId);
            tickState.properties.disabled = true;
            return state;
        }
        return null;
    }
});
//# sourceMappingURL=PercentSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/PercentChart.js
/**
 * Percent chart module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[PercentChart]].
 *
 * @see {@link DataItem}
 */
var PercentChart_PercentChartDataItem = /** @class */ (function (_super) {
    __extends(PercentChartDataItem, _super);
    /**
     * Constructor
     */
    function PercentChartDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "PercentChartDataItem";
        _this.applyTheme();
        return _this;
    }
    return PercentChartDataItem;
}(SerialChart_SerialChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * This is a base class for "percent-based" chart types like Pie and Funnel.
 *
 * @see {@link IPercentChartEvents} for a list of available Events
 * @see {@link IPercentChartAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/pie-chart/} for Pie chart documentation
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/sliced-chart/} for Sliced chart documentation
 */
var PercentChart_PercentChart = /** @class */ (function (_super) {
    __extends(PercentChart, _super);
    /**
     * Constructor
     */
    function PercentChart() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "PercentChart";
        _this.align = "none";
        _this.valign = "none";
        // so that the chart is always drawn, even the legend wants all the space
        _this.chartContainer.minHeight = 50;
        _this.chartContainer.minWidth = 50;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * (Re)validates chart data.
     *
     * @ignore Exclude from docs
     */
    PercentChart.prototype.validateData = function () {
        _super.prototype.validateData.call(this);
        this.feedLegend();
    };
    /**
     * Setups the legend to use the chart's data.
     * @ignore
     */
    PercentChart.prototype.feedLegend = function () {
        var legend = this.legend;
        if (legend) {
            var legendData_1 = [];
            Iterator_each(this.series.iterator(), function (series) {
                if (!series.hiddenInLegend) {
                    Iterator_each(series.dataItems.iterator(), function (dataItem) {
                        if (!dataItem.hiddenInLegend) {
                            legendData_1.push(dataItem);
                            if (!dataItem.legendSettings) {
                                dataItem.legendSettings = series.legendSettings;
                            }
                        }
                    });
                }
            });
            legend.data = legendData_1;
            legend.dataFields.name = "category";
        }
    };
    /**
     * Creates a new [[PercentSeries]].
     *
     * @return New series
     */
    PercentChart.prototype.createSeries = function () {
        return new PercentSeries_PercentSeries();
    };
    /**
     * @ignore
     */
    PercentChart.prototype.setLegend = function (legend) {
        _super.prototype.setLegend.call(this, legend);
        if (legend) {
            legend.labels.template.text = "{category}";
            legend.valueLabels.template.text = "{value.percent.formatNumber('#.0')}%";
            legend.itemContainers.template.events.on("over", function (event) {
                var percentSeriesDataItem = event.target.dataItem.dataContext;
                if (percentSeriesDataItem.visible && !percentSeriesDataItem.isHiding) {
                    var slice = percentSeriesDataItem.slice;
                    slice.dispatchImmediately("over");
                    slice.isHover = true;
                    slice.interactions.isRealHover = true;
                }
            });
            legend.itemContainers.template.events.on("out", function (event) {
                var percentSeriesDataItem = event.target.dataItem.dataContext;
                var slice = percentSeriesDataItem.slice;
                slice.dispatchImmediately("out");
                slice.isHover = false;
            });
        }
    };
    return PercentChart;
}(SerialChart_SerialChart));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @hidden
 */
registry.registeredClasses["PercentChart"] = PercentChart_PercentChart;
registry.registeredClasses["PercentChartDataItem"] = PercentChart_PercentChartDataItem;
//# sourceMappingURL=PercentChart.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/PieTick.js
/**
 * Pie tick module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws an tick line for a pie slice connecting it to a related label.
 *
 * @see {@link IPieTickEvents} for a list of available events
 * @see {@link IPieTickAdapters} for a list of available Adapters
 */
var PieTick_PieTick = /** @class */ (function (_super) {
    __extends(PieTick, _super);
    /**
     * Constructor
     */
    function PieTick() {
        var _this = _super.call(this) || this;
        /**
         * A label element this tick is attached to.
         */
        _this._label = new Disposer_MutableValueDisposer();
        /**
         * A slice element this tick is attached to.
         */
        _this._slice = new Disposer_MutableValueDisposer();
        _this.className = "PieTick";
        _this.element = _this.paper.add("polyline");
        _this._disposers.push(_this._label);
        _this._disposers.push(_this._slice);
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the tick element.
     *
     * @ignore Exclude from docs
     */
    PieTick.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var slice = this.slice;
        var label = this.label;
        var series = slice.dataItem.component;
        if (slice && slice.radius > 0 && label && label.text) {
            var x0 = slice.dx + slice.slice.dx + slice.pixelX + slice.ix * slice.radius * slice.scale;
            var y0 = slice.dy + slice.slice.dy + slice.pixelY + slice.iy * slice.radiusY * slice.scale;
            var x1 = void 0;
            var y1 = void 0;
            var x2 = void 0;
            var y2 = void 0;
            if (series.alignLabels) {
                x1 = label.pixelX - this.length;
                y1 = label.pixelY;
                x2 = label.pixelX;
                y2 = y1;
                if (label.horizontalCenter == "right") {
                    x1 += 2 * this.length;
                    x2 = x1 - this.length;
                }
            }
            else {
                var r = label.pixelRadius(slice.radius);
                x1 = x0 + r * slice.ix;
                y1 = y0 + r * slice.iy;
                x2 = x1;
                y2 = y1;
            }
            this.element.attr({ "points": [x0, y0, x1, y1, x2, y2] });
        }
    };
    Object.defineProperty(PieTick.prototype, "slice", {
        /**
         * @return Slice
         */
        get: function () {
            return this._slice.get();
        },
        /**
         * Slice element tick is attached to.
         *
         * @param slice  Slice
         */
        set: function (slice) {
            this._slice.set(slice, new Disposer_MultiDisposer([
                slice.events.on("transformed", this.invalidate, this),
                slice.events.on("validated", this.invalidate, this)
            ]));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieTick.prototype, "label", {
        /**
         * @return Label
         */
        get: function () {
            return this._label.get();
        },
        /**
         * Label element tick is attached to.
         *
         * @param label  Label
         */
        set: function (label) {
            this._label.set(label, label.events.on("transformed", this.invalidate, this, false));
        },
        enumerable: true,
        configurable: true
    });
    return PieTick;
}(Tick_Tick));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["PieTick"] = PieTick_PieTick;
//# sourceMappingURL=PieTick.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/PieSeries.js
/**
 * Defines Pie Chart Series.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */


//import { Slice3D } from "../../core/elements/3D/Slice3D";






/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
//@todo: sequenced?
/**
 * Defines a [[DataItem]] for [[PieSeries]].
 *
 * @see {@link DataItem}
 */
var PieSeries_PieSeriesDataItem = /** @class */ (function (_super) {
    __extends(PieSeriesDataItem, _super);
    /**
     * Constructor
     */
    function PieSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "PieSeriesDataItem";
        _this.values.radiusValue = {};
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(PieSeriesDataItem.prototype, "radiusValue", {
        /**
         * @return Radius
         */
        get: function () {
            return this.values.radiusValue.value;
        },
        /**
         * Slice's radius, if other than default.
         *
         * @param value  Radius
         */
        set: function (value) {
            this.setValue("radiusValue", value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Hide the data item (and corresponding visual elements).
     *
     * @param duration  Duration (ms)
     * @param delay     Delay hiding (ms)
     * @param toValue   Target value for animation
     * @param fields    Fields to animate while hiding
     */
    PieSeriesDataItem.prototype.hide = function (duration, delay, toValue, fields) {
        return _super.prototype.hide.call(this, duration, delay, 0, ["value", "radiusValue"]);
    };
    /**
     * Show hidden data item (and corresponding visual elements).
     *
     * @param duration  Duration (ms)
     * @param delay     Delay hiding (ms)
     * @param fields    Fields to animate while hiding
     */
    PieSeriesDataItem.prototype.show = function (duration, delay, fields) {
        return _super.prototype.show.call(this, duration, delay, ["value", "radiusValue"]);
    };
    return PieSeriesDataItem;
}(PercentSeries_PercentSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a slice series on a Pie chart.
 *
 * @see {@link IPieSeriesEvents} for a list of available Events
 * @see {@link IPieSeriesAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var PieSeries_PieSeries = /** @class */ (function (_super) {
    __extends(PieSeries, _super);
    /**
     * Constructor
     */
    function PieSeries() {
        var _this = _super.call(this) || this;
        _this.className = "PieSeries";
        _this.alignLabels = true;
        //this.startAngle = -90;
        //this.endAngle = 270;
        _this.layout = "none";
        _this.labels.template.radius = Percent_percent(5);
        _this.addDisposer(_this.labels.template.events.on("enabled", _this.invalidate, _this, false));
        _this.applyTheme();
        return _this;
    }
    /**
     * creates slice
     */
    PieSeries.prototype.createSlice = function () {
        return new Slice_Slice();
    };
    /**
     * creates tick
     */
    PieSeries.prototype.createTick = function () {
        return new PieTick_PieTick();
    };
    /**
     * creates label
     */
    PieSeries.prototype.createLabel = function () {
        return new AxisLabelCircular_AxisLabelCircular();
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    PieSeries.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Pie Slice Series");
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    PieSeries.prototype.createDataItem = function () {
        return new PieSeries_PieSeriesDataItem();
    };
    /**
     * Inits slice.
     *
     * @param slice to init
     */
    PieSeries.prototype.initSlice = function (slice) {
        slice.isMeasured = false;
        slice.defaultState.properties.scale = 1;
        slice.observe("scale", this.handleSliceScale, this);
        slice.observe(["dx", "dy", "x", "y", "shiftRadius"], this.handleSliceMove, this);
        slice.tooltipText = "{category}: {value.percent.formatNumber('#.#')}% ({value.value})";
        var hoverState = slice.states.create("hover");
        hoverState.properties.scale = 1.05;
        var defaultState = slice.defaultState;
        defaultState.properties.shiftRadius = 0;
        slice.togglable = true;
        slice.events.on("toggled", function (event) {
            event.target.hideTooltip();
        });
        var activeState = slice.states.create("active");
        activeState.properties.shiftRadius = 0.10;
    };
    /**
     * (Re)validates the whole series, effectively causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    PieSeries.prototype.validate = function () {
        this._leftItems = [];
        this._rightItems = [];
        this._currentStartAngle = this.startAngle;
        this._arcRect = getArcRect(this.startAngle, this.endAngle);
        this._maxRadiusPercent = 0;
        for (var i = this.startIndex; i < this.endIndex; i++) {
            var dataItem = this.dataItems.getIndex(i);
            var radiusValuePercent = dataItem.values.radiusValue.percent;
            if (radiusValuePercent > this._maxRadiusPercent) {
                this._maxRadiusPercent = radiusValuePercent;
            }
        }
        _super.prototype.validate.call(this);
        if (this.alignLabels) {
            if (this.startAngle > this.endAngle) {
                this._rightItems.reverse();
            }
            else {
                this._leftItems.reverse();
            }
            this._rightItems.sort(function (a, b) {
                var aAngle = (a.slice.middleAngle + 360) % 360;
                var bAngle = (b.slice.middleAngle + 360) % 360;
                if (aAngle > 270) {
                    aAngle -= 360;
                }
                if (bAngle > 270) {
                    bAngle -= 360;
                }
                if (aAngle < bAngle) {
                    return -1;
                }
                else {
                    return 1;
                }
            });
            this._leftItems.sort(function (a, b) {
                var aAngle = (a.slice.middleAngle + 360) % 360;
                var bAngle = (b.slice.middleAngle + 360) % 360;
                if (aAngle < bAngle) {
                    return 1;
                }
                else {
                    return -1;
                }
            });
            this.arrangeLabels(this._rightItems);
            this.arrangeLabels2(this._rightItems);
            this.arrangeLabels(this._leftItems);
            this.arrangeLabels2(this._leftItems);
        }
    };
    /**
     * Validates data item's element, effectively redrawing it.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    PieSeries.prototype.validateDataElement = function (dataItem) {
        if (this.pixelRadius > 0) {
            if (this.ignoreZeroValues && dataItem.value == 0) {
                dataItem.__disabled = true;
            }
            else {
                dataItem.__disabled = false;
            }
            // SLICE
            var slice = dataItem.slice;
            slice.radius = this.pixelRadius;
            if (isNumber(dataItem.radiusValue)) {
                slice.radius = this.pixelInnerRadius + (this.pixelRadius - this.pixelInnerRadius) * dataItem.values.radiusValue.percent / this._maxRadiusPercent;
            }
            if (!(slice.innerRadius instanceof Percent)) {
                slice.innerRadius = this.pixelInnerRadius;
            }
            slice.startAngle = this._currentStartAngle;
            slice.arc = Math.abs(dataItem.values.value.percent) * (this.endAngle - this.startAngle) / 100;
            // LABEL
            if (!this.labels.template.disabled) {
                var label = dataItem.label;
                var tick = dataItem.tick;
                tick.slice = slice;
                tick.label = label;
                var normalizedMiddleAngle = (slice.middleAngle + 360) % 360; // force angle to be 0 - 360;
                var point = void 0;
                if (this.alignLabels) {
                    var labelRadius = label.pixelRadius(slice.radius);
                    var x = tick.length + labelRadius;
                    label.dx = 0;
                    label.dy = 0;
                    label.verticalCenter = "middle";
                    var arcRect = this._arcRect;
                    // right half
                    if (normalizedMiddleAngle > 270 || normalizedMiddleAngle <= 90) {
                        x += (arcRect.width + arcRect.x) * this.pixelRadius;
                        label.horizontalCenter = "left";
                        this._rightItems.push(dataItem);
                    }
                    // left half
                    else {
                        x -= arcRect.x * this.pixelRadius;
                        label.horizontalCenter = "right";
                        this._leftItems.push(dataItem);
                        x *= -1;
                    }
                    var distance = slice.radius + tick.length + labelRadius;
                    point = { x: x, y: slice.iy * distance };
                    label.moveTo(point);
                }
                else {
                    var depth = slice["depth"];
                    if (!isNumber(depth)) {
                        depth = 0;
                    }
                    label.fixPosition(slice.middleAngle, slice.radius, slice.radiusY, 0, -depth);
                }
            }
            this._currentStartAngle += slice.arc;
            // do this at the end, otherwise bullets won't be positioned properly
            _super.prototype.validateDataElement.call(this, dataItem);
        }
    };
    Object.defineProperty(PieSeries.prototype, "radius", {
        /**
         * @return Radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Outer radius for the series' slices in pixels or [[Percent]].
         *
         * @param value  Radius
         */
        set: function (value) {
            if (this.setPercentProperty("radius", value, true, false, 10, false)) {
                this.invalidateDataItems();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieSeries.prototype, "pixelRadius", {
        /**
         * @return Radius
         * @ignore
         */
        get: function () {
            return this._pixelRadius;
        },
        /**
         * @ignore
         */
        set: function (value) {
            if (this._pixelRadius != value) {
                this._pixelRadius = value;
                this.invalidateDataItems();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieSeries.prototype, "pixelInnerRadius", {
        /**
         * @return Pixel inner radius
         * @ignore
         */
        get: function () {
            return this._pixelInnerRadius;
        },
        /**
         * @ignore
         */
        set: function (value) {
            if (this._pixelInnerRadius != value) {
                this._pixelInnerRadius = value;
                this.invalidateDataItems();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieSeries.prototype, "innerRadius", {
        /**
         * @ignore Exclude from docs
         * @return Radius
         */
        get: function () {
            return this.getPropertyValue("innerRadius");
        },
        /**
         * Inner radius for the series' slices in pixels.
         *
         * @ignore Exclude from docs
         * @todo Redo so that users can set it
         * @param value  Radius
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieSeries.prototype, "startAngle", {
        /**
         * @return Angle
         */
        get: function () {
            var startAngle = this.getPropertyValue("startAngle");
            if (isNumber(startAngle)) {
                return startAngle;
            }
            else {
                return this._startAngleInternal;
            }
        },
        /**
         * Start angle for the series' slices in degrees. (0-360)
         *
         * @param value  Angle
         */
        set: function (value) {
            this.setPropertyValue("startAngle", normalizeAngle(value), true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieSeries.prototype, "endAngle", {
        /**
         * @return Angle
         */
        get: function () {
            var endAngle = this.getPropertyValue("endAngle");
            if (isNumber(endAngle)) {
                return endAngle;
            }
            else {
                return this._endAngleInternal;
            }
        },
        /**
         * End angle for the series' slices in degrees. (0-360)
         *
         * @param value  Angle
         */
        set: function (value) {
            this.setPropertyValue("endAngle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Positions series bullet.
     *
     * @ignore Exclude from docs
     * @param bullet  Bullet
     */
    PieSeries.prototype.positionBullet = function (bullet) {
        _super.prototype.positionBullet.call(this, bullet);
        var dataItem = bullet.dataItem;
        var slice = dataItem.slice;
        var locationX = bullet.locationX;
        if (!isNumber(locationX)) {
            locationX = 0.5;
        }
        var locationY = bullet.locationY;
        if (!isNumber(locationY)) {
            locationY = 1;
        }
        var angle = slice.startAngle + slice.arc * locationX;
        bullet.x = locationY * slice.radius * Math_cos(angle);
        bullet.y = locationY * slice.radiusY * Math_sin(angle);
    };
    /**
     * Repositions bullet and labels when slice moves.
     *
     * @ignore Exclude from docs
     * @param event  Event
     */
    PieSeries.prototype.handleSliceMove = function (event) {
        if (!this.alignLabels) {
            var slice = event.target;
            var dataItem = slice.dataItem;
            // moving textelement, as label dx and dy are already employed for aligning
            //@labeltodo
            if (dataItem) {
                var label = dataItem.label;
                if (label) {
                    label.dx = label.fdx + slice.dx + slice.pixelX;
                    label.dy = label.fdy + slice.dy + slice.pixelY;
                }
            }
        }
    };
    Object.defineProperty(PieSeries.prototype, "bbox", {
        /**
         * Returns bounding box (square) for this element.
         *
         * @ignore Exclude from docs
         */
        get: function () {
            if (this.definedBBox) {
                return this.definedBBox;
            }
            var chart = this.chart;
            if (chart) {
                return getArcRect(chart.startAngle, chart.endAngle, this.pixelRadius);
            }
            return getArcRect(this.startAngle, this.endAngle, this.pixelRadius);
        },
        enumerable: true,
        configurable: true
    });
    return PieSeries;
}(PercentSeries_PercentSeries));

/**
 * bboxter class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["PieSeries"] = PieSeries_PieSeries;
registry.registeredClasses["PieSeriesDataItem"] = PieSeries_PieSeriesDataItem;
//# sourceMappingURL=PieSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/PieChart.js
/**
 * Pie chart module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */








/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[PieChart]].
 *
 * @see {@link DataItem}
 */
var PieChart_PieChartDataItem = /** @class */ (function (_super) {
    __extends(PieChartDataItem, _super);
    /**
     * Constructor
     */
    function PieChartDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "PieChartDataItem";
        _this.applyTheme();
        return _this;
    }
    return PieChartDataItem;
}(PercentChart_PercentChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a Pie chart.
 *
 * ```TypeScript
 * // Includes
 * import * as am4core from "@amcharts/amcharts4/core";
 * import * as am4charts from "@amcharts/amcharts4/charts";
 *
 * // Create chart
 * let chart = am4core.create("chartdiv", am4charts.PieChart);
 *
 * // Set data
 * chart.data = [{
 * 	"country": "Lithuania",
 * 	"litres": 501.9
 * }, {
 * 	"country": "Czechia",
 * 	"litres": 301.9
 * }, {
 * 	"country": "Ireland",
 * 	"litres": 201.1
 * }];
 *
 * // Create series
 * let series = chart.series.push(new am4charts.PieSeries());
 * series.dataFields.value = "litres";
 * series.dataFields.category = "country";
 * ```
 * ```JavaScript
 * // Create chart
 * var chart = am4core.create("chartdiv", am4charts.PieChart);
 *
 * // The following would work as well:
 * // var chart = am4core.create("chartdiv", "PieChart");
 *
 * // Set data
 * chart.data = [{
 * 	"country": "Lithuania",
 * 	"litres": 501.9
 * }, {
 * 	"country": "Czechia",
 * 	"litres": 301.9
 * }, {
 * 	"country": "Ireland",
 * 	"litres": 201.1
 * }];
 *
 * // Create series
 * var series = chart.series.push(new am4charts.PieSeries());
 * series.dataFields.value = "litres";
 * series.dataFields.category = "country";
 * ```
 * ```JSON
 * var chart = am4core.createFromConfig({
 *
 * 	// Series
 * 	"series": [{
 * 		"type": "PieSeries",
 * 		"dataFields": {
 * 			"value": "litres",
 * 			"category": "country"
 * 		}
 * 	}],
 *
 * 	// Data
 * 	"data": [{
 * 		"country": "Lithuania",
 * 		"litres": 501.9
 * 	}, {
 * 		"country": "Czechia",
 * 		"litres": 301.9
 * 	}, {
 * 		"country": "Ireland",
 * 		"litres": 201.1
 * 	}]
 *
 * }, "chartdiv", "PieChart");
 * ```
 *
 * @see {@link IPieChartEvents} for a list of available Events
 * @see {@link IPieChartAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/pie-chart/} for documentation
 * @important
 */
var PieChart_PieChart = /** @class */ (function (_super) {
    __extends(PieChart, _super);
    /**
     * Constructor
     */
    function PieChart() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "PieChart";
        // Set defaults
        _this.innerRadius = 0;
        _this.radius = Percent_percent(80);
        _this.align = "none";
        _this.valign = "none";
        _this.startAngle = -90;
        _this.endAngle = 270;
        var seriesContainer = _this.seriesContainer;
        seriesContainer.isMeasured = true;
        seriesContainer.valign = "middle";
        seriesContainer.align = "center";
        seriesContainer.layout = "absolute";
        seriesContainer.width = undefined;
        seriesContainer.height = undefined;
        // so that the pie is always drawn, even the legend wants all the space
        _this.chartContainer.minHeight = 50;
        _this.chartContainer.minWidth = 50;
        _this.chartContainer.events.on("maxsizechanged", _this.updateRadius, _this, false); // need this for the chart to change radius if legend is removed/disabled
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    PieChart.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Add a default screen reader title for accessibility
        // This will be overridden in screen reader if there are any `titles` set
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Pie chart");
        }
    };
    /**
     * (Re)validates the chart, causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    PieChart.prototype.validateLayout = function () {
        _super.prototype.validateLayout.call(this);
        this.updateRadius();
    };
    /**
     * Decorates a new [[Series]] object with required parameters when it is
     * added to the chart.
     *
     * @ignore Exclude from docs
     * @param event  Event
     */
    PieChart.prototype.handleSeriesAdded = function (event) {
        _super.prototype.handleSeriesAdded.call(this, event);
        this._chartPixelRadius = undefined;
        this.updateSeriesAngles();
    };
    PieChart.prototype.updateSeriesAngles = function () {
        var _this = this;
        this.series.each(function (series) {
            series._startAngleInternal = _this.startAngle;
            series._endAngleInternal = _this.endAngle;
            //series.defaultState.properties.startAngle = this.startAngle;
            //series.defaultState.properties.endAngle = this.endAngle;
        });
    };
    /**
     * Recalculates pie's radius, based on a number of criteria.
     *
     * @ignore Exclude from docs
     */
    PieChart.prototype.updateRadius = function () {
        var chartCont = this.chartContainer;
        var rect = getArcRect(this.startAngle, this.endAngle, 1);
        var innerRect = { x: 0, y: 0, width: 0, height: 0 };
        var innerRadius = this.innerRadius;
        if (innerRadius instanceof Percent) {
            innerRect = getArcRect(this.startAngle, this.endAngle, innerRadius.value);
        }
        // @todo handle this when innerRadius set in pixels (do it for radar also)
        rect = getCommonRectangle([rect, innerRect]);
        var maxRadius = Math.min(chartCont.innerWidth / rect.width, chartCont.innerHeight / rect.height);
        if (!isNumber(maxRadius)) {
            maxRadius = 0;
        }
        var chartRadius = relativeRadiusToValue(this.radius, maxRadius);
        var chartPixelInnerRadius = relativeRadiusToValue(this.innerRadius, maxRadius);
        var seriesRadius = (chartRadius - chartPixelInnerRadius) / this.series.length;
        if (chartRadius != this._chartPixelRadius || chartPixelInnerRadius != this._chartPixelInnerRadius) {
            this._chartPixelRadius = chartRadius;
            this._chartPixelInnerRadius = chartPixelInnerRadius;
            //@todo: make it possible to set series radius in percent
            Iterator_each(indexed(this.series.iterator()), function (a) {
                var i = a[0];
                var series = a[1];
                var radius = chartPixelInnerRadius + relativeRadiusToValue(series.radius, chartRadius - chartPixelInnerRadius);
                var innerRadius = chartPixelInnerRadius + relativeRadiusToValue(series.innerRadius, chartRadius - chartPixelInnerRadius);
                if (!isNumber(radius)) {
                    radius = chartPixelInnerRadius + seriesRadius * (i + 1);
                }
                if (!isNumber(innerRadius)) {
                    innerRadius = chartPixelInnerRadius + seriesRadius * i;
                }
                series.pixelRadius = radius;
                series.pixelInnerRadius = innerRadius;
            });
            this.seriesContainer.definedBBox = { x: chartRadius * rect.x, y: chartRadius * rect.y, width: chartRadius * rect.width, height: chartRadius * rect.height };
            this.seriesContainer.invalidateLayout();
            this.bulletsContainer.x = this.seriesContainer.x;
            this.bulletsContainer.y = this.seriesContainer.y;
        }
    };
    Object.defineProperty(PieChart.prototype, "radius", {
        /**
         * @return Radius (px or relative)
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Sets radius of the pie chart.
         *
         * Setting to a number will mean a fixed pixel radius.
         *
         * Setting to an instance of [[Percent]] will mean a relative radius to
         * available space.
         *
         * E.g.:
         *
         * ```TypeScript
         * // Set pie chart to be at 50% of the available space
         * pieChart.radius = am4core.percent.percent(50);
         * ```
         * ```JavaScript
         * // Set pie chart to be at 50% of the available space
         * pieChart.radius = am4core.percent.percent(50);
         * ```
         * ```JSON
         * {
         *   // Set pie chart to be at 50% of the available space
         *   "radius": "50%"
         * }
         * ```
         *
         * @default 80%
         * @param value  Radius (px or relative)
         */
        set: function (value) {
            if (this.setPercentProperty("radius", value, true, false, 10, false)) {
                this.invalidateLayout();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieChart.prototype, "innerRadius", {
        /**
         * @return Relative inner radius (0-1)
         */
        get: function () {
            return this.getPropertyValue("innerRadius");
        },
        /**
         * Sets relative inner radius (to create a donut chart).
         *
         * Setting to a number will mean a fixed pixel radius.
         *
         * Setting to an instance of [[Percent]] will mean a relative radius to
         * available space.
         *
         * NOTE: it's not related to `radius`.
         *
         * E.g.:
         *
         * ```TypeScript
         * // Set pie chart to be at 50% of the available space
         * pieChart.innerRadius = am4core.percent.percent(50);
         * ```
         * ```JavaScript
         * // Set pie chart to be at 50% of the available space
         * pieChart.innerRadius = am4core.percent.percent(50);
         * ```
         * ```JSON
         * {
         *   // Set pie chart to be at 50% of the available space
         *   "innerRadius": "50%"
         * }
         * ```
         *
         * @default 0
         * @param value  Relative inner radius (0-1)
         * @todo Setting things like `innerRadius` modifies `slice.radius` and it then looks like it is not the same value as in default state
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new [[PieSeries]].
     *
     * @return New series
     */
    PieChart.prototype.createSeries = function () {
        return new PieSeries_PieSeries();
    };
    Object.defineProperty(PieChart.prototype, "startAngle", {
        /**
         * @return Start angle (degrees)
         */
        get: function () {
            return this.getPropertyValue("startAngle");
        },
        /**
         * Starting angle of the Pie circle. (degrees)
         *
         * Normally, a pie chart begins (the left side of the first slice is drawn)
         * at the top center. (at -90 degrees)
         *
         * You can use `startAngle` to change this setting.
         *
         * E.g. setting this to 0 will make the first slice be drawn to the right.
         *
         * For a perfect circle the absolute sum of `startAngle` and `endAngle`
         * needs to be 360.
         *
         * However, it's **not** necessary to do so. You can set to those lesser
         * numbers, to create semi-circles.
         *
         * E.g. `startAngle = -90` with `endAngle = 0` will create a Pie chart that
         * looks like a quarter of a circle.
         *
         * NOTE: This setting is not supported in a 3D pie chart.
         *
         * @default -90
         * @param value  Start angle (degrees)
         */
        set: function (value) {
            if (this.setPropertyValue("startAngle", value)) {
                this.updateRadius();
                this.updateSeriesAngles();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieChart.prototype, "endAngle", {
        /**
         * @return End angle (degrees)
         */
        get: function () {
            return this.getPropertyValue("endAngle");
        },
        /**
         * End angle of the Pie circle. (degrees)
         *
         * Normally, a pie chart ends (the right side of the last slice is drawn)
         * at the top center. (at 270 degrees)
         *
         * You can use `endAngle` to change this setting.
         *
         * For a perfect circle the absolute sum of `startAngle` and `endAngle`
         * needs to be 360.
         *
         * However, it's **not** necessary to do so. You can set to those lesser
         * numbers, to create semi-circles.
         *
         * E.g. `startAngle = -90` with `endAngle = 0` will create a Pie chart that
         * looks like a quarter of a circle.
         *
         * NOTE: This setting is not supported in a 3D pie chart.
         *
         * @default 270
         * @param value  End angle (degrees)
         */
        set: function (value) {
            if (this.setPropertyValue("endAngle", value)) {
                this.updateRadius();
                this.updateSeriesAngles();
            }
        },
        enumerable: true,
        configurable: true
    });
    return PieChart;
}(PercentChart_PercentChart));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["PieChart"] = PieChart_PieChart;
registry.registeredClasses["PieChartDataItem"] = PieChart_PieChartDataItem;
//# sourceMappingURL=PieChart.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/PieSeries3D.js
/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[PieSeries3D]].
 *
 * @see {@link DataItem}
 */
var PieSeries3D_PieSeries3DDataItem = /** @class */ (function (_super) {
    __extends(PieSeries3DDataItem, _super);
    /**
     * Constructor
     */
    function PieSeries3DDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "PieSeries3DDataItem";
        _this.values.depthValue = {};
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(PieSeries3DDataItem.prototype, "depthValue", {
        /**
         * @return Depth
         */
        get: function () {
            return this.values["depthValue"].value;
        },
        /**
         * Slice depth (height).
         *
         * @param value  Depth
         */
        set: function (value) {
            this.setValue("depthValue", value);
        },
        enumerable: true,
        configurable: true
    });
    return PieSeries3DDataItem;
}(PieSeries_PieSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a slice series on a 3D pie chart.
 *
 * @see {@link IPieSeries3DEvents} for a list of available Events
 * @see {@link IPieSeries3DAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var PieSeries3D_PieSeries3D = /** @class */ (function (_super) {
    __extends(PieSeries3D, _super);
    /**
     * Constructor
     */
    function PieSeries3D() {
        var _this = _super.call(this) || this;
        _this.className = "PieSeries3D";
        _this.applyTheme();
        return _this;
    }
    /**
     * Returns a new/empty DataItem of the type appropriate for this object
     * @see {@link DataItem}
     * @return Data Item
     */
    PieSeries3D.prototype.createDataItem = function () {
        return new PieSeries3D_PieSeries3DDataItem();
    };
    /**
     * creates slice
     */
    PieSeries3D.prototype.createSlice = function () {
        return new Slice3D_Slice3D();
    };
    /**
     * Validates data item's element, effectively redrawing it.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    PieSeries3D.prototype.validateDataElement = function (dataItem) {
        var slice = dataItem.slice;
        var depth = this.depth;
        if (!isNumber(depth)) {
            depth = this.chart.depth;
        }
        var depthPercent = dataItem.values.depthValue.percent;
        if (!isNumber(depthPercent)) {
            depthPercent = 100;
        }
        slice.depth = depthPercent * depth / 100;
        var angle = this.angle;
        if (!isNumber(angle)) {
            angle = this.chart.angle;
        }
        slice.angle = angle;
        _super.prototype.validateDataElement.call(this, dataItem);
    };
    /**
     * (Re)validates the whole series, effectively causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    PieSeries3D.prototype.validate = function () {
        _super.prototype.validate.call(this);
        for (var i = this._workingStartIndex; i < this._workingEndIndex; i++) {
            var dataItem = this.dataItems.getIndex(i);
            var slice = dataItem.slice;
            var startAngle = slice.startAngle;
            // find quarter
            //q0 || q1
            if ((startAngle >= -90 && startAngle < 90)) {
                slice.toFront();
            }
            //q2 || q3
            else if ((startAngle >= 90)) {
                slice.toBack();
            }
        }
    };
    Object.defineProperty(PieSeries3D.prototype, "depth", {
        /**
         * @return Depth (px)
         */
        get: function () {
            return this.getPropertyValue("depth");
        },
        /**
         * Depth (height) of the pie slice in pixels.
         *
         * @param value  Depth (px)
         */
        set: function (value) {
            this.setPropertyValue("depth", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieSeries3D.prototype, "angle", {
        /**
         * @return Angle
         */
        get: function () {
            return this.getPropertyValue("angle");
        },
        /**
         * Angle of the view point of the 3D pie. (0-360)
         *
         * @param value  Angle
         */
        set: function (value) {
            this.setPropertyValue("angle", value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Positions series bullet.
     *
     * @ignore Exclude from docs
     * @param bullet  Bullet
     */
    PieSeries3D.prototype.positionBullet = function (bullet) {
        _super.prototype.positionBullet.call(this, bullet);
        var dataItem = bullet.dataItem;
        var slice = dataItem.slice;
        bullet.y = bullet.pixelY - slice.depth;
    };
    return PieSeries3D;
}(PieSeries_PieSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["PieSeries3D"] = PieSeries3D_PieSeries3D;
registry.registeredClasses["PieSeries3DDataItem"] = PieSeries3D_PieSeries3DDataItem;
//# sourceMappingURL=PieSeries3D.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/PieChart3D.js
/**
 * 3D Pie chart module.
 */

/**
 * ============================================================================
 * Imports
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[PieChart3D]].
 *
 * @see {@link DataItem}
 */
var PieChart3D_PieChart3DDataItem = /** @class */ (function (_super) {
    __extends(PieChart3DDataItem, _super);
    /**
     * Constructor
     */
    function PieChart3DDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "PieChart3DDataItem";
        _this.applyTheme();
        return _this;
    }
    return PieChart3DDataItem;
}(PieChart_PieChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a 3D Pie chart.
 *
 *  * ```TypeScript
 * // Includes
 * import * as am4core from "@amcharts/amcharts4/core";
 * import * as am4charts from "@amcharts/amcharts4/charts";
 *
 * // Create chart
 * let chart = am4core.create("chartdiv", am4charts.Pie3DChart);
 *
 * // Set data
 * chart.data = [{
 * 	"country": "Lithuania",
 * 	"litres": 501.9
 * }, {
 * 	"country": "Czechia",
 * 	"litres": 301.9
 * }, {
 * 	"country": "Ireland",
 * 	"litres": 201.1
 * }];
 *
 * // Create series
 * let series = chart.series.push(new am4charts.Pie3DSeries());
 * series.dataFields.value = "litres";
 * series.dataFields.category = "country";
 * ```
 * ```JavaScript
 * // Create chart
 * var chart = am4core.create("chartdiv", am4charts.Pie3DChart);
 *
 * // The following would work as well:
 * // var chart = am4core.create("chartdiv", "Pie3DChart");
 *
 * // Set data
 * chart.data = [{
 * 	"country": "Lithuania",
 * 	"litres": 501.9
 * }, {
 * 	"country": "Czechia",
 * 	"litres": 301.9
 * }, {
 * 	"country": "Ireland",
 * 	"litres": 201.1
 * }];
 *
 * // Create series
 * var series = chart.series.push(new am4charts.Pie3DSeries());
 * series.dataFields.value = "litres";
 * series.dataFields.category = "country";
 * ```
 * ```JSON
 * var chart = am4core.createFromConfig({
 *
 * 	// Series
 * 	"series": [{
 * 		"type": "Pie3DSeries",
 * 		"dataFields": {
 * 			"value": "litres",
 * 			"category": "country"
 * 		}
 * 	}],
 *
 * 	// Data
 * 	"data": [{
 * 		"country": "Lithuania",
 * 		"litres": 501.9
 * 	}, {
 * 		"country": "Czechia",
 * 		"litres": 301.9
 * 	}, {
 * 		"country": "Ireland",
 * 		"litres": 201.1
 * 	}]
 *
 * }, "chartdiv", "Pie3DChart");
 * ```
 *
 * @see {@link IPieChart3DEvents} for a list of available Events
 * @see {@link IPieChart3DAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/pie-chart/} for documentation
 * @important
 */
var PieChart3D_PieChart3D = /** @class */ (function (_super) {
    __extends(PieChart3D, _super);
    /**
     * Constructor
     */
    function PieChart3D() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "PieChart3D";
        _this.depth = 20;
        _this.angle = 10;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(PieChart3D.prototype, "depth", {
        /**
         * @return Depth (px)
         */
        get: function () {
            return this.getPropertyValue("depth");
        },
        /**
         * Depth of the 3D pie in pixels.
         *
         * This will determine "height" of the pie.
         *
         * @default 20
         * @param value  Depth (px)
         */
        set: function (value) {
            if (this.setPropertyValue("depth", value)) {
                this.invalidateDataUsers();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PieChart3D.prototype, "angle", {
        /**
         * @return Angle (degrees)
         */
        get: function () {
            return this.getPropertyValue("angle");
        },
        /**
         * An angle of a "point of view" in degrees. Possible range 0 - 90.
         *
         * @default 10
         * @param value  Angle (degrees)
         */
        set: function (value) {
            value = fitToRange(value, 0, 90);
            if (this.setPropertyValue("angle", value)) {
                this.invalidateDataUsers();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates and returns a new Series.
     *
     * @return New series
     */
    PieChart3D.prototype.createSeries = function () {
        return new PieSeries3D_PieSeries3D();
    };
    return PieChart3D;
}(PieChart_PieChart));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["PieChart3D"] = PieChart3D_PieChart3D;
//# sourceMappingURL=PieChart3D.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/SlicedChart.js
/**
 * Sliced chart module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[SlicedChart]].
 *
 * @see {@link DataItem}
 */
var SlicedChart_SlicedChartDataItem = /** @class */ (function (_super) {
    __extends(SlicedChartDataItem, _super);
    /**
     * Constructor
     */
    function SlicedChartDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "SlicedChartDataItem";
        _this.applyTheme();
        return _this;
    }
    return SlicedChartDataItem;
}(PercentChart_PercentChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a Sliced chart.
 *
 * @see {@link ISlicedChartEvents} for a list of available Events
 * @see {@link ISlicedChartAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/sliced-chart/} for documentation
 * @important
 */
var SlicedChart_SlicedChart = /** @class */ (function (_super) {
    __extends(SlicedChart, _super);
    /**
     * Constructor
     */
    function SlicedChart() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "SlicedChart";
        _this.seriesContainer.layout = "horizontal";
        _this.padding(15, 15, 15, 15);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    SlicedChart.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Add a default screen reader title for accessibility
        // This will be overridden in screen reader if there are any `titles` set
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Sliced chart");
        }
    };
    /**
     * (Re)validates the chart, causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    SlicedChart.prototype.validate = function () {
        _super.prototype.validate.call(this);
    };
    return SlicedChart;
}(PercentChart_PercentChart));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["SlicedChart"] = SlicedChart_SlicedChart;
registry.registeredClasses["SlicedChartDataItem"] = SlicedChart_SlicedChartDataItem;
//# sourceMappingURL=SlicedChart.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/FlowDiagramNode.js
/**
 * FlowDiagramNode module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */












/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a node in a Flow Diagram.
 *
 * A Flow node is a block with a value, which represents its size on the
 * diagram.
 *
 * Nodes are connected via [[FlowLink]] elements.
 *
 * @see {@link IFlowDiagramNodeEvents} for a list of available events
 * @see {@link IFlowDiagramNodeAdapters} for a list of available Adapters
 * @important
 */
var FlowDiagramNode_FlowDiagramNode = /** @class */ (function (_super) {
    __extends(FlowDiagramNode, _super);
    /**
     * Constructor
     */
    function FlowDiagramNode() {
        var _this = _super.call(this) || this;
        /**
         * Settings for the appearance of the related legend items.
         */
        _this.legendSettings = new LegendSettings();
        _this.className = "FlowDiagramNode";
        _this.isMeasured = false;
        // TODO can this be removed ?
        new InterfaceColorSet_InterfaceColorSet();
        _this.draggable = true;
        _this.inert = true;
        _this.setStateOnChildren = true;
        _this.events.on("positionchanged", _this.invalidateLinks, _this, false);
        _this.events.on("sizechanged", _this.invalidateLinks, _this, false);
        return _this;
        //this.events.on("hit", this.handleHit, this, false);
    }
    /**
     * @ignore
     */
    FlowDiagramNode.prototype.handleHit = function (event) {
        if (this.isHidden || this.isHiding) {
            this.show();
        }
        else {
            this.hide();
        }
    };
    /**
     * Shows hidden node.
     *
     * @param duration  Duration of reveal animation (ms)
     * @return Animation
     */
    FlowDiagramNode.prototype.show = function (duration) {
        var animation = _super.prototype.show.call(this, duration);
        this.outgoingDataItems.each(function (dataItem) {
            if (!dataItem.toNode || (dataItem.toNode && !dataItem.toNode.isHidden)) {
                dataItem.setWorkingValue("value", dataItem.getValue("value"), duration);
            }
        });
        this.incomingDataItems.each(function (dataItem) {
            if (!dataItem.fromNode || (dataItem.fromNode && !dataItem.fromNode.isHidden)) {
                dataItem.setWorkingValue("value", dataItem.getValue("value"), duration);
            }
        });
        return animation;
    };
    /**
     * Hides node.
     *
     * @param duration  Duration of hiding animation (ms)
     * @return Animation
     */
    FlowDiagramNode.prototype.hide = function (duration) {
        var animation = _super.prototype.hide.call(this, duration);
        this.outgoingDataItems.each(function (dataItem) {
            dataItem.setWorkingValue("value", 0, duration);
        });
        this.incomingDataItems.each(function (dataItem) {
            dataItem.setWorkingValue("value", 0, duration);
        });
        return animation;
    };
    /**
     * Marks node as invalid, for redrawal in the next update cycle.
     *
     * @ignore Exclude from docs
     */
    FlowDiagramNode.prototype.validate = function () {
        if (!this.isDisposed()) {
            _super.prototype.validate.call(this);
            this.invalidateLinks();
        }
    };
    /**
     * Invalidates all links, attached to this node.
     *
     * @ignore Exclude from docs
     */
    FlowDiagramNode.prototype.invalidateLinks = function () {
        var _this = this;
        this.outgoingDataItems.each(function (dataItem) {
            var link = dataItem.link;
            if (link.colorMode == "fromNode") {
                link.fill = link.dataItem.fromNode.color;
            }
            if (link.colorMode == "gradient") {
                link.fill = link.gradient;
                link.stroke = link.gradient;
                var stop_1 = link.gradient.stops.getIndex(0);
                if (stop_1) {
                    stop_1.color = _this.color;
                    link.gradient.validate();
                }
            }
        });
        this.incomingDataItems.each(function (dataItem) {
            var link = dataItem.link;
            if (link.colorMode == "toNode") {
                link.fill = link.dataItem.toNode.color;
            }
            if (link.colorMode == "gradient") {
                link.fill = link.gradient;
                link.stroke = link.gradient;
                var stop_2 = link.gradient.stops.getIndex(1);
                if (stop_2) {
                    stop_2.color = _this.color;
                    link.gradient.validate();
                }
            }
        });
    };
    Object.defineProperty(FlowDiagramNode.prototype, "incomingDataItems", {
        /**
         * List of incoming items (links).
         *
         * @readonly
         * @return Incoming items
         */
        get: function () {
            var _this = this;
            if (!this._incomingDataItems) {
                var incomingDataItems = new List_List();
                incomingDataItems.events.on("inserted", function () {
                    if (_this.chart.sortBy == "name") {
                        _this._incomingSorted = Iterator_sort(_this._incomingDataItems.iterator(), function (x, y) { return order(x.fromName, y.fromName); });
                    }
                    else if (_this.chart.sortBy == "value") {
                        _this._incomingSorted = Iterator_sort(_this._incomingDataItems.iterator(), function (x, y) { return reverse(Number_order(x.value, y.value)); });
                    }
                    else {
                        _this._incomingSorted = _this._incomingDataItems.iterator();
                    }
                }, undefined, false);
                this._incomingDataItems = incomingDataItems;
            }
            return this._incomingDataItems;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramNode.prototype, "outgoingDataItems", {
        /**
         * List of outgoing items (links).
         *
         * @readonly
         * @return Outgoing items
         */
        get: function () {
            var _this = this;
            if (!this._outgoingDataItems) {
                var outgoingDataItems = new List_List();
                outgoingDataItems.events.on("inserted", function () {
                    if (_this.chart.sortBy == "name") {
                        _this._outgoingSorted = Iterator_sort(_this._outgoingDataItems.iterator(), function (x, y) { return order(x.fromName, y.fromName); });
                    }
                    else if (_this.chart.sortBy == "value") {
                        _this._outgoingSorted = Iterator_sort(_this._outgoingDataItems.iterator(), function (x, y) { return reverse(Number_order(x.value, y.value)); });
                    }
                    else {
                        _this._outgoingSorted = _this._outgoingDataItems.iterator();
                    }
                }, undefined, false);
                this._outgoingDataItems = outgoingDataItems;
            }
            return this._outgoingDataItems;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramNode.prototype, "name", {
        /**
         * @return Name
         */
        get: function () {
            return this.getPropertyValue("name");
        },
        /**
         * A name of the node.
         *
         * @param value  Name
         */
        set: function (value) {
            this.setPropertyValue("name", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramNode.prototype, "total", {
        /**
         * @return Value
         */
        get: function () {
            return this.getPropertyValue("total");
        },
        /**
         * Sum of all incoming+outgoing link values
         *
         * @param value  Value
         */
        set: function (value) {
            this.setPropertyValue("total", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramNode.prototype, "totalIncoming", {
        /**
         * @return Value
         */
        get: function () {
            return this.getPropertyValue("totalIncoming");
        },
        /**
         * Sum of all incomming link values.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setPropertyValue("totalIncoming", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramNode.prototype, "totalOutgoing", {
        /**
         * @return Value
         */
        get: function () {
            return this.getPropertyValue("totalOutgoing");
        },
        /**
         * Sum of all outgoing link values.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setPropertyValue("totalOutgoing", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramNode.prototype, "color", {
        /**
         * @return Color
         */
        get: function () {
            return this.getPropertyValue("color");
        },
        /**
         * Node's color.
         *
         * @param value  Color
         */
        set: function (value) {
            this.setColorProperty("color", value);
            if (this._background) {
                this._background.fill = value;
            }
            this.fill = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates elements in related legend container, that mimics the look of this
     * Series.
     *
     * @ignore Exclude from docs
     * @param marker  Legend item container
     */
    FlowDiagramNode.prototype.createLegendMarker = function (marker) {
        var w = marker.pixelWidth;
        var h = marker.pixelHeight;
        marker.removeChildren();
        var column = marker.createChild(RoundedRectangle_RoundedRectangle);
        column.shouldClone = false;
        copyProperties(this, column, visualProperties);
        column.stroke = this.fill;
        column.copyFrom(this);
        column.padding(0, 0, 0, 0); // if columns will have padding (which is often), legend marker will be very narrow
        column.width = w;
        column.height = h;
        var legendDataItem = marker.dataItem;
        legendDataItem.color = column.fill;
        legendDataItem.colorOrig = column.fill;
    };
    Object.defineProperty(FlowDiagramNode.prototype, "legendDataItem", {
        /**
         * @return Data item
         */
        get: function () {
            return this._legendDataItem;
        },
        /**
         * Legend data item that corresponds to this series.
         *
         * @param value  Data item
         */
        set: function (value) {
            this._legendDataItem = value;
            this._legendDataItem.itemContainer.deepInvalidate();
        },
        enumerable: true,
        configurable: true
    });
    return FlowDiagramNode;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["FlowDiagramNode"] = FlowDiagramNode_FlowDiagramNode;
//# sourceMappingURL=FlowDiagramNode.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/FlowDiagramLink.js
/**
 * FlowDiagramLink module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */












/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * This class creates a link (waved color-filled line) between two nodes in a
 * Flow Diagram.
 *
 * @see {@link IFlowDiagramLinkEvents} for a list of available events
 * @see {@link IFlowDiagramLinkAdapters} for a list of available Adapters
 * @important
 */
var FlowDiagramLink_FlowDiagramLink = /** @class */ (function (_super) {
    __extends(FlowDiagramLink, _super);
    /**
     * Constructor
     */
    function FlowDiagramLink() {
        var _this = _super.call(this) || this;
        _this.className = "FlowDiagramLink";
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.maskBullets = false;
        _this.colorMode = "fromNode";
        _this.layout = "none";
        _this.isMeasured = false;
        _this.startAngle = 0;
        _this.endAngle = 0;
        _this.strokeOpacity = 0;
        // this is very important, otherwise the container will be shifted
        _this.verticalCenter = "none";
        _this.horizontalCenter = "none";
        _this.tooltipText = "{fromName}→{toName}:{value.value}";
        _this.tooltipLocation = 0.5;
        _this.link = _this.createChild(Sprite_Sprite);
        _this.link.shouldClone = false;
        _this.link.setElement(_this.paper.add("path"));
        _this.link.isMeasured = false;
        _this.fillOpacity = 0.2;
        _this.fill = interfaceColors.getFor("alternativeBackground");
        _this.applyTheme();
        return _this;
    }
    /**
     * Positions bullets
     * @ignore
     */
    FlowDiagramLink.prototype.positionBullets = function () {
        var _this = this;
        Iterator_each(this.bullets.iterator(), function (bullet) {
            bullet.parent = _this.bulletsContainer;
            bullet.maxWidth = _this.maxWidth;
            bullet.maxHeight = _this.maxHeight;
            _this.positionBullet(bullet);
        });
    };
    Object.defineProperty(FlowDiagramLink.prototype, "bulletsContainer", {
        /**
         * Bullets container
         */
        get: function () {
            if (!this._bulletsContainer) {
                var bulletsContainer = this.createChild(Container_Container);
                bulletsContainer.shouldClone = false;
                bulletsContainer.layout = "none";
                this._bulletsContainer = bulletsContainer;
            }
            return this._bulletsContainer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramLink.prototype, "bulletsMask", {
        /**
         * Bullets mask sprite
         */
        get: function () {
            if (!this._bulletsMask) {
                var bulletsMask = this.createChild(Sprite_Sprite);
                bulletsMask.shouldClone = false;
                bulletsMask.setElement(this.paper.add("path"));
                bulletsMask.isMeasured = false;
                this._bulletsMask = bulletsMask;
            }
            return this._bulletsMask;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Positions bullets at relative bullet.locationX position on the link.
     * @ignore
     */
    FlowDiagramLink.prototype.positionBullet = function (bullet) {
        var location = bullet.locationX;
        if (!isNumber(location)) {
            location = bullet.locationY;
        }
        if (!isNumber(location)) {
            location = 0.5;
        }
        var point = this.middleLine.positionToPoint(location);
        bullet.moveTo(point);
        var rotationField = bullet.propertyFields.rotation;
        var angle;
        if (bullet.dataItem) {
            var dataContext = bullet.dataItem.dataContext;
            angle = dataContext[rotationField];
        }
        if (!isNumber(angle)) {
            angle = point.angle;
        }
        bullet.rotation = angle;
    };
    Object.defineProperty(FlowDiagramLink.prototype, "startAngle", {
        /**
         * @return Start angle
         */
        get: function () {
            return this.getPropertyValue("startAngle");
        },
        /**
         * [startAngle description]
         *
         * @todo Description
         * @param value  Start angle
         */
        set: function (value) {
            this.setPropertyValue("startAngle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramLink.prototype, "endAngle", {
        /**
         * @return End angle
         */
        get: function () {
            return this.getPropertyValue("endAngle");
        },
        /**
         * [endAngle description]
         *
         * @todo Description
         * @param value  End angle
         */
        set: function (value) {
            this.setPropertyValue("endAngle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramLink.prototype, "colorMode", {
        /**
         * Fill mode
         */
        get: function () {
            return this.getPropertyValue("colorMode");
        },
        /**
         * Should link be filled with a solid color, color of from node, color of toNode or gradient between node colors.
         * Some of the links, like ChordLink does not support gradiens well.
         *
         * @param value  Fill mode
         */
        set: function (value) {
            if (value == "gradient") {
                var color = this.fill;
                this.gradient.stops.clear();
                if (color instanceof Color_Color) {
                    this.gradient.addColor(color);
                    this.gradient.addColor(color);
                }
                this.fill = this.gradient;
                this.stroke = this.gradient;
            }
            this.setPropertyValue("colorMode", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramLink.prototype, "maskBullets", {
        /**
         * @return mask bullets value
         */
        get: function () {
            return this.getPropertyValue("maskBullets");
        },
        /**
         * Should link bullets be masked or not
         *
         * @param value
         * @default false
         */
        set: function (value) {
            this.setPropertyValue("maskBullets", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramLink.prototype, "tooltipLocation", {
        /**
         * Tooltip location value
         */
        get: function () {
            return this.getPropertyValue("tooltipLocation");
        },
        /**
         * Relative location of a tooltip.
         * @default 0.5
         *
         * @param value
         */
        set: function (value) {
            this.setPropertyValue("tooltipLocation", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds color steps in the link gradient.
     *
     * @param value  Fill option
     */
    FlowDiagramLink.prototype.setFill = function (value) {
        _super.prototype.setFill.call(this, value);
        var gradient = this._gradient;
        if (gradient && value instanceof Color_Color) {
            gradient.stops.clear();
            gradient.addColor(value);
            gradient.addColor(value);
        }
    };
    /**
     * Updates bounding box based on element dimension settings.
     *
     * @ignore Exclude from docs
     */
    FlowDiagramLink.prototype.measureElement = function () {
    };
    Object.defineProperty(FlowDiagramLink.prototype, "bullets", {
        /**
         * List of bullets
         *
         * @return [description]
         */
        get: function () {
            var _this = this;
            if (!this._bullets) {
                this._bullets = new List_ListTemplate(new Bullet_Bullet());
                this._disposers.push(new List_ListDisposer(this._bullets));
                this._disposers.push(this._bullets.template);
                this._bullets.events.on("inserted", function (event) {
                    event.newValue.events.on("propertychanged", function (event) {
                        if (event.property == "locationX" || event.property == "locationY") {
                            _this.positionBullet(event.target);
                        }
                    }, undefined, false);
                }, undefined, false);
            }
            return this._bullets;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies properties from another [[FlowDiagramLink]].
     *
     * @param source  Source link
     */
    FlowDiagramLink.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.bullets.copyFrom(source.bullets);
        var middleLine = this.middleLine;
        if (middleLine) {
            if (middleLine instanceof Line_Line && source.middleLine instanceof Line_Line) {
                middleLine.copyFrom(source.middleLine);
            }
            if (middleLine instanceof Polyline_Polyline && source.middleLine instanceof Polyline_Polyline) {
                middleLine.copyFrom(source.middleLine);
            }
        }
        this.link.copyFrom(source.link);
    };
    /**
     * @ignore Exclude from docs
     * @return Tooltip X (px)
     */
    FlowDiagramLink.prototype.getTooltipX = function () {
        if (this.middleLine) {
            return this.middleLine.positionToPoint(this.tooltipLocation).x;
        }
    };
    /**
     * @ignore Exclude from docs
     * @return Tooltip Y (px)
     */
    FlowDiagramLink.prototype.getTooltipY = function () {
        if (this.middleLine) {
            return this.middleLine.positionToPoint(this.tooltipLocation).y;
        }
    };
    Object.defineProperty(FlowDiagramLink.prototype, "gradient", {
        /**
         * A gradiend instance that is used to provided colored gradient fills for
         * the Flow link.
         */
        get: function () {
            if (!this._gradient) {
                this._gradient = new LinearGradient_LinearGradient();
            }
            return this._gradient;
        },
        enumerable: true,
        configurable: true
    });
    return FlowDiagramLink;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["FlowDiagramLink"] = FlowDiagramLink_FlowDiagramLink;
//# sourceMappingURL=FlowDiagramLink.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/FlowDiagram.js
/**
 * FlowDiagram module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */















/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
//@todo rearange notes after dragged
/**
 * Defines a [[DataItem]] for [[FlowDiagram]].
 *
 * @see {@link DataItem}
 */
var FlowDiagram_FlowDiagramDataItem = /** @class */ (function (_super) {
    __extends(FlowDiagramDataItem, _super);
    /**
     * Constructor
     */
    function FlowDiagramDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "FlowDiagramDataItem";
        _this.values.value = {};
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(FlowDiagramDataItem.prototype, "fromName", {
        /**
         * @return name
         */
        get: function () {
            return this.properties.fromName;
        },
        /**
         * Source node's name.
         *
         * @param value  Name
         */
        set: function (value) {
            this.setProperty("fromName", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramDataItem.prototype, "toName", {
        /**
         * @return name
         */
        get: function () {
            return this.properties.toName;
        },
        /**
         * Destination node's name.
         *
         * @param value  Name
         */
        set: function (value) {
            this.setProperty("toName", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramDataItem.prototype, "color", {
        /**
         * @return color
         */
        get: function () {
            return this.properties.color;
        },
        /**
         * Node color
         *
         * @param value  Name
         */
        set: function (value) {
            this.setProperty("color", toColor(value));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramDataItem.prototype, "value", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.value.value;
        },
        /**
         * Link's value.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("value", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagramDataItem.prototype, "link", {
        /**
         * A visual element, representing link between the source and target nodes.
         *
         * Link's actual thickness will be determined by `value` of this link and
         * `value` of the source node.
         *
         * @readonly
         * @return Link element
         */
        get: function () {
            var _this = this;
            if (!this._link) {
                var link_1 = this.component.links.create();
                this._link = link_1;
                this.addSprite(link_1);
                this._disposers.push(new Disposer(function () {
                    if (_this.component) {
                        _this.component.links.removeValue(link_1);
                    }
                }));
            }
            return this._link;
        },
        enumerable: true,
        configurable: true
    });
    return FlowDiagramDataItem;
}(Chart_ChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a Pie chart
 * @see {@link IFlowDiagramEvents} for a list of available Events
 * @see {@link IFlowDiagramAdapters} for a list of available Adapters
 * @important
 */
var FlowDiagram_FlowDiagram = /** @class */ (function (_super) {
    __extends(FlowDiagram, _super);
    /**
     * Constructor
     */
    function FlowDiagram() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * A Color Set to use when applying/generating colors for each subsequent
         * node.
         */
        _this.colors = new ColorSet_ColorSet();
        _this.className = "FlowDiagram";
        _this.nodePadding = 20;
        _this.sortBy = "none";
        _this.sequencedInterpolation = true;
        _this.colors.step = 2;
        _this.minNodeSize = 0.02;
        var linksContainer = _this.chartContainer.createChild(Container_Container);
        linksContainer.shouldClone = false;
        linksContainer.layout = "none";
        linksContainer.isMeasured = false;
        _this.linksContainer = linksContainer;
        var nodesContainer = _this.chartContainer.createChild(Container_Container);
        nodesContainer.shouldClone = false;
        nodesContainer.layout = "none";
        nodesContainer.isMeasured = false;
        _this.nodesContainer = nodesContainer;
        // this data item holds sums, averages, etc
        _this.dataItem = _this.createDataItem();
        _this.dataItem.component = _this;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    FlowDiagram.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.dataItem.dispose();
    };
    /**
     * (Re)validates chart's data, effectively causing the chart to redraw.
     *
     * @ignore Exclude from docs
     */
    FlowDiagram.prototype.validateData = function () {
        var _this = this;
        if (this._parseDataFrom == 0) {
            this.nodes.clear();
        }
        this.sortNodes();
        this.colors.reset();
        _super.prototype.validateData.call(this);
        var sum = 0;
        var count = 0;
        var low;
        var high;
        // build blocks
        Iterator_each(this.dataItems.iterator(), function (dataItem) {
            var fromName = dataItem.fromName;
            if (fromName) {
                var node = _this.nodes.getKey(fromName);
                if (!node) {
                    node = _this.nodes.create(fromName);
                    node.name = fromName;
                    node.chart = _this;
                    node.dataItem = dataItem;
                }
                dataItem.fromNode = node;
                dataItem.fromNode.outgoingDataItems.push(dataItem);
            }
            var toName = dataItem.toName;
            if (toName) {
                var node = _this.nodes.getKey(toName);
                if (!node) {
                    node = _this.nodes.create(toName);
                    node.name = toName;
                    node.chart = _this;
                    node.dataItem = dataItem;
                }
                dataItem.toNode = node;
                dataItem.toNode.incomingDataItems.push(dataItem);
            }
            if (!dataItem.fromNode) {
                var strokeModifier = new LinearGradientModifier_LinearGradientModifier();
                strokeModifier.opacities = [0, 1];
                dataItem.link.strokeModifier = strokeModifier;
            }
            if (!dataItem.toNode) {
                var fillModifier = new LinearGradientModifier_LinearGradientModifier();
                fillModifier.opacities = [1, 0];
                dataItem.link.strokeModifier = fillModifier;
            }
            var value = dataItem.value;
            if (isNumber(value)) {
                sum += value;
                count++;
                if (low > value || !isNumber(low)) {
                    low = value;
                }
                if (high < value || !isNumber(high)) {
                    high = value;
                }
            }
        });
        var key = "value";
        this.dataItem.setCalculatedValue(key, high, "high");
        this.dataItem.setCalculatedValue(key, low, "low");
        this.dataItem.setCalculatedValue(key, sum, "sum");
        this.dataItem.setCalculatedValue(key, sum / count, "average");
        this.dataItem.setCalculatedValue(key, count, "count");
        Iterator_each(this.nodes.iterator(), function (strNode) {
            var node = strNode[1];
            if (node.fill instanceof Color_Color) {
                node.color = node.fill;
            }
            if (node.color == undefined) {
                node.color = _this.colors.next();
            }
            if (node.dataItem.color != undefined) {
                node.color = node.dataItem.color;
            }
            if (!node.dataItem.visible) {
                node.hide(0);
            }
            _this.getNodeValue(node);
        });
        this.sortNodes();
        this.feedLegend();
    };
    /**
     * [handleDataItemWorkingValueChange description]
     *
     * @ignore Exclude from docs
     */
    FlowDiagram.prototype.handleDataItemWorkingValueChange = function (dataItem, name) {
        this.invalidate();
    };
    /**
     * Sorts nodes by either their values or names, based on `sortBy` setting.
     */
    FlowDiagram.prototype.sortNodes = function () {
        if (this.sortBy == "name") {
            this._sorted = this.nodes.sortedIterator();
        }
        else if (this.sortBy == "value") {
            this._sorted = Iterator_sort(this.nodes.iterator(), function (x, y) { return reverse(Number_order(x[1].total, y[1].total)); });
        }
        else {
            this._sorted = this.nodes.iterator();
        }
    };
    /**
     * Updates a cummulative value of the node.
     *
     * A node's value is determined by summing values of all of the incoming
     * links or all of the outgoing links, whichever results in bigger number.
     *
     * @param node  Node value
     */
    FlowDiagram.prototype.getNodeValue = function (node) {
        // todo: totalIncomming totalOutgoing, total
        var incomingTotal = 0;
        var outgoingTotal = 0;
        Iterator_each(node.incomingDataItems.iterator(), function (dataItem) {
            var value = dataItem.getWorkingValue("value");
            if (isNumber(value)) {
                incomingTotal += value;
            }
        });
        Iterator_each(node.outgoingDataItems.iterator(), function (dataItem) {
            var value = dataItem.getWorkingValue("value");
            if (isNumber(value)) {
                outgoingTotal += value;
            }
        });
        node.total = incomingTotal + outgoingTotal;
        node.totalIncoming = incomingTotal;
        node.totalOutgoing = outgoingTotal;
    };
    ;
    /**
     * Changes the sort type of the nodes.
     *
     * This will actually reshuffle nodes using nice animation.
     */
    FlowDiagram.prototype.changeSorting = function () {
        this.sortNodes();
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    FlowDiagram.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Add a default screen reader title for accessibility
        // This will be overridden in screen reader if there are any `titles` set
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Flow diagram");
        }
    };
    /**
     * Creates and returns a new data item.
     *
     * @return Data item
     */
    FlowDiagram.prototype.createDataItem = function () {
        return new FlowDiagram_FlowDiagramDataItem();
    };
    Object.defineProperty(FlowDiagram.prototype, "nodePadding", {
        /**
         * @return Padding (px)
         */
        get: function () {
            return this.getPropertyValue("nodePadding");
        },
        /**
         * Padding for node square in pixels.
         *
         * Padding will add extra space around node's name label.
         *
         * @param value Padding (px)
         */
        set: function (value) {
            this.setPropertyValue("nodePadding", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagram.prototype, "sortBy", {
        /**
         * @returns Node sorting
         */
        get: function () {
            return this.getPropertyValue("sortBy");
        },
        /**
         * Sort nodes by "name" or "value" or do not sort at all. If not sorted, nodes will appear in the same order as they are in the data.
         * @default "none"
         * @param value  Node sorting
         */
        set: function (value) {
            this.setPropertyValue("sortBy", value);
            this.changeSorting();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagram.prototype, "minNodeSize", {
        /**
         * @returns min node size
         */
        get: function () {
            return this.getPropertyValue("minNodeSize");
        },
        /**
         * Sometimes nodes can get very small if their value is little. With this setting you
         * can set min size of a node (this is relative value from the total size of all nodes)
         * @default 0.02
         * @param value  Node sorting
         */
        set: function (value) {
            this.setPropertyValue("minNodeSize", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FlowDiagram.prototype, "nodes", {
        /**
         * A list of chart's nodes.
         *
         * @param {DictionaryTemplate<string, this["_node"]>}
         */
        get: function () {
            if (!this._nodes) {
                var template = this.createNode();
                template.events.on("hit", function (event) {
                    event.target.handleHit(event);
                });
                this._nodes = new Dictionary_DictionaryTemplate(template);
                this._disposers.push(new Dictionary_DictionaryDisposer(this._nodes));
            }
            return this._nodes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    FlowDiagram.prototype.createNode = function () {
        var node = new FlowDiagramNode_FlowDiagramNode();
        this._disposers.push(node);
        return node;
    };
    Object.defineProperty(FlowDiagram.prototype, "links", {
        /**
         * A list of chart's links.
         *
         * @param {ListTemplate<this["_link"]>}
         */
        get: function () {
            if (!this._links) {
                this._links = new List_ListTemplate(this.createLink());
                this._disposers.push(new List_ListDisposer(this._links));
            }
            return this._links;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    FlowDiagram.prototype.createLink = function () {
        var link = new FlowDiagramLink_FlowDiagramLink();
        this._disposers.push(link);
        return link;
    };
    /**
     * Setups the legend to use the chart's data.
     * @ignore
     */
    FlowDiagram.prototype.feedLegend = function () {
        var legend = this.legend;
        if (legend) {
            var legendData_1 = [];
            this.nodes.each(function (key, node) {
                legendData_1.push(node);
            });
            legend.data = legendData_1;
            legend.dataFields.name = "name";
        }
    };
    /**
     * @ignore
     */
    FlowDiagram.prototype.disposeData = function () {
        _super.prototype.disposeData.call(this);
        this.nodes.clear();
    };
    return FlowDiagram;
}(Chart_Chart));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["FlowDiagram"] = FlowDiagram_FlowDiagram;
//# sourceMappingURL=FlowDiagram.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/LabelBullet.js
/**
 * Bullet module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a bullet with a textual label.
 *
 * Uses [[Label]] instance to draw the label, so the label itself is
 * configurable.
 *
 * @see {@link IBulletEvents} for a list of available events
 * @see {@link IBulletAdapters} for a list of available Adapters
 * @todo Usage example
 * @important
 */
var LabelBullet_LabelBullet = /** @class */ (function (_super) {
    __extends(LabelBullet, _super);
    /**
     * Constructor
     */
    function LabelBullet() {
        var _this = _super.call(this) || this;
        _this.className = "LabelBullet";
        var label = _this.createChild(Label_Label);
        label.shouldClone = false;
        label.verticalCenter = "middle";
        label.horizontalCenter = "middle";
        label.truncate = true;
        label.hideOversized = false;
        label.maxWidth = 500;
        label.maxHeight = 500;
        label.stroke = Color_color();
        label.strokeOpacity = 0;
        label.fill = new InterfaceColorSet_InterfaceColorSet().getFor("text");
        _this.events.on("maxsizechanged", _this.handleMaxSize, _this, false);
        _this.label = label;
        // not good, as lineSeries will have labels somewhere in the middle.
        //this.locationX = 0.5;
        //this.locationY = 0.5;
        _this.applyTheme();
        return _this;
    }
    LabelBullet.prototype.handleMaxSize = function () {
        this.label.maxWidth = this.maxWidth;
        this.label.maxHeight = this.maxHeight;
    };
    /**
     * Copies all proprities and related stuff from another instance of
     * [[LabelBullet]].
     *
     * @param source  Source element
     */
    LabelBullet.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.label.copyFrom(source.label);
    };
    return LabelBullet;
}(Bullet_Bullet));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["LabelBullet"] = LabelBullet_LabelBullet;
//# sourceMappingURL=LabelBullet.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/SankeyNode.js
/**
 * SankeyNode module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a node in a Sankey Diagram.
 *
 * A Sankey node is a block with a value, which represents its size on the
 * diagram.
 *
 * Nodes are connected via [[SankeyLink]] elements.
 *
 * @see {@link ISankeyNodeEvents} for a list of available events
 * @see {@link ISankeyNodeAdapters} for a list of available Adapters
 * @important
 */
var SankeyNode_SankeyNode = /** @class */ (function (_super) {
    __extends(SankeyNode, _super);
    /**
     * Constructor
     */
    function SankeyNode() {
        var _this = _super.call(this) || this;
        /**
         * [nextInCoord description]
         *
         * @ignore Exclude from docs
         * @todo Description
         */
        _this.nextInCoord = 0;
        /**
         * [nextOutCoord description]
         *
         * @ignore Exclude from docs
         * @todo Description
         */
        _this.nextOutCoord = 0;
        _this.className = "SankeyNode";
        _this.width = 10;
        _this.height = 10;
        var nameLabel = _this.createChild(LabelBullet_LabelBullet);
        nameLabel.shouldClone = false;
        //@should we auto update these locations if position is changed?
        nameLabel.locationX = 1;
        nameLabel.locationY = 0.5;
        nameLabel.label.text = "{name}";
        //nameLabel.label.textElement.hideOversized = false;
        nameLabel.width = 150;
        nameLabel.height = 150;
        nameLabel.label.horizontalCenter = "left";
        nameLabel.label.padding(0, 5, 0, 5);
        _this.nameLabel = nameLabel;
        var valueLabel = _this.createChild(LabelBullet_LabelBullet);
        valueLabel.shouldClone = false;
        valueLabel.label.hideOversized = false;
        valueLabel.locationX = 0.5;
        valueLabel.locationY = 0.5;
        valueLabel.width = 150;
        valueLabel.height = 150;
        //valueLabel.label.text = "{value}";
        valueLabel.label.horizontalCenter = "middle";
        _this.valueLabel = valueLabel;
        var hiddenState = _this.hiddenState;
        hiddenState.properties.fill = new InterfaceColorSet_InterfaceColorSet().getFor("disabledBackground");
        hiddenState.properties.opacity = 0.5;
        hiddenState.properties.visible = true;
        _this.background.hiddenState.copyFrom(hiddenState);
        return _this;
    }
    /**
     * Invalidates all links, attached to this node.
     *
     * @ignore Exclude from docs
     */
    SankeyNode.prototype.invalidateLinks = function () {
        var _this = this;
        _super.prototype.invalidateLinks.call(this);
        this.nextInCoord = 0;
        this.nextOutCoord = 0;
        var chart = this.chart;
        if (chart) {
            var orientation_1 = chart.orientation;
            if (this._incomingSorted) {
                Iterator_each(this._incomingSorted, function (dataItem) {
                    var link = dataItem.link;
                    var value = dataItem.getWorkingValue("value");
                    if (isNumber(value)) {
                        link.parent = _this.chart.linksContainer;
                        var x = void 0;
                        var y = void 0;
                        var angle = void 0;
                        if (orientation_1 == "horizontal") {
                            x = _this.pixelX + _this.dx;
                            y = _this.nextInCoord + _this.pixelY + _this.dy;
                            angle = 0;
                        }
                        else {
                            y = _this.pixelY + _this.dy;
                            x = _this.nextInCoord + _this.pixelX + _this.dx;
                            angle = 90;
                        }
                        link.endX = x;
                        link.endY = y;
                        link.startAngle = angle;
                        link.endAngle = angle;
                        link.gradient.rotation = angle;
                        link.linkWidth = value * chart.valueHeight;
                        if (!dataItem.fromNode) {
                            if (orientation_1 == "horizontal") {
                                link.maxWidth = 200;
                                link.startX = _this.pixelX + _this.dx - link.maxWidth;
                                link.startY = link.endY;
                            }
                            else {
                                link.maxHeight = 200;
                                link.startX = link.endX;
                                link.startY = _this.pixelY + _this.dy - link.maxHeight;
                            }
                            // TODO is this needed ?
                            used(link.gradient);
                            link.fill = dataItem.toNode.color;
                            var stop_1 = link.gradient.stops.getIndex(0);
                            if (stop_1) {
                                if (link.colorMode == "gradient") {
                                    stop_1.color = _this.color;
                                }
                                stop_1.opacity = 0;
                                link.fill = link.gradient;
                                link.stroke = link.gradient;
                                link.gradient.validate();
                            }
                        }
                        //link.validate();
                        _this.nextInCoord += link.linkWidth;
                    }
                });
            }
            if (this._outgoingSorted) {
                Iterator_each(this._outgoingSorted, function (dataItem) {
                    var link = dataItem.link;
                    link.parent = _this.chart.linksContainer;
                    var value = dataItem.getWorkingValue("value");
                    if (isNumber(value)) {
                        var x = void 0;
                        var y = void 0;
                        var angle = void 0;
                        if (orientation_1 == "horizontal") {
                            angle = 0;
                            x = _this.pixelX + _this.pixelWidth + _this.dx - 1;
                            y = _this.nextOutCoord + _this.pixelY + _this.dy;
                        }
                        else {
                            angle = 90;
                            x = _this.nextOutCoord + _this.pixelX + _this.dx;
                            y = _this.pixelY + _this.pixelHeight + _this.dy - 1;
                        }
                        link.startX = x;
                        link.startY = y;
                        link.startAngle = angle;
                        link.endAngle = angle;
                        link.gradient.rotation = angle;
                        link.linkWidth = value * _this.chart.valueHeight;
                        if (!dataItem.toNode) {
                            if (orientation_1 == "horizontal") {
                                link.maxWidth = 200;
                                link.endX = _this.pixelX + link.maxWidth + _this.dx;
                                link.endY = link.startY;
                            }
                            else {
                                link.maxHeight = 200;
                                link.endX = link.startX;
                                link.endY = _this.pixelY + link.maxHeight + _this.dy;
                            }
                            link.opacity = _this.opacity;
                            var stop_2 = link.gradient.stops.getIndex(1);
                            if (stop_2) {
                                if (link.colorMode == "gradient") {
                                    stop_2.color = _this.color;
                                }
                                stop_2.opacity = 0;
                                link.fill = link.gradient;
                                link.stroke = link.gradient;
                                link.gradient.validate();
                            }
                        }
                        //link.validate();
                        _this.nextOutCoord += link.linkWidth;
                    }
                });
            }
        }
        this.positionBullet(this.nameLabel);
        this.positionBullet(this.valueLabel);
    };
    /**
     * Positions the bullet so it is centered within the node element.
     *
     * @param bullet  Target bullet
     */
    SankeyNode.prototype.positionBullet = function (bullet) {
        if (bullet) {
            bullet.x = this.measuredWidth * bullet.locationX;
            bullet.y = this.measuredHeight * bullet.locationY;
        }
    };
    Object.defineProperty(SankeyNode.prototype, "level", {
        /**
         * @return Level
         */
        get: function () {
            return this.getPropertyValue("level");
        },
        /**
         * A level node is displayed at. (0 - ...)
         *
         * Levels are measured from left to right.
         *
         * The nodes in the left-most column will have `level = 0`.
         *
         * Nodes in second column - `level = 1`, etc.
         *
         * @param value  Level
         */
        set: function (value) {
            this.setPropertyValue("level", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies properties and labels from another [[SankeyNode]].
     *
     * @param source  Source node
     */
    SankeyNode.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.nameLabel.copyFrom(source.nameLabel);
        this.valueLabel.copyFrom(source.valueLabel);
    };
    return SankeyNode;
}(FlowDiagramNode_FlowDiagramNode));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["SankeyNode"] = SankeyNode_SankeyNode;
//# sourceMappingURL=SankeyNode.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/SankeyLink.js
/**
 * SankeyLink module
 */









/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * This class creates a link (waved color-filled line) between two nodes in a
 * Sankey Diagram.
 *
 * @see {@link ISankeyLinkEvents} for a list of available events
 * @see {@link ISankeyLinkAdapters} for a list of available Adapters
 * @important
 */
var SankeyLink_SankeyLink = /** @class */ (function (_super) {
    __extends(SankeyLink, _super);
    /**
     * Constructor
     */
    function SankeyLink() {
        var _this = _super.call(this) || this;
        _this.className = "SankeyLink";
        // TODO can this be removed ?
        new InterfaceColorSet_InterfaceColorSet();
        _this.tension = 0.8;
        _this.controlPointDistance = 0.2;
        _this.startAngle = 0;
        _this.endAngle = 0;
        _this.linkWidth = 0;
        _this.startX = 0;
        _this.endX = 0;
        _this.startY = 0;
        _this.endY = 0;
        _this.middleLine = _this.createChild(Polyspline_Polyspline);
        _this.middleLine.shouldClone = false;
        _this.middleLine.strokeOpacity = 0;
        _this.applyTheme();
        return _this;
    }
    /**
     * (Re)validates (redraws) the link.
     *
     * @ignore Exclude from docs
     */
    SankeyLink.prototype.validate = function () {
        _super.prototype.validate.call(this);
        if (!this.isTemplate) {
            var x0 = this.startX;
            var y0 = this.startY;
            var x1 = this.endX;
            var y1 = this.endY;
            if (!isNumber(x1)) {
                x1 = x0;
            }
            if (!isNumber(y1)) {
                y1 = y0;
            }
            var startAngle = this.startAngle;
            var endAngle = this.endAngle;
            var w = this.linkWidth;
            var path = "";
            var xt0 = x0;
            var yt0 = y0;
            var xt1 = x1;
            var yt1 = y1;
            var xb0 = x0 + w * Math_sin(startAngle);
            var xb1 = x1 + w * Math_sin(endAngle);
            var yb0 = y0 + w * Math_cos(startAngle);
            var yb1 = y1 + w * Math_cos(endAngle);
            var xm0 = x0 + w / 2 * Math_sin(startAngle);
            var xm1 = x1 + w / 2 * Math_sin(endAngle);
            var ym0 = y0 + w / 2 * Math_cos(startAngle);
            var ym1 = y1 + w / 2 * Math_cos(endAngle);
            this.zIndex = this.zIndex || this.dataItem.index;
            var tensionX = this.tension + (1 - this.tension) * Math_sin(startAngle);
            var tensionY = this.tension + (1 - this.tension) * Math_cos(startAngle);
            this.middleLine.tensionX = tensionX;
            this.middleLine.tensionY = tensionY;
            if (isNumber(w) && (isNumber(x0) && isNumber(x1) && isNumber(y0) && isNumber(y1))) {
                // solves issues with gradient fill of straight lines
                if (Math_round(xt0, 3) == Math_round(xt1, 3)) {
                    xt1 += 0.01;
                }
                if (Math_round(yt0, 3) == Math_round(yt1, 3)) {
                    yt1 += 0.01;
                }
                if (Math_round(xb0, 3) == Math_round(xb1, 3)) {
                    xb1 += 0.01;
                }
                if (Math_round(yb0, 3) == Math_round(yb1, 3)) {
                    yb1 += 0.01;
                }
                var minX = Math.min(xb0, xb1, xt0, xt1);
                var minY = Math.min(yb0, yb1, yt0, yt1);
                var maxX = Math.max(xb0, xb1, xt0, xt1);
                var maxY = Math.max(yb0, yb1, yt0, yt1);
                this._bbox = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };
                var cpd = this.controlPointDistance;
                var kxt0 = xt0 + (xt1 - xt0) * cpd * Math_cos(startAngle);
                var kyt0 = yt0 + (yt1 - yt0) * cpd * Math_sin(startAngle);
                var kxt1 = xt1 - (xt1 - xt0) * cpd * Math_cos(endAngle);
                var kyt1 = yt1 - (yt1 - yt0) * cpd * Math_sin(endAngle);
                var kxm0 = xm0 + (xm1 - xm0) * cpd * Math_cos(startAngle);
                var kym0 = ym0 + (ym1 - ym0) * cpd * Math_sin(startAngle);
                var kxm1 = xm1 - (xm1 - xm0) * cpd * Math_cos(endAngle);
                var kym1 = ym1 - (ym1 - ym0) * cpd * Math_sin(endAngle);
                var angle = getAngle({ x: kxt0, y: kyt0 }, { x: kxt1, y: kyt1 });
                var dx = (w / Math_cos(angle) - w) / tan(angle) * Math_cos(startAngle);
                var dy = (w / Math_sin(angle) - w) * tan(angle) * Math_sin(startAngle);
                var kxb0 = -dx / 2 + xb0 + (xb1 - xb0) * cpd * Math_cos(startAngle);
                var kyb0 = -dy / 2 + yb0 + (yb1 - yb0) * cpd * Math_sin(startAngle);
                var kxb1 = -dx / 2 + xb1 - (xb1 - xb0) * cpd * Math_cos(endAngle);
                var kyb1 = -dy / 2 + yb1 - (yb1 - yb0) * cpd * Math_sin(endAngle);
                this.middleLine.segments = [[{ x: xm0, y: ym0 }, { x: kxm0, y: kym0 }, { x: kxm1, y: kym1 }, { x: xm1, y: ym1 }]];
                kxt0 += dx / 2;
                kyt0 += dy / 2;
                kxt1 += dx / 2;
                kyt1 += dy / 2;
                path += moveTo({ x: xt0, y: yt0 });
                path += new Smoothing_Tension(tensionX, tensionY).smooth([{ x: xt0, y: yt0 }, { x: kxt0, y: kyt0 }, { x: kxt1, y: kyt1 }, { x: xt1, y: yt1 }]);
                path += lineTo({ x: xb1, y: yb1 });
                path += new Smoothing_Tension(tensionX, tensionY).smooth([{ x: xb1, y: yb1 }, { x: kxb1, y: kyb1 }, { x: kxb0, y: kyb0 }, { x: xb0, y: yb0 }]);
                path += closePath();
            }
            this.link.path = path;
            if (this.maskBullets) {
                this.bulletsMask.path = path;
                this.bulletsContainer.mask = this.bulletsMask;
            }
            this.positionBullets();
        }
    };
    Object.defineProperty(SankeyLink.prototype, "startX", {
        /**
         * @return Start X
         */
        get: function () {
            return this.getPropertyValue("startX");
        },
        /**
         * [startX description]
         *
         * @todo Description
         * @param value  Start X
         */
        set: function (value) {
            this.setPropertyValue("startX", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SankeyLink.prototype, "endX", {
        /**
         * @return End X
         */
        get: function () {
            return this.getPropertyValue("endX");
        },
        /**
         * [endX description]
         *
         * @todo Description
         * @param value  End X
         */
        set: function (value) {
            this.setPropertyValue("endX", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SankeyLink.prototype, "startY", {
        /**
         * @return Start Y
         */
        get: function () {
            return this.getPropertyValue("startY");
        },
        /**
         * [startY description]
         *
         * @todo Description
         * @param value  Start Y
         */
        set: function (value) {
            this.setPropertyValue("startY", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SankeyLink.prototype, "endY", {
        /**
         * @return End Y
         */
        get: function () {
            return this.getPropertyValue("endY");
        },
        /**
         * [endY description]
         *
         * @todo Description
         * @param value End Y
         */
        set: function (value) {
            this.setPropertyValue("endY", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SankeyLink.prototype, "linkWidth", {
        /**
         * @return [description]
         */
        get: function () {
            return this.getPropertyValue("linkWidth");
        },
        /**
         * [linkWidth description]
         *
         * @todo Description
         * @param value [description]
         */
        set: function (value) {
            this.setPropertyValue("linkWidth", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SankeyLink.prototype, "controlPointDistance", {
        /**
         * @return relative control point distance
         */
        get: function () {
            return this.getPropertyValue("controlPointDistance");
        },
        /**
         * Distance of control point of a link, defines relative distance from a node at which linke should bend
         * @default 0.2
         * @param value
         */
        set: function (value) {
            this.setPropertyValue("controlPointDistance", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SankeyLink.prototype, "tension", {
        /**
         * @return tension value
         */
        get: function () {
            return this.getPropertyValue("tension");
        },
        /**
         * Tension of a spline, 1 would make the link to have sharp edges
         * @default 0.8
         * @param value
         */
        set: function (value) {
            this.setPropertyValue("tension", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return SankeyLink;
}(FlowDiagramLink_FlowDiagramLink));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["SankeyLink"] = SankeyLink_SankeyLink;
//# sourceMappingURL=SankeyLink.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/SankeyDiagram.js
/**
 * Sankey diagram module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */










/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
//@todo rearange notes after dragged
/**
 * Defines a [[DataItem]] for [[SankeyDiagram]].
 *
 * @see {@link DataItem}
 */
var SankeyDiagram_SankeyDiagramDataItem = /** @class */ (function (_super) {
    __extends(SankeyDiagramDataItem, _super);
    /**
     * Constructor
     */
    function SankeyDiagramDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "SankeyDiagramDataItem";
        _this.applyTheme();
        return _this;
    }
    return SankeyDiagramDataItem;
}(FlowDiagram_FlowDiagramDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a Sankey Diagram chart.
 *
 * @see {@link ISankeyDiagramEvents} for a list of available Events
 * @see {@link ISankeyDiagramAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/sankey-diagram/} for documentation
 * @important
 */
var SankeyDiagram_SankeyDiagram = /** @class */ (function (_super) {
    __extends(SankeyDiagram, _super);
    /**
     * Constructor
     */
    function SankeyDiagram() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "SankeyDiagram";
        _this.orientation = "horizontal";
        _this.nodeAlign = "middle";
        _this.nodesContainer.width = Percent_percent(100);
        _this.nodesContainer.height = Percent_percent(100);
        _this.linksContainer.width = Percent_percent(100);
        _this.linksContainer.height = Percent_percent(100);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * (Re)validates chart's data, effectively causing the chart to redraw.
     *
     * @ignore Exclude from docs
     */
    SankeyDiagram.prototype.validateData = function () {
        var _this = this;
        _super.prototype.validateData.call(this);
        this._levelCount = 0;
        this.nodes.each(function (key, node) {
            node.level = undefined;
        });
        this.nodes.each(function (key, node) {
            node.level = _this.getNodeLevel(node, 0);
            _this._levelCount = Math_max(_this._levelCount, node.level);
        });
    };
    /**
     * Returns node's highest level.
     *
     * @param node   Node
     * @param level  Current level
     * @return New level
     */
    SankeyDiagram.prototype.getNodeLevel = function (node, level) {
        var _this = this;
        //@todo solve circular so
        var levels = [level];
        Iterator_each(node.incomingDataItems.iterator(), function (link) {
            if (link.fromNode) {
                if (isNumber(link.fromNode.level)) {
                    levels.push(link.fromNode.level + 1);
                }
                else {
                    levels.push(_this.getNodeLevel(link.fromNode, level + 1));
                }
            }
        });
        return Math.max.apply(Math, __spread(levels));
    };
    /**
     * Calculates relation between pixel height and total value.
     *
     * In Sankey the actual thickness of links and height of nodes will depend
     * on their values.
     */
    SankeyDiagram.prototype.calculateValueHeight = function () {
        var _this = this;
        // calculate sums of each level
        this._levelSum = {};
        this._levelNodesCount = {};
        this.maxSum = 0;
        var total = this.dataItem.values.value.sum;
        Iterator_each(this._sorted, function (strNode) {
            var node = strNode[1];
            _this.getNodeValue(node);
        });
        this.nodes.each(function (key, node) {
            var level = node.level;
            var value = Math.max(node.totalIncoming, node.totalOutgoing);
            if (value / total < _this.minNodeSize) {
                value = total * _this.minNodeSize;
            }
            if (isNumber(_this._levelSum[level])) {
                _this._levelSum[level] += value;
            }
            else {
                _this._levelSum[level] = value;
            }
            if (isNumber(_this._levelNodesCount[level])) {
                _this._levelNodesCount[level]++;
            }
            else {
                _this._levelNodesCount[level] = 1;
            }
        });
        var availableHeight;
        if (this.orientation == "horizontal") {
            availableHeight = this.chartContainer.maxHeight - 1;
        }
        else {
            availableHeight = this.chartContainer.maxWidth - 1;
        }
        var maxSumLevel;
        var minHeight;
        Object_each(this._levelSum, function (key, value) {
            var realValue = value;
            var levelNodeCount = _this._levelNodesCount[key];
            var valueHeight = (availableHeight - (levelNodeCount - 1) * _this.nodePadding) / realValue;
            if (valueHeight == Infinity) {
                valueHeight = 0;
            }
            if (minHeight > valueHeight || !isNumber(minHeight)) {
                minHeight = valueHeight;
                _this.maxSum = realValue;
                maxSumLevel = toNumber(key);
            }
        });
        this._maxSumLevel = maxSumLevel;
        var maxSumLevelNodeCount = this._levelNodesCount[this._maxSumLevel];
        var valueHeight = (availableHeight - (maxSumLevelNodeCount - 1) * this.nodePadding) / this.maxSum;
        if (valueHeight == Infinity) {
            valueHeight = 0;
        }
        if (!isNumber(this.valueHeight)) {
            this.valueHeight = valueHeight;
        }
        else {
            var finalHeight = void 0;
            try {
                finalHeight = this._heightAnimation.animationOptions[0].to;
            }
            catch (err) {
            }
            // without animations it will be non-smooth as maxValue jumps from one column to another
            if (finalHeight != valueHeight) {
                var duration = this.interpolationDuration;
                try {
                    duration = this.nodes.template.states.getKey("active").transitionDuration;
                }
                catch (err) {
                }
                this._heightAnimation = new Animation_Animation(this, { property: "valueHeight", from: this.valueHeight, to: valueHeight }, duration, this.interpolationEasing).start();
                this._disposers.push(this._heightAnimation);
            }
        }
    };
    /**
     * Redraws the chart.
     *
     * @ignore Exclude from docs
     */
    SankeyDiagram.prototype.validate = function () {
        var _this = this;
        _super.prototype.validate.call(this);
        this.calculateValueHeight();
        var container = this.nodesContainer;
        var nextCoordinate = {};
        var maxSumLevelNodeCount = this._levelNodesCount[this._maxSumLevel];
        var total = this.dataItem.values.value.sum;
        Iterator_each(this._sorted, function (strNode) {
            var node = strNode[1];
            var level = node.level;
            var levelCoordinate = 0;
            var nodeCount = _this._levelNodesCount[level];
            switch (_this.nodeAlign) {
                case "bottom":
                    levelCoordinate = (_this.maxSum - _this._levelSum[level]) * _this.valueHeight - (nodeCount - maxSumLevelNodeCount) * _this.nodePadding;
                    break;
                case "middle":
                    levelCoordinate = (_this.maxSum - _this._levelSum[level]) * _this.valueHeight / 2 - (nodeCount - maxSumLevelNodeCount) * _this.nodePadding / 2;
                    break;
            }
            node.parent = container;
            var delta;
            var x;
            var y;
            var value = Math.max(node.totalIncoming, node.totalOutgoing);
            if (value / total < _this.minNodeSize) {
                value = total * _this.minNodeSize;
            }
            if (_this.orientation == "horizontal") {
                delta = (_this.innerWidth - node.pixelWidth) / _this._levelCount;
                x = delta * node.level;
                y = nextCoordinate[level] || levelCoordinate;
                var h = value * _this.valueHeight;
                node.height = h;
                node.minX = x;
                node.maxX = x;
                nextCoordinate[level] = y + h + _this.nodePadding;
            }
            else {
                delta = (_this.innerHeight - node.pixelHeight) / _this._levelCount;
                x = nextCoordinate[level] || levelCoordinate;
                y = delta * node.level;
                var w = value * _this.valueHeight;
                node.width = w;
                node.minY = y;
                node.maxY = y;
                nextCoordinate[level] = x + w + _this.nodePadding;
            }
            node.x = x;
            node.y = y;
        });
    };
    /**
     * Performs actual operations to reveal this element.
     *
     * @ignore Exclude from docs
     * @param duration Fade in duration (ms)
     * @return Fade in duration (ms)
     */
    SankeyDiagram.prototype.showReal = function (duration) {
        var _this = this;
        if (this.preventShow) {
            return;
        }
        if (this.interpolationDuration > 0) {
            var container_1 = this.nodesContainer;
            var i_1 = 0;
            Iterator_each(this.links.iterator(), function (link) {
                link.hide(0);
            });
            Iterator_each(this._sorted, function (strNode) {
                var node = strNode[1];
                var property;
                if (_this.orientation == "horizontal") {
                    node.dx = -(container_1.pixelWidth - node.pixelWidth) / Math.max(_this._levelCount, 1);
                    property = "dx";
                }
                else {
                    node.dy = -(container_1.pixelHeight - node.pixelHeight) / Math.max(_this._levelCount, 1);
                    property = "dy";
                }
                var delay = 0;
                var duration = _this.interpolationDuration;
                if (_this.sequencedInterpolation) {
                    delay = _this.sequencedInterpolationDelay * i_1 + duration * i_1 / Iterator_length(_this.nodes.iterator());
                }
                node.opacity = 0;
                node.invalidateLinks();
                node.animate([{ property: "opacity", from: 0, to: 1 }, { property: property, to: 0 }], _this.interpolationDuration, _this.interpolationEasing).delay(delay);
                Iterator_each(node.outgoingDataItems.iterator(), function (dataItem) {
                    var animation = dataItem.link.show(_this.interpolationDuration);
                    if (animation && !animation.isFinished()) {
                        animation.delay(delay);
                    }
                });
                Iterator_each(node.incomingDataItems.iterator(), function (dataItem) {
                    if (!dataItem.fromNode) {
                        var animation = dataItem.link.show(_this.interpolationDuration);
                        if (animation && !animation.isFinished()) {
                            animation.delay(delay);
                        }
                    }
                });
                i_1++;
            });
        }
        return _super.prototype.showReal.call(this);
    };
    /**
     * Changes the sort type of the nodes.
     *
     * This will actually reshuffle nodes using nice animation.
     */
    SankeyDiagram.prototype.changeSorting = function () {
        var _this = this;
        this.sortNodes();
        var nextCoordinate = {};
        Iterator_each(this._sorted, function (strNode) {
            var node = strNode[1];
            var level = node.level;
            var levelCoordinate = (_this.maxSum - _this._levelSum[level]) * _this.valueHeight / 2;
            var property;
            var nodeHeight;
            if (_this.orientation == "horizontal") {
                property = "y";
                nodeHeight = node.pixelHeight;
            }
            else {
                property = "x";
                nodeHeight = node.pixelWidth;
            }
            node.animate({ property: property, to: nextCoordinate[level] || levelCoordinate }, _this.interpolationDuration, _this.interpolationEasing);
            nextCoordinate[level] = (nextCoordinate[level] || levelCoordinate) + nodeHeight + _this.nodePadding;
            node.invalidateLinks();
        });
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    SankeyDiagram.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Add a default screen reader title for accessibility
        // This will be overridden in screen reader if there are any `titles` set
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Sankey diagram");
        }
    };
    /**
     * Creates and returns a new data item.
     *
     * @return Data item
     */
    SankeyDiagram.prototype.createDataItem = function () {
        return new SankeyDiagram_SankeyDiagramDataItem();
    };
    Object.defineProperty(SankeyDiagram.prototype, "nodeAlign", {
        /**
         * @returns Returns nodeAlign value
         */
        get: function () {
            return this.getPropertyValue("nodeAlign");
        },
        /**
         * How to align nodes. In case layout is vertical, top means left and bottom means right
         *
         * @param value  Node sorting
         */
        set: function (value) {
            this.setPropertyValue("nodeAlign", value);
            this.changeSorting();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SankeyDiagram.prototype, "orientation", {
        /**
         * @return Orientation
         */
        get: function () {
            return this.getPropertyValue("orientation");
        },
        /**
         * Orientation of the chart: "horizontal" or "vertical";
         *
         * @param value Orientation
         */
        set: function (value) {
            this.setPropertyValue("orientation", value, true);
            var nameLabel = this.nodes.template.nameLabel;
            if (value == "vertical") {
                this.nodes.template.width = undefined;
                nameLabel.label.horizontalCenter = "middle";
                nameLabel.locationX = 0.5;
            }
            else {
                this.nodes.template.height = undefined;
                nameLabel.label.horizontalCenter = "left";
                nameLabel.locationX = 1;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    SankeyDiagram.prototype.createNode = function () {
        var node = new SankeyNode_SankeyNode();
        this._disposers.push(node);
        return node;
    };
    /**
     * @ignore
     */
    SankeyDiagram.prototype.createLink = function () {
        var link = new SankeyLink_SankeyLink();
        this._disposers.push(link);
        return link;
    };
    Object.defineProperty(SankeyDiagram.prototype, "valueHeight", {
        /**
         * @ignore
         */
        get: function () {
            return this._valueHeight;
        },
        /**
         * @ignore
         */
        set: function (value) {
            if (value != this._valueHeight) {
                this._valueHeight = value;
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    SankeyDiagram.prototype.disposeData = function () {
        _super.prototype.disposeData.call(this);
        this._sorted = this.nodes.iterator();
    };
    return SankeyDiagram;
}(FlowDiagram_FlowDiagram));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["SankeyDiagram"] = SankeyDiagram_SankeyDiagram;
//# sourceMappingURL=SankeyDiagram.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/ChordNode.js
/**
 * ChordNode module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a node in a Chord Diagram.
 *
 * A Chord node is a block with a value, which represents its size on the
 * diagram.
 *
 * Nodes are connected via [[ChordLink]] elements.
 *
 * @see {@link IChordNodeEvents} for a list of available events
 * @see {@link IChordNodeAdapters} for a list of available Adapters
 * @important
 */
var ChordNode_ChordNode = /** @class */ (function (_super) {
    __extends(ChordNode, _super);
    /**
     * Constructor
     */
    function ChordNode() {
        var _this = _super.call(this) || this;
        _this.className = "ChordNode";
        var label = _this.createChild(AxisLabelCircular_AxisLabelCircular);
        label.location = 0.5;
        label.radius = 5;
        label.text = "{name}";
        label.zIndex = 1;
        label.shouldClone = false;
        _this.label = label;
        _this.layout = "none";
        _this.events.on("positionchanged", _this.updateRotation, _this, false);
        _this.isMeasured = false;
        _this.slice = _this.createChild(Slice_Slice);
        _this.slice.isMeasured = false;
        var hiddenState = _this.hiddenState;
        hiddenState.properties.fill = new InterfaceColorSet_InterfaceColorSet().getFor("disabledBackground");
        hiddenState.properties.opacity = 0.5;
        hiddenState.properties.visible = true;
        _this.setStateOnChildren = false;
        _this.slice.hiddenState.properties.visible = true;
        _this.adapter.add("tooltipX", function (tooltipX, target) {
            return target.slice.ix * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);
        });
        _this.adapter.add("tooltipY", function (tooltipY, target) {
            return target.slice.iy * (target.slice.radius - (target.slice.radius - target.slice.pixelInnerRadius) / 2);
        });
        return _this;
    }
    /**
     * Invalidates all links, attached to this node.
     *
     * @ignore Exclude from docs
     */
    ChordNode.prototype.invalidateLinks = function () {
        var _this = this;
        _super.prototype.invalidateLinks.call(this);
        var label = this.label;
        var slice = this.slice;
        var chart = this.chart;
        if (chart && slice) {
            var sum = this.total;
            var arc_1 = slice.arc;
            var sliceStartAngle_1 = slice.startAngle;
            this.children.each(function (child) {
                if (child instanceof Bullet_Bullet) {
                    var locationX = child.locationX;
                    if (!isNumber(locationX)) {
                        locationX = 0.5;
                    }
                    var locationY = child.locationY;
                    if (!isNumber(locationY)) {
                        locationY = 1;
                    }
                    var childAngle = sliceStartAngle_1 + arc_1 * locationX;
                    var childRadius = locationY * slice.radius;
                    child.x = childRadius * Math_cos(childAngle);
                    child.y = childRadius * Math_sin(childAngle);
                }
            });
            var labelAngle = sliceStartAngle_1 + arc_1 * label.location;
            var startAngle = sliceStartAngle_1 + (1 - sum / this.adjustedTotal) * arc_1 * 0.5; // if value of a node is > then sum of the links, add to center link
            if (Type_isNaN(startAngle)) {
                startAngle = sliceStartAngle_1;
            }
            label.fixPosition(labelAngle, slice.radius);
            this.nextAngle = startAngle;
            if (this._outgoingSorted) {
                Iterator_each(this._outgoingSorted, function (dataItem) {
                    var link = dataItem.link;
                    link.parent = _this.chart.linksContainer;
                    var value = dataItem.getWorkingValue("value");
                    if (isNumber(value)) {
                        if (chart.nonRibbon) {
                            var percentWidth = link.percentWidth;
                            if (!isNumber(percentWidth)) {
                                percentWidth = 5;
                            }
                            percentWidth = percentWidth / 100;
                            link.startAngle = sliceStartAngle_1 + arc_1 / 2 - arc_1 / 2 * percentWidth;
                            link.arc = arc_1 * percentWidth;
                        }
                        else {
                            link.arc = value * chart.valueAngle;
                            link.startAngle = _this.nextAngle;
                            _this.nextAngle += link.arc;
                        }
                        if (!dataItem.toNode) {
                            link.endAngle = link.startAngle;
                        }
                        link.radius = slice.pixelInnerRadius;
                    }
                    //link.validate();
                });
            }
            if (this._incomingSorted) {
                Iterator_each(this._incomingSorted, function (dataItem) {
                    var link = dataItem.link;
                    link.radius = slice.pixelInnerRadius;
                    if (chart.nonRibbon) {
                        var percentWidth = link.percentWidth;
                        if (!isNumber(percentWidth)) {
                            percentWidth = 5;
                        }
                        percentWidth = percentWidth / 100;
                        link.endAngle = sliceStartAngle_1 + arc_1 / 2 - arc_1 / 2 * percentWidth;
                        link.arc = arc_1 * percentWidth;
                    }
                    else {
                        link.endAngle = _this.nextAngle;
                        var value = dataItem.getWorkingValue("value");
                        if (isNumber(value)) {
                            link.arc = value * chart.valueAngle; // yes, this is needed
                            _this.nextAngle += link.arc;
                        }
                    }
                    if (!dataItem.fromNode) {
                        link.startAngle = link.endAngle;
                    }
                    //link.validate();
                });
            }
        }
    };
    /**
     * @ignore
     * updates slice start angle so that when we drag a node it would face the center
     */
    ChordNode.prototype.updateRotation = function () {
        var slice = this.slice;
        var mAngle = this.trueStartAngle + slice.arc / 2;
        var radius = slice.radius;
        var tx = radius * Math_cos(mAngle);
        var ty = radius * Math_sin(mAngle);
        var angle = getAngle({ x: tx + this.pixelX, y: ty + this.pixelY });
        slice.startAngle = this.trueStartAngle + (angle - mAngle);
        this.dx = -this.pixelX;
        this.dy = -this.pixelY;
    };
    /**
     * Copies properties and labels from another [[ChordNode]].
     *
     * @param source  Source node
     */
    ChordNode.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.label.copyFrom(source.label);
        this.slice.copyFrom(source.slice);
    };
    return ChordNode;
}(FlowDiagramNode_FlowDiagramNode));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ChordNode"] = ChordNode_ChordNode;
//# sourceMappingURL=ChordNode.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/core/elements/QuadraticCurve.js
/**
 * Functionality for drawing quadratic curves.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws a waved line.
 *
 * @see {@link IQuadraticCurveEvents} for a list of available events
 * @see {@link IQuadraticCurveAdapters} for a list of available Adapters
 */
var QuadraticCurve_QuadraticCurve = /** @class */ (function (_super) {
    __extends(QuadraticCurve, _super);
    /**
     * Constructor
     */
    function QuadraticCurve() {
        var _this = _super.call(this) || this;
        _this.className = "QuadraticCurve";
        _this.element = _this.paper.add("path");
        _this.pixelPerfect = false;
        _this.fill = Color_color();
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the waved line.
     *
     * @ignore Exclude from docs
     */
    QuadraticCurve.prototype.draw = function () {
        //super.draw();
        if (isNumber(this.x1 + this.x2 + this.y1 + this.y2 + this.cpx + this.cpy)) {
            var p1 = { x: this.x1, y: this.y1 };
            var p2 = { x: this.x2, y: this.y2 };
            var cp = { x: this.cpx, y: this.cpy };
            var d = moveTo(p1) + quadraticCurveTo(p2, cp);
            this.path = d;
        }
    };
    Object.defineProperty(QuadraticCurve.prototype, "cpx", {
        /**
         * @return X
         */
        get: function () {
            return this.getPropertyValue("cpx");
        },
        /**
         * X coordinate of control point.
         *
         * @param value X
         */
        set: function (value) {
            this.setPropertyValue("cpx", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QuadraticCurve.prototype, "cpy", {
        /**
         * @return Y
         */
        get: function () {
            return this.getPropertyValue("cpy");
        },
        /**
         * Y coordinate of control point.
         *
         * @param value Y
         */
        set: function (value) {
            this.setPropertyValue("cpy", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Converts relative position along the line (0-1) into pixel coordinates.
     *
     * @param position  Position (0-1)
     * @return Coordinates
     */
    QuadraticCurve.prototype.positionToPoint = function (position) {
        var p1 = { x: this.x1, y: this.y1 };
        var cp = { x: this.cpx, y: this.cpy };
        var p2 = { x: this.x2, y: this.y2 };
        var point1 = getPointOnQuadraticCurve(p1, p2, cp, position);
        var point2 = getPointOnQuadraticCurve(p1, p2, cp, position + 0.001);
        return { x: point1.x, y: point1.y, angle: getAngle(point1, point2) };
    };
    return QuadraticCurve;
}(Line_Line));

//# sourceMappingURL=QuadraticCurve.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/ChordLink.js
/**
 * ChordLink module
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * This class creates a link (waved color-filled line) between two nodes in a
 * Chord Diagram.
 *
 * @see {@link IChordLinkEvents} for a list of available events
 * @see {@link IChordLinkAdapters} for a list of available Adapters
 * @important
 */
var ChordLink_ChordLink = /** @class */ (function (_super) {
    __extends(ChordLink, _super);
    /**
     * Constructor
     */
    function ChordLink() {
        var _this = _super.call(this) || this;
        _this.className = "ChordLink";
        _this.middleLine = _this.createChild(QuadraticCurve_QuadraticCurve);
        _this.middleLine.shouldClone = false;
        _this.middleLine.strokeOpacity = 0;
        _this.applyTheme();
        return _this;
    }
    /**
     * (Re)validates (redraws) the link.
     *
     * @ignore Exclude from docs
     */
    ChordLink.prototype.validate = function () {
        _super.prototype.validate.call(this);
        if (!this.isTemplate) {
            var startAngle = this.startAngle;
            var endAngle = this.endAngle;
            var arc = this.arc;
            var radius = this.radius;
            var fromNode = this.dataItem.fromNode;
            var toNode = this.dataItem.toNode;
            var fromX = 0;
            var fromY = 0;
            if (fromNode) {
                fromX = fromNode.pixelX + fromNode.dx;
                fromY = fromNode.pixelY + fromNode.dy;
            }
            var toX = 0;
            var toY = 0;
            if (toNode) {
                toX = toNode.pixelX + toNode.dx;
                toY = toNode.pixelY + toNode.dy;
            }
            if (radius > 0) {
                var x1 = radius * Math_cos(startAngle) + fromX;
                var y1 = radius * Math_sin(startAngle) + fromY;
                var x2 = radius * Math_cos(endAngle) + toX;
                var y2 = radius * Math_sin(endAngle) + toY;
                //let cpAngle = startAngle + arc + (endAngle - startAngle - arc) / 2;
                //let arcWidth = $math.getDistance({x:x1, y:y1}, {x:x4, y:y4});
                //let cpx = (arcWidth) * $math.cos(cpAngle);
                //let cpy = (arcWidth) * $math.sin(cpAngle);
                var cp = { x: 0, y: 0 };
                var path = moveTo({ x: x1, y: y1 });
                path += arcTo(startAngle, arc, radius);
                path += quadraticCurveTo({ x: x2, y: y2 }, cp);
                path += arcTo(endAngle, arc, radius);
                path += quadraticCurveTo({ x: x1, y: y1 }, cp);
                if (arc > 0) {
                    this.link.path = path;
                }
                else {
                    this.link.path = "";
                }
                if (this.maskBullets) {
                    this.bulletsMask.path = path;
                    this.bulletsContainer.mask = this.bulletsMask;
                }
                var mAngle1 = startAngle + arc / 2;
                var mAngle2 = endAngle + arc / 2;
                var middleLine = this.middleLine;
                middleLine.x1 = radius * Math_cos(mAngle1) + fromX;
                middleLine.y1 = radius * Math_sin(mAngle1) + fromY;
                middleLine.x2 = radius * Math_cos(mAngle2) + toX;
                middleLine.y2 = radius * Math_sin(mAngle2) + toY;
                middleLine.cpx = 0;
                middleLine.cpy = 0;
                middleLine.stroke = this.fill;
                this.positionBullets();
            }
        }
    };
    Object.defineProperty(ChordLink.prototype, "radius", {
        /**
         * @return End Y
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * [radius description]
         *
         * @todo Description
         * @param value End Y
         */
        set: function (value) {
            this.setPropertyValue("radius", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChordLink.prototype, "arc", {
        /**
         * @return [description]
         */
        get: function () {
            return this.getPropertyValue("arc");
        },
        /**
         * [arc description]
         *
         * @todo Description
         * @param value [description]
         */
        set: function (value) {
            this.setPropertyValue("arc", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return ChordLink;
}(FlowDiagramLink_FlowDiagramLink));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ChordLink"] = ChordLink_ChordLink;
//# sourceMappingURL=ChordLink.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/ChordDiagram.js
/**
 * Chord diagram module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */










/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
//@todo rearange notes after dragged
/**
 * Defines a [[DataItem]] for [[ChordDiagram]].
 *
 * @see {@link DataItem}
 */
var ChordDiagram_ChordDiagramDataItem = /** @class */ (function (_super) {
    __extends(ChordDiagramDataItem, _super);
    /**
     * Constructor
     */
    function ChordDiagramDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "ChordDiagramDataItem";
        _this.applyTheme();
        return _this;
    }
    return ChordDiagramDataItem;
}(FlowDiagram_FlowDiagramDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a Chord Diagram chart.
 *
 * @see {@link IChordDiagramEvents} for a list of available Events
 * @see {@link IChordDiagramAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/chord-diagram/} for documentation
 * @important
 */
var ChordDiagram_ChordDiagram = /** @class */ (function (_super) {
    __extends(ChordDiagram, _super);
    /**
     * Constructor
     */
    function ChordDiagram() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * [valueAngle description]
         *
         * @ignore Exclude from docs
         * @todo Description
         */
        _this.valueAngle = 0;
        _this.className = "ChordDiagram";
        _this.startAngle = -90;
        _this.endAngle = 270;
        _this.radius = Percent_percent(80);
        _this.innerRadius = -15;
        _this.nodePadding = 5;
        var chordContainer = _this.chartContainer.createChild(Container_Container);
        chordContainer.align = "center";
        chordContainer.valign = "middle";
        chordContainer.shouldClone = false;
        chordContainer.layout = "absolute";
        _this.chordContainer = chordContainer;
        _this.nodesContainer.parent = chordContainer;
        _this.linksContainer.parent = chordContainer;
        _this.chartContainer.events.on("maxsizechanged", _this.invalidate, _this, false);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Redraws the chart.
     *
     * @ignore Exclude from docs
     */
    ChordDiagram.prototype.validate = function () {
        var _this = this;
        var chartContainer = this.chartContainer;
        var endAngle = this.endAngle;
        var startAngle = this.startAngle + this.nodePadding / 2;
        var rect = getArcRect(this.startAngle, this.endAngle, 1);
        var innerRect = { x: 0, y: 0, width: 0, height: 0 };
        rect = getCommonRectangle([rect, innerRect]);
        var maxRadius = Math.min(chartContainer.innerWidth / rect.width, chartContainer.innerHeight / rect.height);
        if (!isNumber(maxRadius)) {
            maxRadius = 0;
        }
        var radius = relativeRadiusToValue(this.radius, maxRadius);
        var pixelInnerRadius = relativeRadiusToValue(this.innerRadius, radius, true);
        var total = this.dataItem.values.value.sum;
        var count = 0;
        var newTotal = 0;
        Iterator_each(this._sorted, function (strNode) {
            var node = strNode[1];
            _this.getNodeValue(node);
            count++;
            var value = node.total;
            if (node.total / total < _this.minNodeSize) {
                value = total * _this.minNodeSize;
            }
            newTotal += value;
        });
        this.valueAngle = (endAngle - this.startAngle - this.nodePadding * count) / newTotal;
        Iterator_each(this._sorted, function (strNode) {
            var node = strNode[1];
            var slice = node.slice;
            slice.radius = radius;
            slice.innerRadius = pixelInnerRadius;
            var value = node.total;
            if (node.total / total < _this.minNodeSize) {
                value = total * _this.minNodeSize;
            }
            node.adjustedTotal = value;
            var arc;
            if (_this.nonRibbon) {
                arc = (endAngle - _this.startAngle) / count - _this.nodePadding;
            }
            else {
                arc = _this.valueAngle * value;
            }
            slice.arc = arc;
            slice.startAngle = startAngle;
            node.trueStartAngle = startAngle;
            node.parent = _this.nodesContainer;
            node.validate(); // otherwise flickers - nodes are already created, but not yet positioned etc.
            startAngle += arc + _this.nodePadding;
        });
        this.chordContainer.definedBBox = { x: radius * rect.x, y: radius * rect.y, width: radius * rect.width, height: radius * rect.height };
        this.chordContainer.invalidateLayout();
        _super.prototype.validate.call(this);
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    ChordDiagram.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Add a default screen reader title for accessibility
        // This will be overridden in screen reader if there are any `titles` set
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Chord diagram");
        }
    };
    /**
     * Creates and returns a new data item.
     *
     * @return Data item
     */
    ChordDiagram.prototype.createDataItem = function () {
        return new ChordDiagram_ChordDiagramDataItem();
    };
    Object.defineProperty(ChordDiagram.prototype, "startAngle", {
        /**
         * @return Start angle (degrees)
         */
        get: function () {
            return this.getPropertyValue("startAngle");
        },
        /**
         * Starting angle of the Radar face. (degrees)
         *
         * Normally, a circular radar face begins (the radial axis is drawn) at the
         * top center. (at -90 degrees)
         *
         * You can use `startAngle` to change this setting.
         *
         * E.g. setting this to 0 will make the radial axis start horizontally to
         * the right, as opposed to vertical.
         *
         * For a perfect circle the absolute sum of `startAngle` and `endAngle`
         * needs to be 360.
         *
         * However, it's **not** necessary to do so. You can set those to lesser
         * numbers, to create semi-circles.
         *
         * E.g. `startAngle = -90` with `endAngle = 0` will create a radar face that
         * looks like a quarter of a circle.
         *
         * @default -90
         * @param value  Start angle (degrees)
         */
        set: function (value) {
            this.setPropertyValue("startAngle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChordDiagram.prototype, "endAngle", {
        /**
         * @return End angle (degrees)
         */
        get: function () {
            return this.getPropertyValue("endAngle");
        },
        /**
         * Starting angle of the Radar face. (degrees)
         *
         * Normally, a circular radar face ends (the radial axis is drawn) exactly
         * where it has started, forming a full 360 circle. (at 270 degrees)
         *
         * You can use `endAngle` to end the circle somewhere else.
         *
         * E.g. setting this to 180 will make the radar face end at horizontal line
         * to the left off the center.
         *
         * For a perfect circle the absolute sum of `startAngle` and `endAngle`
         * needs to be 360.
         *
         * However, it's **not** necessary to do so. You can set those to lesser
         * numbers, to create semi-circles.
         *
         * E.g. `startAngle = -90` with `endAngle = 0` will create a radar face that
         * looks like a quarter of a circle.
         *
         * @default -90
         * @param value  End angle (degrees)
         */
        set: function (value) {
            this.setPropertyValue("endAngle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChordDiagram.prototype, "radius", {
        /**
         * @return Outer radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Outer radius of the Radar face.
         *
         * This can either be in absolute pixel value, or relative [[Percent]].
         *
         * @param value  Outer radius
         */
        set: function (value) {
            this.setPercentProperty("radius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChordDiagram.prototype, "innerRadius", {
        /**
         * @return Inner radius
         */
        get: function () {
            return this.getPropertyValue("innerRadius");
        },
        /**
         * Inner radius of the Chord nodes.
         *
         * This can either be in absolute pixel value, or relative [[Percent]].
         *
         * @param value  Outer radius
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChordDiagram.prototype, "nonRibbon", {
        /**
         * @return Non-ribbon
         */
        get: function () {
            return this.getPropertyValue("nonRibbon");
        },
        /**
         *
         * If you set this to true, all the lines will be of the same width. This is done by making middleLine of a ChordLink visible.
         *
         * @param value
         */
        set: function (value) {
            this.setPropertyValue("nonRibbon", value, true);
            this.links.template.middleLine.strokeOpacity = 1;
            this.links.template.link.fillOpacity = 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @ignore
     */
    ChordDiagram.prototype.createNode = function () {
        var node = new ChordNode_ChordNode();
        this._disposers.push(node);
        return node;
    };
    /**
     * @ignore
     */
    ChordDiagram.prototype.createLink = function () {
        var link = new ChordLink_ChordLink();
        this._disposers.push(link);
        return link;
    };
    return ChordDiagram;
}(FlowDiagram_FlowDiagram));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ChordDiagram"] = ChordDiagram_ChordDiagram;
//# sourceMappingURL=ChordDiagram.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/Column.js
/**
 * Module that defines everything related to building Columns.
 * It is a container which has column element which is a RoundedRectangle.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Class used to creates Columns.
 *
 * @see {@link IColumnEvents} for a list of available events
 * @see {@link IColumnAdapters} for a list of available Adapters
 * @todo Usage example
 * @important
 */
var Column_Column = /** @class */ (function (_super) {
    __extends(Column, _super);
    /**
     * Constructor
     */
    function Column() {
        var _this = _super.call(this) || this;
        _this.className = "Column";
        _this.width = Percent_percent(80);
        _this.height = Percent_percent(80);
        //this.isMeasured = true; // for correct position of the tooltip
        _this.events.disableType("transformed"); // not to bug parent
        _this.applyOnClones = true;
        _this.strokeOpacity = 1;
        _this.layout = "none";
        _this.createAssets();
        // otherwise users will have to set layout themselves if they'll want to align, scale etc children
        _this.events.on("childadded", _this.handleKidAdded, _this, false);
        return _this;
    }
    /**
     * @ignore
     */
    Column.prototype.handleKidAdded = function () {
        if (this.layout == "none") {
            this.layout = "absolute";
        }
    };
    /**
     * @ignore
     */
    Column.prototype.createAssets = function () {
        this.column = this.createChild(RoundedRectangle_RoundedRectangle);
        this.column.shouldClone = false;
        this.column.isMeasured = false;
        this.column.cornerRadius(0, 0, 0, 0);
        this._disposers.push(this.column);
    };
    /**
     * @ignore Exclude from docs
     */
    Column.prototype.validate = function () {
        _super.prototype.validate.call(this);
        var column = this.column;
        if (column) {
            column.width = Math_min(this.pixelWidth, this.maxWidth);
            column.height = Math_min(this.pixelHeight, this.maxHeight);
            if (column.invalid) {
                column.validate(); // important!
            }
        }
    };
    /**
     * Copies all parameters from another [[Column]].
     *
     * @param source Source Column
     */
    Column.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (this.column) {
            this.column.copyFrom(source.column);
        }
    };
    Object.defineProperty(Column.prototype, "bbox", {
        /**
         * Returns bounding box (square) for this element.
         *
         * @ignore Exclude from docs
         */
        get: function () {
            if (this.definedBBox) {
                return this.definedBBox;
            }
            if (this.column) {
                return { x: 0, y: 0, width: this.column.measuredWidth, height: this.column.measuredHeight };
            }
            else {
                return { x: 0, y: 0, width: Math_min(this.pixelWidth, this.maxWidth), height: Math_min(this.pixelHeight, this.maxHeight) };
            }
        },
        enumerable: true,
        configurable: true
    });
    return Column;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Column"] = Column_Column;
//# sourceMappingURL=Column.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/ColumnSeries.js
/**
 * Column series module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */

















/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[ColumnSeries]].
 *
 * @see {@link DataItem}
 */
var ColumnSeries_ColumnSeriesDataItem = /** @class */ (function (_super) {
    __extends(ColumnSeriesDataItem, _super);
    /**
     * Constructor
     */
    function ColumnSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "ColumnSeriesDataItem";
        _this.locations["dateX"] = 0.5;
        _this.locations["dateY"] = 0.5;
        _this.locations["categoryX"] = 0.5;
        _this.locations["categoryY"] = 0.5;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(ColumnSeriesDataItem.prototype, "column", {
        /**
         * @return Column
         */
        get: function () {
            return this._column;
        },
        /**
         * A column used to draw a column for this data item.
         *
         * @param column
         */
        set: function (column) {
            this.setColumn(column);
        },
        enumerable: true,
        configurable: true
    });
    ColumnSeriesDataItem.prototype.setColumn = function (column) {
        var _this = this;
        if (this._column && column != this._column) {
            remove(this.sprites, this._column);
        }
        this._column = column;
        if (column) {
            var prevDataItem = column.dataItem;
            if (prevDataItem && prevDataItem != this) {
                prevDataItem.column = undefined;
            }
            this.addSprite(column);
            this._disposers.push(new Disposer(function () {
                // TODO investigate why component is undefined
                // https://codepen.io/team/amcharts/pen/dac4be245d658233a6d7e5597df2208b?editors=0010
                if (_this.component) {
                    _this.component.columns.removeValue(column);
                }
            }));
        }
    };
    Object.defineProperty(ColumnSeriesDataItem.prototype, "width", {
        get: function () {
            var width = this.properties.width;
            if (this._adapterO) {
                width = this._adapterO.apply("width", width);
            }
            return width;
        },
        set: function (value) {
            if (this.properties.width != value) {
                this.properties.width = value;
                if (this.component) {
                    this.component.validateDataElement(this);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnSeriesDataItem.prototype, "rangesColumns", {
        /**
         * A dictionary storing axes ranges columns by axis uid
         */
        get: function () {
            if (!this._rangesColumns) {
                this._rangesColumns = new Dictionary_Dictionary();
            }
            return this._rangesColumns;
        },
        enumerable: true,
        configurable: true
    });
    return ColumnSeriesDataItem;
}(XYSeries_XYSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a column graph.
 *
 * @see {@link IColumnSeriesEvents} for a list of available Events
 * @see {@link IColumnSeriesAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var ColumnSeries_ColumnSeries = /** @class */ (function (_super) {
    __extends(ColumnSeries, _super);
    /**
     * Constructor
     */
    function ColumnSeries() {
        var _this = _super.call(this) || this;
        /**
         * Start location within cell for columns.
         */
        _this._startLocation = 0;
        /**
         * End location within cell for columns.
         */
        _this._endLocation = 1;
        _this.className = "ColumnSeries";
        _this.width = Percent_percent(100);
        _this.height = Percent_percent(100);
        _this.strokeOpacity = 0;
        _this.fillOpacity = 1;
        _this.clustered = true;
        var columnsContainer = _this.mainContainer.createChild(Container_Container);
        columnsContainer.shouldClone = false;
        columnsContainer.isMeasured = false;
        columnsContainer.layout = "none";
        _this._columnsContainer = columnsContainer;
        _this.columns.template.pixelPerfect = false;
        _this.tooltipColorSource = _this.columns.template;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(ColumnSeries.prototype, "columnsContainer", {
        /**
         * A container that columns are created in.
         *
         * @ignore Exclude from docs
         */
        get: function () {
            return this._columnsContainer;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    ColumnSeries.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Column Series");
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    ColumnSeries.prototype.createDataItem = function () {
        return new ColumnSeries_ColumnSeriesDataItem();
    };
    /**
     * (Re)validates the whole series, effectively causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    ColumnSeries.prototype.validate = function () {
        //@todo Check if we can do better than use `instanceof`
        // find start/end locations based on clustered/stacked settings
        // go through chart series instead of base axis series, because axis series doesn't maintain order
        var _this = this;
        this.group.node.removeAttribute("fill");
        if (this.chart && this.xAxis && this.yAxis) {
            var baseAxisSeries = this.chart.series;
            var clusterCount_1 = 0;
            var index_1 = 0;
            var sortedByAxis_1 = [];
            Iterator_each(baseAxisSeries.iterator(), function (series) {
                if (series instanceof ColumnSeries) {
                    if (_this.baseAxis == series.baseAxis) {
                        var index_2;
                        if (_this.baseAxis == _this.xAxis) {
                            index_2 = _this.chart.yAxes.indexOf(series.yAxis);
                        }
                        else {
                            index_2 = _this.chart.xAxes.indexOf(series.xAxis);
                        }
                        sortedByAxis_1.push({ series: series, axis: index_2 });
                    }
                }
            });
            sortedByAxis_1.sort(function (a, b) { return a.axis - b.axis; });
            var prevAxisIndex_1;
            each(sortedByAxis_1, function (sortedItem) {
                var series = sortedItem.series;
                if (series instanceof ColumnSeries) {
                    if ((!series.stacked && series.clustered) || (prevAxisIndex_1 != sortedItem.axis && series.clustered)) {
                        clusterCount_1++;
                    }
                    if (series == _this) {
                        index_1 = clusterCount_1 - 1;
                    }
                }
                prevAxisIndex_1 = sortedItem.axis;
            });
            if (!this.clustered) {
                index_1 = 0;
                clusterCount_1 = 1;
            }
            var renderer = this.baseAxis.renderer;
            var cellStartLocation = renderer.cellStartLocation;
            var cellEndLocation = renderer.cellEndLocation;
            this._startLocation = cellStartLocation + (index_1 / clusterCount_1) * (cellEndLocation - cellStartLocation);
            this._endLocation = cellStartLocation + (index_1 + 1) / clusterCount_1 * (cellEndLocation - cellStartLocation);
            var xAxis = this.xAxis;
            var yAxis = this.yAxis;
            if (xAxis instanceof CategoryAxis_CategoryAxis && yAxis instanceof ValueAxis_ValueAxis) {
                if (xAxis.sortBySeries == this) {
                    this.sortCategoryAxis(xAxis, "valueY");
                }
            }
            if (yAxis instanceof CategoryAxis_CategoryAxis && xAxis instanceof ValueAxis_ValueAxis) {
                if (yAxis.sortBySeries == this) {
                    this.sortCategoryAxis(yAxis, "valueX");
                }
            }
        }
        _super.prototype.validate.call(this);
        for (var i = 0; i < this.startIndex; i++) {
            var dataItem = this.dataItems.getIndex(i);
            this.disableUnusedColumns(dataItem);
        }
        for (var i = this.dataItems.length - 1; i > this.endIndex; i--) {
            var dataItem = this.dataItems.getIndex(i);
            this.disableUnusedColumns(dataItem);
        }
        this._propertiesChanged = false;
    };
    ColumnSeries.prototype.sortCategoryAxis = function (axis, key) {
        var _this = this;
        this.dataItems.values.sort(function (x, y) {
            return y.values[key].workingValue - x.values[key].workingValue;
        });
        var i = 0;
        this.dataItems.each(function (dataItem) {
            dataItem._index = i;
            i++;
        });
        axis.dataItems.each(function (dataItem) {
            var axis = dataItem.component;
            var currentPosition = axis.categoryToPosition(dataItem.category) - dataItem.deltaPosition;
            var seriesDataItem = axis.getSeriesDataItemByCategory(dataItem.category, _this);
            if (seriesDataItem) {
                var index = _this.dataItems.indexOf(seriesDataItem);
                dataItem._index = index;
                var deltaPosition = Math_round((index + 0.5) / _this.dataItems.length - currentPosition, 3);
                if (dataItem.deltaAnimation && !dataItem.deltaAnimation.isDisposed() && dataItem.deltaAnimation.animationOptions[0].to == deltaPosition) {
                    // void
                }
                else if (deltaPosition != Math_round(dataItem.deltaPosition, 3)) {
                    if (dataItem.deltaAnimation) {
                        dataItem.deltaAnimation.stop();
                    }
                    dataItem.deltaAnimation = dataItem.animate({ property: "deltaPosition", from: -deltaPosition, to: 0 }, axis.interpolationDuration, axis.interpolationEasing);
                    _this._disposers.push(dataItem.deltaAnimation);
                }
            }
        });
        axis.dataItems.values.sort(function (x, y) {
            return x.index - y.index;
        });
    };
    /**
     * Validates data item's element, effectively redrawing it.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    ColumnSeries.prototype.validateDataElement = function (dataItem) {
        // important oder here, first real, then super. we need this to know size
        if (this.chart && this.xAxis && this.yAxis) {
            this.validateDataElementReal(dataItem);
            _super.prototype.validateDataElement.call(this, dataItem);
        }
    };
    /**
     * Returns relative start location for the data item.
     *
     * @param dataItem  Data item
     * @return Location (0-1)
     */
    ColumnSeries.prototype.getStartLocation = function (dataItem) {
        var startLocation = this._startLocation;
        if (this.baseAxis == this.xAxis) {
            startLocation += dataItem.locations[this.xOpenField] - 0.5;
        }
        else {
            startLocation += dataItem.locations[this.yOpenField] - 0.5;
        }
        return startLocation;
    };
    /**
     * [handleDataItemWorkingValueChange description]
     *
     * @ignore Exclude from docs
     */
    /*
   public handleDataItemWorkingValueChange(dataItem?: this["_dataItem"], name?: string): void {
       if (this.simplifiedProcessing) {
           this.validateDataElement(dataItem);
       }
       else {
           super.handleDataItemWorkingValueChange(dataItem, name);
       }
   }*/
    /**
     * Returns relative end location for the data item.
     *
     * @param dataItem  Data item
     * @return Location (0-1)
     */
    ColumnSeries.prototype.getEndLocation = function (dataItem) {
        var endLocation = this._endLocation;
        if (this.baseAxis == this.xAxis) {
            endLocation += dataItem.locations[this.xField] - 0.5;
        }
        else {
            endLocation += dataItem.locations[this.yField] - 0.5;
        }
        return endLocation;
    };
    /**
     * Validates data item's elements.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    ColumnSeries.prototype.validateDataElementReal = function (dataItem) {
        var _this = this;
        //	if (dataItem.hasValue([this.xField, this.yField])) { // todo: this doesn't work with categories, think of a better way
        var l;
        var r;
        var t;
        var b;
        var startLocation = this.getStartLocation(dataItem);
        var endLocation = this.getEndLocation(dataItem);
        var xField = this.xField;
        var xOpenField = this.xOpenField;
        var yField = this.yField;
        var yOpenField = this.yOpenField;
        var template = this.columns.template;
        var percentWidth = template.percentWidth;
        var percentHeight = template.percentHeight;
        var pixelWidth = template.pixelWidth;
        var pixelHeight = template.pixelHeight;
        var maxWidth = template.maxWidth;
        var maxHeight = template.maxHeight;
        var paddingLeft = template.pixelPaddingLeft;
        var paddingRight = template.pixelPaddingRight;
        var paddingTop = template.pixelPaddingTop;
        var paddingBottom = template.pixelPaddingBottom;
        var outOfBounds = false;
        var diw = dataItem.width;
        if (hasValue(diw)) {
            if (isNumber(diw)) {
                pixelWidth = diw;
            }
            if (diw instanceof Percent) {
                percentWidth = diw.value * 100;
            }
        }
        // two category axes
        if ((this.xAxis instanceof CategoryAxis_CategoryAxis) && (this.yAxis instanceof CategoryAxis_CategoryAxis)) {
            if (!dataItem.hasValue(this._xValueFields) || !dataItem.hasValue(this._yValueFields)) {
                return;
            }
            startLocation = 0;
            endLocation = 1;
            if (!Type_isNaN(percentWidth)) {
                var offset = Math_round((endLocation - startLocation) * (1 - percentWidth / 100) / 2, 5);
                startLocation += offset;
                endLocation -= offset;
            }
            l = this.xAxis.getX(dataItem, xOpenField, startLocation);
            r = this.xAxis.getX(dataItem, xField, endLocation);
            // in case width is set in pixels
            if (Type_isNaN(percentWidth)) {
                var offset = ((r - l) - pixelWidth) / 2;
                l += offset;
                r -= offset;
            }
            // in case max width is set in pixels
            if (!Type_isNaN(maxWidth) && maxWidth < Math.abs(r - l)) {
                var offset = ((r - l) - maxWidth) / 2;
                l += offset;
                r -= offset;
            }
            startLocation = 0;
            endLocation = 1;
            if (!Type_isNaN(percentHeight)) {
                var offset = Math_round((1 - percentHeight / 100) / 2, 5);
                startLocation += offset;
                endLocation -= offset;
            }
            t = this.yAxis.getY(dataItem, yOpenField, startLocation);
            b = this.yAxis.getY(dataItem, yField, endLocation);
            // in case width is set in pixels
            if (Type_isNaN(percentHeight)) {
                var offset = ((b - t) - pixelHeight) / 2;
                b += offset;
                t -= offset;
            }
            // in case max width is set in pixels
            if (!Type_isNaN(maxHeight) && maxHeight < Math.abs(b - t)) {
                var offset = ((b - t) - maxHeight) / 2;
                b += offset;
                t -= offset;
            }
            r = this.fixHorizontalCoordinate(r);
            l = this.fixHorizontalCoordinate(l);
            t = this.fixVerticalCoordinate(t);
            b = this.fixVerticalCoordinate(b);
        }
        else if (this.baseAxis == this.xAxis) {
            if (!dataItem.hasValue(this._yValueFields)) {
                return;
            }
            // in case width is set in percent
            if (!Type_isNaN(percentWidth)) {
                var offset = Math_round((endLocation - startLocation) * (1 - percentWidth / 100) / 2, 5);
                startLocation += offset;
                endLocation -= offset;
            }
            l = this.xAxis.getX(dataItem, xOpenField, startLocation);
            r = this.xAxis.getX(dataItem, xField, endLocation);
            // in case width is set in pixels
            if (Type_isNaN(percentWidth)) {
                var offset = ((r - l) - pixelWidth) / 2;
                l += offset;
                r -= offset;
            }
            // in case width is set in pixels
            if (!Type_isNaN(maxWidth) && maxWidth < Math.abs(r - l)) {
                var offset = ((r - l) - maxWidth) / 2;
                l += offset;
                r -= offset;
            }
            var bottomLocation = dataItem.locations[yOpenField];
            var topLocation = dataItem.locations[yField];
            // otherwise gantt chart will start items in the middle of a cell
            if (this.yAxis instanceof ValueAxis_ValueAxis) {
                if (this.dataFields[this.yField] != this.dataFields[this.yOpenField]) {
                    bottomLocation = 0;
                    topLocation = 0;
                }
            }
            b = this.yAxis.getY(dataItem, yOpenField, bottomLocation);
            t = this.yAxis.getY(dataItem, yField, topLocation);
            // used to save location for bullets, but it's not a good approach
            // dataItem.locations[xField] = startLocation + (endLocation - startLocation) / 2;
            var axisLenght = Math.ceil(this.yAxis.axisLength);
            if ((t < 0 && b < 0) || (t > axisLenght && b > axisLenght)) {
                outOfBounds = true;
            }
            t = this.fixVerticalCoordinate(t);
            b = this.fixVerticalCoordinate(b);
            if (Math.abs(r - l) - paddingLeft - paddingRight == 0) {
                outOfBounds = true;
            }
        }
        // horizontal bars
        else {
            if (!dataItem.hasValue(this._xValueFields)) {
                return;
            }
            if (!Type_isNaN(percentHeight)) {
                var offset = Math_round((endLocation - startLocation) * (1 - percentHeight / 100) / 2, 5);
                startLocation += offset;
                endLocation -= offset;
            }
            t = this.yAxis.getY(dataItem, yOpenField, startLocation);
            b = this.yAxis.getY(dataItem, yField, endLocation);
            // in case height is set in pixels
            if (Type_isNaN(percentHeight)) {
                var offset = ((b - t) - pixelHeight) / 2;
                b -= offset;
                t += offset;
            }
            // in case height is set in pixels
            if (!Type_isNaN(maxHeight) && maxHeight < Math.abs(b - t)) {
                var offset = ((b - t) - maxHeight) / 2;
                b -= offset;
                t += offset;
            }
            var rightLocation = dataItem.locations[xField];
            var leftLocation = dataItem.locations[xOpenField];
            // otherwise gantt chart will start items in the middle of a cell
            if (this.xAxis instanceof ValueAxis_ValueAxis) {
                if (this.dataFields[this.xField] != this.dataFields[this.xOpenField]) {
                    rightLocation = 0;
                    leftLocation = 0;
                }
            }
            r = this.xAxis.getX(dataItem, xField, rightLocation);
            l = this.xAxis.getX(dataItem, xOpenField, leftLocation);
            // used to save location for bullets, but it's not a good approach
            // dataItem.locations[yField] = startLocation + (endLocation - startLocation) / 2;
            var axisLenght = Math.ceil(this.xAxis.axisLength);
            if ((r < 0 && l < 0) || (r > axisLenght && l > axisLenght)) {
                outOfBounds = true;
            }
            r = this.fixHorizontalCoordinate(r);
            l = this.fixHorizontalCoordinate(l);
            if (Math.abs(t - b) - paddingTop - paddingBottom == 0) {
                outOfBounds = true;
            }
        }
        var w = Math.abs(r - l);
        var h = Math.abs(b - t);
        var x = Math.min(l, r);
        var y = Math.min(t, b);
        if (!outOfBounds) {
            var column_1;
            if (!dataItem.column) {
                column_1 = this.columns.create();
                //$object.forceCopyProperties(this.columns.template, column, visualProperties);
                copyProperties(this, column_1, visualProperties); // need this because 3d columns are not in the same container
                copyProperties(this.columns.template, column_1, visualProperties); // second time, no force, so that columns.template would override series properties
                dataItem.addSprite(column_1);
                dataItem.column = column_1;
                column_1.paper = this.paper; // sometimes pattern is not drawn if is set with adapter without this.
                // accessibility
                if (this.itemsFocusable()) {
                    this.role = "menu";
                    column_1.role = "menuitem";
                    column_1.focusable = true;
                }
                else {
                    this.role = "list";
                    column_1.role = "listitem";
                    column_1.focusable = false;
                }
                if (column_1.focusable) {
                    column_1.events.on("focus", function (ev) {
                        column_1.readerTitle = _this.populateString(_this.itemReaderText, dataItem);
                    }, undefined, false);
                    column_1.events.on("blur", function (ev) {
                        column_1.readerTitle = "";
                    }, undefined, false);
                }
                if (column_1.hoverable) {
                    column_1.events.on("over", function (ev) {
                        column_1.readerTitle = _this.populateString(_this.itemReaderText, dataItem);
                    }, undefined, false);
                    column_1.events.on("out", function (ev) {
                        column_1.readerTitle = "";
                    }, undefined, false);
                }
                column_1.parent = this.columnsContainer;
                column_1.virtualParent = this;
            }
            else {
                column_1 = dataItem.column;
                if (this._propertiesChanged) {
                    copyProperties(this, column_1, visualProperties);
                    copyProperties(this.columns.template, column_1, visualProperties);
                    each(visualProperties, function (property) {
                        column_1[property] = column_1[property];
                    });
                }
            }
            column_1.width = w;
            column_1.height = h;
            column_1.x = x;
            column_1.y = y;
            column_1.realX = l;
            column_1.realY = t;
            column_1.realWidth = r - l;
            column_1.realHeight = b - t;
            this.setColumnStates(column_1);
            if (column_1.invalid) {
                column_1.validate(); // validate as if it was used previously, it will flicker with previous dimensions
            }
            column_1.__disabled = false;
            //column.returnAfterTemp();
            Iterator_each(this.axisRanges.iterator(), function (axisRange) {
                var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
                if (!rangeColumn) {
                    rangeColumn = _this.columns.create();
                    //$object.forceCopyProperties(this.columns.template, rangeColumn, visualProperties);
                    copyProperties(axisRange.contents, rangeColumn, visualProperties); // need this because 3d columns are not in the same container
                    dataItem.addSprite(rangeColumn);
                    dataItem.rangesColumns.setKey(axisRange.uid, rangeColumn);
                    rangeColumn.paper = _this.paper; // sometimes pattern is not drawn if is set with adapter without this.
                }
                rangeColumn.parent = axisRange.contents;
                rangeColumn.width = w;
                rangeColumn.height = h;
                rangeColumn.x = x;
                rangeColumn.y = y;
                _this.setColumnStates(rangeColumn);
                if (rangeColumn.invalid) {
                    rangeColumn.validate(); // validate as if it was used previously, it will flicker with previous dimensions
                }
                rangeColumn.__disabled = false;
                //rangeColumn.returnAfterTemp();
            });
        }
        else {
            this.disableUnusedColumns(dataItem);
        }
        dataItem.itemWidth = w;
        dataItem.itemHeight = h;
    };
    /**
     * @ignore
     */
    ColumnSeries.prototype.disableUnusedColumns = function (dataItem) {
        if (dataItem) {
            if (dataItem.column) {
                // otherwise might flicker when enabling
                dataItem.column.width = 0;
                dataItem.column.height = 0;
                dataItem.column.__disabled = true;
            }
            Iterator_each(this.axisRanges.iterator(), function (axisRange) {
                var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
                if (rangeColumn) {
                    // otherwise might flicker when enabling
                    rangeColumn.width = 0;
                    rangeColumn.height = 0;
                    rangeColumn.__disabled = true;
                }
            });
        }
    };
    /**
     * Apply different state/coloring to columns based on the change value.
     *
     * @param sprite  Sprite to apply state to
     * @todo Do not apply accessibility to wicks of the candlesticks
     */
    ColumnSeries.prototype.setColumnStates = function (sprite) {
        if (this._dropFromOpenState || this._dropFromPreviousState || this._riseFromOpenState || this._riseFromPreviousState) {
            var dataItem = sprite.dataItem;
            if (this.xAxis instanceof ValueAxis_ValueAxis || this.yAxis instanceof ValueAxis_ValueAxis) {
                var open_1;
                var value = void 0;
                var change = void 0;
                if (this.baseAxis == this.yAxis) {
                    if (this.xOpenField && this.xField && this.xAxis instanceof ValueAxis_ValueAxis) {
                        open_1 = dataItem.getValue(this.xOpenField);
                        value = dataItem.getValue(this.xField);
                        change = dataItem.getValue(this.xAxis.axisFieldName + "X", "previousChange");
                    }
                }
                else {
                    if (this.yOpenField && this.yField && this.yAxis instanceof ValueAxis_ValueAxis) {
                        open_1 = dataItem.getValue(this.yOpenField);
                        value = dataItem.getValue(this.yField);
                        change = dataItem.getValue(this.yAxis.axisFieldName + "Y", "previousChange");
                    }
                }
                if (value < open_1) {
                    dataItem.droppedFromOpen = true;
                    sprite.defaultState.copyFrom(this._dropFromOpenState);
                    sprite.setState(this._dropFromOpenState, 0);
                }
                else {
                    dataItem.droppedFromOpen = false;
                    sprite.defaultState.copyFrom(this._riseFromOpenState);
                    sprite.setState(this._riseFromOpenState, 0);
                }
                if (change < 0) {
                    dataItem.droppedFromPrevious = true;
                    sprite.defaultState.copyFrom(this._dropFromPreviousState);
                    sprite.setState((this._dropFromPreviousState), 0);
                }
                else {
                    dataItem.droppedFromPrevious = false;
                    sprite.defaultState.copyFrom(this._riseFromPreviousState);
                    sprite.setState((this._riseFromPreviousState), 0);
                }
            }
        }
    };
    Object.defineProperty(ColumnSeries.prototype, "columns", {
        /**
         * A list of column elements in the series.
         *
         * @return Columns
         */
        get: function () {
            if (!this._columns) {
                this._columns = new List_ListTemplate(this.createColumnTemplate());
                this._disposers.push(new List_ListDisposer(this._columns));
                this._disposers.push(this._columns.template);
            }
            return this._columns;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates and returns a column element to use as a template.
     *
     * @return Column template
     */
    ColumnSeries.prototype.createColumnTemplate = function () {
        return new Column_Column();
    };
    Object.defineProperty(ColumnSeries.prototype, "clustered", {
        /**
         * @return Clustered?
         */
        get: function () {
            return this.getPropertyValue("clustered");
        },
        /**
         * Cluster this series columns?
         *
         * Setting to `false` will make columns overlap with other series.
         *
         * @default true
         * @param value  Clustered?
         */
        set: function (value) {
            this.setPropertyValue("clustered", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnSeries.prototype, "dropFromOpenState", {
        /**
         * @return State
         */
        get: function () {
            if (!this._dropFromOpenState) {
                this._dropFromOpenState = this.states.create("dropFromOpenState");
            }
            return this._dropFromOpenState;
        },
        /**
         * A state to apply to a column when close value is lower than open value.
         *
         * Can be used to differentiate appearance based on value relations.
         *
         * NOTE: this will work only if at least one axis is [[ValueAxis]].
         *
         * @readonly You can modify state object, but can't overwrite it
         * @param  value  State
         */
        set: function (value) {
            this._dropFromOpenState = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnSeries.prototype, "dropFromPreviousState", {
        /**
         * @return State
         */
        get: function () {
            if (!this._dropFromPreviousState) {
                this._dropFromPreviousState = this.states.create("dropFromPreviousState");
            }
            return this._dropFromPreviousState;
        },
        /**
         * A state to apply to a column when its value is lower value of a previous
         * column.
         *
         * Can be used to differentiate appearance based on value relations.
         *
         * @readonly You can modify state object, but can't overwrite it
         * @param  value  State
         */
        set: function (value) {
            this._dropFromPreviousState = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnSeries.prototype, "riseFromOpenState", {
        /**
         * @return State
         */
        get: function () {
            if (!this._riseFromOpenState) {
                this._riseFromOpenState = this.states.create("riseFromOpenState");
            }
            return this._riseFromOpenState;
        },
        /**
         * A state to apply to a column when close value is same or higher than open
         * value.
         *
         * Can be used to differentiate appearance based on value relations.
         *
         * NOTE: this will work only if at least one axis is [[ValueAxis]].
         *
         * @readonly You can modify state object, but can't overwrite it
         * @param  value  State
         */
        set: function (value) {
            this._riseFromOpenState = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnSeries.prototype, "riseFromPreviousState", {
        /**
         * @return State
         */
        get: function () {
            if (!this._riseFromPreviousState) {
                this._riseFromPreviousState = this.states.create("riseFromPreviousState");
            }
            return this._riseFromPreviousState;
        },
        /**
         * A state to apply to a column when its value is same or higher than value
         * of a previous column.
         *
         * Can be used to differentiate appearance based on value relations.
         *
         * @readonly You can modify state object, but can't overwrite it
         * @param  value  State
         */
        set: function (value) {
            this._riseFromPreviousState = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates value of the related legend item.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    ColumnSeries.prototype.updateLegendValue = function (dataItem, notRange) {
        var _this = this;
        _super.prototype.updateLegendValue.call(this, dataItem, notRange);
        if (this.legendDataItem) {
            var marker = this.legendDataItem.marker;
            var fromOpenState_1;
            var fromPreviousState_1;
            if (dataItem) {
                if (dataItem.droppedFromOpen) {
                    fromOpenState_1 = this._dropFromOpenState;
                }
                else {
                    fromOpenState_1 = this._riseFromOpenState;
                }
                if (dataItem.droppedFromPrevious) {
                    fromPreviousState_1 = this._dropFromPreviousState;
                }
                else {
                    fromPreviousState_1 = this._riseFromPreviousState;
                }
            }
            Iterator_each(marker.children.iterator(), function (child) {
                if (dataItem) {
                    child.setState(fromPreviousState_1);
                    child.setState(fromOpenState_1);
                }
                else {
                    // todo: think what to do here, maybe apply above states based on totals?
                    child.setState(_this._riseFromPreviousState);
                    child.setState(_this._riseFromOpenState);
                }
            });
        }
    };
    /**
     * Creates elements in related legend container, that mimics the look of this
     * Series.
     *
     * @ignore Exclude from docs
     * @param marker  Legend item container
     */
    ColumnSeries.prototype.createLegendMarker = function (marker) {
        var w = marker.pixelWidth;
        var h = marker.pixelHeight;
        marker.removeChildren();
        var column = marker.createChild(RoundedRectangle_RoundedRectangle);
        column.shouldClone = false;
        copyProperties(this, column, visualProperties);
        column.copyFrom(this.columns.template);
        column.padding(0, 0, 0, 0); // if columns will have padding (which is often), legend marker will be very narrow
        column.width = w;
        column.height = h;
        var legendDataItem = marker.dataItem;
        legendDataItem.color = this.fill;
        legendDataItem.colorOrig = this.fill;
    };
    /**
     * Copies all properties from another instance of [[ColumnSeries]].
     *
     * @param source  Source series
     */
    ColumnSeries.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.columns.template.copyFrom(source.columns.template);
    };
    /**
    * returns bullet x location
    * @ignore
    */
    ColumnSeries.prototype.getBulletLocationX = function (bullet, field) {
        if (this.baseAxis == this.xAxis) {
            var bulletLocationX = bullet.locationX;
            if (!isNumber(bulletLocationX)) {
                bulletLocationX = 0.5;
            }
            var endLocation = this.getEndLocation(bullet.dataItem);
            var startLocation = this.getStartLocation(bullet.dataItem);
            return endLocation - (endLocation - startLocation) * bulletLocationX;
        }
        else {
            return _super.prototype.getBulletLocationX.call(this, bullet, field);
        }
    };
    /**
    * returns bullet y location
    * @ignore
    */
    ColumnSeries.prototype.getBulletLocationY = function (bullet, field) {
        if (this.baseAxis == this.yAxis) {
            var bulletLocationY = bullet.locationY;
            if (!isNumber(bulletLocationY)) {
                bulletLocationY = 0.5;
            }
            var endLocation = this.getEndLocation(bullet.dataItem);
            var startLocation = this.getStartLocation(bullet.dataItem);
            return endLocation - (endLocation - startLocation) * bulletLocationY;
        }
        else {
            return _super.prototype.getBulletLocationY.call(this, bullet, field);
        }
    };
    ColumnSeries.prototype.getAdjustedXLocation = function (dataItem, field) {
        if (this.baseAxis == this.xAxis) {
            var bulletLocationX = 0.5;
            if (dataItem) {
                bulletLocationX = dataItem.locations[field];
            }
            if (!isNumber(bulletLocationX)) {
                bulletLocationX = 0.5;
            }
            return this._endLocation - (this._endLocation - this._startLocation) * bulletLocationX;
        }
        else {
            return _super.prototype.getAdjustedXLocation.call(this, dataItem, field);
        }
    };
    ColumnSeries.prototype.getAdjustedYLocation = function (dataItem, field) {
        if (this.baseAxis == this.yAxis) {
            var bulletLocationY = 0.5;
            if (dataItem) {
                bulletLocationY = dataItem.locations[field];
            }
            if (!isNumber(bulletLocationY)) {
                bulletLocationY = 0.5;
            }
            return this._endLocation - (this._endLocation - this._startLocation) * bulletLocationY;
        }
        else {
            return _super.prototype.getAdjustedXLocation.call(this, dataItem, field);
        }
    };
    /**
     * @ignore Exclude from docs
     */
    ColumnSeries.prototype.fixVerticalCoordinate = function (coordinate) {
        var paddingBottom = this.columns.template.pixelPaddingBottom;
        var paddingTop = this.columns.template.pixelPaddingTop;
        var minY = -paddingTop;
        var maxY = this.yAxis.axisLength + paddingBottom;
        return fitToRange(coordinate, minY, maxY);
    };
    /**
     * @ignore Exclude from docs
     */
    ColumnSeries.prototype.fixHorizontalCoordinate = function (coordinate) {
        var paddingLeft = this.columns.template.pixelPaddingLeft;
        var paddingRight = this.columns.template.pixelPaddingRight;
        var minX = -paddingLeft;
        var maxX = this.xAxis.axisLength + paddingRight;
        return fitToRange(coordinate, minX, maxX);
    };
    /**
     * @ignore
     */
    ColumnSeries.prototype.disposeData = function () {
        _super.prototype.disposeData.call(this);
        this.columns.clear();
    };
    return ColumnSeries;
}(XYSeries_XYSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ColumnSeries"] = ColumnSeries_ColumnSeries;
registry.registeredClasses["ColumnSeriesDataItem"] = ColumnSeries_ColumnSeriesDataItem;
//# sourceMappingURL=ColumnSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/TreeMapSeries.js
/**
 * TreeMap series module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[TreeMapSeries]].
 *
 * @see {@link DataItem}
 */
var TreeMapSeries_TreeMapSeriesDataItem = /** @class */ (function (_super) {
    __extends(TreeMapSeriesDataItem, _super);
    /**
     * Constructor
     */
    function TreeMapSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "TreeMapSeriesDataItem";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(TreeMapSeriesDataItem.prototype, "parentName", {
        /**
         * Data for the this particular item.
         *
         * @param value  Item's data
         */
        //public set dataContext(value: Object) {
        //	this._dataContext = value;
        //}
        /**
         * @return Item's data
         */
        /*
       public get dataContext(): Object {
           // It's because data of tree series is TreeMapDataItems.
           if (this._dataContext) {
               return (<any>this._dataContext).dataContext;
           }
       }*/
        /**
         * The name of the item's parent item.
         *
         * @return Parent name
         */
        get: function () {
            var treeMapDataItem = this.treeMapDataItem;
            if (treeMapDataItem && treeMapDataItem.parent) {
                return treeMapDataItem.parent.name;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapSeriesDataItem.prototype, "value", {
        /**
         * Item's numeric value.
         *
         * @readonly
         * @return Value
         */
        get: function () {
            var treeMapDataItem = this.treeMapDataItem;
            if (treeMapDataItem) {
                return treeMapDataItem.value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapSeriesDataItem.prototype, "treeMapDataItem", {
        /**
         * A corresponding data item from the tree map.
         *
         * @readonly
         * @return Data item
         */
        get: function () {
            return this._dataContext;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Hides the Data Item and related visual elements.
     *
     * @param duration  Animation duration (ms)
     * @param delay     Delay animation (ms)
     * @param toValue   A value to set to `fields` when hiding
     * @param fields    A list of data fields to set value to `toValue`
     */
    TreeMapSeriesDataItem.prototype.hide = function (duration, delay, toValue, fields) {
        var treeMapDataItem = this.treeMapDataItem;
        if (treeMapDataItem) {
            treeMapDataItem.hide(duration);
        }
        return _super.prototype.hide.call(this, duration, delay, toValue, fields);
    };
    /**
     * Shows the Data Item and related visual elements.
     *
     * @param duration  Animation duration (ms)
     * @param delay     Delay animation (ms)
     * @param fields    A list of fields to set values of
     */
    TreeMapSeriesDataItem.prototype.show = function (duration, delay, fields) {
        var treeMapDataItem = this.treeMapDataItem;
        if (treeMapDataItem) {
            treeMapDataItem.show(duration, delay, fields);
        }
        return _super.prototype.show.call(this, duration, delay, fields);
    };
    return TreeMapSeriesDataItem;
}(ColumnSeries_ColumnSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines Series for a TreeMap chart.
 *
 * @see {@link ITreeMapSeriesEvents} for a list of available Events
 * @see {@link ITreeMapSeriesAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var TreeMapSeries_TreeMapSeries = /** @class */ (function (_super) {
    __extends(TreeMapSeries, _super);
    /**
     * Constructor
     */
    function TreeMapSeries() {
        var _this = _super.call(this) || this;
        _this.className = "TreeMapSeries";
        _this.applyTheme();
        _this.fillOpacity = 1;
        _this.strokeOpacity = 1;
        _this.minBulletDistance = 0;
        _this.columns.template.tooltipText = "{parentName} {name}: {value}"; //@todo add format number?
        _this.columns.template.configField = "config";
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        _this.stroke = interfaceColors.getFor("background");
        _this.dataFields.openValueX = "x0";
        _this.dataFields.valueX = "x1";
        _this.dataFields.openValueY = "y0";
        _this.dataFields.valueY = "y1";
        _this.sequencedInterpolation = false;
        _this.showOnInit = false;
        // otherwise nodes don't stack nicely to each other
        _this.columns.template.pixelPerfect = false;
        return _this;
    }
    /**
     * Processes data item.
     *
     * @param dataItem     Data item
     * @param dataContext  Raw data
     * @param index        Index of the data item
     */
    TreeMapSeries.prototype.processDataItem = function (dataItem, dataContext) {
        dataContext.seriesDataItem = dataItem; // save a reference here. dataContext is TreeMapDataItem and we need to know dataItem sometimes
        _super.prototype.processDataItem.call(this, dataItem, dataContext);
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    TreeMapSeries.prototype.createDataItem = function () {
        return new TreeMapSeries_TreeMapSeriesDataItem();
    };
    /**
     * Shows series.
     *
     * @param duration  Duration of fade in (ms)
     * @return Animation
     */
    TreeMapSeries.prototype.show = function (duration) {
        if (this.preventShow) {
            return;
        }
        var interpolationDuration = this.defaultState.transitionDuration;
        if (isNumber(duration)) {
            interpolationDuration = duration;
        }
        this.dataItems.each(function (dataItem) {
            //dataItem.treeMapDataItem.setWorkingValue("value", dataItem.treeMapDataItem.values.value.value);
            dataItem.show(duration);
        });
        return _super.prototype.showReal.call(this, interpolationDuration);
    };
    /**
     * Hides series.
     *
     * @param duration  Duration of fade out (ms)
     * @return Animation
     */
    TreeMapSeries.prototype.hide = function (duration) {
        var interpolationDuration = this.defaultState.transitionDuration;
        if (isNumber(duration)) {
            interpolationDuration = duration;
        }
        var animation = _super.prototype.hideReal.call(this, interpolationDuration);
        this.dataItems.each(function (dataItem) {
            //dataItem.treeMapDataItem.setWorkingValue("value", 0);
            dataItem.hide(duration);
        });
        return animation;
    };
    /**
     * Process values.
     *
     * @ignore Exclude from docs
     */
    TreeMapSeries.prototype.processValues = function () {
        // Just overriding so that inherited method does not kick in.
    };
    /**
     * Returns relative start location for the data item.
     *
     * @param dataItem  Data item
     * @return Location (0-1)
     */
    TreeMapSeries.prototype.getStartLocation = function (dataItem) {
        return 0;
    };
    /**
     * Returns relative end location for the data item.
     *
     * @param dataItem  Data item
     * @return Location (0-1)
     */
    TreeMapSeries.prototype.getEndLocation = function (dataItem) {
        return 1;
    };
    /**
     * @ignore
     */
    TreeMapSeries.prototype.dataChangeUpdate = function () {
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    TreeMapSeries.prototype.processConfig = function (config) {
        if (config) {
            // Add empty data fields if the they are not set, so that XYSeries
            // dataField check does not result in error.
            if (!hasValue(config.dataFields) || !isObject(config.dataFields)) {
                config.dataFields = {};
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    /**
     * Creates elements in related legend container, that mimics the look of this
     * Series.
     *
     * @ignore Exclude from docs
     * @param marker  Legend item container
     */
    TreeMapSeries.prototype.createLegendMarker = function (marker) {
        var w = marker.pixelWidth;
        var h = marker.pixelHeight;
        marker.removeChildren();
        var column = marker.createChild(RoundedRectangle_RoundedRectangle);
        column.shouldClone = false;
        copyProperties(this, column, visualProperties);
        //column.copyFrom(<any>this.columns.template);
        column.padding(0, 0, 0, 0); // if columns will have padding (which is often), legend marker will be very narrow
        column.width = w;
        column.height = h;
        var legendDataItem = marker.dataItem;
        legendDataItem.color = column.fill;
        legendDataItem.colorOrig = column.fill;
    };
    TreeMapSeries.prototype.disableUnusedColumns = function (dataItem) {
        _super.prototype.disableUnusedColumns.call(this, dataItem);
        if (dataItem.column) {
            dataItem.column.__disabled = false;
        }
    };
    return TreeMapSeries;
}(ColumnSeries_ColumnSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["TreeMapSeries"] = TreeMapSeries_TreeMapSeries;
registry.registeredClasses["TreeMapSeriesDataItem"] = TreeMapSeries_TreeMapSeriesDataItem;
//# sourceMappingURL=TreeMapSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/TreeMap.js
/**
 * TreeMap chart module.
 *
 * Parts of the functionality used in this module are taken from D3.js library
 * (https://d3js.org/)
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */










/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[TreeMap]].
 *
 * @see {@link DataItem}
 */
var TreeMap_TreeMapDataItem = /** @class */ (function (_super) {
    __extends(TreeMapDataItem, _super);
    /**
     * Constructor
     */
    function TreeMapDataItem() {
        var _this = _super.call(this) || this;
        /**
         * Required for squarify functionality.
         *
         * @ignore Exclude from docs
         */
        _this.rows = [];
        _this.className = "TreeMapDataItem";
        _this.values.value = {};
        _this.values.x0 = {};
        _this.values.y0 = {};
        _this.values.x1 = {};
        _this.values.y1 = {};
        _this.hasChildren.children = true;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(TreeMapDataItem.prototype, "legendDataItem", {
        /**
         * @return Legend data item
         */
        get: function () {
            return this._legendDataItem;
        },
        /**
         * A legend's data item, that corresponds to this data item.
         *
         * @param value  Legend data item
         */
        set: function (value) {
            this._legendDataItem = value;
            if (value.label) {
                value.label.dataItem = this;
            }
            if (value.valueLabel) {
                value.valueLabel.dataItem = this;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a duration (ms) the Data Item should take to animate from one
     * value to another.
     *
     * If the duration is not specified via parameter, this method will try to
     * request a default duration from the related `Component`.
     *
     * @param duration  Default duration (ms)
     * @return Duration (ms)
     */
    TreeMapDataItem.prototype.getDuration = function () {
        return 0;
    };
    Object.defineProperty(TreeMapDataItem.prototype, "value", {
        /**
         * @return Value
         */
        get: function () {
            var value = 0;
            if (!this.children || this.children.length == 0) {
                value = this.values["value"].workingValue;
            }
            else {
                Iterator_each(this.children.iterator(), function (child) {
                    var childValue = child.value;
                    if (isNumber(childValue)) {
                        value += childValue;
                    }
                });
            }
            return value;
            /*
            let value = this.values["value"].workingValue;
    
            if (!$type.isNumber(value)) {
                value = 0;
                if (this.children) {
                    $iter.each(this.children.iterator(), (child) => {
                        if ($type.isNumber(child.value)) {
                            value += child.value;
                        }
                    });
                }
            }
            return value;*/
        },
        /**
         * Numeric value of the item.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("value", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "percent", {
        /**
         * Percent value of a node
         */
        get: function () {
            if (this.parent) {
                return this.value / this.parent.value * 100;
            }
            return 100;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "x0", {
        /**
         * @return X
         */
        get: function () {
            return this.values.x0.value;
        },
        /**
         * Item's X position.
         *
         * @ignore Exclude from docs
         * @todo Description (review)
         * @param value  X
         */
        set: function (value) {
            this.setValue("x0", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "x1", {
        /**
         * @return X
         */
        get: function () {
            return this.values.x1.value;
        },
        /**
         * Item's X position.
         *
         * @ignore Exclude from docs
         * @todo Description (review)
         * @param value  X
         */
        set: function (value) {
            this.setValue("x1", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "y0", {
        /**
         * @return Y
         */
        get: function () {
            return this.values.y0.value;
        },
        /**
         * Item's Y position.
         *
         * @ignore Exclude from docs
         * @todo Description (review)
         * @param value  Y
         */
        set: function (value) {
            this.setValue("y0", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "y1", {
        /**
         * @return Y
         */
        get: function () {
            return this.values.y1.value;
        },
        /**
         * Item's Y position.
         *
         * @ignore Exclude from docs
         * @todo Description (review)
         * @param value  Y
         */
        set: function (value) {
            this.setValue("y1", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "name", {
        /**
         * @return Name
         */
        get: function () {
            return this.properties.name;
        },
        /**
         * Item's name.
         *
         * @param name  Name
         */
        set: function (name) {
            this.setProperty("name", name);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "children", {
        /**
         * @return Item's children
         */
        get: function () {
            return this.properties.children;
        },
        /**
         * A list of item's sub-children.
         *
         * Having children means that the TreeMap chat will automatically be
         * "drillable". Clicking on an item with children will zoom to the item, then
         * display its children.
         *
         * Treemap can have any level of nesting.
         *
         * @param children  Item's children
         */
        set: function (children) {
            this.setProperty("children", children);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "level", {
        /**
         * Depth level in the treemap hierarchy.
         *
         * The top-level item will have level set at 0. Its children will have
         * level 1, and so on.
         *
         * @readonly
         * @return Level
         */
        get: function () {
            if (!this.parent) {
                return 0;
            }
            else {
                return this.parent.level + 1;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "color", {
        /**
         * @return Color
         */
        get: function () {
            var color = this.properties.color;
            if (color == undefined) {
                if (this.parent) {
                    color = this.parent.color;
                }
            }
            if (color == undefined) {
                if (this.component) {
                    color = this.component.colors.getIndex(this.component.colors.step * this.index);
                }
            }
            return color;
        },
        /**
         * Item's color.
         *
         * If not set, will use parent's color, or, if that is not set either,
         * automatically assigned color from chart's color set. (`chart.colors`)
         *
         * @param value  Color
         */
        set: function (value) {
            this.setProperty("color", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "fill", {
        /**
         * @ignore
         * For the legend to work properly
         */
        get: function () {
            return this.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMapDataItem.prototype, "series", {
        get: function () {
            return this._series;
        },
        /**
         * Series of children data items
         * @todo: proper descrition
         */
        set: function (series) {
            if (series != this._series) {
                if (this._series) {
                    this.component.series.removeValue(this._series);
                    this._series.dispose();
                }
                this._series = series;
                this._disposers.push(series);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Hides the Data Item and related visual elements.
     *
     * @param duration  Animation duration (ms)
     * @param delay     Delay animation (ms)
     * @param toValue   A value to set to `fields` when hiding
     * @param fields    A list of data fields to set value to `toValue`
     */
    TreeMapDataItem.prototype.hide = function (duration, delay, toValue, fields) {
        this.setWorkingValue("value", 0);
        if (this.children) {
            this.children.each(function (child) {
                child.hide(duration, delay, toValue, fields);
            });
        }
        var seriesDataItem = this.seriesDataItem;
        if (seriesDataItem) {
            seriesDataItem.bullets.each(function (key, value) {
                value.hide();
                value.preventShow = true;
            });
        }
        return _super.prototype.hide.call(this, duration, delay, toValue, fields);
    };
    /**
     * Shows the Data Item and related visual elements.
     *
     * @param duration  Animation duration (ms)
     * @param delay     Delay animation (ms)
     * @param fields    A list of fields to set values of
     */
    TreeMapDataItem.prototype.show = function (duration, delay, fields) {
        this.setWorkingValue("value", this.values.value.value);
        if (this.children) {
            this.children.each(function (child) {
                child.show(duration, delay, fields);
            });
        }
        var seriesDataItem = this.seriesDataItem;
        if (seriesDataItem) {
            seriesDataItem.bullets.each(function (key, value) {
                value.preventShow = false;
            });
        }
        return _super.prototype.show.call(this, duration, delay, fields);
    };
    return TreeMapDataItem;
}(XYChart_XYChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a TreeMap chart.
 *
 * @see {@link ITreeMapEvents} for a list of available Events
 * @see {@link ITreeMapAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/treemap/} for documentation
 */
var TreeMap_TreeMap = /** @class */ (function (_super) {
    __extends(TreeMap, _super);
    /**
     * Constructor
     */
    function TreeMap() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * An algorithm used to divide area into squares based on their value.
         *
         * Available options: squarify (default), binaryTree, slice, dice, sliceDice.
         *
         * ```TypeScript
         * chart.layoutAlgorithm = chart.sliceDice;
         * ```
         * ```JavaScript
         * chart.layoutAlgorithm = chart.sliceDice;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "layoutAlgorithm": "sliceDice",
         *   // ...
         * }
         * ```
         *
         * @see {@link https://www.amcharts.com/docs/v4/chart-types/treemap/#Area_division_methods} For more info and examples.
         * @default squarify
         */
        _this.layoutAlgorithm = _this.squarify;
        /**
         * Is the chart zoomable?
         *
         * If the chart is `zoomable`, and items have sub-items, the chart will
         * drill-down to sub-items when click on their parent item.
         *
         * @default true
         */
        _this.zoomable = true;
        _this.className = "TreeMap";
        _this._usesData = true;
        _this.maxLevels = 2;
        _this.currentLevel = 0;
        _this.hideParentColumns = false;
        _this.colors = new ColorSet_ColorSet();
        _this.sorting = "descending";
        // create two value axes for the chart
        var xAxis = _this.xAxes.push(new ValueAxis_ValueAxis());
        xAxis.title.disabled = true;
        xAxis.strictMinMax = true;
        var xRenderer = xAxis.renderer;
        xRenderer.inside = true;
        xRenderer.labels.template.disabled = true;
        xRenderer.ticks.template.disabled = true;
        xRenderer.grid.template.disabled = true;
        xRenderer.axisFills.template.disabled = true;
        xRenderer.minGridDistance = 100;
        xRenderer.line.disabled = true;
        xRenderer.baseGrid.disabled = true;
        //xRenderer.inversed = true;
        var yAxis = _this.yAxes.push(new ValueAxis_ValueAxis());
        yAxis.title.disabled = true;
        yAxis.strictMinMax = true;
        var yRenderer = yAxis.renderer;
        yRenderer.inside = true;
        yRenderer.labels.template.disabled = true;
        yRenderer.ticks.template.disabled = true;
        yRenderer.grid.template.disabled = true;
        yRenderer.axisFills.template.disabled = true;
        yRenderer.minGridDistance = 100;
        yRenderer.line.disabled = true;
        yRenderer.baseGrid.disabled = true;
        yRenderer.inversed = true;
        // shortcuts
        _this.xAxis = xAxis;
        _this.yAxis = yAxis;
        var template = new TreeMapSeries_TreeMapSeries();
        _this.seriesTemplates = new Dictionary_DictionaryTemplate(template);
        template.virtualParent = _this;
        _this._disposers.push(new Dictionary_DictionaryDisposer(_this.seriesTemplates));
        _this._disposers.push(template);
        _this.zoomOutButton.events.on("hit", function () {
            _this.zoomToChartDataItem(_this._homeDataItem);
        }, undefined, false);
        _this.seriesTemplates.events.on("insertKey", function (event) {
            event.newValue.isTemplate = true;
        }, undefined, false);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(TreeMap.prototype, "navigationBar", {
        /**
         * Returns navigationBar if it is added to a chart
         */
        get: function () {
            return this._navigationBar;
        },
        /**
         * A navigation bar used to show "breadcrumb" control, indicating current
         * drill-down path.
         */
        set: function (navigationBar) {
            var _this = this;
            if (this._navigationBar != navigationBar) {
                this._navigationBar = navigationBar;
                navigationBar.parent = this;
                navigationBar.toBack();
                navigationBar.links.template.events.on("hit", function (event) {
                    var dataItem = event.target.dataItem.dataContext;
                    if (!dataItem.isDisposed()) {
                        _this.zoomToChartDataItem(dataItem);
                        _this.createTreeSeries(dataItem);
                    }
                }, undefined, true);
                this._disposers.push(navigationBar);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * (Re)validates chart's data.
     *
     * @ignore Exclude from docs
     */
    TreeMap.prototype.validateData = function () {
        this.series.clear();
        this._tempSeries = [];
        _super.prototype.validateData.call(this);
        if (this._homeDataItem) {
            this._homeDataItem.dispose();
        }
        var homeDataItem = this.dataItems.template.clone(); // cant' use createDataItem here!
        this._homeDataItem = homeDataItem;
        Iterator_each(this.dataItems.iterator(), function (dataItem) {
            dataItem.parent = homeDataItem;
        });
        homeDataItem.children = this.dataItems;
        homeDataItem.x0 = 0;
        homeDataItem.y0 = 0;
        homeDataItem.name = this._homeText;
        var maxX = 1000;
        var maxY = Math.round((maxX * this.pixelHeight / this.pixelWidth) / 10) * 10 || 1000;
        homeDataItem.x1 = maxX;
        homeDataItem.y1 = maxY;
        this.xAxis.min = 0;
        this.xAxis.max = maxX;
        this.xAxis.getMinMax();
        this.yAxis.min = 0;
        this.yAxis.max = maxY;
        this.yAxis.getMinMax();
        this.layoutItems(homeDataItem);
        this.createTreeSeries(homeDataItem);
        this.feedLegend();
    };
    /**
     * Layouts and sizes all items according to their value and
     * `layoutAlgorithm`.
     *
     * @ignore Exclude from docs
     * @param parent  Parent data item
     */
    TreeMap.prototype.layoutItems = function (parent, sorting) {
        if (parent) {
            var children = parent.children;
            if (!sorting) {
                sorting = this.sorting;
            }
            if (sorting == "ascending") {
                children.values.sort(function (a, b) {
                    return a.value - b.value;
                });
            }
            if (sorting == "descending") {
                children.values.sort(function (a, b) {
                    return b.value - a.value;
                });
            }
            this._updateDataItemIndexes(0);
            this.layoutAlgorithm(parent);
            for (var i = 0, len = children.length; i < len; i++) {
                var node = children.getIndex(i);
                if (node.children) {
                    this.layoutItems(node);
                }
            }
        }
    };
    /**
     * Creates and returns a new treemap series.
     *
     * @todo Description
     * @param dataItem  Data item to create series out of
     */
    TreeMap.prototype.createTreeSeries = function (dataItem) {
        var _this = this;
        this._tempSeries = [];
        var navigationData = [dataItem];
        // create parent series and navigation data
        var parentDataItem = dataItem.parent;
        while (parentDataItem != undefined) {
            this.initSeries(parentDataItem);
            navigationData.push(parentDataItem);
            parentDataItem = parentDataItem.parent;
        }
        navigationData.reverse();
        if (this.navigationBar) {
            this.navigationBar.data = navigationData;
        }
        // create series and children series
        this.createTreeSeriesReal(dataItem);
        // add those which are not in the list
        each(this._tempSeries, function (series) {
            if (_this.series.indexOf(series) == -1) {
                _this.series.push(series);
            }
            series.zIndex = series.level;
        });
    };
    /**
     * [createTreeSeriesReal description]
     *
     * @todo Description
     * @param dataItem [description]
     */
    TreeMap.prototype.createTreeSeriesReal = function (dataItem) {
        if (dataItem.children) {
            var level = dataItem.level;
            if (level < this.currentLevel + this.maxLevels) {
                this.initSeries(dataItem);
                for (var i = 0; i < dataItem.children.length; i++) {
                    var child = dataItem.children.getIndex(i);
                    if (child.children) {
                        this.createTreeSeriesReal(child);
                    }
                }
            }
        }
    };
    TreeMap.prototype.setData = function (value) {
        this.currentLevel = 0;
        this.currentlyZoomed = undefined;
        this.xAxis.start = 0;
        this.xAxis.end = 1;
        this.yAxis.start = 0;
        this.yAxis.end = 1;
        _super.prototype.setData.call(this, value);
    };
    /**
     * @ignore
     * Overriding, as tree map series are created on the fly all the time
     */
    TreeMap.prototype.seriesAppeared = function () {
        return true;
    };
    /**
     * Initializes the treemap series.
     *
     * @todo Description
     * @param dataItem  Chart data item
     */
    TreeMap.prototype.initSeries = function (dataItem) {
        var _this = this;
        if (!dataItem.series) {
            var series = void 0;
            var template = this.seriesTemplates.getKey(dataItem.level.toString());
            if (template) {
                series = template.clone();
            }
            else {
                series = this.series.create();
            }
            // for the legend to get {value}
            series.dataItem.dataContext = dataItem;
            series.name = dataItem.name;
            series.parentDataItem = dataItem;
            dataItem.series = series;
            var level = dataItem.level;
            series.level = level;
            var dataContext = dataItem.dataContext;
            if (dataContext) {
                series.config = dataContext.config;
            }
            this.dataUsers.removeValue(series); // series do not use data directly, that's why we remove it
            series.data = dataItem.children.values;
            series.fill = dataItem.color;
            series.columnsContainer.hide(0);
            series.bulletsContainer.hide(0);
            series.columns.template.adapter.add("fill", function (fill, target) {
                var dataItem = target.dataItem;
                if (dataItem) {
                    var treeMapDataItem = dataItem.treeMapDataItem;
                    if (treeMapDataItem) {
                        target.fill = treeMapDataItem.color;
                        target.adapter.remove("fill"); //@todo: make it possible adapters applied once?
                        return treeMapDataItem.color;
                    }
                }
            });
            if (this.zoomable && (dataItem.level > this.currentLevel || (dataItem.children && dataItem.children.length > 0))) {
                series.columns.template.cursorOverStyle = MouseCursorStyle.pointer;
                if (this.zoomable) {
                    series.columns.template.events.on("hit", function (event) {
                        var seriesDataItem = event.target.dataItem;
                        if (dataItem.level > _this.currentLevel) {
                            _this.zoomToChartDataItem(seriesDataItem.treeMapDataItem.parent);
                        }
                        else {
                            _this.zoomToSeriesDataItem(seriesDataItem);
                        }
                    }, this, undefined);
                }
            }
        }
        this._tempSeries.push(dataItem.series);
    };
    /**
     * Toggles bullets so that labels that belong to current drill level are
     * shown.
     *
     * @param duration  Animation duration (ms)
     */
    TreeMap.prototype.toggleBullets = function (duration) {
        var _this = this;
        // hide all series which are not in tempSeries
        Iterator_each(this.series.iterator(), function (series) {
            if (_this._tempSeries.indexOf(series) == -1) {
                //series.hideReal(duration);
                series.columnsContainer.hide();
                series.bulletsContainer.hide(duration);
            }
            else {
                //series.showReal(duration);
                series.columnsContainer.show();
                series.bulletsContainer.show(duration);
                series.dataItems.each(function (dataItem) {
                    dataItem.bullets.each(function (key, bullet) {
                        bullet.show();
                    });
                });
                if (series.level < _this.currentLevel) {
                    if (_this.hideParentColumns) {
                        series.columnsContainer.hide();
                    }
                    series.bulletsContainer.hide(duration);
                }
                else if (series.level == _this.currentLevel) {
                    if (_this.maxLevels > 1) {
                        series.dataItems.each(function (dataItem) {
                            if (dataItem.treeMapDataItem.children) {
                                dataItem.bullets.each(function (key, bullet) {
                                    bullet.hide();
                                });
                            }
                        });
                    }
                }
            }
        });
    };
    /**
     * Zooms to particular item in series.
     *
     * @param dataItem  Data item
     */
    TreeMap.prototype.zoomToSeriesDataItem = function (dataItem) {
        this.zoomToChartDataItem(dataItem.treeMapDataItem);
    };
    /**
     * Zooms to particular item. If dataItem is not specified, the chart will zoom-out.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    TreeMap.prototype.zoomToChartDataItem = function (dataItem) {
        var _this = this;
        if (!dataItem) {
            dataItem = this._homeDataItem;
        }
        var zoomOutButton = this.zoomOutButton;
        // this is needed because if there is only one fist level, it wont' be shown
        if (zoomOutButton) {
            if (dataItem != this._homeDataItem) {
                zoomOutButton.show();
            }
            else {
                zoomOutButton.hide();
            }
        }
        if (dataItem && dataItem.children) {
            this.xAxis.zoomToValues(dataItem.x0, dataItem.x1);
            this.yAxis.zoomToValues(dataItem.y0, dataItem.y1);
            this.currentLevel = dataItem.level;
            this.currentlyZoomed = dataItem;
            this.createTreeSeries(dataItem);
            var rangeChangeAnimation = this.xAxis.rangeChangeAnimation || this.yAxis.rangeChangeAnimation;
            if (rangeChangeAnimation && !rangeChangeAnimation.isDisposed() && !rangeChangeAnimation.isFinished()) {
                this._dataDisposers.push(rangeChangeAnimation);
                rangeChangeAnimation.events.once("animationended", function () {
                    _this.toggleBullets();
                });
            }
            else {
                this.toggleBullets();
            }
        }
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    TreeMap.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        // Add a default screen reader title for accessibility
        // This will be overridden in screen reader if there are any `titles` set
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("TreeMap chart");
        }
        //this.homeText = this.language.translate("Home");
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    TreeMap.prototype.createDataItem = function () {
        return new TreeMap_TreeMapDataItem();
    };
    Object.defineProperty(TreeMap.prototype, "maxLevels", {
        /**
         * @return Maximum drill-down level
         */
        get: function () {
            return this.getPropertyValue("maxLevels");
        },
        /**
         * Maximum number of levels the chart will display initially.
         *
         * @default 2
         * @param value  Maximum drill-down level
         */
        set: function (value) {
            this.setPropertyValue("maxLevels", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMap.prototype, "currentLevel", {
        /**
         * @return Current level
         */
        get: function () {
            return this.getPropertyValue("currentLevel");
        },
        /**
         * Current drill-down level the chart is at.
         *
         * @param value  Current level
         */
        set: function (value) {
            this.setPropertyValue("currentLevel", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMap.prototype, "hideParentColumns", {
        /**
         * @return Hide?
         */
        get: function () {
            return this.getPropertyValue("hideParentColumns");
        },
        /**
         * If set to `true`, columns of parent nodes will be hidden when user
         * drills-down into deeper levels.
         *
         * @sice 4.7.4
         * @default false
         * @param  value  Hide?
         */
        set: function (value) {
            this.setPropertyValue("hideParentColumns", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeMap.prototype, "sorting", {
        get: function () {
            return this.getPropertyValue("sorting");
        },
        /**
         * Sorting direction of treemap items.
         *
         * Available options: "none", "ascending", and "descending" (default).
         *
         * @default "descending"
         * @param value [description]
         */
        set: function (value) {
            this.setPropertyValue("sorting", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates and returns a new series of the suitable type.
     *
     * @return new series
     */
    TreeMap.prototype.createSeries = function () {
        return new TreeMapSeries_TreeMapSeries();
    };
    Object.defineProperty(TreeMap.prototype, "homeText", {
        /**
         * @return Home text
         */
        get: function () {
            return this._homeText;
        },
        /**
         * A text displayed on the "home" button which is used to go back to level 0
         * after drill into sub-items.
         *
         * @param value  Home text
         */
        set: function (value) {
            this._homeText = value;
            if (this._homeDataItem) {
                this._homeDataItem.name = this._homeText;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    TreeMap.prototype.processConfig = function (config) {
        if (config) {
            // Instantiate layout algorithm
            if (hasValue(config["layoutAlgorithm"]) && isString(config["layoutAlgorithm"])) {
                switch (config["layoutAlgorithm"]) {
                    case "squarify":
                        config["layoutAlgorithm"] = this.squarify;
                        break;
                    case "binaryTree":
                        config["layoutAlgorithm"] = this.binaryTree;
                        break;
                    case "slice":
                        config["layoutAlgorithm"] = this.slice;
                        break;
                    case "dice":
                        config["layoutAlgorithm"] = this.dice;
                        break;
                    case "sliceDice":
                        config["layoutAlgorithm"] = this.sliceDice;
                        break;
                    default:
                        delete config["layoutAlgorithm"];
                        break;
                }
            }
            // Set type for navigation bar
            if (hasValue(config.navigationBar) && !hasValue(config.navigationBar.type)) {
                config.navigationBar.type = "NavigationBar";
            }
            _super.prototype.processConfig.call(this, config);
        }
    };
    /**
     * Measures the size of container and informs its children of how much size
     * they can occupy, by setting their relative `maxWidth` and `maxHeight`
     * properties.
     *
     * @ignore Exclude from docs
     */
    TreeMap.prototype.validateLayout = function () {
        _super.prototype.validateLayout.call(this);
        this.layoutItems(this.currentlyZoomed);
    };
    /**
     * Validates (processes) data items.
     *
     * @ignore Exclude from docs
     */
    TreeMap.prototype.validateDataItems = function () {
        _super.prototype.validateDataItems.call(this);
        this.layoutItems(this._homeDataItem);
        Iterator_each(this.series.iterator(), function (series) {
            series.validateRawData();
        });
        this.zoomToChartDataItem(this._homeDataItem);
    };
    /**
     * ==========================================================================
     * TREEMAP LAYOUT FUNCTIONS
     * ==========================================================================
     * @hidden
     */
    /**
     * The functions below are from D3.js library (https://d3js.org/)
     *
     * --------------------------------------------------------------------------
     * Copyright 2017 Mike Bostock
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice,
     *    this list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright
     *    notice,this list of conditions and the following disclaimer in the
     *    documentation and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its
     *    contributors may be used to endorse or promote products derived from
     *    this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     * POSSIBILITY OF SUCH DAMAGE.
     * --------------------------------------------------------------------------
     * @hidden
     */
    /**
     * Treemap layout algorithm: binaryTree.
     *
     * @ignore Exclude from docs
     * @param parent  Data item
     */
    TreeMap.prototype.binaryTree = function (parent) {
        var nodes = parent.children, i, n = nodes.length, sum, sums = new Array(n + 1);
        for (sums[0] = sum = i = 0; i < n; ++i) {
            sums[i + 1] = sum += nodes.getIndex(i).value;
        }
        partition(0, n, parent.value, parent.x0, parent.y0, parent.x1, parent.y1);
        function partition(i, j, value, x0, y0, x1, y1) {
            if (i >= j - 1) {
                var node = nodes.getIndex(i);
                node.x0 = x0;
                node.y0 = y0;
                node.x1 = x1;
                node.y1 = y1;
                return;
            }
            var valueOffset = sums[i], valueTarget = (value / 2) + valueOffset, k = i + 1, hi = j - 1;
            while (k < hi) {
                var mid = k + hi >>> 1;
                if (sums[mid] < valueTarget) {
                    k = mid + 1;
                }
                else {
                    hi = mid;
                }
            }
            if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) {
                --k;
            }
            var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft;
            if ((x1 - x0) > (y1 - y0)) {
                var xk = (x0 * valueRight + x1 * valueLeft) / value;
                partition(i, k, valueLeft, x0, y0, xk, y1);
                partition(k, j, valueRight, xk, y0, x1, y1);
            }
            else {
                var yk = (y0 * valueRight + y1 * valueLeft) / value;
                partition(i, k, valueLeft, x0, y0, x1, yk);
                partition(k, j, valueRight, x0, yk, x1, y1);
            }
        }
    };
    /**
     * Treemap layout algorithm: slice.
     *
     * @ignore Exclude from docs
     * @param parent  Data item
     */
    TreeMap.prototype.slice = function (parent) {
        var x0 = parent.x0;
        var x1 = parent.x1;
        var y0 = parent.y0;
        var y1 = parent.y1;
        var nodes = parent.children;
        var node;
        var i = -1;
        var n = nodes.length;
        var k = parent.value && (y1 - y0) / parent.value;
        while (++i < n) {
            node = nodes.getIndex(i);
            node.x0 = x0;
            node.x1 = x1;
            node.y0 = y0;
            y0 += node.value * k;
            node.y1 = y0;
        }
    };
    /**
     * Treemap layout algorithm: dice.
     *
     * @ignore Exclude from docs
     * @param parent  Data item
     */
    TreeMap.prototype.dice = function (parent) {
        var x0 = parent.x0;
        var x1 = parent.x1;
        var y0 = parent.y0;
        var y1 = parent.y1;
        var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
        while (++i < n) {
            node = nodes.getIndex(i);
            node.y0 = y0;
            node.y1 = y1;
            node.x0 = x0;
            x0 += node.value * k;
            node.x1 = x0;
        }
    };
    /**
     * Treemap layout algorithm: slideDice.
     *
     * @ignore Exclude from docs
     * @param parent  Data item
     */
    TreeMap.prototype.sliceDice = function (parent) {
        if (parent.level & 1) {
            this.slice(parent);
        }
        else {
            this.dice(parent);
        }
    };
    /**
     * Treemap layout algorithm: squarify.
     *
     * @ignore Exclude from docs
     * @param parent  Data item
     */
    TreeMap.prototype.squarify = function (parent) {
        var ratio = (1 + Math.sqrt(5)) / 2;
        var x0 = parent.x0;
        var x1 = parent.x1;
        var y0 = parent.y0;
        var y1 = parent.y1;
        var nodes = parent.children;
        var nodeValue;
        var i0 = 0;
        var i1 = 0;
        var n = nodes.length;
        var dx;
        var dy;
        var value = parent.value;
        var sumValue;
        var minValue;
        var maxValue;
        var newRatio;
        var minRatio;
        var alpha;
        var beta;
        while (i0 < n) {
            dx = x1 - x0;
            dy = y1 - y0;
            // Find the next non-empty node.
            do {
                sumValue = nodes.getIndex(i1++).value;
            } while (!sumValue && i1 < n);
            minValue = maxValue = sumValue;
            alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
            beta = sumValue * sumValue * alpha;
            minRatio = Math.max(maxValue / beta, beta / minValue);
            // Keep adding nodes while the aspect ratio maintains or improves.
            for (; i1 < n; ++i1) {
                sumValue += nodeValue = nodes.getIndex(i1).value;
                if (nodeValue < minValue) {
                    minValue = nodeValue;
                }
                if (nodeValue > maxValue) {
                    maxValue = nodeValue;
                }
                beta = sumValue * sumValue * alpha;
                newRatio = Math.max(maxValue / beta, beta / minValue);
                if (newRatio > minRatio) {
                    sumValue -= nodeValue;
                    break;
                }
                minRatio = newRatio;
            }
            // Position and record the row orientation.
            var row = this.dataItems.template.clone();
            row.value = sumValue;
            row.dice = dx < dy;
            row.children = nodes.slice(i0, i1);
            row.x0 = x0;
            row.y0 = y0;
            row.x1 = x1;
            row.y1 = y1;
            if (row.dice) {
                row.y1 = value ? (y0 += (dy * sumValue) / value) : y1;
                this.dice(row);
            }
            else {
                row.x1 = value ? (x0 += (dx * sumValue) / value) : x1;
                this.slice(row);
            }
            value -= sumValue;
            i0 = i1;
        }
    };
    TreeMap.prototype.handleSeriesAdded2 = function () {
        // void
    };
    /**
     * [handleDataItemValueChange description]
     *
     * @ignore Exclude from docs
     * @todo Description
     */
    TreeMap.prototype.handleDataItemValueChange = function (dataItem, name) {
        if (name == "value") {
            this.invalidateDataItems();
        }
    };
    TreeMap.prototype.handleDataItemWorkingValueChange = function (dataItem, name) {
        if (name == "value") {
            this.invalidateDataItems();
        }
    };
    TreeMap.prototype.getLegendLevel = function (dataItem) {
        if (!dataItem) {
            return;
        }
        if (!dataItem.children) {
            return;
        }
        if (dataItem.children.length > 1) {
            return dataItem;
        }
        else if (dataItem.children.length == 1) {
            return this.getLegendLevel(dataItem.children.getIndex(0));
        }
        else {
            return dataItem;
        }
    };
    Object.defineProperty(TreeMap.prototype, "homeDataItem", {
        /**
         * A data item associated with top node.
         *
         * @since 4.8.2
         */
        get: function () {
            return this._homeDataItem;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Setups the legend to use the chart's data.
     * @ignore
     */
    TreeMap.prototype.feedLegend = function () {
        var legend = this.legend;
        if (legend) {
            legend.dataFields.name = "name";
            var legendParent = this.getLegendLevel(this._homeDataItem);
            if (legendParent) {
                var legendData_1 = [];
                legendParent.children.each(function (dataItem) {
                    //if (!dataItem.hiddenInLegend) {
                    legendData_1.push(dataItem);
                    //}
                });
                legend.data = legendData_1;
            }
        }
    };
    /**
     * @ignore
     */
    TreeMap.prototype.disposeData = function () {
        _super.prototype.disposeData.call(this);
        this._homeDataItem = undefined;
        this.series.clear();
        if (this.navigationBar) {
            this.navigationBar.disposeData();
        }
        this.xAxis.disposeData();
        this.yAxis.disposeData();
    };
    /**
     * Since this chart uses hierarchical data, we need to remove childrent
     * dataField from export of non-hierarchical formats such as CSV and XSLX.
     *
     * @return Export
     */
    TreeMap.prototype.getExporting = function () {
        var _this = this;
        var exporting = _super.prototype.getExporting.call(this);
        exporting.adapter.add("formatDataFields", function (info) {
            if (info.format == "csv" || info.format == "xlsx") {
                if (hasValue(_this.dataFields.children)) {
                    delete info.dataFields[_this.dataFields.children];
                }
            }
            return info;
        });
        return exporting;
    };
    return TreeMap;
}(XYChart_XYChart));

/**
 * Register class, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["TreeMap"] = TreeMap_TreeMap;
//# sourceMappingURL=TreeMap.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererX3D.js
/**
 * Module, defining Axis Renderer for horizontal 3D axes.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Renderer for horizontal 3D axis.
 *
 * @see {@link IAxisRendererX3DEvents} for a list of available events
 * @see {@link IAxisRendererX3DAdapters} for a list of available Adapters
 */
var AxisRendererX3D_AxisRendererX3D = /** @class */ (function (_super) {
    __extends(AxisRendererX3D, _super);
    /**
     * Constructor.
     *
     * @param axis Related axis
     */
    function AxisRendererX3D() {
        var _this = _super.call(this) || this;
        /**
         * A related chart.
         *
         * @todo Description
         */
        _this._chart = new Disposer_MutableValueDisposer();
        _this.className = "AxisRendererX3D";
        _this._disposers.push(_this._chart);
        _this.applyTheme();
        return _this;
    }
    /**
     * Updates and positions a grid element.
     *
     * @ignore Exclude from docs
     * @param grid         Grid element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererX3D.prototype.updateGridElement = function (grid, position, endPosition) {
        position = position + (endPosition - position) * grid.location;
        var point = this.positionToPoint(position);
        if (grid.element) {
            var dx = this.chart.dx3D || 0;
            var dy = this.chart.dy3D || 0;
            var h = this.getHeight();
            grid.path = moveTo({ x: dx, y: dy }) + lineTo({ x: dx, y: h + dy }) + lineTo({ x: 0, y: h });
        }
        this.positionItem(grid, point);
        this.toggleVisibility(grid, position, 0, 1);
    };
    /**
     * Updates and positions the base grid element.
     *
     * @ignore Exclude from docs
     */
    AxisRendererX3D.prototype.updateBaseGridElement = function () {
        _super.prototype.updateBaseGridElement.call(this);
        var h = this.getHeight();
        var dx = this.chart.dx3D || 0;
        var dy = this.chart.dy3D || 0;
        this.baseGrid.path = moveTo({ x: dx, y: dy }) + lineTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: h });
    };
    Object.defineProperty(AxisRendererX3D.prototype, "chart", {
        /**
         * @ignore Exclude from docs
         * @return Chart
         */
        get: function () {
            return this._chart.get();
        },
        /**
         * Chart, associated with the Axis.
         *
         * @ignore Exclude from docs
         * @param value Chart
         */
        set: function (chart) {
            if (chart) {
                this._chart.set(chart, chart.events.on("propertychanged", this.handle3DChanged, this, false));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Invoked when 3D-related settings change, like depth or angle.
     *
     * @param event Event
     */
    AxisRendererX3D.prototype.handle3DChanged = function (event) {
        if (event.property == "depth" || event.property == "angle") {
            this.invalidate();
        }
    };
    return AxisRendererX3D;
}(AxisRendererX_AxisRendererX));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["AxisRendererX3D"] = AxisRendererX3D_AxisRendererX3D;
//# sourceMappingURL=AxisRendererX3D.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererY3D.js
/**
 * Module, defining Axis Renderer for vertical 3D axes.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Renderer for vertical 3D axis.
 *
 * @see {@link IAxisRendererY3DEvents} for a list of available events
 * @see {@link IAxisRendererY3DAdapters} for a list of available Adapters
 */
var AxisRendererY3D_AxisRendererY3D = /** @class */ (function (_super) {
    __extends(AxisRendererY3D, _super);
    /**
     * Constructor.
     *
     * @param axis Related axis
     */
    function AxisRendererY3D() {
        var _this = _super.call(this) || this;
        /**
         * A related chart.
         *
         * @todo Description
         */
        _this._chart = new Disposer_MutableValueDisposer();
        _this.className = "AxisRendererY3D";
        _this._disposers.push(_this._chart);
        _this.applyTheme();
        return _this;
    }
    /**
     * Updates and positions a grid element.
     *
     * @ignore Exclude from docs
     * @param grid         Grid element
     * @param position     Starting position
     * @param endPosition  End position
     */
    AxisRendererY3D.prototype.updateGridElement = function (grid, position, endPosition) {
        position = position + (endPosition - position) * grid.location;
        var point = this.positionToPoint(position);
        if (grid.element) {
            var dx = this.chart.dx3D || 0;
            var dy = this.chart.dy3D || 0;
            var w = this.getWidth();
            grid.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: dx, y: dy }) + lineTo({ x: w + dx, y: dy });
        }
        this.positionItem(grid, point);
        this.toggleVisibility(grid, position, 0, 1);
    };
    /**
     * Updates and positions the base grid element.
     *
     * @ignore Exclude from docs
     */
    AxisRendererY3D.prototype.updateBaseGridElement = function () {
        _super.prototype.updateBaseGridElement.call(this);
        var dx = this.chart.dx3D || 0;
        var dy = this.chart.dy3D || 0;
        var w = this.getWidth();
        this.baseGrid.path = moveTo({ x: 0, y: 0 })
            + lineTo({ x: w, y: 0 })
            + lineTo({ x: w + dx, y: dy });
    };
    Object.defineProperty(AxisRendererY3D.prototype, "chart", {
        /**
         * @ignore Exclude from docs
         * @return Chart
         */
        get: function () {
            return this._chart.get();
        },
        /**
         * Chart, associated with the Axis.
         *
         * @ignore Exclude from docs
         * @param value  Chart
         */
        set: function (chart) {
            if (chart) {
                this._chart.set(chart, chart.events.on("propertychanged", this.handle3DChanged, this, false));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Invoked when 3D-related settings change, like depth or angle.
     *
     * @param event Event
     */
    AxisRendererY3D.prototype.handle3DChanged = function (event) {
        if (event.property == "depth" || event.property == "angle") {
            this.invalidate();
        }
    };
    return AxisRendererY3D;
}(AxisRendererY_AxisRendererY));

//# sourceMappingURL=AxisRendererY3D.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/Column3D.js
/**
 * Module that defines everything related to building 3D Columns.
 * It is a container which has column3D element which is a Rectangle3D.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Class used to creates Column3Ds.
 *
 * @see {@link IColumn3DEvents} for a list of available events
 * @see {@link IColumn3DAdapters} for a list of available Adapters
 * @todo Usage example
 * @important
 */
var Column3D_Column3D = /** @class */ (function (_super) {
    __extends(Column3D, _super);
    /**
     * Constructor
     */
    function Column3D() {
        var _this = _super.call(this) || this;
        _this.className = "Column3D";
        return _this;
    }
    /**
     * @ignore
     */
    Column3D.prototype.createAssets = function () {
        this.column3D = this.createChild(Rectangle3D_Rectangle3D);
        this.column3D.shouldClone = false;
        this.column3D.strokeOpacity = 0;
        // some dirty hack so that if user access column, it won't get error
        this.column = this.column3D;
    };
    /**
     * @ignore Exclude from docs
     */
    Column3D.prototype.validate = function () {
        _super.prototype.validate.call(this);
        if (this.column3D) {
            this.column3D.width = this.pixelWidth;
            this.column3D.height = this.pixelHeight;
            if (this.column3D.invalid) {
                this.column3D.validate();
            }
        }
    };
    /**
     * Copies all parameters from another [[Column3D]].
     *
     * @param source Source Column3D
     */
    Column3D.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (this.column3D) {
            this.column3D.copyFrom(source.column3D);
        }
    };
    /**
     * Sets actual `fill` property on the SVG element, including applicable color
     * modifiers.
     *
     * @ignore Exclude from docs
     * @param value  Fill
     */
    Column3D.prototype.setFill = function (value) {
        _super.prototype.setFill.call(this, value);
        this.column.fill = value;
    };
    return Column3D;
}(Column_Column));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Column3D"] = Column3D_Column3D;
//# sourceMappingURL=Column3D.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/ColumnSeries3D.js
/**
 * 3D column series module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
var ColumnSeries3D_ColumnSeries3DDataItem = /** @class */ (function (_super) {
    __extends(ColumnSeries3DDataItem, _super);
    /**
     * Constructor
     */
    function ColumnSeries3DDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "ColumnSeries3DDataItem";
        _this.applyTheme();
        return _this;
    }
    return ColumnSeries3DDataItem;
}(ColumnSeries_ColumnSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a 3D column graph.
 *
 * @see {@link IColumnSeries3DEvents} for a list of available Events
 * @see {@link IColumnSeries3DAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var ColumnSeries3D_ColumnSeries3D = /** @class */ (function (_super) {
    __extends(ColumnSeries3D, _super);
    /**
     * Constructor
     */
    function ColumnSeries3D() {
        var _this = _super.call(this) || this;
        _this.className = "ColumnSeries3D";
        _this.columns.template.column3D.applyOnClones = true;
        _this.columns.template.hiddenState.properties.visible = true;
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(ColumnSeries3D.prototype, "columnsContainer", {
        /**
         * @ignore
         */
        get: function () {
            var chart = this.chart;
            if (chart && chart.columnsContainer && chart.leftAxesContainer.layout != "vertical" && chart.rightAxesContainer.layout != "vertical" && chart.bottomAxesContainer.layout != "horizontal" && chart.topAxesContainer.layout != "horizontal") {
                return chart.columnsContainer;
            }
            else {
                return this._columnsContainer;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Validates data item's elements.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    ColumnSeries3D.prototype.validateDataElementReal = function (dataItem) {
        _super.prototype.validateDataElementReal.call(this, dataItem);
        if (dataItem.column) {
            dataItem.column.dx = this.dx;
            dataItem.column.dy = this.dy;
        }
    };
    /**
     * Validates data item's elements.
     *
     * @ignore Exclude from docs
     */
    ColumnSeries3D.prototype.validateDataElements = function () {
        _super.prototype.validateDataElements.call(this);
        if (this.chart) {
            this.chart.invalidateLayout();
        }
    };
    /**
     * Returns an element to use for 3D bar.
     * @ignore
     * @return Element.
     */
    ColumnSeries3D.prototype.createColumnTemplate = function () {
        return new Column3D_Column3D();
    };
    Object.defineProperty(ColumnSeries3D.prototype, "depth", {
        /**
         * @ignore Exclude from docs
         * @return Depth (px)
         */
        get: function () {
            return this.getPropertyValue("depth");
        },
        /**
         * Depth (height) of the slices in the series in pixels.
         *
         * @ignore Exclude from docs
         * @param value  Depth (px)
         */
        set: function (value) {
            this.setPropertyValue("depth", value, true);
            var template = this.columns.template; // todo: Cone is not Rectangle3D, maybe we should do some I3DShape?
            template.column3D.depth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnSeries3D.prototype, "angle", {
        /**
         * @ignore Exclude from docs
         * @return Angle (0-360)
         */
        get: function () {
            return this.getPropertyValue("angle");
        },
        /**
         * Angle of view for the slices in series. (0-360)
         *
         * @ignore Exclude from docs
         * @param value  Angle (0-360)
         */
        set: function (value) {
            this.setPropertyValue("angle", value);
            var template = this.columns.template;
            template.column3D.angle = value;
        },
        enumerable: true,
        configurable: true
    });
    return ColumnSeries3D;
}(ColumnSeries_ColumnSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ColumnSeries3D"] = ColumnSeries3D_ColumnSeries3D;
registry.registeredClasses["ColumnSeries3DDataItem"] = ColumnSeries3D_ColumnSeries3DDataItem;
//# sourceMappingURL=ColumnSeries3D.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/types/XYChart3D.js
/**
 * Module for building 3D serial charts.
 */

/**
 * ============================================================================
 * Imports
 * ============================================================================
 * @hidden
 */












/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[XYChart3D]].
 *
 * @see {@link DataItem}
 */
var XYChart3D_XYChart3DDataItem = /** @class */ (function (_super) {
    __extends(XYChart3DDataItem, _super);
    function XYChart3DDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "XYChart3DDataItem";
        _this.applyTheme();
        return _this;
    }
    return XYChart3DDataItem;
}(XYChart_XYChartDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a 3D XY chart.
 *
 * @see {@link IXYChart3DEvents} for a list of available Events
 * @see {@link IXYChart3DAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/xy-chart/} for documentation
 * @important
 */
var XYChart3D_XYChart3D = /** @class */ (function (_super) {
    __extends(XYChart3D, _super);
    /**
     * Constructor
     */
    function XYChart3D() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Type of the axis renderer to use for X axes.
         */
        _this._axisRendererX = AxisRendererX3D_AxisRendererX3D;
        /**
         * Type of the axis renderer to use for Y axes.
         */
        _this._axisRendererY = AxisRendererY3D_AxisRendererY3D;
        _this.className = "XYChart3D";
        // Set defaults
        _this.depth = 30;
        _this.angle = 30;
        // Creeate container for columns
        var columnsContainer = _this.seriesContainer.createChild(Container_Container);
        columnsContainer.shouldClone = false;
        columnsContainer.isMeasured = false;
        columnsContainer.layout = "none";
        _this.columnsContainer = columnsContainer;
        _this.columnsContainer.mask = _this.createChild(Sprite_Sprite);
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * This is done because for some reason IE doesn't change mask if path of a
     * mask changes.
     */
    XYChart3D.prototype.updateSeriesMasks = function () {
        _super.prototype.updateSeriesMasks.call(this);
        if (isIE()) {
            var columnsContainer = this.columnsContainer;
            var mask = columnsContainer.mask;
            columnsContainer.mask = undefined;
            columnsContainer.mask = mask;
        }
    };
    Object.defineProperty(XYChart3D.prototype, "depth", {
        /**
         * @return Depth (px)
         */
        get: function () {
            return this.getPropertyValue("depth");
        },
        /**
         * Depth of the 3D chart / columns in pixels.
         *
         * @param value  Depth (px)
         */
        set: function (value) {
            this.setPropertyValue("depth", value);
            this.fixLayout();
            this.invalidateDataUsers();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYChart3D.prototype, "angle", {
        /**
         * @return Angle
         */
        get: function () {
            return this.getPropertyValue("angle");
        },
        /**
         * Angle the chart is viewed at.
         *
         * @todo Description (review)
         * @param value  Angle
         */
        set: function (value) {
            this.setPropertyValue("angle", value);
            this.fixLayout();
            this.invalidateDataUsers();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYChart3D.prototype, "dx3D", {
        /**
         * A calculated horizontal 3D offset (px).
         *
         * @readonly
         * @return Offset (px)
         */
        get: function () {
            return Math_cos(this.angle) * this.depth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYChart3D.prototype, "dy3D", {
        /**
         * A calculated vertical 3D offset (px).
         *
         * @readonly
         * @return Offset (px)
         */
        get: function () {
            return -Math_sin(this.angle) * this.depth;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * (Re)validates layout
     *
     * @ignore Exclude from docs
     */
    XYChart3D.prototype.validateLayout = function () {
        _super.prototype.validateLayout.call(this);
        this.fixColumns();
    };
    /**
     * Updates the layout (padding and scrollbar positions) to accommodate for
     * 3D depth and angle.
     */
    XYChart3D.prototype.fixLayout = function () {
        this.chartContainer.marginTop = -this.dy3D;
        this.chartContainer.paddingRight = this.dx3D;
        if (this.scrollbarX) {
            this.scrollbarX.dy = this.dy3D;
            this.scrollbarX.dx = this.dx3D;
        }
        if (this.scrollbarY) {
            this.scrollbarY.dy = this.dy3D;
            this.scrollbarY.dx = this.dx3D;
        }
        this.fixColumns();
        _super.prototype.fixLayout.call(this);
    };
    /**
     * Updates column positions, offset and dimensions based on chart's angle
     * and depth.
     */
    XYChart3D.prototype.fixColumns = function () {
        var _this = this;
        var count = 1;
        var i = 0;
        Iterator_each(this.series.iterator(), function (series) {
            if (series instanceof ColumnSeries3D_ColumnSeries3D) {
                if (!series.clustered && i > 0) {
                    count++;
                }
                series.depthIndex = count - 1;
                i++;
            }
        });
        var s = 0;
        Iterator_each(this.series.iterator(), function (series) {
            if (series instanceof ColumnSeries3D_ColumnSeries3D) {
                series.depth = _this.depth / (count);
                series.angle = _this.angle;
                if (series.columnsContainer == _this.columnsContainer) {
                    series.dx = _this.depth / (count) * Math_cos(_this.angle) * (series.depthIndex);
                    series.dy = -_this.depth / (count) * Math_sin(_this.angle) * (series.depthIndex);
                }
                var inversed_1 = false;
                if ((series.baseAxis == series.xAxis && series.xAxis.renderer.inversed) || (series.baseAxis == series.yAxis && series.yAxis.renderer.inversed)) {
                    inversed_1 = true;
                }
                var i_1 = 1;
                series.dataItems.each(function (dataItem) {
                    var column = dataItem.column;
                    if (column) {
                        if (inversed_1) {
                            column.zIndex = 1000 * (1000 - i_1) + s - series.depthIndex * 100;
                        }
                        else {
                            column.zIndex = 1000 * i_1 + s - series.depthIndex * 100;
                        }
                    }
                    i_1++;
                });
                if (inversed_1) {
                    s--;
                }
                else {
                    s++;
                }
            }
        });
        this.maskColumns();
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    XYChart3D.prototype.processConfig = function (config) {
        if (config) {
            // Set up series
            if (hasValue(config.series) && isArray(config.series)) {
                for (var i = 0, len = config.series.length; i < len; i++) {
                    config.series[i].type = config.series[i].type || "ColumnSeries3D";
                }
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    XYChart3D.prototype.maskColumns = function () {
        var w = this.plotContainer.pixelWidth;
        var h = this.plotContainer.pixelHeight;
        var dx = this.dx3D;
        var dy = this.dy3D;
        var path = moveTo({ x: 0, y: 0 }) + lineTo({ x: dx, y: dy }) + lineTo({ x: w + dx, y: dy }) + lineTo({ x: w + dx, y: h + dy }) + lineTo({ x: w, y: h }) + lineTo({ x: w, y: h }) + lineTo({ x: 0, y: h }) + closePath();
        var columnsContainer = this.columnsContainer;
        if (columnsContainer && columnsContainer.mask) {
            columnsContainer.mask.path = path;
        }
    };
    return XYChart3D;
}(XYChart_XYChart));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["XYChart3D"] = XYChart3D_XYChart3D;
//# sourceMappingURL=XYChart3D.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/HeatLegend.js
/**
 * HeatLegend module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */













/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * This class creates a link (waved color-filled line) between two nodes in a
 * Sankey Diagram.
 *
 * @see {@link IHeatLegendEvents} for a list of available events
 * @see {@link IHeatLegendAdapters} for a list of available Adapters
 * @important
 */
var HeatLegend_HeatLegend = /** @class */ (function (_super) {
    __extends(HeatLegend, _super);
    /**
     * Constructor
     */
    function HeatLegend() {
        var _this = _super.call(this) || this;
        _this.className = "HeatLegend";
        _this.markerContainer = _this.createChild(Container_Container);
        _this.markerContainer.shouldClone = false;
        _this.markerCount = 1;
        // Create a template container and list for the a marker
        var marker = new RoundedRectangle_RoundedRectangle();
        marker.minHeight = 20;
        marker.minWidth = 20;
        marker.interactionsEnabled = false;
        marker.fillOpacity = 1;
        marker.cornerRadius(0, 0, 0, 0);
        _this.markerContainer.minHeight = 20;
        _this.markerContainer.minWidth = 20;
        _this.orientation = "horizontal";
        _this.markers = new List_ListTemplate(marker);
        _this._disposers.push(new List_ListDisposer(_this.markers));
        _this._disposers.push(_this.markers.template);
        _this.applyTheme();
        return _this;
    }
    HeatLegend.prototype.getMinFromRules = function (property) {
        var series = this.series;
        if (series) {
            var minValue_1;
            Iterator_eachContinue(series.heatRules.iterator(), function (heatRule) {
                if (heatRule.property == property) {
                    minValue_1 = heatRule.min;
                    return false;
                }
                return true;
            });
            return minValue_1;
        }
    };
    HeatLegend.prototype.getMaxFromRules = function (property) {
        var series = this.series;
        if (series) {
            var maxValue_1;
            Iterator_each(series.heatRules.iterator(), function (heatRule) {
                if (heatRule.property == property) {
                    maxValue_1 = heatRule.max;
                    return false;
                }
                return true;
            });
            return maxValue_1;
        }
    };
    /**
     *
     * @ignore Exclude from docs
     */
    HeatLegend.prototype.validate = function () {
        _super.prototype.validate.call(this);
        this.valueAxis.renderer.inversed = this.reverseOrder;
        var series = this.series;
        var minColor = this.minColor;
        var maxColor = this.maxColor;
        if (!hasValue(minColor)) {
            minColor = toColor(this.getMinFromRules("fill"));
        }
        if (!hasValue(maxColor)) {
            maxColor = toColor(this.getMaxFromRules("fill"));
        }
        if (series) {
            var seriesFill = series.fill;
            if (!hasValue(minColor) && seriesFill instanceof Color_Color) {
                minColor = seriesFill;
            }
            if (!hasValue(maxColor) && seriesFill instanceof Color_Color) {
                maxColor = seriesFill;
            }
        }
        if (!hasValue(maxColor)) {
            maxColor = toColor(this.getMaxFromRules("fill"));
        }
        var minOpacity = toNumber(this.getMinFromRules("fillOpacity"));
        if (!isNumber(minOpacity)) {
            minOpacity = 1;
        }
        var maxOpacity = toNumber(this.getMaxFromRules("fillOpacity"));
        if (!isNumber(maxOpacity)) {
            maxOpacity = 1;
        }
        var minStrokeOpacity = toNumber(this.getMinFromRules("strokeOpacity"));
        if (!isNumber(minStrokeOpacity)) {
            minStrokeOpacity = 1;
        }
        var maxStrokeOpacity = toNumber(this.getMaxFromRules("strokeOpacity"));
        if (!isNumber(maxStrokeOpacity)) {
            maxStrokeOpacity = 1;
        }
        var minStroke = toColor(this.getMinFromRules("stroke"));
        var maxStroke = toColor(this.getMaxFromRules("stroke"));
        //if (series) {
        for (var i = 0; i < this.markerCount; i++) {
            var marker = this.markers.getIndex(i);
            if (!marker) {
                marker = this.markers.create();
                marker.parent = this.markerContainer;
                marker.height = Percent_percent(100);
                marker.width = Percent_percent(100);
            }
            if (this.markerCount == 1) {
                var gradient = new LinearGradient_LinearGradient();
                if (this.reverseOrder) {
                    gradient.addColor(maxColor, maxOpacity);
                    gradient.addColor(minColor, minOpacity);
                }
                else {
                    gradient.addColor(minColor, minOpacity);
                    gradient.addColor(maxColor, maxOpacity);
                }
                if (this.orientation == "vertical") {
                    gradient.rotation = -90;
                }
                marker.fill = gradient;
                if (hasValue(minStroke) && hasValue(maxStroke)) {
                    var strokeGradient = new LinearGradient_LinearGradient();
                    if (this.reverseOrder) {
                        strokeGradient.addColor(maxStroke, maxStrokeOpacity);
                        strokeGradient.addColor(minStroke, minStrokeOpacity);
                    }
                    else {
                        strokeGradient.addColor(minStroke, minStrokeOpacity);
                        strokeGradient.addColor(maxStroke, maxStrokeOpacity);
                    }
                    if (this.orientation == "vertical") {
                        strokeGradient.rotation = -90;
                    }
                    marker.stroke = strokeGradient;
                }
            }
            else {
                var c = i;
                if (this.reverseOrder) {
                    c = this.markerCount - i - 1;
                }
                var color = new Color_Color(interpolate(minColor.rgb, maxColor.rgb, c / this.markerCount));
                marker.fill = color;
                var opacity = minOpacity + (maxOpacity - minOpacity) * c / this.markerCount;
                marker.fillOpacity = opacity;
                if (hasValue(minStroke) && hasValue(maxStroke)) {
                    var color_1 = new Color_Color(interpolate(minStroke.rgb, maxStroke.rgb, c / this.markerCount));
                    marker.stroke = color_1;
                    var opacity_1 = minStrokeOpacity + (maxStrokeOpacity - minStrokeOpacity) * c / this.markerCount;
                    marker.strokeOpacity = opacity_1;
                }
            }
        }
        var renderer = this.valueAxis.renderer;
        if (this.markerCount > 1) {
            if (this.orientation == "horizontal") {
                renderer.minGridDistance = this.measuredWidth / this.markerCount;
            }
            else {
                renderer.minGridDistance = this.measuredHeight / this.markerCount;
            }
        }
        this.valueAxis.invalidate();
        for (var i = this.markerCount, len = this.markers.length; i < len; i++) {
            this.markers.getIndex(i).parent = undefined;
        }
    };
    Object.defineProperty(HeatLegend.prototype, "minColor", {
        /**
         * Returns minColor value
         * @return {Color}
         */
        get: function () {
            return this.getPropertyValue("minColor");
        },
        /**
         * Min color of a heat legend. If a series is set for the legend, minColor is taken from series.
         *
         * @param {Color}
         */
        set: function (value) {
            if (!(value instanceof Color_Color)) {
                value = toColor(value);
            }
            this.setColorProperty("minColor", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeatLegend.prototype, "maxColor", {
        /**
         * Returns maxColor value
         * @return {Color}
         */
        get: function () {
            return this.getPropertyValue("maxColor");
        },
        /**
         * Max color of a heat legend. If a series is set for the legend, maxColor is taken from series.
         *
         * @param {Color}
         */
        set: function (value) {
            if (!isObject(value)) {
                value = toColor(value);
            }
            this.setColorProperty("maxColor", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeatLegend.prototype, "markerCount", {
        /**
         * Returns number of color squares (markers).
         * @return {number}
         */
        get: function () {
            return this.getPropertyValue("markerCount");
        },
        /**
         * Number of color squares (markers) in the heat legend. If only 1 marker is used, it will be filled with gradient.
         *
         * @param {number}
         */
        set: function (value) {
            this.setPropertyValue("markerCount", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeatLegend.prototype, "minValue", {
        /**
         * Returns minimum value of heat legend.
         * @return {number}
         */
        get: function () {
            return this.getPropertyValue("minValue");
        },
        /**
         * Minimum value of heat legend's value axis. If a series is set for the legend, min is taken from series.
         *
         * @param {number}
         */
        set: function (value) {
            this.setPropertyValue("minValue", value);
            this.valueAxis.min = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeatLegend.prototype, "maxValue", {
        /**
         * Returns maximum value of heat legend.
         * @return {number}
         */
        get: function () {
            return this.getPropertyValue("maxValue");
        },
        /**
         * Maximum value of heat legend's value axis. If a series is set for the legend, max is taken from series.
         *
         * @param {number}
         */
        set: function (value) {
            this.setPropertyValue("maxValue", value);
            this.valueAxis.max = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeatLegend.prototype, "orientation", {
        /**
         * Returns orientation value.
         *
         * @return {"horizontal" | "vertical"}
         */
        get: function () {
            return this.getPropertyValue("orientation");
        },
        /**
        * Heat legend orientation. Note, if you change orientation of a heat legend, you must set value axis renderer properties after that, as with orientation renderer changes.
        *
        * @param {"horizontal" | "vertical"}
        */
        set: function (value) {
            this.setPropertyValue("orientation", value, true);
            var markerContainer = this.markerContainer;
            var valueAxis = this.valueAxis;
            // HORIZONTAL
            if (value == "horizontal") {
                if (!hasValue(this.width)) {
                    this.width = 200;
                }
                this.height = undefined;
                valueAxis.width = Percent_percent(100);
                valueAxis.height = undefined;
                valueAxis.tooltip.pointerOrientation = "vertical";
                this.layout = "vertical";
                markerContainer.width = Percent_percent(100);
                markerContainer.height = undefined;
                if (!(valueAxis.renderer instanceof AxisRendererX_AxisRendererX)) {
                    valueAxis.renderer = new AxisRendererX_AxisRendererX();
                }
            }
            // VERTICAL
            else {
                if (!hasValue(this.height)) {
                    this.height = 200;
                }
                this.width = undefined;
                this.layout = "horizontal";
                markerContainer.width = undefined;
                markerContainer.height = Percent_percent(100);
                valueAxis.height = Percent_percent(100);
                valueAxis.width = undefined;
                valueAxis.tooltip.pointerOrientation = "horizontal";
                if (!(valueAxis.renderer instanceof AxisRendererY_AxisRendererY)) {
                    valueAxis.renderer = new AxisRendererY_AxisRendererY();
                }
                valueAxis.renderer.inside = true;
                valueAxis.renderer.labels.template.inside = true;
                this.markerContainer.reverseOrder = true;
            }
            var renderer = valueAxis.renderer;
            renderer.grid.template.disabled = true;
            renderer.axisFills.template.disabled = true;
            renderer.baseGrid.disabled = true;
            renderer.labels.template.padding(2, 3, 2, 3);
            renderer.minHeight = undefined;
            renderer.minWidth = undefined;
            this.markerContainer.layout = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeatLegend.prototype, "valueAxis", {
        /**
         * Returns valueAxis value.
         * @return {ValueAxis}
         */
        get: function () {
            if (!this._valueAxis) {
                this.valueAxis = this.createChild(ValueAxis_ValueAxis);
                this.valueAxis.shouldClone = false;
            }
            return this._valueAxis;
        },
        /**
         * Sets a value axis of heat legend. Value axis for heat legend is created automatically.
         * @param {ValueAxis}
         */
        set: function (valueAxis) {
            this._valueAxis = valueAxis;
            valueAxis.parent = this;
            valueAxis.strictMinMax = true;
            this.orientation = this.orientation;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeatLegend.prototype, "series", {
        /**
         * Returns series value.
         * @return {Series}
         */
        get: function () {
            return this._series;
        },
        /**
         * You can set series for heat legend. It will take min, max, minColor and maxColor values from this series.
         * @param series
         */
        set: function (series) {
            var _this = this;
            this._series = series;
            var dataField = "value";
            try {
                var dataFieldDefined = series.heatRules.getIndex(0).dataField;
                if (dataFieldDefined) {
                    dataField = dataFieldDefined;
                }
            }
            catch (err) {
            }
            this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);
            series.dataItem.events.on("calculatedvaluechanged", function (event) {
                _this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);
            }, undefined, false);
            series.heatRules.events.on("inserted", this.invalidate, this, false);
            series.heatRules.events.on("removed", this.invalidate, this, false);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates min/max of value axis.
     * @ignore
     */
    HeatLegend.prototype.updateMinMax = function (min, max) {
        var valueAxis = this.valueAxis;
        if (!isNumber(this.minValue)) {
            valueAxis.min = min;
            valueAxis.invalidate();
        }
        if (!isNumber(this.maxValue)) {
            valueAxis.max = max;
            valueAxis.invalidate();
        }
    };
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    HeatLegend.prototype.processConfig = function (config) {
        if (config) {
            // Set up series
            if (hasValue(config.series) && isString(config.series)) {
                if (isString(config.series)) {
                    if (this.map.hasKey(config.series)) {
                        config.series = this.map.getKey(config.series);
                    }
                    else {
                        var seriesId_1 = config.series;
                        var disposer_1 = this.map.events.on("insertKey", function (ev) {
                            if (ev.key == seriesId_1) {
                                this.series = ev.newValue;
                                disposer_1.dispose();
                            }
                        }, this);
                        this._disposers.push(disposer_1);
                        delete config.series;
                    }
                }
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    return HeatLegend;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["HeatLegend"] = HeatLegend_HeatLegend;
//# sourceMappingURL=HeatLegend.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/Candlestick.js
/**
 * Module that defines everything related to building Candlesticks.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Class used to creates Candlesticks.
 *
 * @see {@link ICandlestickEvents} for a list of available events
 * @see {@link ICandlestickAdapters} for a list of available Adapters
 * @todo Usage example
 * @important
 */
var Candlestick_Candlestick = /** @class */ (function (_super) {
    __extends(Candlestick, _super);
    /**
     * Constructor
     */
    function Candlestick() {
        var _this = _super.call(this) || this;
        _this.className = "Candlestick";
        _this.layout = "none";
        return _this;
    }
    /**
     * @ignore
     */
    Candlestick.prototype.createAssets = function () {
        _super.prototype.createAssets.call(this);
        this.lowLine = this.createChild(Line_Line);
        this.lowLine.shouldClone = false;
        this.highLine = this.createChild(Line_Line);
        this.highLine.shouldClone = false;
    };
    /**
     * Copies all parameters from another [[Candlestick]].
     *
     * @param source Source Candlestick
     */
    Candlestick.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (this.lowLine) {
            this.lowLine.copyFrom(source.lowLine);
        }
        if (this.highLine) {
            this.highLine.copyFrom(source.highLine);
        }
    };
    return Candlestick;
}(Column_Column));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Candlestick"] = Candlestick_Candlestick;
//# sourceMappingURL=Candlestick.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/CandlestickSeries.js
/**
 * Candlestick Series module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[CandlestickSeries]].
 *
 * @see {@link DataItem}
 */
var CandlestickSeries_CandlestickSeriesDataItem = /** @class */ (function (_super) {
    __extends(CandlestickSeriesDataItem, _super);
    /**
     * Defines a type of [[Component]] this data item is used for
     * @todo Disabled to work around TS bug (see if we can re-enable it again)
     */
    //public _component!: CandlestickSeries;
    /**
     * Constructor
     */
    function CandlestickSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.values.lowValueX = {};
        _this.values.lowValueY = {};
        _this.values.highValueX = {};
        _this.values.highValueY = {};
        _this.className = "CandlestickSeriesDataItem";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(CandlestickSeriesDataItem.prototype, "lowValueX", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.lowValueX.value;
        },
        /**
         * Low value for horizontal axis.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("lowValueX", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CandlestickSeriesDataItem.prototype, "lowValueY", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.lowValueY.value;
        },
        /**
         * Low value for vertical axis.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("lowValueY", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CandlestickSeriesDataItem.prototype, "highValueX", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.highValueX.value;
        },
        /**
         * High value for horizontal axis.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("highValueX", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CandlestickSeriesDataItem.prototype, "highValueY", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.highValueY.value;
        },
        /**
         * High value for vertical axis.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("highValueY", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CandlestickSeriesDataItem.prototype, "closeValueX", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.valueX.value;
        },
        /**
         * Close value for horizontal axis.
         *
         * This is an alias for `valueX` added for convenience only.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("valueX", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CandlestickSeriesDataItem.prototype, "closeValueY", {
        /**
         * @return Value
         */
        get: function () {
            return this.values.valueY.value;
        },
        /**
         * Close value for vertical axis.
         *
         * This is an alias for `valueX` added for convenience only.
         *
         * @param value  Value
         */
        set: function (value) {
            this.setValue("valueY", value);
        },
        enumerable: true,
        configurable: true
    });
    return CandlestickSeriesDataItem;
}(ColumnSeries_ColumnSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a candlestick graph.
 *
 * @see {@link ICandlestickSeriesEvents} for a list of available Events
 * @see {@link ICandlestickSeriesAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var CandlestickSeries_CandlestickSeries = /** @class */ (function (_super) {
    __extends(CandlestickSeries, _super);
    /**
     * Constructor
     */
    function CandlestickSeries() {
        var _this = _super.call(this) || this;
        _this.className = "CandlestickSeries";
        _this.groupFields.lowValueX = "low";
        _this.groupFields.lowValueY = "low";
        _this.groupFields.highValueX = "high";
        _this.groupFields.highValueY = "high";
        _this.strokeOpacity = 1;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        var positiveColor = interfaceColors.getFor("positive");
        var negativeColor = interfaceColors.getFor("negative");
        _this.dropFromOpenState.properties.fill = negativeColor;
        _this.dropFromOpenState.properties.stroke = negativeColor;
        _this.riseFromOpenState.properties.fill = positiveColor;
        _this.riseFromOpenState.properties.stroke = positiveColor;
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    CandlestickSeries.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Candlestick Series");
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    CandlestickSeries.prototype.createDataItem = function () {
        return new CandlestickSeries_CandlestickSeriesDataItem();
    };
    /**
     * Validates data item's element, effectively redrawing it.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    CandlestickSeries.prototype.validateDataElementReal = function (dataItem) {
        _super.prototype.validateDataElementReal.call(this, dataItem);
        this.validateCandlestick(dataItem);
    };
    CandlestickSeries.prototype.validateCandlestick = function (dataItem) {
        var column = dataItem.column;
        if (column) {
            var lowLine_1 = column.lowLine;
            var highLine_1 = column.highLine;
            if (this.baseAxis == this.xAxis) {
                var x = column.pixelWidth / 2;
                lowLine_1.x = x;
                highLine_1.x = x;
                var open_1 = dataItem.getWorkingValue(this.yOpenField);
                var close_1 = dataItem.getWorkingValue(this.yField);
                var yOpen = this.yAxis.getY(dataItem, this.yOpenField);
                var yClose = this.yAxis.getY(dataItem, this.yField);
                var yLow = this.yAxis.getY(dataItem, this.yLowField);
                var yHigh = this.yAxis.getY(dataItem, this.yHighField);
                var pixelY = column.pixelY;
                lowLine_1.y1 = yLow - pixelY;
                highLine_1.y1 = yHigh - pixelY;
                if (open_1 < close_1) {
                    lowLine_1.y2 = yOpen - pixelY;
                    highLine_1.y2 = yClose - pixelY;
                }
                else {
                    lowLine_1.y2 = yClose - pixelY;
                    highLine_1.y2 = yOpen - pixelY;
                }
            }
            if (this.baseAxis == this.yAxis) {
                var y = column.pixelHeight / 2;
                lowLine_1.y = y;
                highLine_1.y = y;
                var open_2 = dataItem.getWorkingValue(this.xOpenField);
                var close_2 = dataItem.getWorkingValue(this.xField);
                var xOpen = this.xAxis.getX(dataItem, this.xOpenField);
                var xClose = this.xAxis.getX(dataItem, this.xField);
                var xLow = this.xAxis.getX(dataItem, this.xLowField);
                var xHigh = this.xAxis.getX(dataItem, this.xHighField);
                var pixelX = column.pixelX;
                lowLine_1.x1 = xLow - pixelX;
                highLine_1.x1 = xHigh - pixelX;
                if (open_2 < close_2) {
                    lowLine_1.x2 = xOpen - pixelX;
                    highLine_1.x2 = xClose - pixelX;
                }
                else {
                    lowLine_1.x2 = xClose - pixelX;
                    highLine_1.x2 = xOpen - pixelX;
                }
            }
            Iterator_each(this.axisRanges.iterator(), function (axisRange) {
                // LOW LINE
                var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
                if (rangeColumn) {
                    var rangeLowLine = rangeColumn.lowLine;
                    rangeLowLine.x = lowLine_1.x;
                    rangeLowLine.y = lowLine_1.y;
                    rangeLowLine.x1 = lowLine_1.x1;
                    rangeLowLine.x2 = lowLine_1.x2;
                    rangeLowLine.y1 = lowLine_1.y1;
                    rangeLowLine.y2 = lowLine_1.y2;
                    // HIGH LINE
                    var rangehighLine = rangeColumn.highLine;
                    rangehighLine.x = highLine_1.x;
                    rangehighLine.y = highLine_1.y;
                    rangehighLine.x1 = highLine_1.x1;
                    rangehighLine.x2 = highLine_1.x2;
                    rangehighLine.y1 = highLine_1.y1;
                    rangehighLine.y2 = highLine_1.y2;
                }
            });
        }
    };
    Object.defineProperty(CandlestickSeries.prototype, "xLowField", {
        /**
         * A data field to look for "low" value for horizontal axis.
         *
         * @ignore Exclude from docs
         * @return Field name
         */
        get: function () {
            return this._xLowField;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CandlestickSeries.prototype, "yLowField", {
        /**
         * A data field to look for "low" value for vertical axis.
         *
         * @ignore Exclude from docs
         * @return Field name
         */
        get: function () {
            return this._yLowField;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CandlestickSeries.prototype, "xHighField", {
        /**
         * A data field to look for "high" value for horizontal axis.
         *
         * @ignore Exclude from docs
         * @return Field name
         */
        get: function () {
            return this._xHighField;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CandlestickSeries.prototype, "yHighField", {
        /**
         * A data field to look for "high" value for vertical axis.
         *
         * @ignore Exclude from docs
         * @return Field name
         */
        get: function () {
            return this._yHighField;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets up which data fields to use for data access.
     */
    CandlestickSeries.prototype.defineFields = function () {
        _super.prototype.defineFields.call(this);
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (xAxis && yAxis) {
            if (this.baseAxis == xAxis) {
                var yAxisFieldName = capitalize(yAxis.axisFieldName);
                this._yLowField = ("low" + yAxisFieldName + "Y");
                this._yHighField = ("high" + yAxisFieldName + "Y");
            }
            if (this.baseAxis == yAxis) {
                var xAxisFieldName = capitalize(xAxis.axisFieldName);
                this._xLowField = ("low" + xAxisFieldName + "X");
                this._xHighField = ("high" + xAxisFieldName + "X");
            }
            this.addValueField(xAxis, this._xValueFields, this._xLowField);
            this.addValueField(xAxis, this._xValueFields, this._xHighField);
            this.addValueField(yAxis, this._yValueFields, this._yLowField);
            this.addValueField(yAxis, this._yValueFields, this._yHighField);
        }
    };
    /**
     * Creates elements in related legend container, that mimics the look of this
     * Series.
     *
     * @ignore Exclude from docs
     * @param marker  Legend item container
     */
    CandlestickSeries.prototype.createLegendMarker = function (marker) {
        var w = marker.pixelWidth;
        var h = marker.pixelHeight;
        marker.removeChildren();
        var column = marker.createChild(Candlestick_Candlestick);
        column.shouldClone = false;
        column.copyFrom(this.columns.template);
        var cw;
        var ch;
        var highLine = column.lowLine;
        var lowLine = column.highLine;
        if (this.baseAxis == this.yAxis) {
            cw = w / 3;
            ch = h;
            highLine.y = h / 2;
            lowLine.y = h / 2;
            highLine.x2 = w / 3;
            lowLine.x2 = w / 3;
            lowLine.x = w / 3 * 2;
            column.column.x = w / 3;
        }
        else {
            cw = w;
            ch = h / 3;
            highLine.x = w / 2;
            lowLine.x = w / 2;
            highLine.y2 = h / 3;
            lowLine.y2 = h / 3;
            lowLine.y = h / 3 * 2;
            column.column.y = h / 3;
        }
        column.width = cw;
        column.height = ch;
        copyProperties(this, marker, visualProperties);
        copyProperties(this.columns.template, column, visualProperties);
        column.stroke = this.riseFromOpenState.properties.stroke;
        column.fill = column.stroke;
        var legendDataItem = marker.dataItem;
        legendDataItem.color = column.fill;
        legendDataItem.colorOrig = column.fill;
    };
    /**
     * Returns an element to use for Candlestick
     * @ignore
     * @return Element.
     */
    CandlestickSeries.prototype.createColumnTemplate = function () {
        return new Candlestick_Candlestick();
    };
    return CandlestickSeries;
}(ColumnSeries_ColumnSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["CandlestickSeries"] = CandlestickSeries_CandlestickSeries;
registry.registeredClasses["CandlestickSeriesDataItem"] = CandlestickSeries_CandlestickSeriesDataItem;
//# sourceMappingURL=CandlestickSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/OHLC.js
/**
 * Module that defines everything related to building OHLCs.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Class used to creates OHLCs.
 *
 * @see {@link IOHLCEvents} for a list of available events
 * @see {@link IOHLCAdapters} for a list of available Adapters
 * @todo Usage example
 * @important
 */
var OHLC_OHLC = /** @class */ (function (_super) {
    __extends(OHLC, _super);
    /**
     * Constructor
     */
    function OHLC() {
        var _this = _super.call(this) || this;
        _this.className = "OHLC";
        _this.layout = "none";
        return _this;
    }
    /**
     * @ignore
     */
    OHLC.prototype.createAssets = function () {
        //super.createAssets();
        this.openLine = this.createChild(Line_Line);
        this.openLine.shouldClone = false;
        this.highLowLine = this.createChild(Line_Line);
        this.highLowLine.shouldClone = false;
        this.closeLine = this.createChild(Line_Line);
        this.closeLine.shouldClone = false;
    };
    /**
     * Copies all parameters from another [[OHLC]].
     *
     * @param source Source OHLC
     */
    OHLC.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (this.openLine) {
            this.openLine.copyFrom(source.openLine);
        }
        if (this.highLowLine) {
            this.highLowLine.copyFrom(source.highLowLine);
        }
        if (this.closeLine) {
            this.closeLine.copyFrom(source.closeLine);
        }
    };
    return OHLC;
}(Candlestick_Candlestick));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["OHLC"] = OHLC_OHLC;
//# sourceMappingURL=OHLC.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/OHLCSeries.js
/**
 * Candlestick Series module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[OHLCSeries]].
 *
 * @see {@link DataItem}
 */
var OHLCSeries_OHLCSeriesDataItem = /** @class */ (function (_super) {
    __extends(OHLCSeriesDataItem, _super);
    /**
     * Defines a type of [[Component]] this data item is used for
     * @todo Disabled to work around TS bug (see if we can re-enable it again)
     */
    //public _component!: OHLCSeries;
    /**
     * Constructor
     */
    function OHLCSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "OHLCSeriesDataItem";
        _this.applyTheme();
        return _this;
    }
    return OHLCSeriesDataItem;
}(CandlestickSeries_CandlestickSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a candlestick graph.
 *
 * @see {@link IOHLCSeriesEvents} for a list of available Events
 * @see {@link IOHLCSeriesAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var OHLCSeries_OHLCSeries = /** @class */ (function (_super) {
    __extends(OHLCSeries, _super);
    /**
     * Constructor
     */
    function OHLCSeries() {
        var _this = _super.call(this) || this;
        _this.className = "OHLCSeries";
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    OHLCSeries.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("OHLC Series");
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    OHLCSeries.prototype.createDataItem = function () {
        return new OHLCSeries_OHLCSeriesDataItem();
    };
    OHLCSeries.prototype.validateCandlestick = function (dataItem) {
        var column = dataItem.column;
        if (column) {
            var openLine_1 = column.openLine;
            var highLowLine_1 = column.highLowLine;
            var closeLine_1 = column.closeLine;
            if (this.baseAxis == this.xAxis) {
                var x = column.pixelWidth / 2;
                highLowLine_1.x = x;
                // TODO can these be removed ?
                dataItem.getWorkingValue(this.yOpenField);
                dataItem.getWorkingValue(this.yField);
                var yOpen = this.yAxis.getY(dataItem, this.yOpenField);
                var yClose = this.yAxis.getY(dataItem, this.yField);
                var yLow = this.yAxis.getY(dataItem, this.yLowField);
                var yHigh = this.yAxis.getY(dataItem, this.yHighField);
                var pixelY = column.pixelY;
                openLine_1.y1 = yOpen - pixelY;
                openLine_1.y2 = yOpen - pixelY;
                openLine_1.x1 = 0;
                openLine_1.x2 = x;
                closeLine_1.y1 = yClose - pixelY;
                closeLine_1.y2 = yClose - pixelY;
                closeLine_1.x1 = x;
                closeLine_1.x2 = 2 * x;
                highLowLine_1.y1 = yHigh - pixelY;
                highLowLine_1.y2 = yLow - pixelY;
            }
            if (this.baseAxis == this.yAxis) {
                var y = column.pixelHeight / 2;
                highLowLine_1.y = y;
                // TODO can these be removed ?
                dataItem.getWorkingValue(this.xOpenField);
                dataItem.getWorkingValue(this.xField);
                var xOpen = this.xAxis.getX(dataItem, this.xOpenField);
                var xClose = this.xAxis.getX(dataItem, this.xField);
                var xLow = this.xAxis.getX(dataItem, this.xLowField);
                var xHigh = this.xAxis.getX(dataItem, this.xHighField);
                var pixelX = column.pixelX;
                openLine_1.x1 = xOpen - pixelX;
                openLine_1.x2 = xOpen - pixelX;
                openLine_1.y1 = y;
                openLine_1.y2 = 2 * y;
                closeLine_1.x1 = xClose - pixelX;
                closeLine_1.x2 = xClose - pixelX;
                closeLine_1.y1 = 0;
                closeLine_1.y2 = y;
                highLowLine_1.x1 = xHigh - pixelX;
                highLowLine_1.x2 = xLow - pixelX;
            }
            Iterator_each(this.axisRanges.iterator(), function (axisRange) {
                var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
                if (rangeColumn) {
                    var rangeOpenLine = rangeColumn.openLine;
                    rangeOpenLine.x = openLine_1.x;
                    rangeOpenLine.y = openLine_1.y;
                    rangeOpenLine.x1 = openLine_1.x1;
                    rangeOpenLine.x2 = openLine_1.x2;
                    rangeOpenLine.y1 = openLine_1.y1;
                    rangeOpenLine.y2 = openLine_1.y2;
                    var rangeCloseLine = rangeColumn.closeLine;
                    rangeCloseLine.x = closeLine_1.x;
                    rangeCloseLine.y = closeLine_1.y;
                    rangeCloseLine.x1 = closeLine_1.x1;
                    rangeCloseLine.x2 = closeLine_1.x2;
                    rangeCloseLine.y1 = closeLine_1.y1;
                    rangeCloseLine.y2 = closeLine_1.y2;
                    var rangeHighLowLine = rangeColumn.highLowLine;
                    rangeHighLowLine.x = highLowLine_1.x;
                    rangeHighLowLine.y = highLowLine_1.y;
                    rangeHighLowLine.x1 = highLowLine_1.x1;
                    rangeHighLowLine.x2 = highLowLine_1.x2;
                    rangeHighLowLine.y1 = highLowLine_1.y1;
                    rangeHighLowLine.y2 = highLowLine_1.y2;
                }
            });
        }
    };
    /**
     * Creates elements in related legend container, that mimics the look of this
     * Series.
     *
     * @ignore Exclude from docs
     * @param marker  Legend item container
     */
    OHLCSeries.prototype.createLegendMarker = function (marker) {
        var w = marker.pixelWidth;
        var h = marker.pixelHeight;
        marker.removeChildren();
        var column = marker.createChild(OHLC_OHLC);
        column.shouldClone = false;
        column.copyFrom(this.columns.template);
        var cw;
        var ch;
        var openLine = column.openLine;
        var closeLine = column.closeLine;
        var highLowLine = column.highLowLine;
        if (this.baseAxis == this.yAxis) {
            cw = w / 3;
            ch = h;
            highLowLine.y = h / 2;
            highLowLine.x2 = w;
            openLine.x = w / 3 * 2;
            openLine.y2 = h / 2;
            closeLine.x = w / 3;
            closeLine.y2 = h;
            closeLine.y1 = h / 2;
        }
        else {
            cw = w;
            ch = h / 3;
            highLowLine.x = w / 2;
            highLowLine.y2 = h;
            openLine.y = h / 3 * 2;
            openLine.x2 = w / 2;
            closeLine.y = h / 3;
            closeLine.x2 = w;
            closeLine.x1 = w / 2;
        }
        column.width = cw;
        column.height = ch;
        copyProperties(this, marker, visualProperties);
        copyProperties(this.columns.template, column, visualProperties);
        column.stroke = this.riseFromOpenState.properties.stroke;
        var legendDataItem = marker.dataItem;
        legendDataItem.color = column.stroke;
        legendDataItem.colorOrig = column.stroke;
    };
    /**
     * Returns an element to use for Candlestick
     * @ignore
     * @return Element.
     */
    OHLCSeries.prototype.createColumnTemplate = function () {
        return new OHLC_OHLC();
    };
    return OHLCSeries;
}(CandlestickSeries_CandlestickSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["OHLCSeries"] = OHLCSeries_OHLCSeries;
registry.registeredClasses["OHLCSeriesDataItem"] = OHLCSeries_OHLCSeriesDataItem;
//# sourceMappingURL=OHLCSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/StepLineSeriesSegment.js
/**
 * Line series segment module.
 * @todo Add description about what this is
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Represents a line series segment.
 *
 * A line segment can be used to apply different properties to a part of the
 * line series, between two data points.
 *
 * @see {@link IStepLineSeriesSegmentEvents} for a list of available events
 * @see {@link IStepLineSeriesSegmentAdapters} for a list of available Adapters
 * @todo Example
 */
var StepLineSeriesSegment_StepLineSeriesSegment = /** @class */ (function (_super) {
    __extends(StepLineSeriesSegment, _super);
    /**
     * Constructor
     */
    function StepLineSeriesSegment() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "StepLineSeriesSegment";
        return _this;
    }
    /**
     * Draws the series segment.
     *
     * @ignore Exclude from docs
     * @param points       Points to connect
     * @param closePoints  ?
     * @param smoothnessX  Horizontal bezier setting (?)
     * @param smoothnessY  Vertical bezier setting (?)
     */
    StepLineSeriesSegment.prototype.drawSegment = function (points, closePoints, smoothnessX, smoothnessY, noRisers, vertical) {
        if (points.length > 0 && closePoints.length > 0) {
            if (noRisers) {
                var path = moveTo(points[0]);
                if (points.length > 0) {
                    for (var i = 1; i < points.length; i++) {
                        var point = points[i];
                        if (i / 2 == Math.round(i / 2)) {
                            path += moveTo(point);
                        }
                        else {
                            path += lineTo(point);
                        }
                    }
                }
                this.strokeSprite.path = path;
                if (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) { // helps to avoid drawing fill object if fill is not visible
                    path = moveTo(points[0]) + polyline(points);
                    path += lineTo(closePoints[0]) + polyline(closePoints);
                    path += lineTo(points[0]);
                    path += closePath();
                    this.fillSprite.path = path;
                }
                else {
                }
            }
            else {
                var path = moveTo(points[0]) + polyline(points);
                this.strokeSprite.path = path;
                if (this.fillOpacity > 0 || this.fillSprite.fillOpacity > 0) { // helps to avoid drawing fill object if fill is not visible
                    path += lineTo(closePoints[0]) + polyline(closePoints);
                    path += lineTo(points[0]);
                    path += closePath();
                    this.fillSprite.path = path;
                }
            }
        }
    };
    return StepLineSeriesSegment;
}(LineSeriesSegment_LineSeriesSegment));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["StepLineSeriesSegment"] = StepLineSeriesSegment_StepLineSeriesSegment;
//# sourceMappingURL=StepLineSeriesSegment.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/StepLineSeries.js
/**
 * Step line series module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[StepLineSeries]].
 *
 * @see {@link DataItem}
 */
var StepLineSeries_StepLineSeriesDataItem = /** @class */ (function (_super) {
    __extends(StepLineSeriesDataItem, _super);
    /**
     * Constructor
     */
    function StepLineSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "StepLineSeriesDataItem";
        _this.applyTheme();
        return _this;
    }
    return StepLineSeriesDataItem;
}(LineSeries_LineSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a step line graph.
 *
 * @see {@link IStepLineSeriesEvents} for a list of available Events
 * @see {@link IStepLineSeriesAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var StepLineSeries_StepLineSeries = /** @class */ (function (_super) {
    __extends(StepLineSeries, _super);
    /**
     * Constructor
     */
    function StepLineSeries() {
        var _this = _super.call(this) || this;
        _this.className = "StepLineSeries";
        _this.applyTheme();
        _this.startLocation = 0;
        _this.endLocation = 1;
        return _this;
    }
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    StepLineSeries.prototype.createDataItem = function () {
        return new StepLineSeries_StepLineSeriesDataItem();
    };
    /**
     * [addPoints description]
     *
     * @todo Description
     * @param points     [description]
     * @param dataItem   [description]
     * @param xField     [description]
     * @param yField     [description]
     * @param backwards  [description]
     */
    StepLineSeries.prototype.addPoints = function (points, dataItem, xField, yField, backwards) {
        var startLocationX;
        var endLocationX;
        var startLocationY;
        var endLocationY;
        if (this.baseAxis == this.xAxis) {
            startLocationX = this.startLocation;
            endLocationX = this.endLocation;
            startLocationY = this.getAdjustedXLocation(dataItem, this.yOpenField);
            endLocationY = this.getAdjustedXLocation(dataItem, this.yField);
        }
        if (this.baseAxis == this.yAxis) {
            startLocationY = this.startLocation;
            endLocationY = this.endLocation;
            startLocationX = this.getAdjustedXLocation(dataItem, this.xOpenField);
            endLocationX = this.getAdjustedXLocation(dataItem, this.xField);
        }
        var x0 = this.xAxis.getX(dataItem, xField, startLocationX);
        var y0 = this.yAxis.getY(dataItem, yField, startLocationY);
        var x1 = this.xAxis.getX(dataItem, xField, endLocationX);
        var y1 = this.yAxis.getY(dataItem, yField, endLocationY);
        x0 = fitToRange(x0, -100000, 100000); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.
        y0 = fitToRange(y0, -100000, 100000); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.
        x1 = fitToRange(x1, -100000, 100000); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.
        y1 = fitToRange(y1, -100000, 100000); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.
        // this might make an impression that points are duplicated, and they indeed are, but this is needed to handle gaps in data
        if (!this.noRisers) {
            if (points.length > 1) {
                var prevPoint = points[points.length - 1];
                if (this.baseAxis == this.xAxis) {
                    if (backwards) {
                        points.push({ x: prevPoint.x, y: y1 });
                    }
                    else {
                        points.push({ x: x0, y: prevPoint.y });
                    }
                }
                if (this.baseAxis == this.yAxis) {
                    if (backwards) {
                        points.push({ x: x1, y: prevPoint.y });
                    }
                    else {
                        points.push({ x: prevPoint.x, y: y0 });
                    }
                }
            }
        }
        var point0 = { x: x0, y: y0 };
        var point1 = { x: x1, y: y1 };
        if (backwards) {
            points.push(point1, point0);
        }
        else {
            points.push(point0, point1);
        }
    };
    /**
     * Draws the line segment.
     *
     * @param segment     Segment
     * @param points      Segment points
     * @param closePoints Segment close points
     */
    StepLineSeries.prototype.drawSegment = function (segment, points, closePoints) {
        var vertical = false;
        if (this.yAxis == this.baseAxis) {
            vertical = true;
        }
        segment.drawSegment(points, closePoints, this.tensionX, this.tensionY, this.noRisers, vertical);
    };
    /**
     * @ignore
     */
    StepLineSeries.prototype.createSegment = function () {
        return new StepLineSeriesSegment_StepLineSeriesSegment();
    };
    Object.defineProperty(StepLineSeries.prototype, "noRisers", {
        /**
         * @return No risers
         */
        get: function () {
            return this.getPropertyValue("noRisers");
        },
        /**
         * Specifies if step line series should draw only horizontal (or only
         * vertical, depending on base axis) lines, instead of connecting them with
         * vertical (or horizontal) lines.
         *
         * @default false
         * @param value  No risers
         */
        set: function (value) {
            this.setPropertyValue("noRisers", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepLineSeries.prototype, "startLocation", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("startLocation");
        },
        /**
         * start location of the step
         *
         * @param value Location (0-1)
         * @default 0
         */
        set: function (value) {
            this.setPropertyValue("startLocation", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StepLineSeries.prototype, "endLocation", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("endLocation");
        },
        /**
         * Step end location.
         *
         * @param value Location (0-1)
         * #default 1
         */
        set: function (value) {
            this.setPropertyValue("endLocation", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return StepLineSeries;
}(LineSeries_LineSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["StepLineSeries"] = StepLineSeries_StepLineSeries;
registry.registeredClasses["StepLineSeriesDataItem"] = StepLineSeries_StepLineSeriesDataItem;
//# sourceMappingURL=StepLineSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/RadarColumn.js
/**
 * Module that defines everything related to building RadarColumns.
 * It is a container which has radarColumn element which is a Slice.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Class used to creates RadarColumns.
 *
 * @see {@link IRadarColumnEvents} for a list of available events
 * @see {@link IRadarColumnAdapters} for a list of available Adapters
 * @todo Usage example
 * @important
 */
var RadarColumn_RadarColumn = /** @class */ (function (_super) {
    __extends(RadarColumn, _super);
    /**
     * Constructor
     */
    function RadarColumn() {
        var _this = _super.call(this) || this;
        _this.className = "RadarColumn";
        return _this;
    }
    /**
     * @ignore
     */
    RadarColumn.prototype.createAssets = function () {
        this.radarColumn = this.createChild(Slice_Slice);
        this.radarColumn.shouldClone = false;
        this.radarColumn.strokeOpacity = undefined;
        // some dirty hack so that if user access column, it won't get error
        this.column = this.radarColumn;
    };
    /**
     * Copies all parameters from another [[RadarColumn]].
     *
     * @param source Source RadarColumn
     */
    RadarColumn.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (this.radarColumn) {
            this.radarColumn.copyFrom(source.radarColumn);
        }
    };
    /**
     * X coordinate for the slice tooltip.
     *
     * @return X
     * @ignore
     */
    RadarColumn.prototype.getTooltipX = function () {
        var value = this.getPropertyValue("tooltipX");
        if (!isNumber(value)) {
            return this.radarColumn.getTooltipX();
        }
        return value;
    };
    /**
     * Y coordinate for the slice tooltip.
     *
     * @return Y
     * @ignore
     */
    RadarColumn.prototype.getTooltipY = function () {
        var value = this.getPropertyValue("tooltipX");
        if (!isNumber(value)) {
            return this.radarColumn.getTooltipY();
        }
        return value;
    };
    return RadarColumn;
}(Column_Column));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["RadarColumn"] = RadarColumn_RadarColumn;
//# sourceMappingURL=RadarColumn.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/RadarColumnSeries.js
/**
 * Radar column series module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */











/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[RadarColumnSeries]].
 *
 * @see {@link DataItem}
 */
var RadarColumnSeries_RadarColumnSeriesDataItem = /** @class */ (function (_super) {
    __extends(RadarColumnSeriesDataItem, _super);
    /**
     * Constructor
     */
    function RadarColumnSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "ColumnSeriesDataItem";
        _this.applyTheme();
        return _this;
    }
    return RadarColumnSeriesDataItem;
}(ColumnSeries_ColumnSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a 3D column graph.
 *
 * @see {@link IRadarColumnSeriesEvents} for a list of available Events
 * @see {@link IRadarColumnSeriesAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var RadarColumnSeries_RadarColumnSeries = /** @class */ (function (_super) {
    __extends(RadarColumnSeries, _super);
    /**
     * Constructor
     */
    function RadarColumnSeries() {
        var _this = _super.call(this) || this;
        _this.className = "RadarColumnSeries";
        _this.applyTheme();
        return _this;
    }
    /**
     * Creates and returns a RadarColumn element to use as column in radar chart.
     *
     * @return RadarColumn.
     */
    RadarColumnSeries.prototype.createColumnTemplate = function () {
        return new RadarColumn_RadarColumn();
    };
    /**
     * (Re)validates the whole series, effectively causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    RadarColumnSeries.prototype.validate = function () {
        // so that radius would be updated
        if (this.chart.invalid) {
            this.chart.validate();
        }
        _super.prototype.validate.call(this);
    };
    /**
     * @ignore
     */
    RadarColumnSeries.prototype.disableUnusedColumns = function (dataItem) {
        if (dataItem) {
            if (dataItem.column) {
                dataItem.column.__disabled = true;
            }
            Iterator_each(this.axisRanges.iterator(), function (axisRange) {
                var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
                if (rangeColumn) {
                    rangeColumn.__disabled = true;
                }
            });
        }
    };
    /**
     * Validates data item's element, effectively redrawing it.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    RadarColumnSeries.prototype.validateDataElementReal = function (dataItem) {
        var _this = this;
        var startAngle = this.chart.startAngle;
        var endAngle = this.chart.endAngle;
        var yField = this.yField;
        var yOpenField = this.yOpenField;
        var xField = this.xField;
        var xOpenField = this.xOpenField;
        var lAngle;
        var rAngle;
        var tRadius;
        var bRadius;
        var startLocation = this.getStartLocation(dataItem);
        var endLocation = this.getEndLocation(dataItem);
        var cellAngle = (endAngle - startAngle) / (this.dataItems.length * (this.end - this.start));
        var radarColumn = dataItem.column;
        if (!radarColumn) {
            radarColumn = this.columns.create();
            dataItem.column = radarColumn;
            copyProperties(this, radarColumn, visualProperties); // need this 
            copyProperties(this.columns.template, radarColumn, visualProperties); // second time, no force, so that columns.template would override series properties			
            dataItem.addSprite(radarColumn);
            radarColumn.paper = this.paper; // sometimes pattern is not drawn if is set with adapter without this.
            this.setColumnStates(radarColumn);
        }
        var width = radarColumn.width;
        var percentWidth = 100;
        if (width instanceof Percent) {
            percentWidth = width.percent;
        }
        var offset = Math_round((endLocation - startLocation) * (1 - percentWidth / 100) / 2, 5);
        startLocation += offset;
        endLocation -= offset;
        // two category axes
        if ((this.xAxis instanceof CategoryAxis_CategoryAxis) && (this.yAxis instanceof CategoryAxis_CategoryAxis)) {
            tRadius = getDistance({ x: this.yAxis.getX(dataItem, yField, 0, "valueY"), y: this.yAxis.getY(dataItem, yField, 0, "valueY") });
            bRadius = getDistance({ x: this.yAxis.getX(dataItem, yOpenField, 1, "valueY"), y: this.yAxis.getY(dataItem, yOpenField, 1, "valueY") });
            lAngle = this.xAxis.getAngle(dataItem, xOpenField, 0, "valueX");
            rAngle = this.xAxis.getAngle(dataItem, xField, 1, "valueX");
            startAngle = startAngle + startLocation * cellAngle;
            endAngle = endAngle - (1 - endLocation) * cellAngle;
        }
        else if (this.baseAxis == this.xAxis) {
            tRadius = getDistance({ x: this.yAxis.getX(dataItem, yField, dataItem.locations[yField], "valueY"), y: this.yAxis.getY(dataItem, yField, dataItem.locations[yField], "valueY") });
            bRadius = getDistance({ x: this.yAxis.getX(dataItem, yOpenField, dataItem.locations[yOpenField], "valueY"), y: this.yAxis.getY(dataItem, yOpenField, dataItem.locations[yOpenField], "valueY") });
            lAngle = this.xAxis.getAngle(dataItem, xOpenField, startLocation, "valueX");
            rAngle = this.xAxis.getAngle(dataItem, xField, endLocation, "valueX");
            startAngle = startAngle + startLocation * cellAngle;
            endAngle = endAngle - (1 - endLocation) * cellAngle;
        }
        else {
            tRadius = getDistance({ x: this.yAxis.getX(dataItem, yField, startLocation, "valueY"), y: this.yAxis.getY(dataItem, yField, startLocation, "valueY") });
            bRadius = getDistance({ x: this.yAxis.getX(dataItem, yOpenField, endLocation, "valueY"), y: this.yAxis.getY(dataItem, yOpenField, endLocation, "valueY") });
            lAngle = this.xAxis.getAngle(dataItem, xField, dataItem.locations[xField], "valueX");
            rAngle = this.xAxis.getAngle(dataItem, xOpenField, dataItem.locations[xOpenField], "valueX");
        }
        if (rAngle < lAngle) {
            var temp = rAngle;
            rAngle = lAngle;
            lAngle = temp;
        }
        lAngle = fitToRange(lAngle, startAngle, endAngle);
        rAngle = fitToRange(rAngle, startAngle, endAngle);
        var slice = radarColumn.radarColumn;
        slice.startAngle = lAngle;
        var arc = rAngle - lAngle;
        if (arc > 0) {
            slice.arc = arc;
            slice.radius = tRadius;
            slice.innerRadius = bRadius;
            radarColumn.__disabled = false;
            radarColumn.parent = this.columnsContainer;
            Iterator_each(this.axisRanges.iterator(), function (axisRange) {
                var rangeColumn = dataItem.rangesColumns.getKey(axisRange.uid);
                if (!rangeColumn) {
                    rangeColumn = _this.columns.create();
                    forceCopyProperties(_this.columns.template, rangeColumn, visualProperties);
                    copyProperties(axisRange.contents, rangeColumn, visualProperties); // need this because 3d columns are not in the same container
                    if (rangeColumn.dataItem) {
                        remove(rangeColumn.dataItem.sprites, rangeColumn);
                    }
                    dataItem.addSprite(rangeColumn);
                    rangeColumn.paper = _this.paper; // sometimes pattern is not drawn if is set with adapter without this.					
                    _this.setColumnStates(rangeColumn);
                    dataItem.rangesColumns.setKey(axisRange.uid, rangeColumn);
                }
                var slice = rangeColumn.radarColumn;
                slice.startAngle = lAngle;
                slice.arc = arc;
                slice.radius = tRadius;
                slice.innerRadius = bRadius;
                if (slice.invalid) {
                    slice.paper = _this.paper;
                    slice.validate(); // validate as if it was used previously, it will flicker with previous dimensions
                }
                rangeColumn.__disabled = false;
                rangeColumn.parent = axisRange.contents;
            });
        }
        else {
            this.disableUnusedColumns(dataItem);
        }
    };
    /**
     * Returns an [[IPoint]] coordinates of the specific Serie's data point.
     *
     * @param    dataItem   Data item
     * @param    xKey       Name of X data field
     * @param    yKey       Name of Y data field
     * @param    locationX  X location
     * @param    locationY  Y location
     * @param    stackKeyX  ?
     * @param    stackKeyY  ?
     * @returns             Coordinates
     */
    RadarColumnSeries.prototype.getPoint = function (dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {
        if (!stackKeyX) {
            stackKeyX = "valueX";
        }
        if (!stackKeyY) {
            stackKeyY = "valueY";
        }
        var x = this.yAxis.getX(dataItem, yKey, locationY, stackKeyY);
        var y = this.yAxis.getY(dataItem, yKey, locationY, stackKeyY);
        var radius = getDistance({ x: x, y: y });
        // hack to be able to determine angle later
        if (radius == 0) {
            radius = 0.00001;
        }
        var angle = this.xAxis.getAngle(dataItem, xKey, locationX, stackKeyX);
        return { x: radius * Math_cos(angle), y: radius * Math_sin(angle) };
    };
    /**
     * Returns an SVG path to be used as a mask for the series.
     *
     * @return SVG path
     */
    RadarColumnSeries.prototype.getMaskPath = function () {
        var renderer = this.yAxis.renderer;
        return Path_arc(renderer.startAngle, renderer.endAngle - renderer.startAngle, renderer.pixelRadius, renderer.pixelInnerRadius);
    };
    RadarColumnSeries.prototype.positionBulletReal = function (bullet, positionX, positionY) {
        var xAxis = this.xAxis;
        var yAxis = this.yAxis;
        if (positionX < xAxis.start || positionX > xAxis.end || positionY < yAxis.start || positionY > yAxis.end) {
            bullet.visible = false;
        }
        bullet.moveTo(this.xAxis.renderer.positionToPoint(positionX, positionY));
    };
    RadarColumnSeries.prototype.setXAxis = function (axis) {
        _super.prototype.setXAxis.call(this, axis);
        this.updateRendererRefs();
    };
    RadarColumnSeries.prototype.setYAxis = function (axis) {
        _super.prototype.setYAxis.call(this, axis);
        this.updateRendererRefs();
    };
    RadarColumnSeries.prototype.updateRendererRefs = function () {
        var rendererX = this.xAxis.renderer;
        var rendererY = this.yAxis.renderer;
        rendererX.axisRendererY = rendererY;
    };
    return RadarColumnSeries;
}(ColumnSeries_ColumnSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["RadarColumnSeries"] = RadarColumnSeries_RadarColumnSeries;
registry.registeredClasses["RadarColumnSeriesDataItem"] = RadarColumnSeries_RadarColumnSeriesDataItem;
//# sourceMappingURL=RadarColumnSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/FunnelSlice.js
/**
 * Module that defines everything related to building Funnel slices.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Class used to create [[FunnelSlice]] elements.
 *
 * @see {@link IFunnelSliceEvents} for a list of available events
 * @see {@link IFunnelSliceAdapters} for a list of available adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/sliced-chart/} for documentation
 * @important
 */
var FunnelSlice_FunnelSlice = /** @class */ (function (_super) {
    __extends(FunnelSlice, _super);
    /**
     * Constructor
     */
    function FunnelSlice() {
        var _this = _super.call(this) || this;
        _this.slice = _this.createChild(Sprite_Sprite);
        _this.slice.shouldClone = false;
        _this.slice.setElement(_this.paper.add("path"));
        _this.slice.isMeasured = false;
        _this.orientation = "vertical";
        _this.bottomWidth = Percent_percent(100);
        _this.topWidth = Percent_percent(100);
        _this.isMeasured = false;
        _this.width = 10;
        _this.height = 10;
        _this.expandDistance = 0;
        _this.className = "FunnelSlice";
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the element.
     */
    FunnelSlice.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var pt = this.pixelPaddingTop;
        var pb = this.pixelPaddingBottom;
        var pr = this.pixelPaddingRight;
        var pl = this.pixelPaddingLeft;
        var w = this.pixelWidth - pr - pl;
        var h = this.pixelHeight - pt - pb;
        var ed = this.expandDistance;
        var path = "";
        if (this.orientation == "vertical") {
            var tw = relativeToValue(this.topWidth, w);
            var bw = relativeToValue(this.bottomWidth, w);
            var tl = { x: (w - tw) / 2 + pl, y: pt };
            var tr = { x: (w + tw) / 2 + pl, y: pt };
            var br = { x: (w + bw) / 2 + pl, y: pt + h };
            var bl = { x: (w - bw) / 2 + pl, y: pt + h };
            var cpr = { x: tr.x + (br.x - tr.x) / 2 + ed * h, y: tr.y + 0.5 * h };
            var cpl = { x: tl.x + (bl.x - tl.x) / 2 - ed * h, y: tl.y + 0.5 * h };
            var qp1 = lineTo(br);
            var qp2 = "";
            if (ed != 0) {
                qp1 = quadraticCurveTo(br, cpr);
                qp2 = quadraticCurveTo(tl, cpl);
            }
            path = moveTo(tl) + lineTo(tr) + qp1 + lineTo(bl) + qp2;
            this.tickPoint = { x: tr.x + (br.x - tr.x) / 2, y: tr.y + (br.y - tr.y) / 2 };
        }
        else {
            var tw = relativeToValue(this.topWidth, h);
            var bw = relativeToValue(this.bottomWidth, h);
            var tt = { x: pl, y: (h - tw) / 2 + pt };
            var tb = { x: pl, y: (h + tw) / 2 + pt };
            var bt = { x: pl + w, y: (h - bw) / 2 + pt };
            var bb = { x: pl + w, y: (h + bw) / 2 + pt };
            var cpr = { y: tt.y + (bt.y - tt.y) / 2 - ed * w, x: tt.x + 0.5 * w };
            var cpl = { y: tb.y + (bb.y - tb.y) / 2 + ed * w, x: tb.x + 0.5 * w };
            var qp1 = lineTo(bt);
            var qp2 = "";
            if (ed != 0) {
                qp1 = quadraticCurveTo(bt, cpr);
                qp2 = quadraticCurveTo(tb, cpl);
            }
            path = moveTo(tb) + lineTo(tt) + qp1 + lineTo(bb) + qp2;
            this.tickPoint = { y: tb.y + (bb.y - tb.y) / 2, x: tb.x + (bb.x - tb.x) / 2 };
        }
        this.slice.path = path;
        this.invalidateLayout();
    };
    FunnelSlice.prototype.getPoint = function (locationX, locationY) {
        var pt = this.pixelPaddingTop;
        var pb = this.pixelPaddingBottom;
        var pr = this.pixelPaddingRight;
        var pl = this.pixelPaddingLeft;
        var w = this.pixelWidth - pr - pl;
        var h = this.pixelHeight - pt - pb;
        if (this.orientation == "vertical") {
            var tw = relativeToValue(this.topWidth, w);
            var bw = relativeToValue(this.bottomWidth, w);
            var tl = { x: (w - tw) / 2 + pl, y: pt };
            var tr = { x: (w + tw) / 2 + pl, y: pt };
            var br = { x: (w + bw) / 2 + pl, y: pt + h };
            var bl = { x: (w - bw) / 2 + pl, y: pt + h };
            var mlx = tl.x + (bl.x - tl.x) * locationY;
            var mrx = tr.x + (br.x - tr.x) * locationY;
            return { x: mlx + (mrx - mlx) * locationX, y: tr.y + (br.y - tr.y) * locationY };
        }
        else {
            var tw = relativeToValue(this.topWidth, h);
            var bw = relativeToValue(this.bottomWidth, h);
            var tt = { x: pl, y: (h - tw) / 2 + pt };
            var tb = { x: pl, y: (h + tw) / 2 + pt };
            var bt = { x: pl + w, y: (h - bw) / 2 + pt };
            var bb = { x: pl + w, y: (h + bw) / 2 + pt };
            var mty = tt.y + (bt.y - tt.y) * locationX;
            var mby = tb.y + (bb.y - tb.y) * locationX;
            return { y: mty + (mby - mty) * locationY, x: tt.x + (bt.x - tt.x) * locationX };
        }
    };
    Object.defineProperty(FunnelSlice.prototype, "bottomWidth", {
        /**
         * @return bottom width
         */
        get: function () {
            return this.getPropertyValue("bottomWidth");
        },
        /**
         * Bottom width in pixels or percent.
         *
         * IMPORTANT: this setting might be used to set dimensions if you use slice
         * as a standalone element. If it's a part of [[FunnelSeries]] this setting
         * becomes read-only as it will be automatically reset by series.
         *
         * @param value  Bottom width
         */
        set: function (value) {
            this.setPercentProperty("bottomWidth", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunnelSlice.prototype, "topWidth", {
        /**
         * @return Top width
         */
        get: function () {
            return this.getPropertyValue("topWidth");
        },
        /**
         * Top width in pixels or percent.
         *
         * IMPORTANT: this setting might be used to set dimensions if you use slice
         * as a standalone element. If it's a part of [[FunnelSeries]] this setting
         * becomes read-only as it will be automatically reset by series.
         *
         * @param value  Top width
         */
        set: function (value) {
            this.setPercentProperty("topWidth", value, true, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunnelSlice.prototype, "orientation", {
        /**
         * @return Orientation
         */
        get: function () {
            return this.getPropertyValue("orientation");
        },
        /**
         * Orientation of the funnel slice: "horizontal" or "vertical".
         *
         * IMPORTANT: this setting might be used to set orintation if you use slice
         * as a standalone element. If it's a part of [[FunnelSeries]] this setting
         * becomes read-only as it will be automatically reset by series.
         *
         * @param value  Orientation
         */
        set: function (value) {
            this.setPropertyValue("orientation", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunnelSlice.prototype, "expandDistance", {
        /**
         * @return expandDistance
         */
        get: function () {
            return this.getPropertyValue("expandDistance");
        },
        /**
         * A relative distance slice's sides should be bent to. It's relative to the
         * height of the slice.
         *
         * Zero (default) will mean the sides will be perfectly straight.
         *
         * Positive value will make them bend outwards, resulting in "puffed" slices.
         *
         * Negative values will make them bend inwards.
         *
         * @default 0
         * @param {number}
         */
        set: function (value) {
            this.setPropertyValue("expandDistance", value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Copies all parameters from another [[Sprite]].
     *
     * @param source Source Sprite
     */
    FunnelSlice.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (this.slice) {
            this.slice.copyFrom(source.slice);
        }
    };
    return FunnelSlice;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["FunnelSlice"] = FunnelSlice_FunnelSlice;
//# sourceMappingURL=FunnelSlice.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/FunnelTick.js
/**
 * Funnel tick module.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Draws an tick line for a funnel slice connecting it to a related label.
 *
 * @see {@link IFunnelTickEvents} for a list of available events
 * @see {@link IFunnelTickAdapters} for a list of available Adapters
 */
var FunnelTick_FunnelTick = /** @class */ (function (_super) {
    __extends(FunnelTick, _super);
    /**
     * Constructor
     */
    function FunnelTick() {
        var _this = _super.call(this) || this;
        /**
         * A label element this tick is attached to.
         */
        _this._label = new Disposer_MutableValueDisposer();
        /**
         * A slice element this tick is attached to.
         */
        _this._slice = new Disposer_MutableValueDisposer();
        _this.className = "FunnelTick";
        _this.element = _this.paper.add("path");
        _this._disposers.push(_this._label);
        _this._disposers.push(_this._slice);
        _this.setPropertyValue("locationX", 0);
        _this.setPropertyValue("locationY", 0);
        _this.applyTheme();
        return _this;
    }
    /**
     * Draws the tick element.
     *
     * @ignore Exclude from docs
     */
    FunnelTick.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var slice = this.slice;
        var point = slice.getPoint(this.locationX, this.locationY);
        if (point) {
            var label = this.label;
            var series = slice.dataItem.component;
            var p0 = void 0;
            var p1 = void 0;
            var p2 = void 0;
            if (series.orientation == "vertical") {
                var x1 = label.pixelX;
                var y1 = label.pixelY;
                if (!series.labelsOpposite) {
                    x1 += label.maxRight;
                }
                p0 = spritePointToSprite(point, slice, this.parent);
                p2 = spritePointToSprite({ x: x1, y: y1 }, label.parent, this.parent);
                p1 = { x: label.parent.pixelX - this.length, y: p2.y };
                if (!series.labelsOpposite) {
                    p1.x = label.parent.measuredWidth + this.length;
                }
            }
            else {
                var x1 = label.pixelX;
                var y1 = label.pixelY;
                if (!series.labelsOpposite) {
                    y1 += label.maxBottom;
                }
                p0 = spritePointToSprite(point, slice, this.parent);
                p2 = spritePointToSprite({ x: x1, y: y1 }, label.parent, this.parent);
                p1 = { x: p2.x, y: label.parent.pixelY - this.length };
                if (!series.labelsOpposite) {
                    p1.y = label.parent.measuredHeight + this.length;
                }
            }
            this.path = moveTo(p0) + lineTo(p1) + lineTo(p2);
        }
    };
    Object.defineProperty(FunnelTick.prototype, "slice", {
        /**
         * @return FunnelSlice
         */
        get: function () {
            return this._slice.get();
        },
        /**
         * [[FunnelSlice]] element tick is attached to.
         *
         * @param slice  Slice
         */
        set: function (slice) {
            this._slice.set(slice, new Disposer_MultiDisposer([
                slice.events.on("transformed", this.invalidate, this, false),
                slice.events.on("validated", this.invalidate, this, false)
            ]));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunnelTick.prototype, "label", {
        /**
         * @return Label
         */
        get: function () {
            return this._label.get();
        },
        /**
         * [[Label]] element tick is attached to.
         *
         * @param label  Label
         */
        set: function (label) {
            this._label.set(label, label.events.on("transformed", this.invalidate, this, false));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunnelTick.prototype, "locationX", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("locationX");
        },
        /**
         * A relative horizontal position within target element a tick is pointing
         * to.
         *
         * A scale is from 0 to 1, where 0 means left edge, and 1 right edge.
         *
         * You can also set any value in-between (e.g. 0.5 will point to the middle
         * of the slice), or outside 0-1 range, which will put tick anchor position
         * outside target element.
         *
         * @param value  Location (0-1)
         */
        set: function (value) {
            this.setPropertyValue("locationX", value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunnelTick.prototype, "locationY", {
        /**
         * @return Location (0-1)
         */
        get: function () {
            return this.getPropertyValue("locationY");
        },
        /**
         * A relative vertical position within target element a tick is pointing
         * to.
         *
         * A scale is from 0 to 1, where 0 means top edge, and 1 bottom edge.
         *
         * You can also set any value in-between (e.g. 0.5 will point to the middle
         * of the slice), or outside 0-1 range, which will put tick anchor position
         * outside target element.
         *
         * @param value  Location (0-1)
         */
        set: function (value) {
            this.setPropertyValue("locationY", value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    return FunnelTick;
}(Tick_Tick));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["FunnelTick"] = FunnelTick_FunnelTick;
//# sourceMappingURL=FunnelTick.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/FunnelSeries.js
/**
 * Defines Funnel Chart Series.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */












/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
//@todo: sequenced?
/**
 * Defines a [[DataItem]] for [[FunnelSeries]].
 *
 * @see {@link DataItem}
 */
var FunnelSeries_FunnelSeriesDataItem = /** @class */ (function (_super) {
    __extends(FunnelSeriesDataItem, _super);
    /**
     * Constructor
     */
    function FunnelSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "FunnelSeriesDataItem";
        // this helps to invalidate series when value is 0 an it is hidden (no other events are triggered then)
        _this.events.on("visibilitychanged", function () {
            if (_this.component) {
                _this.component.invalidateDataItems();
            }
        }, _this, false);
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(FunnelSeriesDataItem.prototype, "sliceLink", {
        /**
         * A [[FunnelSlice]] element, related to this data item ([[FunnelSlice]]).
         *
         * @readonly
         * @return Slice element
         */
        get: function () {
            var _this = this;
            if (!this._sliceLink) {
                var sliceLink_1 = this.component.sliceLinks.create();
                this._sliceLink = sliceLink_1;
                this._disposers.push(sliceLink_1);
                sliceLink_1.parent = this.component.slicesContainer;
                this._disposers.push(new Disposer(function () {
                    if (_this.component) {
                        _this.component.sliceLinks.removeValue(sliceLink_1);
                    }
                }));
                this.addSprite(sliceLink_1);
                sliceLink_1.visible = this.visible;
            }
            return this._sliceLink;
        },
        enumerable: true,
        configurable: true
    });
    return FunnelSeriesDataItem;
}(PercentSeries_PercentSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a FunnelSlice series on a [[SlicedChart]].
 *
 * @see {@link IFunnelSeriesEvents} for a list of available Events
 * @see {@link IFunnelSeriesAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/sliced-chart/} for documentation
 * @important
 */
var FunnelSeries_FunnelSeries = /** @class */ (function (_super) {
    __extends(FunnelSeries, _super);
    /**
     * Constructor
     */
    function FunnelSeries() {
        var _this = _super.call(this) || this;
        _this._nextY = 0;
        _this.className = "FunnelSeries";
        _this.orientation = "vertical";
        _this.width = Percent_percent(100);
        _this.height = Percent_percent(100);
        _this.slicesContainer.width = Percent_percent(100);
        _this.slicesContainer.height = Percent_percent(100);
        _this._disposers.push(_this.slicesContainer.events.on("maxsizechanged", _this.invalidateDataItems, _this, false));
        _this.labelsOpposite = true;
        _this.labelsContainer.layout = "absolute";
        _this.bottomRatio = 0;
        _this.applyTheme();
        return _this;
    }
    /**
     * Creates a [[FunnelSlice]] element.
     *
     * @return Slice
     */
    FunnelSeries.prototype.createSlice = function () {
        return new FunnelSlice_FunnelSlice();
    };
    /**
     * Creates a [[FunnelTick]] element.
     *
     * @return Tick
     */
    FunnelSeries.prototype.createTick = function () {
        return new FunnelTick_FunnelTick();
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    FunnelSeries.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Funnel Series");
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    FunnelSeries.prototype.createDataItem = function () {
        return new FunnelSeries_FunnelSeriesDataItem();
    };
    /**
     * Inits FunnelSlice.
     *
     * @param slice to init
     */
    FunnelSeries.prototype.initSlice = function (slice) {
        slice.isMeasured = false;
        slice.defaultState.properties.scale = 1;
        slice.observe("scale", this.handleSliceScale, this);
        slice.observe(["dx", "dy", "x", "y"], this.handleSliceMove, this);
        slice.tooltipText = "{category}: {value.percent.formatNumber('#.#')}% ({value.value})";
        var hoverState = slice.states.create("hover");
        hoverState.properties.expandDistance = 0.2;
    };
    /**
     * [initLabel description]
     *
     * @todo Description
     * @param label [description]
     */
    FunnelSeries.prototype.initLabel = function (label) {
        _super.prototype.initLabel.call(this, label);
        label.verticalCenter = "middle";
        label.horizontalCenter = "middle";
        label.isMeasured = true;
        label.padding(5, 5, 5, 5);
    };
    /**
     * (Re)validates the whole series, effectively causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    FunnelSeries.prototype.validate = function () {
        _super.prototype.validate.call(this);
        this._nextY = 0;
    };
    /**
     * [validateDataElements description]
     *
     * @todo Description
     * @ignore Exclude from docs
     */
    FunnelSeries.prototype.validateDataElements = function () {
        var _this = this;
        var slicesContainer = this.slicesContainer;
        var labelsContainer = this.labelsContainer;
        var labelTemplate = this.labels.template;
        if (this.alignLabels) {
            labelTemplate.interactionsEnabled = true;
            slicesContainer.isMeasured = true;
            labelsContainer.isMeasured = true;
        }
        else {
            labelTemplate.interactionsEnabled = false;
            slicesContainer.isMeasured = false;
            labelsContainer.isMeasured = false;
        }
        var total = 0;
        var count = 0;
        this.dataItems.each(function (dItem) {
            if (hasValue(dItem.value)) {
                count++;
                if (dItem.value > 0) {
                    total += Math.abs(dItem.getWorkingValue("value") / dItem.value);
                }
                else {
                    if (_this.ignoreZeroValues) {
                        count--;
                    }
                    else {
                        if (!dItem.visible || dItem.__disabled || dItem.isHiding) {
                            count--;
                        }
                        else {
                            total += 1;
                        }
                    }
                }
            }
        });
        this._total = 1 / count * total;
        this._count = count;
        _super.prototype.validateDataElements.call(this);
        this.arrangeLabels();
    };
    /**
     * [getNextValue description]
     *
     * @todo Description
     * @param dataItem  [description]
     * @return [description]
     */
    FunnelSeries.prototype.getNextValue = function (dataItem) {
        var index = dataItem.index;
        var nextValue = dataItem.getWorkingValue("value");
        if (index < this.dataItems.length - 1) {
            var nextItem = this.dataItems.getIndex(index + 1);
            nextValue = nextItem.getWorkingValue("value");
            if (!nextItem.visible || nextItem.isHiding || nextItem.__disabled || (nextItem.value == 0 && this.ignoreZeroValues)) {
                return this.getNextValue(nextItem);
            }
        }
        return nextValue;
    };
    /**
     * [formDataElement description]
     *
     * @todo Description
     */
    FunnelSeries.prototype.formDataElement = function () {
    };
    /**
     * Validates data item's element, effectively redrawing it.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    FunnelSeries.prototype.validateDataElement = function (dataItem) {
        var _this = this;
        //if ($type.hasValue(dataItem.value)) {
        // FunnelSlice
        var slice = dataItem.slice;
        slice.orientation = this.orientation;
        var sliceLink = dataItem.sliceLink;
        sliceLink.orientation = this.orientation;
        var tick = dataItem.tick;
        var label = dataItem.label;
        tick.slice = slice;
        tick.label = label;
        if (hasValue(dataItem.value)) {
            this.decorateSlice(dataItem);
            each(dataItem.sprites, function (sprite) {
                if (dataItem.value == 0 && _this.ignoreZeroValues) {
                    sprite.__disabled = true;
                }
                else {
                    sprite.__disabled = false;
                }
            });
        }
        else {
            each(dataItem.sprites, function (sprite) {
                sprite.__disabled = true;
            });
        }
        if (dataItem.index == this.dataItems.length - 1) {
            sliceLink.disabled = true;
        }
        // do this at the end, otherwise bullets won't be positioned properly
        _super.prototype.validateDataElement.call(this, dataItem);
        sliceLink.fill = slice.fill;
        //}
    };
    /**
     * [decorateSlice description]
     *
     * @todo Description
     * @param dataItem [description]
     */
    FunnelSeries.prototype.decorateSlice = function (dataItem) {
        var slice = dataItem.slice;
        var sliceLink = dataItem.sliceLink;
        var label = dataItem.label;
        var tick = dataItem.tick;
        var maxWidth = this.slicesContainer.innerWidth;
        var maxHeight = this.slicesContainer.innerHeight;
        var nextValue = this.getNextValue(dataItem);
        var workingValue = Math.abs(dataItem.getWorkingValue("value"));
        var bottomRatio = this.bottomRatio;
        var d = 1;
        if (dataItem.value != 0) {
            d = workingValue / Math.abs(dataItem.value);
        }
        else {
            if (dataItem.__disabled || dataItem.isHiding || !dataItem.visible) {
                d = 0.000001;
            }
        }
        if (this.ignoreZeroValues && dataItem.value == 0) {
            dataItem.__disabled = true;
            return;
        }
        else {
            dataItem.__disabled = false;
        }
        if (this._nextY == Infinity) {
            this._nextY = 0;
        }
        if (this.orientation == "vertical") {
            var linkHeight = sliceLink.pixelHeight * d;
            maxHeight = maxHeight + linkHeight; // to avoid one link gap in the bottom
            slice.topWidth = workingValue / this.dataItem.values.value.high * maxWidth;
            slice.bottomWidth = (workingValue - (workingValue - nextValue) * bottomRatio) / this.dataItem.values.value.high * maxWidth;
            sliceLink.topWidth = slice.bottomWidth;
            sliceLink.bottomWidth = (workingValue - (workingValue - nextValue)) / this.dataItem.values.value.high * maxWidth;
            slice.y = this._nextY;
            slice.height = Math.min(100000, Math_max(0, maxHeight / this._count * d / this._total - linkHeight));
            slice.x = maxWidth / 2;
            if (!this.alignLabels) {
                label.x = slice.x;
            }
            else {
                label.x = undefined;
            }
            label.y = slice.pixelY + slice.pixelHeight * tick.locationY;
            this._nextY += slice.pixelHeight + linkHeight;
            sliceLink.y = this._nextY - linkHeight;
            sliceLink.x = slice.x;
        }
        else {
            var linkWidth = sliceLink.pixelWidth * d;
            maxWidth = maxWidth + linkWidth; // to avoid one link gap in the bottom
            slice.topWidth = workingValue / this.dataItem.values.value.high * maxHeight;
            slice.bottomWidth = (workingValue - (workingValue - nextValue) * bottomRatio) / this.dataItem.values.value.high * maxHeight;
            sliceLink.topWidth = slice.bottomWidth;
            sliceLink.bottomWidth = (workingValue - (workingValue - nextValue)) / this.dataItem.values.value.high * maxHeight;
            slice.x = this._nextY;
            slice.width = Math.min(100000, maxWidth / this._count * d * 1 / this._total - linkWidth);
            slice.y = maxHeight / 2;
            if (!this.alignLabels) {
                label.y = slice.y;
            }
            else {
                label.y = this.labelsContainer.measuredHeight;
            }
            label.x = slice.pixelX + slice.pixelWidth * tick.locationX;
            this._nextY += slice.pixelWidth + linkWidth;
            sliceLink.x = this._nextY - linkWidth;
            sliceLink.y = slice.y;
        }
    };
    FunnelSeries.prototype.getLastLabel = function (index) {
        if (index > 0) {
            var lastLabel = this.labels.getIndex(index);
            if (lastLabel.__disabled || !lastLabel.visible) {
                return this.getLastLabel(index - 1);
            }
            else {
                return lastLabel;
            }
        }
    };
    /**
     * [arrangeLabels description]
     *
     * @todo Description
     */
    FunnelSeries.prototype.arrangeLabels = function () {
        if (this.alignLabels) {
            var count = this.labels.length;
            if (count > 1) {
                var lastLabel = this.getLastLabel(count - 1);
                if (lastLabel) {
                    var lastY = lastLabel.pixelY;
                    var lastX = lastLabel.pixelX;
                    if (count > 1) {
                        for (var i = count - 2; i >= 0; i--) {
                            var label = this.labels.getIndex(i);
                            if (label.visible && !label.__disabled) {
                                if (label.invalid) {
                                    label.validate();
                                }
                                if (this.orientation == "vertical") {
                                    if (label.pixelY + label.measuredHeight > lastY) {
                                        label.y = Math.min(1000000, lastY - label.measuredHeight);
                                    }
                                }
                                // horizontal
                                else {
                                    if (label.pixelX + label.measuredWidth > lastX) {
                                        label.x = Math.min(1000000, lastX - label.measuredWidth);
                                    }
                                }
                                lastY = label.pixelY;
                                lastX = label.pixelX;
                            }
                        }
                        lastY = 0;
                        lastX = 0;
                        for (var i = 0; i < count; i++) {
                            var label = this.labels.getIndex(i);
                            if (label.visible && !label.__disabled) {
                                if (label.invalid) {
                                    label.validate();
                                }
                                if (this.orientation == "vertical") {
                                    if (label.pixelY < lastY) {
                                        label.y = Math.min(1000000, lastY);
                                    }
                                }
                                // horizontal
                                else {
                                    if (label.pixelX < lastX) {
                                        label.x = Math.min(1000000, lastX);
                                    }
                                }
                                lastY += label.measuredHeight;
                                lastX += label.measuredWidth;
                            }
                        }
                    }
                }
            }
        }
    };
    /**
     * Positions series bullet.
     *
     * @ignore Exclude from docs
     * @param bullet  Bullet
     */
    FunnelSeries.prototype.positionBullet = function (bullet) {
        _super.prototype.positionBullet.call(this, bullet);
        var dataItem = bullet.dataItem;
        var slice = dataItem.slice;
        var locationX = bullet.locationX;
        if (!isNumber(locationX)) {
            locationX = 0.5;
        }
        var locationY = bullet.locationY;
        if (!isNumber(locationY)) {
            locationY = 1;
        }
        bullet.x = slice.pixelX + slice.measuredWidth * locationX;
        bullet.y = slice.pixelY + slice.measuredHeight * locationY;
    };
    Object.defineProperty(FunnelSeries.prototype, "orientation", {
        /**
         * @return Orientation
         */
        get: function () {
            return this.getPropertyValue("orientation");
        },
        /**
         * Orientation of the funnel slices: "horizontal" or "vertical" (default).
         *
         * @default "vertical"
         * @param value Orientation
         */
        set: function (value) {
            if (this.setPropertyValue("orientation", value)) {
                this.labelsOpposite = this.labelsOpposite;
                this.invalidate();
                if (value == "vertical") {
                    this.ticks.template.locationX = 1;
                    this.ticks.template.locationY = 0.5;
                    this.labels.template.rotation = 0;
                    this.layout = "horizontal";
                }
                else {
                    this.ticks.template.locationX = 0.5;
                    this.ticks.template.locationY = 1;
                    this.labels.template.rotation = -90;
                    this.layout = "vertical";
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunnelSeries.prototype, "bottomRatio", {
        /**
         * @return {number}
         */
        get: function () {
            return this.getPropertyValue("bottomRatio");
        },
        /**
         * Indicates how slice's bottom will change in relation to slices top AND
         * next slices top.
         *
         * Basically it's a relative value (0-1) that indicates bottom width
         * position between current slice's top width and the top withd of the next
         * one.
         *
         * The scale goes from 0 (closer to current slice width) to 1 (closer to next
         * slice with).
         *
         * `0` (default) will mean that bottom will be the same as top, resulting in
         * a prefectly square slice.
         *
         * From the data-viz standpoint `0` is a correct setting, since area of the
         * slices will depict their value correctly.
         *
         * `1` will mean that slice will become trapezoid with its bottom matching
         * width of the next slice.
         *
         * `0.5` will make bottom width be in the middle of width of current slice
         * and the next slice.
         *
         * @default 0
         * @param {number}
         */
        set: function (value) {
            if (this.setPropertyValue("bottomRatio", value)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FunnelSeries.prototype, "sliceLinks", {
        /**
         * A list of elements linking each actual slice.
         *
         * Please note that links are [[FunnelSlice]] objects, just like real links,
         * so they have all the same configuration options.
         *
         * You can use `template` of this link, to specify how links will look.
         *
         * ```TypeScript
         * series.sliceLinks.template.fillOpacity = 0.5;
         * ```
         * ```JavaScript
         * series.sliceLinks.template.fillOpacity = 0.5;
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": [{
         *     "type": "FunnelSeries",
         *      // ...
         *      "sliceLinks": {
         *        "fillOpacity": 0.5
         *      }
         *   }]
         * }
         * ```
         *
         * @return Funnel links
         */
        get: function () {
            if (!this._sliceLinks) {
                var sliceLink = new FunnelSlice_FunnelSlice();
                sliceLink.applyOnClones = true;
                sliceLink.fillOpacity = 0.5;
                sliceLink.expandDistance = -0.3;
                sliceLink.hiddenState.properties.opacity = 0;
                this._disposers.push(sliceLink);
                this._sliceLinks = new List_ListTemplate(sliceLink);
                this._disposers.push(new List_ListDisposer(this._sliceLinks));
            }
            return this._sliceLinks;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows hidden series.
     *
     * @param duration  Duration of reveal animation (ms)
     * @return Animation
     */
    FunnelSeries.prototype.show = function (duration) {
        var _this = this;
        var startIndex = this.startIndex;
        var endIndex = this.endIndex;
        var interpolationDuration = this.defaultState.transitionDuration;
        if (isNumber(duration)) {
            interpolationDuration = duration;
        }
        if (!Options_options.animationsEnabled) {
            interpolationDuration = 0;
        }
        var delay = 0;
        Iterator_each(indexed(this.dataItems.iterator()), function (a) {
            var i = a[0];
            var dataItem = a[1];
            if (_this.sequencedInterpolation) {
                delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);
            }
            dataItem.show(interpolationDuration, delay, ["value"]);
        });
        var animation = _super.prototype.show.call(this, duration);
        return animation;
    };
    /**
     * Hides series.
     *
     * @param duration  Duration of hiding animation (ms)
     * @return Animation
     */
    FunnelSeries.prototype.hide = function (duration) {
        var _this = this;
        var fields = ["value"];
        var value = 0;
        var startIndex = this.startIndex;
        var endIndex = this.endIndex;
        var delay = 0;
        var interpolationDuration = this.hiddenState.transitionDuration;
        if (isNumber(duration)) {
            interpolationDuration = duration;
        }
        if (!Options_options.animationsEnabled) {
            interpolationDuration = 0;
        }
        Iterator_each(indexed(this.dataItems.iterator()), function (a) {
            var i = a[0];
            var dataItem = a[1];
            if (_this.sequencedInterpolation) {
                delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);
            }
            dataItem.hide(interpolationDuration, delay, value, fields);
        });
        var animation = _super.prototype.hide.call(this, duration);
        if (animation && !animation.isFinished()) {
            animation.delay(delay);
        }
        return animation;
    };
    /**
     * @ignore
     */
    FunnelSeries.prototype.setAlignLabels = function (value) {
        _super.prototype.setAlignLabels.call(this, value);
        this.ticks.template.disabled = !value;
        var labelsContainer = this.labelsContainer;
        if (labelsContainer) {
            // do not align
            if (!value) {
                labelsContainer.width = Percent_percent(100);
                labelsContainer.height = Percent_percent(100);
            }
            //align
            else {
                labelsContainer.height = undefined;
                labelsContainer.width = undefined;
                labelsContainer.margin(10, 10, 10, 10);
            }
        }
        this.labelsOpposite = this.labelsOpposite;
    };
    Object.defineProperty(FunnelSeries.prototype, "labelsOpposite", {
        /**
         * @return Labels on opposite side?
         */
        get: function () {
            return this.getPropertyValue("labelsOpposite");
        },
        /**
         * Put labels on the oppsite side of the series?
         *
         * This setting is only used if `alignLabels = true`.
         *
         * If set to `true` (default) labels will be drawn to the right (on vertical
         * series), or to the bottom (on horizontal series).
         *
         * If set to `false`, labels will be positioned to the left or top
         * respectively.
         *
         * @default true
         * @since 4.1.13
         * @param  value  Labels on opposite side?
         */
        set: function (value) {
            this.setPropertyValue("labelsOpposite", value);
            var labelTemplate = this.labels.template;
            var labelAlign = "none";
            var labelValign = "none";
            if (!this.alignLabels) {
                if (this.orientation == "vertical") {
                    labelAlign = "center";
                }
                else {
                    labelValign = "middle";
                }
            }
            else {
                // opposite (left/bottom)
                if (value) {
                    this.labelsContainer.toFront();
                    // left
                    if (this.orientation == "vertical") {
                        this.ticks.template.locationX = 1;
                        labelTemplate.horizontalCenter = "left";
                        labelAlign = "right";
                    }
                    // bottom
                    else {
                        this.ticks.template.locationY = 1;
                        labelTemplate.horizontalCenter = "right";
                        labelValign = "bottom";
                    }
                }
                // non oposite (right/top)
                else {
                    this.labelsContainer.toBack();
                    // right
                    if (this.orientation == "vertical") {
                        this.ticks.template.locationX = 0;
                        labelAlign = "left";
                    }
                    // top
                    else {
                        labelValign = "top";
                        this.ticks.template.locationY = 0;
                    }
                }
            }
            labelTemplate.align = labelAlign;
            labelTemplate.valign = labelValign;
            this.validateLayout();
            this.ticks.each(function (tick) {
                tick.invalidate();
            });
            this.invalidateDataItems();
        },
        enumerable: true,
        configurable: true
    });
    return FunnelSeries;
}(PercentSeries_PercentSeries));

/**
 * bboxter class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["FunnelSeries"] = FunnelSeries_FunnelSeries;
registry.registeredClasses["FunnelSeriesDataItem"] = FunnelSeries_FunnelSeriesDataItem;
//# sourceMappingURL=FunnelSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/PyramidSeries.js
/**
 * Defines Pyramid Series.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */





/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
//@todo: sequenced?
/**
 * Defines a [[DataItem]] for [[PyramidSeries]].
 *
 * @see {@link DataItem}
 */
var PyramidSeries_PyramidSeriesDataItem = /** @class */ (function (_super) {
    __extends(PyramidSeriesDataItem, _super);
    /**
     * Constructor
     */
    function PyramidSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "PyramidSeriesDataItem";
        _this.applyTheme();
        return _this;
    }
    return PyramidSeriesDataItem;
}(FunnelSeries_FunnelSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a FunnelSlice series on a [[SlicedChart]].
 *
 * @see {@link IPyramidSeriesEvents} for a list of available Events
 * @see {@link IPyramidSeriesAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/sliced-chart/} for documentation
 * @important
 */
var PyramidSeries_PyramidSeries = /** @class */ (function (_super) {
    __extends(PyramidSeries, _super);
    /**
     * Constructor
     */
    function PyramidSeries() {
        var _this = _super.call(this) || this;
        _this.className = "PyramidSeries";
        _this.topWidth = Percent_percent(0);
        _this.bottomWidth = Percent_percent(100);
        _this.pyramidHeight = Percent_percent(100);
        _this.valueIs = "area";
        _this.sliceLinks.template.width = 0;
        _this.sliceLinks.template.height = 0;
        _this.applyTheme();
        return _this;
    }
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    PyramidSeries.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Pyramid Series");
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    PyramidSeries.prototype.createDataItem = function () {
        return new PyramidSeries_PyramidSeriesDataItem();
    };
    /**
     * (Re)validates the whole series, effectively causing it to redraw.
     *
     * @ignore Exclude from docs
     */
    PyramidSeries.prototype.validate = function () {
        _super.prototype.validate.call(this);
        this._nextWidth = undefined;
    };
    /**
     * [getNextValue description]
     *
     * @todo Description
     * @param dataItem [description]
     * @return [description]
     */
    PyramidSeries.prototype.getNextValue = function (dataItem) {
        var index = dataItem.index;
        var nextValue = dataItem.getWorkingValue("value");
        if (index < this.dataItems.length - 1) {
            var nextItem = this.dataItems.getIndex(index + 1);
            nextValue = nextItem.getWorkingValue("value");
        }
        if (nextValue == 0) {
            nextValue = 0.000001;
        }
        return nextValue;
    };
    /**
     * [validateDataElements description]
     *
     * @todo Description
     * @ignore Exclude from docs
     */
    PyramidSeries.prototype.validateDataElements = function () {
        var _this = this;
        var maxWidth = this.slicesContainer.innerWidth;
        var maxHeight = this.slicesContainer.innerHeight;
        this.dataItems.each(function (dataItem) {
            if (dataItem.value > 0) {
                var relValue = dataItem.getWorkingValue("value") / dataItem.value;
                var sliceLink = dataItem.sliceLink;
                if (_this.orientation == "vertical") {
                    maxHeight -= (sliceLink.pixelHeight * relValue);
                }
                else {
                    maxWidth -= (sliceLink.pixelWidth * relValue);
                }
            }
        });
        this._pyramidHeight = relativeToValue(this.pyramidHeight, maxHeight);
        this._pyramidWidth = relativeToValue(this.pyramidHeight, maxWidth);
        if (this.orientation == "vertical") {
            var y = (maxHeight - this._pyramidHeight) / 2;
            this.slicesContainer.y = y;
            this.labelsContainer.y = y;
            this.ticksContainer.y = y;
        }
        else {
            var x = (maxWidth - this._pyramidWidth) / 2;
            this.slicesContainer.x = x;
            this.labelsContainer.x = x;
            this.ticksContainer.x = x;
        }
        _super.prototype.validateDataElements.call(this);
    };
    /**
     * [decorateSlice description]
     *
     * @todo Description
     * @param dataItem [description]
     */
    PyramidSeries.prototype.decorateSlice = function (dataItem) {
        var sum = this.dataItem.values.value.absoluteSum;
        if (sum == 0) {
            return;
        }
        var slice = dataItem.slice;
        var sliceLink = dataItem.sliceLink;
        var label = dataItem.label;
        var tick = dataItem.tick;
        // TODO can this be removed ?
        this.getNextValue(dataItem);
        var workingValue = Math.abs(dataItem.getWorkingValue("value"));
        var pyramidWidth = this._pyramidWidth;
        var pyramidHeight = this._pyramidHeight;
        var maxWidth = this.slicesContainer.innerWidth;
        var maxHeight = this.slicesContainer.innerHeight;
        var linkWidth = sliceLink.pixelWidth;
        var linkHeight = sliceLink.pixelHeight;
        if (dataItem.value == 0 && this.ignoreZeroValues) {
            dataItem.__disabled = true;
        }
        else {
            dataItem.__disabled = false;
        }
        if (this.orientation == "vertical") {
            var topWidth = relativeToValue(this.topWidth, maxWidth);
            if (!isNumber(this._nextWidth)) {
                this._nextWidth = topWidth;
            }
            var bottomWidth = relativeToValue(this.bottomWidth, maxWidth);
            var sliceTopWidth = this._nextWidth;
            var angle = Math.atan2(pyramidHeight, topWidth - bottomWidth);
            var c = Math.tan(Math.PI / 2 - angle);
            if (c == 0) {
                c = 0.00000001;
            }
            var sliceHeight = void 0;
            var sliceBottomWidth = void 0;
            if (this.valueIs == "area") {
                var totalSquare = (topWidth + bottomWidth) / 2 * pyramidHeight;
                var square = totalSquare * workingValue / sum;
                var s = Math.abs(sliceTopWidth * sliceTopWidth - 2 * square * c);
                sliceHeight = (sliceTopWidth - Math.sqrt(s)) / c;
                if (sliceHeight > 0) {
                    sliceBottomWidth = (2 * square - sliceHeight * sliceTopWidth) / sliceHeight;
                }
                else {
                    sliceBottomWidth = sliceTopWidth;
                }
            }
            else {
                sliceHeight = pyramidHeight * workingValue / sum;
                sliceBottomWidth = sliceTopWidth - sliceHeight * c;
            }
            slice.height = sliceHeight;
            slice.width = maxWidth;
            slice.bottomWidth = sliceBottomWidth;
            slice.topWidth = sliceTopWidth;
            sliceLink.topWidth = slice.bottomWidth;
            sliceLink.bottomWidth = slice.bottomWidth;
            slice.y = this._nextY;
            //slice.x = maxWidth / 2;
            if (!this.alignLabels) {
                label.x = maxWidth / 2;
            }
            else {
                label.x = 0;
            }
            label.y = slice.pixelY + slice.pixelHeight * tick.locationY + slice.dy;
            this._nextY += slice.pixelHeight + linkHeight * workingValue / Math.max(Math.abs(dataItem.value), 0.00000001);
            sliceLink.y = this._nextY - linkHeight;
            sliceLink.x = maxWidth / 2;
        }
        else {
            var topWidth = relativeToValue(this.topWidth, maxHeight);
            if (!isNumber(this._nextWidth)) {
                this._nextWidth = topWidth;
            }
            var bottomWidth = relativeToValue(this.bottomWidth, maxHeight);
            var sliceTopWidth = this._nextWidth;
            var angle = Math.atan2(pyramidWidth, topWidth - bottomWidth);
            var c = Math.tan(Math.PI / 2 - angle);
            if (c == 0) {
                c = 0.00000001;
            }
            var sliceWidth = void 0;
            var sliceBottomWidth = void 0;
            if (this.valueIs == "area") {
                var totalSquare = (topWidth + bottomWidth) / 2 * pyramidWidth;
                var square = totalSquare * workingValue / sum;
                sliceWidth = (sliceTopWidth - Math.sqrt(sliceTopWidth * sliceTopWidth - 2 * square * c)) / c;
                sliceBottomWidth = (2 * square - sliceWidth * sliceTopWidth) / sliceWidth;
            }
            else {
                sliceWidth = pyramidWidth * workingValue / sum;
                sliceBottomWidth = sliceTopWidth - sliceWidth * c;
            }
            slice.width = sliceWidth;
            slice.height = maxHeight;
            slice.bottomWidth = sliceBottomWidth;
            slice.topWidth = sliceTopWidth;
            sliceLink.topWidth = slice.bottomWidth;
            sliceLink.bottomWidth = slice.bottomWidth;
            slice.x = this._nextY;
            if (!this.alignLabels) {
                label.y = maxHeight / 2;
            }
            else {
                label.y = this.labelsContainer.measuredHeight;
            }
            label.x = slice.pixelX + slice.pixelWidth * tick.locationX + slice.dx;
            this._nextY += slice.pixelWidth + linkWidth * workingValue / Math.max(Math.abs(dataItem.value), 0.00000001);
            sliceLink.x = this._nextY - linkWidth;
            sliceLink.y = maxHeight / 2;
        }
        this._nextWidth = slice.bottomWidth;
    };
    Object.defineProperty(PyramidSeries.prototype, "topWidth", {
        /**
         * @return {number | Percent}
         */
        get: function () {
            return this.getPropertyValue("topWidth");
        },
        /**
         * Width of the pyramid's tip in pixels or relative (`Percent`).
         *
         * `0%` (default) means the pyramid will be perfectly pointy.
         * `50%` will have a cut off / blunt top that is half the width of the chart.
         * `100%` will take the whole width of the chart.
         *
         * If you need the downward-pointing pyramid, you might want to `topWidth` to
         * `100%` and `bottomWidth` to `0%`.
         *
         * @default 0%
         * @param {number | Percent}
         */
        set: function (value) {
            if (this.setPercentProperty("topWidth", value, false, false, 10, false)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PyramidSeries.prototype, "pyramidHeight", {
        /**
         * @return {number | Percent}
         */
        get: function () {
            return this.getPropertyValue("pyramidHeight");
        },
        /**
         * Height of pyramid
         *
         *
         * @default 100%
         * @param {number | Percent}
         */
        set: function (value) {
            if (this.setPercentProperty("pyramidHeight", value, false, false, 10, false)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PyramidSeries.prototype, "bottomWidth", {
        /**
         * @return {number | Percent}
         */
        get: function () {
            return this.getPropertyValue("bottomWidth");
        },
        /**
         * Width of the pyramid's bottom (bsae) in pixels or relative (`Percent`).
         *
         * `0%` means the pyramid's botto will be pointy.
         * `50%` will have a cut off / blunt bottom that is half the width of the chart.
         * `100%` (default) will take the whole width of the chart.
         *
         * If you need the downward-pointing pyramid, you might want to `topWidth` to
         * `100%` and `bottomWidth` to `0%`.
         *
         * @param {number | Percent}
         */
        set: function (value) {
            if (this.setPercentProperty("bottomWidth", value, false, false, 10, false)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PyramidSeries.prototype, "valueIs", {
        /**
         * @return {"area" | "height"}
         */
        get: function () {
            return this.getPropertyValue("valueIs");
        },
        /**
         * Indicates how slice's value will influence its size.
         *
         * `"area"` (default) means that the whole area of the pyramid (counting in
         * modifications by `topWidth` and `bottomWidth`) will be divvied up between
         * slices based on their value.
         *
         * With this setting at `"area"` the area of the trapezoids of each slice
         * will represent their value relatively to values of the other slices.
         *
         * This is a correct way to depict "weight" of each slice based on their
         * values.
         *
         * `"height"` means whole height (as opposed to area) of the pyramid will be
         * divvied up between slices. Actual slice width or area is not counted in.
         *
         * From the data-viz standpoint this does not make a lot of sense, since
         * slices with lesser values might appear more prominent if they are placed
         * towards thick end of the pyramid since their areas will be bigger.
         *
         * @default "area"
         * @param {"area" | "height"}
         */
        set: function (value) {
            if (this.setPropertyValue("valueIs", value)) {
                this.invalidate();
            }
        },
        enumerable: true,
        configurable: true
    });
    return PyramidSeries;
}(FunnelSeries_FunnelSeries));

/**
 * bboxter class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["PyramidSeries"] = PyramidSeries_PyramidSeries;
registry.registeredClasses["PyramidSeriesDataItem"] = PyramidSeries_PyramidSeriesDataItem;
//# sourceMappingURL=PyramidSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/PictorialStackedSeries.js
/**
 * Defines Pictorial Stacked Series.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */






/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
//@todo: sequenced?
/**
 * Defines a [[DataItem]] for [[PictorialStackedSeries]].
 *
 * @see {@link DataItem}
 */
var PictorialStackedSeries_PictorialStackedSeriesDataItem = /** @class */ (function (_super) {
    __extends(PictorialStackedSeriesDataItem, _super);
    /**
     * Constructor
     */
    function PictorialStackedSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "PictorialStackedSeriesDataItem";
        _this.applyTheme();
        return _this;
    }
    return PictorialStackedSeriesDataItem;
}(PyramidSeries_PyramidSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a PictorialStacked series on a [[SlicedChart]].
 *
 * @see {@link IPictorialStackedSeriesEvents} for a list of available Events
 * @see {@link IPictorialStackedSeriesAdapters} for a list of available Adapters
 * @see {@link https://www.amcharts.com/docs/v4/chart-types/sliced-chart/} for documentation
 * @important
 */
var PictorialStackedSeries_PictorialStackedSeries = /** @class */ (function (_super) {
    __extends(PictorialStackedSeries, _super);
    /**
     * Constructor
     */
    function PictorialStackedSeries() {
        var _this = _super.call(this) || this;
        _this.className = "PictorialStackedSeries";
        _this.topWidth = Percent_percent(100);
        _this.bottomWidth = Percent_percent(100);
        _this.valueIs = "height";
        _this.applyTheme();
        _this.startLocation = 0;
        _this.endLocation = 1;
        _this.align = "center";
        _this.valign = "middle";
        _this._maskSprite = _this.slicesContainer.createChild(Sprite_Sprite);
        _this._maskSprite.visible = false;
        _this._maskSprite.zIndex = 100;
        _this._maskSprite.shouldClone = false;
        return _this;
    }
    /**
     * Sizes the mask to fit the series.
     *
     * @ignore
     */
    PictorialStackedSeries.prototype.validateDataElements = function () {
        var maxWidth = this.slicesContainer.maxWidth;
        var maxHeight = this.slicesContainer.maxHeight;
        var maskSprite = this._maskSprite;
        //maskSprite.validatePosition(); // for some reason size of the maskSprite is 0x0 after we removed validatePosition in afterdraw
        var pictureWidth = maskSprite.measuredWidth / maskSprite.scale;
        var pictureHeight = maskSprite.measuredHeight / maskSprite.scale;
        var scale = Math_min(maxHeight / pictureHeight, maxWidth / pictureWidth);
        if (scale == Infinity) {
            scale = 1; // can't return here, won't draw legend properly
        }
        scale = Math_max(0.001, scale);
        var startLocation = this.startLocation;
        var endLocation = this.endLocation;
        var newWidth = Math_min(maxWidth, pictureWidth * scale);
        var newHeight = Math_min(maxHeight, pictureHeight * scale);
        maskSprite.scale = scale;
        if (this.orientation == "vertical") {
            this.topWidth = newWidth + 4;
            this.bottomWidth = newWidth + 4;
            this.pyramidHeight = newHeight * (endLocation - startLocation);
            maskSprite.x = maxWidth / 2;
            maskSprite.y = newHeight / 2;
        }
        else {
            this.topWidth = newHeight + 4;
            this.bottomWidth = newHeight + 4;
            this.pyramidHeight = newWidth * (endLocation - startLocation);
            maskSprite.valign = "middle";
            maskSprite.x = newWidth / 2;
            maskSprite.y = maxHeight / 2;
        }
        maskSprite.verticalCenter = "middle";
        maskSprite.horizontalCenter = "middle";
        _super.prototype.validateDataElements.call(this);
        var y;
        var x;
        if (this.orientation == "vertical") {
            if (this.valign == "bottom") {
                y = (maxHeight - newHeight);
            }
            if (this.valign == "middle") {
                y = (maxHeight - newHeight) / 2;
            }
            if (this.valign == "top") {
                y = 0;
            }
            if (this.align == "left") {
                x = -(maxWidth - newWidth) / 2;
            }
            if (this.align == "center") {
                x = 0;
            }
            if (this.align == "right") {
                x = (maxWidth - newWidth) / 2;
            }
            this.slices.template.dy = startLocation * newHeight;
            if (this.alignLabels) {
                this.slicesContainer.dx = x;
            }
        }
        else {
            if (this.valign == "bottom") {
                y = (maxHeight - newHeight) / 2;
            }
            if (this.valign == "middle") {
                y = 0;
            }
            if (this.valign == "top") {
                y = -(maxHeight - newHeight) / 2;
            }
            if (this.align == "left") {
                x = 0;
            }
            if (this.align == "center") {
                x = (maxWidth - newWidth) / 2;
            }
            if (this.align == "right") {
                x = (maxWidth - newWidth);
            }
            this.slices.template.dx = startLocation * newWidth;
            if (this.alignLabels) {
                this.slicesContainer.dy = y;
            }
        }
        this.slicesContainer.x = x;
        this.labelsContainer.x = x;
        this.ticksContainer.x = x;
        this.slicesContainer.y = y;
        this.labelsContainer.y = y;
        this.ticksContainer.y = y;
        if (newWidth > 0 && newHeight > 0) {
            this.slicesContainer.mask = maskSprite;
        }
    };
    /**
     * Sets defaults that instantiate some objects that rely on parent, so they
     * cannot be set in constructor.
     */
    PictorialStackedSeries.prototype.applyInternalDefaults = function () {
        _super.prototype.applyInternalDefaults.call(this);
        if (!hasValue(this.readerTitle)) {
            this.readerTitle = this.language.translate("Pyramid Series");
        }
    };
    /**
     * Returns a new/empty DataItem of the type appropriate for this object.
     *
     * @see {@link DataItem}
     * @return Data Item
     */
    PictorialStackedSeries.prototype.createDataItem = function () {
        return new PictorialStackedSeries_PictorialStackedSeriesDataItem();
    };
    Object.defineProperty(PictorialStackedSeries.prototype, "maskSprite", {
        /**
         * A [[Sprite]] element that is used as a series mask.
         *
         * If set, this element's shape will be used to apply shape to the whole
         * stacked pictorial series.
         *
         * You can use this element's `path` property to set an SVG path for the
         * shape:
         *
         * ```TypeScript
         * let iconPath = "M511.82,329.991c-0.256-1.212-1.064-2.244-2.192-2.784l-24.396-11.684c17.688-29.776,11.804-68.912-15.58-91.88 c-53.756-45.084-131.696-70.936-213.828-70.936c-82.128,0-160.068,25.856-213.82,70.936c-27.416,22.992-33.28,62.18-15.524,91.972 L2.276,327.203c-1.128,0.54-1.936,1.572-2.192,2.792c-0.256,1.22,0.08,2.496,0.896,3.436l21.204,24.388 c0.764,0.88,1.868,1.376,3.02,1.376c0.084,0,0.172,0,0.26-0.008c1.244-0.084,2.384-0.74,3.072-1.776l14.852-22.376 c12.648,10.112,28.392,15.776,44.916,15.776c16.872,0,33.284-5.98,46.232-16.836c27.828-23.34,73.172-37.272,121.288-37.272 c48.12,0,93.464,13.932,121.296,37.272c12.944,10.856,29.36,16.836,46.228,16.836c16.596,0,32.4-5.724,45.08-15.916l14.94,22.512 c0.692,1.04,1.824,1.696,3.076,1.776c0.084,0.008,0.172,0.008,0.256,0.008c1.156,0,2.256-0.496,3.02-1.376l21.2-24.388C511.74,332.487,512.068,331.211,511.82,329.991z";
         * // ...
         * series.maskSprite.path = iconPath;
         * ```
         * ```JavaScript
         * let iconPath = "M511.82,329.991c-0.256-1.212-1.064-2.244-2.192-2.784l-24.396-11.684c17.688-29.776,11.804-68.912-15.58-91.88 c-53.756-45.084-131.696-70.936-213.828-70.936c-82.128,0-160.068,25.856-213.82,70.936c-27.416,22.992-33.28,62.18-15.524,91.972 L2.276,327.203c-1.128,0.54-1.936,1.572-2.192,2.792c-0.256,1.22,0.08,2.496,0.896,3.436l21.204,24.388 c0.764,0.88,1.868,1.376,3.02,1.376c0.084,0,0.172,0,0.26-0.008c1.244-0.084,2.384-0.74,3.072-1.776l14.852-22.376 c12.648,10.112,28.392,15.776,44.916,15.776c16.872,0,33.284-5.98,46.232-16.836c27.828-23.34,73.172-37.272,121.288-37.272 c48.12,0,93.464,13.932,121.296,37.272c12.944,10.856,29.36,16.836,46.228,16.836c16.596,0,32.4-5.724,45.08-15.916l14.94,22.512 c0.692,1.04,1.824,1.696,3.076,1.776c0.084,0.008,0.172,0.008,0.256,0.008c1.156,0,2.256-0.496,3.02-1.376l21.2-24.388C511.74,332.487,512.068,331.211,511.82,329.991z";
         * // ...
         * series.maskSprite.path = iconPath;
         * ```
         * ```JSON
         * let iconPath = "M511.82,329.991c-0.256-1.212-1.064-2.244-2.192-2.784l-24.396-11.684c17.688-29.776,11.804-68.912-15.58-91.88 c-53.756-45.084-131.696-70.936-213.828-70.936c-82.128,0-160.068,25.856-213.82,70.936c-27.416,22.992-33.28,62.18-15.524,91.972 L2.276,327.203c-1.128,0.54-1.936,1.572-2.192,2.792c-0.256,1.22,0.08,2.496,0.896,3.436l21.204,24.388 c0.764,0.88,1.868,1.376,3.02,1.376c0.084,0,0.172,0,0.26-0.008c1.244-0.084,2.384-0.74,3.072-1.776l14.852-22.376 c12.648,10.112,28.392,15.776,44.916,15.776c16.872,0,33.284-5.98,46.232-16.836c27.828-23.34,73.172-37.272,121.288-37.272 c48.12,0,93.464,13.932,121.296,37.272c12.944,10.856,29.36,16.836,46.228,16.836c16.596,0,32.4-5.724,45.08-15.916l14.94,22.512 c0.692,1.04,1.824,1.696,3.076,1.776c0.084,0.008,0.172,0.008,0.256,0.008c1.156,0,2.256-0.496,3.02-1.376l21.2-24.388C511.74,332.487,512.068,331.211,511.82,329.991z";
         * // ...
         * {
         *   // ...
         *   "series": [{
         *     "type": "PictorialStackedSeries",
         *     // ...
         *     "maskSprite": {
         *       "path": iconPath
         *     }
         *   }]
         * }
         * ```
         *
         * @return Mask sprite
         */
        get: function () {
            return this._maskSprite;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Inits FunnelSlice.
     *
     * @param slice to init
     */
    PictorialStackedSeries.prototype.initSlice = function (slice) {
        _super.prototype.initSlice.call(this, slice);
        var hs = slice.states.getKey("hover");
        if (hs) {
            hs.properties.expandDistance = 0;
        }
    };
    Object.defineProperty(PictorialStackedSeries.prototype, "startLocation", {
        /**
         * @return  Start location
         */
        get: function () {
            return this.getPropertyValue("startLocation");
        },
        /**
         * Relative location to start series from.
         *
         * Range of values: 0 to 1.
         *
         * This setting indicates where actual slices will start relatively to the
         * whole height/width of the series.
         *
         * For example, if we want slices to start at 30% from the top/left of the
         * series, we can set `startLocation = 0.3`.
         *
         * To fill shape outside of the location range, use background of the
         * property `slicesContainer`.
         *
         * ```TypeScript
         * series.startLocation = 0.2;
         * series.endLocation = 0.8;
         * series.slicesContainer.background.fill = am4core.color("#eee");
         * ```
         * ```JavaScript
         * series.startLocation = 0.2;
         * series.endLocation = 0.8;
         * series.slicesContainer.background.fill = am4core.color("#eee");
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": [{
         *     // ...
         *     "startLocation": 0.2,
         *     "endLocation": 0.8,
         *     "slicesContainer": {
         *       "background": {
         *         "fill": "#eee"
         *       }
         *     }
         *   }]
         * }
         * ```
         *
         * @default 0
         * @since 4.1.13
         * @param  value  Start location
         */
        set: function (value) {
            if (this.setPropertyValue("startLocation", value)) {
                this.invalidateDataItems();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PictorialStackedSeries.prototype, "endLocation", {
        /**
         * @return End location
         */
        get: function () {
            return this.getPropertyValue("endLocation");
        },
        /**
         * Relative location to end series at.
         *
         * Range of values: 0 to 1.
         *
         * This setting indicates where actual slices will end relatively to the
         * whole height/width of the series.
         *
         * For example, if we want slices to end at 70% from the top/left of the
         * series, we can set `endLocation = 0.7`.
         *
         * To fill shape outside of the location range, use background of the
         * property `slicesContainer`.
         *
         * ```TypeScript
         * series.startLocation = 0.2;
         * series.endLocation = 0.8;
         * series.slicesContainer.background.fill = am4core.color("#eee");
         * ```
         * ```JavaScript
         * series.startLocation = 0.2;
         * series.endLocation = 0.8;
         * series.slicesContainer.background.fill = am4core.color("#eee");
         * ```
         * ```JSON
         * {
         *   // ...
         *   "series": [{
         *     // ...
         *     "startLocation": 0.2,
         *     "endLocation": 0.8,
         *     "slicesContainer": {
         *       "background": {
         *         "fill": "#eee"
         *       }
         *     }
         *   }]
         * }
         * ```
         *
         * @default 1
         * @since 4.1.13
         * @param  value  End location
         */
        set: function (value) {
            if (this.setPropertyValue("endLocation", value)) {
                this.invalidateDataItems();
            }
        },
        enumerable: true,
        configurable: true
    });
    return PictorialStackedSeries;
}(PyramidSeries_PyramidSeries));

/**
 * bboxter class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["PictorialStackedSeries"] = PictorialStackedSeries_PictorialStackedSeries;
registry.registeredClasses["PictorialStackedSeriesDataItem"] = PictorialStackedSeries_PictorialStackedSeriesDataItem;
//# sourceMappingURL=PictorialStackedSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/ConeColumn.js
/**
 * Module that defines everything related to building Cone Columns.
 * It is a container which has coneColumn element which is a Cone.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Class used to creates ConeColumns.
 *
 * @see {@link IConeColumnEvents} for a list of available events
 * @see {@link IConeColumnAdapters} for a list of available Adapters
 * @todo Usage example
 * @important
 */
var ConeColumn_ConeColumn = /** @class */ (function (_super) {
    __extends(ConeColumn, _super);
    /**
     * Constructor
     */
    function ConeColumn() {
        var _this = _super.call(this) || this;
        _this.className = "ConeColumn";
        return _this;
    }
    /**
     * @ignore
     */
    ConeColumn.prototype.createAssets = function () {
        this.coneColumn = this.createChild(Cone_Cone);
        this.coneColumn.shouldClone = false;
        // some dirty hack so that if user access column, it won't get error
        this.column = this.coneColumn;
    };
    /**
     * Copies all parameters from another [[ConeColumn]].
     *
     * @param source Source ConeColumn
     */
    ConeColumn.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (this.coneColumn) {
            this.coneColumn.copyFrom(source.coneColumn);
        }
    };
    return ConeColumn;
}(Column_Column));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ConeColumn"] = ConeColumn_ConeColumn;
//# sourceMappingURL=ConeColumn.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/ConeSeries.js
/**
 * ConeSeries module
 * Not recommended using if you use scrollbars or your chart is zoomable in some other way.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[ConeSeries]].
 *
 * @see {@link DataItem}
 */
var ConeSeries_ConeSeriesDataItem = /** @class */ (function (_super) {
    __extends(ConeSeriesDataItem, _super);
    /**
     * Constructor
     */
    function ConeSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "ConeSeriesDataItem";
        _this.applyTheme();
        return _this;
    }
    return ConeSeriesDataItem;
}(ColumnSeries_ColumnSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a cone graph.
 *
 * @see {@link IConeSeriesEvents} for a list of available Events
 * @see {@link IConeSeriesAdapters} for a list of available Adapters
 * @todo Example
 * @important
 */
var ConeSeries_ConeSeries = /** @class */ (function (_super) {
    __extends(ConeSeries, _super);
    /**
     * Constructor
     */
    function ConeSeries() {
        var _this = _super.call(this) || this;
        _this.className = "ConeSeries";
        _this.applyTheme();
        return _this;
    }
    /**
     * Returns an element to use for Candlestick
     * @ignore
     * @return Element.
     */
    ConeSeries.prototype.createColumnTemplate = function () {
        return new ConeColumn_ConeColumn();
    };
    /**
     * Returns an SVG path to use as series mask.
     *
     * @return SVG path
     */
    ConeSeries.prototype.getMaskPath = function () {
        var dx = 0;
        var dy = 0;
        var column = this.columns.getIndex(0);
        if (column) {
            if (this.baseAxis == this.xAxis) {
                dy = column.coneColumn.innerWidth / 2 + 1;
            }
            else {
                dx = column.coneColumn.innerHeight / 2 + 1;
            }
            return rectToPath({
                x: -dx,
                y: 0,
                width: this.xAxis.axisLength + dx,
                height: this.yAxis.axisLength + dy
            });
        }
    };
    /**
     * Validates data item's elements.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    ConeSeries.prototype.validateDataElementReal = function (dataItem) {
        _super.prototype.validateDataElementReal.call(this, dataItem);
        var column = dataItem.column;
        if (column) {
            var coneColumn = dataItem.column.coneColumn;
            coneColumn.fill = dataItem.column.fill;
            if (this.baseAxis == this.yAxis) {
                coneColumn.orientation = "horizontal";
            }
            else {
                coneColumn.orientation = "vertical";
            }
        }
    };
    return ConeSeries;
}(ColumnSeries_ColumnSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ConeSeries"] = ConeSeries_ConeSeries;
registry.registeredClasses["ConeSeriesDataItem"] = ConeSeries_ConeSeriesDataItem;
//# sourceMappingURL=ConeSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/CurvedColumn.js
/**
 * Module that defines everything related to building Curved Columns.
 * It is a container which has CurvedColumn element which is a Sprite.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */







/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Class used to creates CurvedColumns.
 *
 * @see {@link ICurvedColumnEvents} for a list of available events
 * @see {@link ICurvedColumnAdapters} for a list of available Adapters
 * @important
 */
var CurvedColumn_CurvedColumn = /** @class */ (function (_super) {
    __extends(CurvedColumn, _super);
    /**
     * Constructor
     */
    function CurvedColumn() {
        var _this = _super.call(this) || this;
        _this.className = "CurvedColumn";
        return _this;
    }
    /**
     * [createAssets description]
     *
     * @todo Description
     * @ignore Exclude from docs
     */
    CurvedColumn.prototype.createAssets = function () {
        this.curvedColumn = this.createChild(Sprite_Sprite);
        this.curvedColumn.shouldClone = false;
        this.setPropertyValue("tension", 0.7);
        this.width = Percent_percent(120);
        this.height = Percent_percent(120);
        // some dirty hack so that if user access column, it won't get error
        this.column = this.curvedColumn;
    };
    /**
     * Draws the element.
     *
     * @ignore Exclude from docs
     */
    CurvedColumn.prototype.draw = function () {
        _super.prototype.draw.call(this);
        var w = this.realWidth;
        var h = this.realHeight;
        var x = this.realX - this.pixelX;
        var y = this.realY - this.pixelY;
        var points;
        // TODO can this be removed ?
        used(this.width);
        var tensionX = 1;
        var tensionY = 1;
        if (this.orientation == "vertical") {
            tensionX = this.tension;
            points = [{ x: 0, y: h + y }, { x: w / 2, y: y }, { x: w, y: h + y }];
        }
        else {
            tensionY = this.tension;
            points = [{ x: x, y: 0 }, { x: x + w, y: h / 2 }, { x: x, y: h }];
        }
        var path = moveTo(points[0]) + new Smoothing_Tension(tensionX, tensionY).smooth(points);
        this.column.path = path;
    };
    /**
     * Copies all parameters from another [[CurvedColumn]].
     *
     * @param source  Source CurvedColumn
     */
    CurvedColumn.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        if (this.curvedColumn) {
            this.curvedColumn.copyFrom(source.curvedColumn);
        }
    };
    Object.defineProperty(CurvedColumn.prototype, "tension", {
        /**
         * @return Tension (0-1)
         */
        get: function () {
            return this.getPropertyValue("tension");
        },
        /**
         * Horizontal tension of the curve.
         *
         * Tension defines how "lose" the line will be.
         *
         * 1 is the maximum tension which would result in pointy columns with
         * straight edges.
         *
         * The smaller the tension th wider the column will be.
         *
         * @default 0.7
         * @param value tension (0-1)
         */
        set: function (value) {
            this.setPropertyValue("tension", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CurvedColumn.prototype, "orientation", {
        /**
         * Orientation
         */
        get: function () {
            return this.getPropertyValue("orientation");
        },
        /**
         * Orientation of the column.
         *
         * Available options: "vertical" (default) and "horizontal".
         *
         * @default "vertical"
         * @param value  Orientation
         */
        set: function (value) {
            this.setPropertyValue("orientation", value, true);
        },
        enumerable: true,
        configurable: true
    });
    return CurvedColumn;
}(Column_Column));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["CurvedColumn"] = CurvedColumn_CurvedColumn;
//# sourceMappingURL=CurvedColumn.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/series/CurvedColumnSeries.js
/**
 * CurvedColumnSeries module.
 *
 * Not recommended using if you use scrollbars or your chart is zoomable in some other way.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[CurvedColumnSeries]].
 *
 * @see {@link DataItem}
 */
var CurvedColumnSeries_CurvedColumnSeriesDataItem = /** @class */ (function (_super) {
    __extends(CurvedColumnSeriesDataItem, _super);
    /**
     * Constructor
     */
    function CurvedColumnSeriesDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "CurvedColumnSeriesDataItem";
        _this.applyTheme();
        return _this;
    }
    return CurvedColumnSeriesDataItem;
}(ColumnSeries_ColumnSeriesDataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Defines [[Series]] for a curved columns graph.
 *
 * @see {@link ICurvedColumnSeriesEvents} for a list of available Events
 * @see {@link ICurvedColumnSeriesAdapters} for a list of available Adapters
 * @important
 */
var CurvedColumnSeries_CurvedColumnSeries = /** @class */ (function (_super) {
    __extends(CurvedColumnSeries, _super);
    /**
     * Constructor
     */
    function CurvedColumnSeries() {
        var _this = _super.call(this) || this;
        _this.className = "CurvedColumnSeries";
        _this.applyTheme();
        return _this;
    }
    /**
     * Returns an element to use for the curved column.
     *
     * @ignore Exclude from docs
     * @return Element.
     */
    CurvedColumnSeries.prototype.createColumnTemplate = function () {
        return new CurvedColumn_CurvedColumn();
    };
    /**
     * Validates data item's elements.
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    CurvedColumnSeries.prototype.validateDataElementReal = function (dataItem) {
        _super.prototype.validateDataElementReal.call(this, dataItem);
        var column = dataItem.column;
        column = dataItem.column;
        if (column) {
            var curvedColumn = dataItem.column.curvedColumn;
            curvedColumn.fill = dataItem.column.fill;
            if (this.baseAxis == this.yAxis) {
                column.orientation = "horizontal";
            }
            else {
                column.orientation = "vertical";
            }
        }
    };
    return CurvedColumnSeries;
}(ColumnSeries_ColumnSeries));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["CurvedColumnSeries"] = CurvedColumnSeries_CurvedColumnSeries;
registry.registeredClasses["CurvedColumnSeriesDataItem"] = CurvedColumnSeries_CurvedColumnSeriesDataItem;
//# sourceMappingURL=CurvedColumnSeries.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/CircleBullet.js
/**
 * Bullet module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */



/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a bullet with a textual label.
 *
 * Uses [[Label]] instance to draw the label, so the label itself is
 * configurable.
 *
 * @see {@link IBulletEvents} for a list of available events
 * @see {@link IBulletAdapters} for a list of available Adapters
 * @todo Usage example
 * @important
 */
var CircleBullet_CircleBullet = /** @class */ (function (_super) {
    __extends(CircleBullet, _super);
    /**
     * Constructor
     */
    function CircleBullet() {
        var _this = _super.call(this) || this;
        _this.className = "CircleBullet";
        var circle = _this.createChild(Circle_Circle);
        circle.shouldClone = false;
        circle.radius = 5;
        circle.isMeasured = false;
        _this.circle = circle;
        _this.applyTheme();
        return _this;
    }
    /**
     * Copies all proprities and related stuff from another instance of
     * [[CircleBullet]].
     *
     * @param source  Source element
     */
    CircleBullet.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.circle.copyFrom(source.circle);
    };
    return CircleBullet;
}(Bullet_Bullet));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["CircleBullet"] = CircleBullet_CircleBullet;
//# sourceMappingURL=CircleBullet.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/ErrorBullet.js
/**
 * Bullet module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */




/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Creates a bullet with a textual label.
 *
 * Uses [[Label]] instance to draw the label, so the label itself is
 * configurable.
 *
 * @see {@link IBulletEvents} for a list of available events
 * @see {@link IBulletAdapters} for a list of available Adapters
 * @todo Usage example
 * @important
 */
var ErrorBullet_ErrorBullet = /** @class */ (function (_super) {
    __extends(ErrorBullet, _super);
    /**
     * Constructor
     */
    function ErrorBullet() {
        var _this = _super.call(this) || this;
        _this.className = "ErrorBullet";
        _this.errorLine = _this.createChild(Sprite_Sprite);
        _this.errorLine.shouldClone = false;
        _this.width = 20;
        _this.height = 20;
        _this.strokeOpacity = 1;
        _this.isDynamic = true;
        return _this;
    }
    ErrorBullet.prototype.validatePosition = function () {
        _super.prototype.validatePosition.call(this);
        var w = this.pixelWidth / 2;
        var h = this.pixelHeight / 2;
        this.errorLine.path = moveTo({ x: -w, y: -h }) + lineTo({ x: w, y: -h }) + moveTo({ x: 0, y: -h }) + lineTo({ x: 0, y: h }) + moveTo({ x: -w, y: h }) + lineTo({ x: w, y: h });
    };
    /**
     * Copies all proprities and related stuff from another instance of
     * [[ErrorBullet]].
     *
     * @param source  Source element
     */
    ErrorBullet.prototype.copyFrom = function (source) {
        _super.prototype.copyFrom.call(this, source);
        this.errorLine.copyFrom(source.errorLine);
    };
    return ErrorBullet;
}(Bullet_Bullet));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["ErrorBullet"] = ErrorBullet_ErrorBullet;
//# sourceMappingURL=ErrorBullet.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/elements/NavigationBar.js
/**
 * Functionality for drawing simple NavigationBar.
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









/**
 * ============================================================================
 * DATA ITEM
 * ============================================================================
 * @hidden
 */
/**
 * Defines a [[DataItem]] for [[NavigationBar]].
 *
 * @see {@link DataItem}
 */
var NavigationBar_NavigationBarDataItem = /** @class */ (function (_super) {
    __extends(NavigationBarDataItem, _super);
    /**
     * Constructor
     */
    function NavigationBarDataItem() {
        var _this = _super.call(this) || this;
        _this.className = "NavigationBarDataItem";
        _this.applyTheme();
        return _this;
    }
    Object.defineProperty(NavigationBarDataItem.prototype, "name", {
        /**
         * @return Name
         */
        get: function () {
            return this.properties["name"];
        },
        /**
         * Name of the navigation bar item.
         *
         * @param value  Name
         */
        set: function (value) {
            this.setProperty("name", value);
        },
        enumerable: true,
        configurable: true
    });
    return NavigationBarDataItem;
}(DataItem_DataItem));

/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * NavigationBar class can be used to create a multi-level breadcrumb-style
 * navigation control.
 *
 * @see {@link INavigationBarEvents} for a list of available events
 * @see {@link INavigationBarAdapters} for a list of available Adapters
 * @todo Implement better
 * @important
 */
var NavigationBar_NavigationBar = /** @class */ (function (_super) {
    __extends(NavigationBar, _super);
    /**
     * Constructor
     */
    function NavigationBar() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "NavigationBar";
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        var textLink = new TextLink_TextLink();
        textLink.valign = "middle";
        textLink.paddingTop = 8;
        textLink.paddingBottom = 8;
        _this.paddingBottom = 2;
        _this.links = new List_ListTemplate(textLink);
        _this._disposers.push(new List_ListDisposer(_this.links));
        _this._disposers.push(textLink);
        _this._linksIterator = new Iterator_ListIterator(_this.links, function () { return _this.links.create(); });
        _this._linksIterator.createNewItems = true;
        var triangle = new Triangle_Triangle();
        triangle.direction = "right";
        triangle.width = 8;
        triangle.height = 12;
        triangle.fill = interfaceColors.getFor("alternativeBackground");
        triangle.fillOpacity = 0.5;
        triangle.valign = "middle";
        triangle.marginLeft = 10;
        triangle.marginRight = 10;
        _this.separators = new List_ListTemplate(triangle);
        _this._disposers.push(new List_ListDisposer(_this.separators));
        _this._disposers.push(triangle);
        var activeLink = new TextLink_TextLink();
        _this.activeLink = activeLink;
        activeLink.copyFrom(textLink);
        activeLink.valign = "middle";
        activeLink.fontWeight = "bold";
        _this.width = Percent_percent(100);
        _this.layout = "grid";
        _this.dataFields.name = "name";
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Completely redraws the navigation bar.
     *
     * @ignore Exclude from docs
     */
    NavigationBar.prototype.validateDataElements = function () {
        this.removeChildren();
        this._linksIterator.reset();
        _super.prototype.validateDataElements.call(this);
        //@todo: dispose
    };
    /**
     * Creates a visual element for a data item (nav item).
     *
     * @ignore Exclude from docs
     * @param dataItem  Data item
     */
    NavigationBar.prototype.validateDataElement = function (dataItem) {
        _super.prototype.validateDataElement.call(this, dataItem);
        var textLink;
        if (dataItem.index < this.dataItems.length - 1) {
            textLink = this._linksIterator.getLast();
            textLink.parent = this;
            var separator = this.separators.create();
            separator.parent = this;
            separator.valign = "middle";
        }
        else {
            textLink = this.activeLink;
            textLink.events.copyFrom(this.links.template.events);
            textLink.hide(0);
            textLink.show();
            textLink.parent = this;
        }
        textLink.dataItem = dataItem;
        textLink.text = dataItem.name;
        textLink.validate();
    };
    return NavigationBar;
}(Component_Component));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["NavigationBar"] = NavigationBar_NavigationBar;
registry.registeredClasses["NavigationBarDataItem"] = NavigationBar_NavigationBarDataItem;
//# sourceMappingURL=NavigationBar.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/cursors/Cursor.js
/**
 * Cursor module
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */









/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Main Cursor class with common cursor functionality.
 *
 * Chart-specific cursors must extend this class.
 *
 * @see {@link ICursorEvents} for a list of available events
 * @see {@link ICursorAdapters} for a list of available Adapters
 * @todo Add description, examples
 * @todo Should we allow changing `_generalBehavior`?
 */
var Cursor_Cursor = /** @class */ (function (_super) {
    __extends(Cursor, _super);
    /**
     * Constructor
     */
    function Cursor() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Current cursor position during selection.
         *
         * @todo Better description
         */
        _this.point = { x: 0, y: 0 };
        /**
         * Specifies the rules when cursor needs to be moved or hidden.
         */
        _this._stick = "none";
        _this.className = "Cursor";
        // Set defaults
        _this.width = Percent_percent(100);
        _this.height = Percent_percent(100);
        _this.shouldClone = false;
        _this.hide(0);
        _this.trackable = true;
        _this.clickable = true;
        _this.isMeasured = false;
        // Add events on body to trigger down and up events (to start zooming or
        // selection)
        var interaction = getInteraction();
        _this._disposers.push(interaction.body.events.on("down", _this.handleCursorDown, _this));
        _this._disposers.push(interaction.body.events.on("up", _this.handleCursorUp, _this));
        _this._disposers.push(interaction.body.events.on("track", _this.handleCursorMove, _this));
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Handle pointer movement in document and update cursor position as needed.
     *
     * @ignore Exclude from docs
     * @param event Event
     */
    Cursor.prototype.handleCursorMove = function (event) {
        if (!this.interactionsEnabled || (this.interactions.isTouchProtected && event.touch)) {
            return;
        }
        if (((this._generalBehavior != "zoom" && this._generalBehavior != "pan") || !this.downPoint) && !getInteraction().isLocalElement(event.pointer, this.paper.svg, this.uid)) {
            // We want to let zoom/pan continue even if cursor is outside chart area
            if (!this.isHidden || !this.isHiding) {
                this.hide();
            }
            return;
        }
        var local = documentPointToSprite(event.pointer.point, this);
        if (this._stick == "hard" && this._stickPoint) {
            local = this._stickPoint;
        }
        if (this._stick == "soft" && this._stickPoint) {
            if (!this.fitsToBounds(local)) {
                local = this._stickPoint;
            }
        }
        this.triggerMove(local);
        return local;
    };
    /**
     * Hides actual SVG elements and handles hiding animations.
     *
     * @param duration  Fade out duration (ms)
     * @return Fade out duration (ms)
     * @ignore
     */
    Cursor.prototype.hideReal = function (duration) {
        if ((this._stick == "hard" || this._stick == "soft") && this._stickPoint) {
            return;
        }
        return _super.prototype.hideReal.call(this, duration);
    };
    /**
     * Places the cursor at specific point.
     *
     * The second parameter has following options:
     *
     * `"none"` - placed cursor will only be there until mouse/touch moves, then
     * it either moves to a new place (if pointer over plot area) or is hidden.
     *
     * `"soft"` - cursor will stay in the place if mouse/touch is happening
     * outside chart, but will move to a new place whe plot area is hovered or
     * touched.
     *
     * `"hard"` - cursor will stay in place no matter what, until it is moved by
     * another `triggerMove()` call.
     *
     * The third parameter - `force` (since `4.9.5`) - if set to `true` will
     * make cursor execute all of the actions associated with cursor move,
     * including line redraws, tooltip updates, etc. Useful when underlying
     * chart data is dynamically being updated.
     *
     * @param point  Point to place cursor at
     * @param stick  Level of cursor stickiness to the place
     * @param force  Force cursor move
     */
    Cursor.prototype.triggerMove = function (point, stick, force) {
        point.x = Math_round(point.x, 1);
        point.y = Math_round(point.y, 1);
        if (stick) {
            this._stick = stick;
        }
        if (stick == "hard" || stick == "soft") {
            this._stickPoint = point;
        }
        this.triggerMoveReal(point, force);
    };
    /**
     * Places the cursor at specific point.
     *
     * @param point Point to place cursor at
     */
    Cursor.prototype.triggerMoveReal = function (point, force) {
        if (this.point.x != point.x || this.point.y != point.y || force) {
            this.point = point;
            this.invalidatePosition();
            // hide cursor if it's out of bounds
            if (this.fitsToBounds(point)) {
                this.show(0);
            }
            else {
                // unless we are selecting (mouse is down)
                if (!this.downPoint) {
                    this.hide(0);
                }
            }
            if (this.visible) {
                this.getPositions();
                this.dispatch("cursorpositionchanged"); // not good to dispatch later (check step count example)
            }
        }
    };
    /**
     * Simulates pressing down (click/touch) action by a cursor.
     *
     * @param point               Point of action
     */
    Cursor.prototype.triggerDown = function (point) {
        this.triggerDownReal(point);
    };
    /**
     * Simulates pressing down (click/touch) action by a cursor.
     *
     * @param point               Point of action
     */
    Cursor.prototype.triggerDownReal = function (point) {
        switch (this._generalBehavior) {
            case "zoom":
                this.dispatchImmediately("zoomstarted");
                break;
            case "select":
                this.dispatchImmediately("selectstarted");
                break;
            case "pan":
                this.dispatchImmediately("panstarted");
                getInteraction().setGlobalStyle(MouseCursorStyle.grabbing);
                break;
        }
    };
    /**
     * Simulates the action of release of the mouse down / touch.
     *
     * @param point               Point of action
     */
    Cursor.prototype.triggerUp = function (point) {
        this.triggerUpReal(point);
    };
    /**
     * Simulates the action of release of the mouse down / touch.
     *
     * @param point               Point of action
     */
    Cursor.prototype.triggerUpReal = function (point) {
        system.requestFrame();
        this.updatePoint(this.upPoint);
        var interaction = getInteraction();
        if (getDistance(this._upPointOrig, this._downPointOrig) > interaction.getHitOption(this.interactions, "hitTolerance")) {
            switch (this._generalBehavior) {
                case "zoom":
                    this.dispatch("zoomended");
                    break;
                case "select":
                    this.dispatch("selectended");
                    break;
                case "pan":
                    this.dispatch("panended");
                    interaction.setGlobalStyle(MouseCursorStyle.default);
                    break;
            }
            this.downPoint = undefined;
            this.updateSelection();
        }
        /*
        else {
            
            if(this._generalBehavior == "select"){
                this.dispatchImmediately("selectended");
            }
            this.dispatchImmediately("behaviorcanceled");
            interaction.setGlobalStyle(MouseCursorStyle.default);
            this.downPoint = undefined;
        }*/
    };
    /**
     * Updates selection dimensions on size change.
     *
     * @ignore Exclude from docs
     */
    Cursor.prototype.updateSelection = function () {
    };
    /**
     * Updates cursors current positions.
     */
    Cursor.prototype.getPositions = function () {
        // positions are used by axes or series
        this.xPosition = this.point.x / this.innerWidth;
        this.yPosition = 1 - this.point.y / this.innerHeight;
    };
    /**
     * Handles pointer down event so we can start zoom or selection.
     *
     * @ignore Exclude from docs
     * @param event Original event
     */
    Cursor.prototype.handleCursorDown = function (event) {
        if (!this.interactionsEnabled || (this.interactions.isTouchProtected && event.touch) || !getInteraction().isLocalElement(event.pointer, this.paper.svg, this.uid)) {
            return;
        }
        // Get local point
        var local = documentPointToSprite(event.pointer.point, this);
        if (this._stick == "hard" && this._stickPoint) {
            local = this._stickPoint;
        }
        this._downPointOrig = { x: local.x, y: local.y };
        // We need to cancel the event to prevent gestures on touch devices
        if (event.event.cancelable && this.shouldPreventGestures(event.touch) && this.fitsToBounds(local)) {
            event.event.preventDefault();
        }
        // Make this happen
        this.triggerMove(local);
        this.triggerDown(local);
    };
    /**
     * Determines whether Cursor should prevent default action on move.
     *
     * Child classes should override this as necessary.
     *
     * @return Prevent default?
     */
    Cursor.prototype.shouldPreventGestures = function (touch) {
        return true;
    };
    /**
     * Updates the coordinates of where pointer down event occurred
     * (was pressed).
     */
    Cursor.prototype.updatePoint = function (point) {
    };
    /**
     * Handles pointer up event - finishes zoom or selection action.
     *
     * @ignore Exclude from docs
     * @param event Original event
     */
    Cursor.prototype.handleCursorUp = function (event) {
        if (!this.interactionsEnabled) {
            return;
        }
        if (!this.downPoint && !getInteraction().isLocalElement(event.pointer, this.paper.svg, this.uid)) {
            return;
        }
        var local = documentPointToSprite(event.pointer.point, this);
        if (this._stick == "hard" && this._stickPoint) {
            local = this._stickPoint;
        }
        this._upPointOrig = { x: local.x, y: local.y };
        this.triggerMove(local);
        this.triggerUp(local);
    };
    Object.defineProperty(Cursor.prototype, "chart", {
        /**
         * @return Chart
         */
        get: function () {
            return this._chart;
        },
        /**
         * A reference to a [[Chart]] the cursor belongs to.
         *
         * @param value  Chart
         */
        set: function (value) {
            this._chart = value;
            if (hasValue(this._chart.plotContainer)) {
                getInteraction().lockElement(this._chart.plotContainer.interactions);
            }
        },
        enumerable: true,
        configurable: true
    });
    return Cursor;
}(Container_Container));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["Cursor"] = Cursor_Cursor;
//# sourceMappingURL=Cursor.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/cursors/XYCursor.js
/**
 * Cursor for XY chart
 */

/**
 * ============================================================================
 * IMPORTS
 * ============================================================================
 * @hidden
 */
















/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * A cursor used on [[XYChart]].
 *
 * @see {@link IXYCursorEvents} for a list of available events
 * @see {@link IXYCursorAdapters} for a list of available Adapters
 * @todo Add description, examples
 */
var XYCursor_XYCursor = /** @class */ (function (_super) {
    __extends(XYCursor, _super);
    /**
     * Constructor
     */
    function XYCursor() {
        var _this = 
        // Init
        _super.call(this) || this;
        /**
         * Vertical cursor line element.
         */
        _this._lineX = new Disposer_MutableValueDisposer();
        /**
         * Horizontal cursor line element.
         */
        _this._lineY = new Disposer_MutableValueDisposer();
        /**
         * Horizontal [[Axis]].
         */
        _this._xAxis = new Disposer_MutableValueDisposer();
        /**
         * Vertical [[Axis]].
         */
        _this._yAxis = new Disposer_MutableValueDisposer();
        _this._snapToDisposers = [];
        _this.className = "XYCursor";
        // Defaults
        _this.behavior = "zoomX";
        _this.maxPanOut = 0.1;
        var interfaceColors = new InterfaceColorSet_InterfaceColorSet();
        // Create selection element
        var selection = _this.createChild(Sprite_Sprite);
        selection.shouldClone = false;
        selection.fillOpacity = 0.2;
        selection.fill = interfaceColors.getFor("alternativeBackground");
        selection.isMeasured = false;
        selection.visible = false;
        selection.interactionsEnabled = false;
        _this.selection = selection;
        _this._disposers.push(_this.selection);
        // Create cursor's vertical line
        var lineX = _this.createChild(Sprite_Sprite);
        lineX.shouldClone = false;
        lineX.stroke = interfaceColors.getFor("grid");
        lineX.fill = Color_color();
        lineX.strokeDasharray = "3,3";
        lineX.isMeasured = false;
        lineX.strokeOpacity = 0.4;
        lineX.interactionsEnabled = false;
        lineX.y = 0; // important
        _this.lineX = lineX;
        _this._disposers.push(_this.lineX);
        // Create cursor's horizontal line
        var lineY = _this.createChild(Sprite_Sprite);
        lineY.shouldClone = false;
        lineY.stroke = interfaceColors.getFor("grid");
        lineY.fill = Color_color();
        lineY.strokeDasharray = "3,3";
        lineY.isMeasured = false;
        lineY.strokeOpacity = 0.4;
        lineY.interactionsEnabled = false;
        lineY.x = 0; // important
        _this.lineY = lineY;
        _this._disposers.push(_this.lineY);
        // Add handler for size changes
        _this.events.on("sizechanged", _this.updateSize, _this, false);
        _this._disposers.push(_this._lineX);
        _this._disposers.push(_this._lineY);
        _this._disposers.push(_this._xAxis);
        _this._disposers.push(_this._yAxis);
        _this.mask = _this;
        _this.hideSeriesTooltipsOnSelection = true;
        // Apply theme
        _this.applyTheme();
        return _this;
    }
    /**
     * Updates cursor element dimensions on size change.
     *
     * @ignore Exclude from docs
     */
    XYCursor.prototype.updateSize = function () {
        if (this.lineX) {
            this.lineX.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: 0, y: this.innerHeight });
        }
        if (this.lineY) {
            this.lineY.path = moveTo({ x: 0, y: 0 }) + lineTo({ x: this.innerWidth, y: 0 });
        }
    };
    /**
     * Updates selection dimensions on size change.
     *
     * @ignore Exclude from docs
     */
    XYCursor.prototype.updateSelection = function () {
        if (this._usesSelection) {
            var downPoint = this.downPoint;
            var behavior = this.behavior;
            if (downPoint) {
                var point = this.point;
                if (this.lineX) {
                    point.x = this.lineX.pixelX;
                }
                if (this.lineY) {
                    point.y = this.lineY.pixelY;
                }
                var selection = this.selection;
                var x = Math.min(point.x, downPoint.x);
                var y = Math.min(point.y, downPoint.y);
                var w = Math_round(Math.abs(downPoint.x - point.x), this._positionPrecision);
                var h = Math_round(Math.abs(downPoint.y - point.y), this._positionPrecision);
                switch (behavior) {
                    case "zoomX":
                        y = 0;
                        h = this.pixelHeight;
                        break;
                    case "zoomY":
                        x = 0;
                        w = this.pixelWidth;
                        break;
                    case "selectX":
                        y = 0;
                        h = this.pixelHeight;
                        break;
                    case "selectY":
                        x = 0;
                        w = this.pixelWidth;
                        break;
                }
                selection.x = x;
                selection.y = y;
                selection.path = Path_rectangle(w, h);
                selection.validatePosition(); // otherwise Edge shoes some incorrect size rectangle
            }
            else {
                if (this._generalBehavior != "select") {
                    this.selection.hide();
                }
            }
        }
    };
    /**
     *
     * @ignore Exclude from docs
     */
    XYCursor.prototype.fixPoint = function (point) {
        point.x = Math.max(0, point.x);
        point.y = Math.max(0, point.y);
        point.x = Math.min(this.pixelWidth, point.x);
        point.y = Math.min(this.pixelHeight, point.y);
        return point;
    };
    /**
     * Places the cursor at specific point.
     *
     * @param point Point to place cursor at
     */
    XYCursor.prototype.triggerMoveReal = function (point, force) {
        _super.prototype.triggerMoveReal.call(this, point, force);
        var snapToSeries = this.snapToSeries;
        if ((snapToSeries && !this.downPoint)) {
            if (snapToSeries instanceof XYSeries_XYSeries) {
                if (snapToSeries.isHidden) {
                    this.updateLinePositions(point);
                }
            }
            else {
                var allHidden_1 = true;
                each(snapToSeries, function (s) {
                    if (!s.isHidden) {
                        allHidden_1 = false;
                    }
                });
                if (allHidden_1) {
                    this.updateLinePositions(point);
                }
            }
        }
        else {
            this.updateLinePositions(point);
        }
        if (this.downPoint && getDistance(this.downPoint, point) > 3) {
            if (this._generalBehavior == "pan") {
                this.getPanningRanges();
                this.dispatch("panning");
            }
        }
    };
    /**
     *
     * @ignore Exclude from docs
     */
    XYCursor.prototype.updateLinePositions = function (point) {
        point = this.fixPoint(this.point);
        if (this.lineX && this.lineX.visible && !this.xAxis) {
            this.lineX.x = point.x;
        }
        if (this.lineY && this.lineY.visible && !this.yAxis) {
            this.lineY.y = point.y;
        }
        this.updateSelection();
    };
    XYCursor.prototype.triggerDownReal = function (point) {
        if (this.visible && !this.isHiding) {
            if (this._generalBehavior == "select") {
                this.selection.parent = this.parent;
            }
            if (this.fitsToBounds(point)) {
                this.downPoint = { x: point.x, y: point.y };
                this.updatePoint(point);
                //this.updateLinePositions(point); // otherwise lines won't be in correct position and touch won't work fine
                this.point.x = this.downPoint.x;
                this.point.y = this.downPoint.y;
                var selection = this.selection;
                var selectionX = this.downPoint.x;
                var selectionY = this.downPoint.y;
                if (this._usesSelection) {
                    selection.x = selectionX;
                    selection.y = selectionY;
                    selection.path = "";
                    selection.show();
                }
                _super.prototype.triggerDownReal.call(this, point);
            }
            else {
                this.downPoint = undefined;
            }
        }
        else {
            this.downPoint = undefined;
        }
    };
    /**
     * Updates the coordinates of where pointer down event occurred
     * (was pressed).
     */
    XYCursor.prototype.updatePoint = function (point) {
        if (this.lineX) {
            point.x = this.lineX.pixelX;
        }
        if (this.lineY) {
            point.y = this.lineY.pixelY;
        }
    };
    /**
     * Handle action when cursor is released, which should perform an operation
     * based on its `behavior`, like zoom.
     *
     * @param  point  Release point
     */
    XYCursor.prototype.triggerUpReal = function (point) {
        if (this.hasMoved()) {
            if (this.downPoint) {
                this.upPoint = point;
                this.updatePoint(this.upPoint);
                if (this._generalBehavior != "pan") {
                    this.getRanges();
                }
                if (this._generalBehavior != "select") {
                    this.selection.hide();
                }
                _super.prototype.triggerUpReal.call(this, point);
            }
        }
        else {
            if (this._generalBehavior != "select") {
                this.selection.hide(0);
            }
            else {
                this.xRange = undefined;
                this.yRange = undefined;
                this.dispatchImmediately("selectended");
            }
            // reset cursor style, just in case
            if (this._generalBehavior == "pan") {
                var interaction = getInteraction();
                interaction.setGlobalStyle(MouseCursorStyle.default);
            }
            this.dispatchImmediately("behaviorcanceled");
        }
        this.downPoint = undefined;
        this.dispatch("cursorpositionchanged");
    };
    /**
     * Calculates if the cursor has moved enough based on its `behavior`.
     *
     * @return Moved?
     */
    XYCursor.prototype.hasMoved = function () {
        var distance;
        if (this.behavior == "zoomX" || this.behavior == "panX") {
            distance = getHorizontalDistance(this._upPointOrig, this._downPointOrig);
        }
        else if (this.behavior == "zoomY" || this.behavior == "panY") {
            distance = getVerticalDistance(this._upPointOrig, this._downPointOrig);
        }
        else {
            distance = getDistance(this._upPointOrig, this._downPointOrig);
        }
        return distance > getInteraction().getHitOption(this.interactions, "hitTolerance");
    };
    /**
     * [getRanges description]
     *
     * @todo Description
     */
    XYCursor.prototype.getPanningRanges = function () {
        var startX = Math_round(this.downPoint.x / this.innerWidth, 5);
        var startY = 1 - Math_round(this.downPoint.y / this.innerHeight, 5);
        var currentX = Math_round(this.point.x / this.innerWidth, 5);
        var currentY = 1 - Math_round(this.point.y / this.innerHeight, 5);
        var deltaX = startX - currentX;
        var deltaY = startY - currentY;
        this.xRange = { start: deltaX, end: 1 + deltaX };
        this.yRange = { start: deltaY, end: 1 + deltaY };
        if (this.behavior == "panX") {
            this.yRange.start = 0;
            this.yRange.end = 1;
        }
        if (this.behavior == "panY") {
            this.xRange.start = 0;
            this.xRange.end = 1;
        }
    };
    /**
     * [getRanges description]
     *
     * @todo Description
     */
    XYCursor.prototype.getRanges = function () {
        if (this.lineX) {
            this.upPoint.x = this.lineX.pixelX;
        }
        if (this.lineY) {
            this.upPoint.y = this.lineY.pixelY;
        }
        // @todo Is this needed?
        used(this.selection);
        var startX = Math_round(this.downPoint.x / this.innerWidth, 5);
        var endX = Math_round((this.upPoint.x) / this.innerWidth, 5);
        var startY = 1 - Math_round(this.downPoint.y / this.innerHeight, 5);
        var endY = 1 - Math_round((this.upPoint.y) / this.innerHeight, 5);
        this.xRange = { start: Math_min(startX, endX), end: Math_max(startX, endX) };
        this.yRange = { start: Math_min(startY, endY), end: Math_max(startY, endY) };
    };
    Object.defineProperty(XYCursor.prototype, "behavior", {
        /**
         * Behavior
         */
        get: function () {
            return this.getPropertyValue("behavior");
        },
        /**
         * Cursor's behavior when it's moved with pointer down:
         *
         * * `"zoomX"` - zooms horizontally.
         * * `"zoomY"` - zooms vertically.
         * * `"zoomXY"` - zooms both horizontally and vertically.
         * * `"selectX"` - selects a range horizontally.
         * * `"selectY"` - selects a range vertically.
         * * `"selectXY"` - selects a range both horizontally and vertically.
         * * `"panX"` - moves (pans) current selection horizontally.
         * * `"panY"` - moves (pans) current selection vertically.
         * * `"panXY"` - moves (pans) current selection both horizontally and vertically.
         * * `"none"` - does nothing with pointer down.
         *
         * E.g. "zoomXY" will mean that pressing a mouse (or touching) over plot area
         * and dragging it will start zooming the chart.
         *
         * NOTE: `"zoomXY"` acts differently when used on a `DateAxis`.
         * See [this note](https://www.amcharts.com/docs/v4/concepts/chart-cursor/#zoomXY_behavior_and_DateAxis).
         *
         * @param value Bheavior
         */
        set: function (value) {
            this.setPropertyValue("behavior", value, true);
            this._usesSelection = false;
            if (value.indexOf("zoom") != -1) {
                this._generalBehavior = "zoom";
                this._usesSelection = true;
            }
            if (value.indexOf("select") != -1) {
                this._generalBehavior = "select";
                this._usesSelection = true;
            }
            if (value.indexOf("pan") != -1) {
                this._generalBehavior = "pan";
                this._usesSelection = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Determines whether Cursor should prevent default action on move.
     *
     * If cursor's behavior is "none", it should not obstruct the page scrolling.
     *
     * @return Prevent default?
     */
    XYCursor.prototype.shouldPreventGestures = function (touch) {
        return (!this.interactions.isTouchProtected || !touch) && this.behavior != "none";
    };
    Object.defineProperty(XYCursor.prototype, "fullWidthLineX", {
        /**
         * @return Full width?
         */
        get: function () {
            return this.getPropertyValue("fullWidthLineX");
        },
        /**
         * Cursor's horizontal line is expanded to take full width of the related
         * Axis' cell/category.
         *
         * NOTE: this setting will work properly if `xAxis` is set and only in case
         * `xAxis` is [[CategoryAxis]] or [[DateAxis]].
         *
         * @param value Full width?
         */
        set: function (value) {
            this.setPropertyValue("fullWidthLineX", value);
            if (!value) {
                this.updateSize();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYCursor.prototype, "fullWidthLineY", {
        /**
         * @return Full width?
         */
        get: function () {
            return this.getPropertyValue("fullWidthLineY");
        },
        /**
         * Cursor's vertical line is expanded to take full width of the related
         * Axis' cell/category.
         *
         * NOTE: this setting will work properly if `yAxis` is set and only in case
         * `yAxis` is [[CategoryAxis]] or [[DateAxis]].
         *
         * @param value Full width?
         */
        set: function (value) {
            this.setPropertyValue("fullWidthLineY", value);
            if (!value) {
                this.updateSize();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYCursor.prototype, "hideSeriesTooltipsOnSelection", {
        /**
         * @return hide tooltip?
         */
        get: function () {
            return this.getPropertyValue("hideSeriesTooltipsOnSelection");
        },
        /**
         * If set to `true` this will hide series tooltips when selecting with cursor.
         *
         * @since 4.5.15
         * @param  value  hide tooltips?
         */
        set: function (value) {
            this.setPropertyValue("hideSeriesTooltipsOnSelection", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYCursor.prototype, "maxTooltipDistance", {
        /**
         * @return Distance
         */
        get: function () {
            return this.getPropertyValue("maxTooltipDistance");
        },
        /**
         * If set to a numeric value, cursor will display closest series' tooltips
         * plus tooltips from series that are closer to than `maxTooltipDistance` to
         * it.
         *
         * Set it to `-1` to always force one tooltip, even if there are multiple
         * data items in exactly same place.
         *
         * @since 4.7.18
         * @param  value  Distance
         */
        set: function (value) {
            this.setPropertyValue("maxTooltipDistance", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYCursor.prototype, "maxPanOut", {
        /**
         * @return Full width?
         */
        get: function () {
            return this.getPropertyValue("maxPanOut");
        },
        /**
         * If cursor behavior is panX or panY, we allow to pan plot out of it's max bounds for a better user experience.
         * This setting specifies relative value by how much we can pan out the plot
         *
         * @param value
         */
        set: function (value) {
            this.setPropertyValue("maxPanOut", value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYCursor.prototype, "xAxis", {
        /**
         * @return X axis
         */
        get: function () {
            return this._xAxis.get();
        },
        /**
         * A reference to X [[Axis]].
         *
         * An XY cursor can live without `xAxis` set. You set xAxis for cursor when
         * you have axis tooltip enabled and you want cursor line to be at the same
         * position as tooltip.
         *
         * This works with [[CategoryAxis]] and [[DateAxis]] but not with
         * [[ValueAxis]].
         *
         * @todo Description (review)
         * @param axis X axis
         */
        set: function (axis) {
            var _this = this;
            if (this._xAxis.get() != axis) {
                this._xAxis.set(axis, new Disposer_MultiDisposer([
                    axis.tooltip.events.on("positionchanged", this.handleXTooltipPosition, this, false),
                    axis.events.on("rangechangestarted", function (event) {
                        _this.hide(0);
                        _this.preventShow = true;
                    }, undefined, false),
                    axis.events.on("rangechangeended", function (event) {
                        _this.preventShow = false;
                        _this.hide(0);
                        _this.dispatch("cursorpositionchanged");
                    }, undefined, false)
                ]));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYCursor.prototype, "yAxis", {
        /**
         * @return Y Axis
         */
        get: function () {
            return this._yAxis.get();
        },
        /**
         * A reference to Y [[Axis]].
         *
         * An XY cursor can live without `yAxis` set. You set xAxis for cursor when
         * you have axis tooltip enabled and you want cursor line to be at the same
         * position as tooltip.
         *
         * This works with [[CategoryAxis]] and [[DateAxis]] but not with
         * [[ValueAxis]].
         *
         * @todo Description (review)
         * @param axis Y axis
         */
        set: function (axis) {
            var _this = this;
            if (this._yAxis.get() != axis) {
                this._yAxis.set(axis, new Disposer_MultiDisposer([
                    axis.tooltip.events.on("positionchanged", this.handleYTooltipPosition, this, false),
                    axis.events.on("rangechangestarted", function (event) {
                        _this.hide(0);
                        _this.__disabled = true;
                    }, undefined, false),
                    axis.events.on("rangechangeended", function (event) {
                        _this.__disabled = false;
                        _this.hide(0);
                        _this.dispatch("cursorpositionchanged");
                    }, undefined, false)
                ]));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates Cursor's position when axis tooltip changes position.
     *
     * @ignore Exclude from docs
     * @param event Original Axis event
     */
    XYCursor.prototype.handleXTooltipPosition = function (event) {
        var tooltip = this.xAxis.tooltip;
        var point = svgPointToSprite({ x: tooltip.pixelX, y: tooltip.pixelY }, this);
        var x = point.x;
        point.y = 1;
        if (this.lineX) {
            this.lineX.x = x;
            if (!this.fitsToBounds(point)) {
                this.hide();
            }
        }
        if (this.xAxis && this.fullWidthLineX) {
            var startPoint = this.xAxis.currentItemStartPoint;
            var endPoint = this.xAxis.currentItemEndPoint;
            if (startPoint && endPoint) {
                this.lineX.x = x;
                var width = endPoint.x - startPoint.x;
                this.lineX.path = Path_rectangle(width, this.innerHeight, -width / 2);
            }
        }
    };
    /**
     * Updates Cursor's position when Y axis changes position or scale.
     *
     * @ignore Exclude from docs
     * @param event Original Axis event
     */
    XYCursor.prototype.handleYTooltipPosition = function (event) {
        var tooltip = this.yAxis.tooltip;
        var point = svgPointToSprite({ x: tooltip.pixelX, y: tooltip.pixelY }, this);
        var y = point.y;
        point.x = 1;
        if (this.lineY) {
            this.lineY.y = y;
            if (!this.fitsToBounds(point)) {
                this.hide();
            }
        }
        if (this.yAxis && this.fullWidthLineY) {
            var startPoint = this.yAxis.currentItemStartPoint;
            var endPoint = this.yAxis.currentItemEndPoint;
            if (startPoint && endPoint) {
                this.lineY.y = y;
                var height = endPoint.y - startPoint.y;
                this.lineY.path = Path_rectangle(this.innerWidth, height, 0, -height / 2);
            }
        }
    };
    Object.defineProperty(XYCursor.prototype, "lineX", {
        /**
         * @return Line element
         */
        get: function () {
            return this._lineX.get();
        },
        /**
         * A Line element to use for X axis.
         *
         * @param lineX Line
         */
        set: function (lineX) {
            if (lineX) {
                lineX.setElement(this.paper.add("path"));
                this._lineX.set(lineX, lineX.events.on("positionchanged", this.updateSelection, this, false));
                lineX.interactionsEnabled = false;
                lineX.parent = this;
            }
            else {
                this._lineX.reset();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYCursor.prototype, "lineY", {
        /**
         * @return Line element
         */
        get: function () {
            return this._lineY.get();
        },
        /**
         * A Line element to use Y axis.
         *
         * @param lineY Line
         */
        set: function (lineY) {
            if (lineY) {
                lineY.setElement(this.paper.add("path"));
                this._lineY.set(lineY, lineY.events.on("positionchanged", this.updateSelection, this, false));
                lineY.parent = this;
                lineY.interactionsEnabled = false;
            }
            else {
                this._lineY.reset();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(XYCursor.prototype, "selection", {
        /**
         * @return Selection rectangle
         */
        get: function () {
            return this._selection;
        },
        /**
         * A selection element ([[Sprite]]).
         *
         * @param selection Selection rectangle
         */
        set: function (selection) {
            this._selection = selection;
            if (selection) {
                selection.element = this.paper.add("path");
                selection.parent = this;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Processes JSON-based config before it is applied to the object.
     *
     * Looks if `xAxis` and `yAxis` is set via ID in JSON config, and replaces
     * with real references.
     *
     * @ignore Exclude from docs
     * @param config  Config
     */
    XYCursor.prototype.processConfig = function (config) {
        if (config) {
            // Set up axes
            if (hasValue(config.xAxis) && isString(config.xAxis)) {
                if (this.map.hasKey(config.xAxis)) {
                    config.xAxis = this.map.getKey(config.xAxis);
                }
                else {
                    this.processingErrors.push("[XYCursor] No axis with id \"" + config.xAxis + "\" found for `xAxis`");
                    delete config.xAxis;
                }
            }
            if (hasValue(config.yAxis) && isString(config.yAxis)) {
                if (this.map.hasKey(config.yAxis)) {
                    config.yAxis = this.map.getKey(config.yAxis);
                }
                else {
                    this.processingErrors.push("[XYCursor] No axis with id \"" + config.yAxis + "\" found for `yAxis`");
                    delete config.yAxis;
                }
            }
            if (hasValue(config.snapToSeries) && isString(config.snapToSeries)) {
                if (this.map.hasKey(config.snapToSeries)) {
                    config.snapToSeries = this.map.getKey(config.snapToSeries);
                }
                else {
                    this.processingErrors.push("[XYCursor] No series with id \"" + config.snapToSeries + "\" found for `series`");
                    delete config.snapToSeries;
                }
            }
        }
        _super.prototype.processConfig.call(this, config);
    };
    Object.defineProperty(XYCursor.prototype, "snapToSeries", {
        /**
         * @return {XYSeries | XYSeries[]}
         */
        get: function () {
            return this.getPropertyValue("snapToSeries");
        },
        /**
         * Specifies to which series cursor lines should be snapped.
         *
         * Can be a single series instance or an array of series.
         *
         * @param {XYSeries | XYSeries[]}
         */
        set: function (series) {
            var _this = this;
            if (this.setPropertyValue("snapToSeries", series)) {
                if (series instanceof XYSeries_XYSeries) {
                    series = [series];
                }
                if (this._snapToDisposers) {
                    each(this._snapToDisposers, function (disposer) {
                        disposer.dispose();
                    });
                }
                this._snapToDisposers = [];
                if (series) {
                    each(series, function (s) {
                        _this._snapToDisposers.push(s.events.on("tooltipshownat", function () { _this.handleSnap(s); }, undefined, false));
                    });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * [handleSnap description]
     *
     * @ignore
     * @todo Description
     */
    XYCursor.prototype.handleSnap = function (series) {
        if (!this.downPoint) {
            var x = series.getTooltipX() + series.xAxis.pixelX;
            var y = series.getTooltipY() + series.yAxis.pixelY;
            if (this.xAxis) {
                if (this.xAxis.renderer.opposite) {
                    y -= this.pixelHeight;
                }
            }
            this.point = { x: x, y: y };
            this.getPositions();
            var xx = x;
            var yy = y;
            x -= this.pixelWidth;
            if (this.yAxis) {
                if (this.yAxis.renderer.opposite) {
                    x += this.pixelWidth;
                }
            }
            var tooltip = series.tooltip;
            var duration = tooltip.animationDuration;
            var easing = tooltip.animationEasing;
            var xAxis = series.xAxis;
            var yAxis = series.yAxis;
            if (xAxis instanceof ValueAxis_ValueAxis && !(xAxis instanceof DateAxis_DateAxis) && yAxis instanceof ValueAxis_ValueAxis && !(yAxis instanceof DateAxis_DateAxis)) {
                series.yAxis.showTooltipAtPosition(this.yPosition);
                series.xAxis.showTooltipAtPosition(this.xPosition);
            }
            else {
                if (series.baseAxis == series.xAxis) {
                    series.yAxis.showTooltipAtPosition(this.yPosition);
                }
                if (series.baseAxis == series.yAxis) {
                    series.xAxis.showTooltipAtPosition(this.xPosition);
                }
            }
            this.lineX.animate([{ property: "y", to: y }], duration, easing);
            this.lineY.animate([{ property: "x", to: x }], duration, easing);
            if (!this.xAxis) {
                this.lineX.animate([{ property: "x", to: xx }], duration, easing);
            }
            if (!this.yAxis) {
                this.lineY.animate([{ property: "y", to: yy }], duration, easing);
            }
        }
    };
    /**
     * Destroys this object and all related data.
     */
    XYCursor.prototype.dispose = function () {
        this.hide(0);
        _super.prototype.dispose.call(this);
    };
    return XYCursor;
}(Cursor_Cursor));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["XYCursor"] = XYCursor_XYCursor;
//# sourceMappingURL=XYCursor.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/charts/cursors/RadarCursor.js








/**
 * ============================================================================
 * MAIN CLASS
 * ============================================================================
 * @hidden
 */
/**
 * Cursor for [[RadarChart]].
 *
 * @see {@link IRadarCursorEvents} for a list of available events
 * @see {@link IRadarCursorAdapters} for a list of available Adapters
 */
var RadarCursor_RadarCursor = /** @class */ (function (_super) {
    __extends(RadarCursor, _super);
    /**
     * Constructor
     */
    function RadarCursor() {
        var _this = 
        // Init
        _super.call(this) || this;
        _this.className = "RadarCursor";
        _this.radius = Percent_percent(100);
        _this.innerRadius = Percent_percent(0);
        // Apply theme
        _this.applyTheme();
        _this.mask = undefined;
        return _this;
    }
    /**
     * Checks if point is within bounds of a container.
     *
     * @ignore Exclude from docs
     * @param point  Point to check
     * @return Fits within container?
     */
    RadarCursor.prototype.fitsToBounds = function (point) {
        var radius = getDistance(point);
        //if(!$math.isAngleInRange(angle, this.startAngle, this.endAngle)){
        //return false;
        //}
        if (radius < this.truePixelRadius + 1 && radius > this.pixelInnerRadius - 1) { // ok to add/remove some
            return true;
        }
        return false;
    };
    Object.defineProperty(RadarCursor.prototype, "startAngle", {
        /**
         * @return Start angle
         */
        get: function () {
            return this.getPropertyValue("startAngle");
        },
        /**
         * Starting angle of the cursor's radial line.
         *
         * @param value Start angle
         */
        set: function (value) {
            this.setPropertyValue("startAngle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadarCursor.prototype, "endAngle", {
        /**
         * @return End angle
         */
        get: function () {
            return this.getPropertyValue("endAngle");
        },
        /**
         * End angle of the cursor's radial line.
         *
         * @param value End angle
         */
        set: function (value) {
            this.setPropertyValue("endAngle", value, true);
        },
        enumerable: true,
        configurable: true
    });
    RadarCursor.prototype.triggerMoveReal = function (point, force) {
        if (!this.xAxis || (this.xAxis && (!this.xAxis.cursorTooltipEnabled || this.xAxis.tooltip.disabled))) {
            this.updateLineX(this.point);
        }
        if (!this.yAxis || (this.yAxis && (!this.yAxis.cursorTooltipEnabled || this.yAxis.tooltip.disabled))) {
            this.updateLineY(this.point);
        }
        this.updateSelection();
        _super.prototype.triggerMoveReal.call(this, point, force);
    };
    /**
     * (Re)draws the horizontal (circular) cursor's line.
     *
     * @param point New target point
     */
    RadarCursor.prototype.updateLineX = function (point) {
        var radius = this.pixelRadius;
        var startAngle = this.startAngle;
        var endAngle = this.endAngle;
        var innerRadius = this.pixelInnerRadius;
        if (radius > 0 && isNumber(startAngle) && isNumber(endAngle) && isNumber(innerRadius)) {
            var angle = fitAngleToRange(getAngle(point), startAngle, endAngle);
            var path = void 0;
            if (this.lineX && this.lineX.visible) {
                this.lineX.moveTo({ x: 0, y: 0 });
                // fill
                if (this.xAxis && this.fullWidthLineX) {
                    var startPoint = this.xAxis.currentItemStartPoint;
                    var endPoint = this.xAxis.currentItemEndPoint;
                    if (startPoint && endPoint) {
                        var fillStartAngle = fitAngleToRange(getAngle(startPoint), startAngle, endAngle);
                        var fillEndAngle = fitAngleToRange(getAngle(endPoint), startAngle, endAngle);
                        var arc = fillEndAngle - fillStartAngle;
                        // clockwise
                        // this is needed, normalizeAngle doesn't solve it
                        if (startAngle < endAngle) {
                            if (arc < 0) {
                                arc += 360;
                            }
                        }
                        // ccw
                        else {
                            if (arc > 0) {
                                arc -= 360;
                            }
                        }
                        angle -= arc / 2;
                        path = moveTo({ x: innerRadius * Math_cos(angle), y: innerRadius * Math_sin(angle) })
                            + lineTo({ x: radius * Math_cos(angle), y: radius * Math_sin(angle) })
                            + arcTo(angle, arc, radius)
                            + lineTo({ x: innerRadius * Math_cos(angle + arc), y: innerRadius * Math_sin(angle + arc) })
                            + arcTo(angle + arc, -arc, innerRadius);
                    }
                }
                // line
                if (!path) {
                    path = moveTo({ x: innerRadius * Math_cos(angle), y: innerRadius * Math_sin(angle) }) + lineTo({ x: radius * Math_cos(angle), y: radius * Math_sin(angle) });
                }
                this.lineX.path = path;
            }
        }
    };
    /**
     * (Re)draws the vertical (radial) cursor's line.
     *
     * @param point New target point
     */
    RadarCursor.prototype.updateLineY = function (point) {
        if (this.lineY && this.lineY.visible) {
            var startAngle = this.startAngle;
            var endAngle = this.endAngle;
            var truePixelRadius = this.truePixelRadius;
            var radius = fitToRange(getDistance(point), 0, this.truePixelRadius);
            if (isNumber(radius) && isNumber(startAngle)) {
                this.lineY.moveTo({ x: 0, y: 0 });
                var path = void 0;
                var arc = endAngle - startAngle;
                if (this.yAxis && this.fullWidthLineY) {
                    // fill
                    var startPoint = this.yAxis.currentItemStartPoint;
                    var endPoint = this.yAxis.currentItemEndPoint;
                    if (startPoint && endPoint) {
                        var innerRadius = fitToRange(getDistance(startPoint), 0, truePixelRadius);
                        radius = fitToRange(getDistance(endPoint), 0, truePixelRadius);
                        path = moveTo({ x: radius * Math_cos(startAngle), y: radius * Math_sin(startAngle) }) + arcTo(startAngle, arc, radius);
                        path += moveTo({ x: innerRadius * Math_cos(endAngle), y: innerRadius * Math_sin(endAngle) }) + arcTo(endAngle, -arc, innerRadius);
                    }
                }
                if (!path) {
                    path = moveTo({ x: radius * Math_cos(startAngle), y: radius * Math_sin(startAngle) }) + arcTo(startAngle, endAngle - startAngle, radius);
                }
                this.lineY.path = path;
            }
        }
    };
    /**
     * Updates selection dimensions on size change.
     *
     * @ignore Exclude from docs
     */
    RadarCursor.prototype.updateSelection = function () {
        if (this._usesSelection) {
            var downPoint = this.downPoint;
            if (downPoint) {
                var point = this.point;
                var radius = this.pixelRadius;
                var truePixelRadius = this.truePixelRadius;
                var innerRadius = this.pixelInnerRadius;
                var startAngle = Math.min(this.startAngle, this.endAngle);
                var endAngle = Math.max(this.startAngle, this.endAngle);
                var downAngle = fitAngleToRange(getAngle(downPoint), startAngle, endAngle);
                var angle = fitAngleToRange(getAngle(point), startAngle, endAngle);
                var downRadius = getDistance(downPoint);
                if (downRadius < truePixelRadius) {
                    var currentRadius = fitToRange(getDistance(point), 0, truePixelRadius);
                    this._prevAngle = angle;
                    var path = moveTo({ x: 0, y: 0 });
                    var downSin = Math_sin(downAngle);
                    var downCos = Math_cos(downAngle);
                    var sin = Math_sin(angle);
                    var cos = Math_cos(angle);
                    var behavior = this.behavior;
                    if (behavior == "zoomX" || behavior == "selectX") {
                        path += lineTo({ x: radius * downCos, y: radius * downSin }) + arcTo(downAngle, angle - downAngle, radius) + lineTo({ x: innerRadius * cos, y: innerRadius * sin }) + arcTo(angle, downAngle - angle, innerRadius);
                    }
                    else if (behavior == "zoomY" || behavior == "selectY") {
                        path = moveTo({ x: currentRadius * Math_cos(startAngle), y: currentRadius * Math_sin(startAngle) }) + arcTo(startAngle, endAngle - startAngle, currentRadius) + lineTo({ x: downRadius * Math_cos(endAngle), y: downRadius * Math_sin(endAngle) }) + arcTo(endAngle, startAngle - endAngle, downRadius) + closePath();
                    }
                    else if (behavior == "zoomXY") {
                        path = moveTo({ x: currentRadius * Math_cos(downAngle), y: currentRadius * Math_sin(downAngle) }) + arcTo(downAngle, angle - downAngle, currentRadius) + lineTo({ x: downRadius * Math_cos(angle), y: downRadius * Math_sin(angle) }) + arcTo(angle, downAngle - angle, downRadius) + closePath();
                    }
                    this.selection.path = path;
                }
                this.selection.moveTo({ x: 0, y: 0 });
            }
        }
    };
    /**
     * Updates cursors current positions.
     */
    RadarCursor.prototype.getPositions = function () {
        // positions are used by axes or series
        var chart = this.chart;
        if (chart) {
            var innerRadius = this.pixelInnerRadius;
            var radius = this.truePixelRadius - innerRadius;
            var startAngle = this.startAngle;
            var endAngle = this.endAngle;
            var angle = fitAngleToRange(getAngle(this.point), startAngle, endAngle);
            var xPosition = ((angle - startAngle) / (endAngle - startAngle));
            this.xPosition = xPosition;
            this.yPosition = fitToRange((getDistance(this.point) - innerRadius) / radius, 0, 1);
        }
    };
    /**
     * Overriding inherited method, so that nothing happens when it's triggered.
     *
     * @ignore Exclude from docs
     */
    RadarCursor.prototype.updatePoint = function (point) {
    };
    /**
     * Updates Cursor's position when axis tooltip changes horizontal position.
     *
     * @param event Axis event
     */
    RadarCursor.prototype.handleXTooltipPosition = function (event) {
        if (this.xAxis.cursorTooltipEnabled) {
            var tooltip = this.xAxis.tooltip;
            this.updateLineX(svgPointToSprite({ x: tooltip.pixelX, y: tooltip.pixelY }, this));
        }
    };
    /**
     * Updates Cursor's position when axis tooltip changes vertical position.
     *
     * @todo Description
     * @param event Axis event
     */
    RadarCursor.prototype.handleYTooltipPosition = function (event) {
        if (this.yAxis.cursorTooltipEnabled) {
            var tooltip = this.yAxis.tooltip;
            this.updateLineY(svgPointToSprite({ x: tooltip.pixelX, y: tooltip.pixelY }, this));
        }
    };
    /**
     * needs to be overriden
     * @ignore
     */
    RadarCursor.prototype.updateLinePositions = function (point) {
    };
    /**
     * [getRanges description]
     *
     * @todo Description
     */
    RadarCursor.prototype.getRanges = function () {
        var downPoint = this.downPoint;
        if (downPoint) {
            var upPoint = this.upPoint;
            var chart = this.chart;
            if (chart) {
                var radius = this.pixelRadius;
                var startAngle = this.startAngle;
                var endAngle = this.endAngle;
                var downAngle = fitAngleToRange(getAngle(downPoint), this.startAngle, this.endAngle);
                var upAngle = fitAngleToRange(getAngle(upPoint), this.startAngle, this.endAngle);
                var downRadius = fitToRange(getDistance(downPoint), 0, radius);
                var upRadius = fitToRange(getDistance(upPoint), 0, radius);
                var startX = 0;
                var endX = 1;
                var startY = 0;
                var endY = 1;
                var behavior = this.behavior;
                if (behavior == "zoomX" || behavior == "selectX" || behavior == "zoomXY" || behavior == "selectXY") {
                    var arc = endAngle - startAngle;
                    startX = Math_round((downAngle - startAngle) / arc, 5);
                    endX = Math_round((upAngle - startAngle) / arc, 5);
                }
                if (behavior == "zoomY" || behavior == "selectY" || behavior == "zoomXY" || behavior == "selectXY") {
                    startY = Math_round(downRadius / radius, 5);
                    endY = Math_round(upRadius / radius, 5);
                }
                this.xRange = { start: Math.min(startX, endX), end: Math.max(startX, endX) };
                this.yRange = { start: Math.min(startY, endY), end: Math.max(startY, endY) };
                if (this.behavior == "selectX" || this.behavior == "selectY" || this.behavior == "selectXY") {
                    // void
                }
                else {
                    this.selection.hide();
                }
            }
        }
    };
    /**
     * Overriding inherited method, so that nothing happens when `updateSize`
     * is triggered.
     *
     * RadarCursor is quite complicated and needs own sizing logic.
     *
     * @ignore Exclude from docs
     */
    RadarCursor.prototype.updateSize = function () { };
    Object.defineProperty(RadarCursor.prototype, "radius", {
        /**
         * @return Outer radius
         */
        get: function () {
            return this.getPropertyValue("radius");
        },
        /**
         * Outer radius of the cursor's circular line.
         * Absolute (px) or relative ([[Percent]]).
         *
         * @param value  Outer radius
         */
        set: function (value) {
            this.setPercentProperty("radius", value, false, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadarCursor.prototype, "pixelRadius", {
        /**
         * Outer radius of the circular line in pixels.
         *
         * @return Outer radius (px)
         * @readonly
         */
        get: function () {
            return relativeRadiusToValue(this.radius, this.truePixelRadius);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadarCursor.prototype, "truePixelRadius", {
        /**
         * [truePixelRadius description]
         *
         * @todo Description
         * @return Outer radius (px)
         * @readonly
         */
        get: function () {
            return relativeToValue(Percent_percent(100), Math_min(this.innerWidth / 2, this.innerHeight / 2));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadarCursor.prototype, "innerRadius", {
        /**
         * @return Inner radius
         */
        get: function () {
            return this.getPropertyValue("innerRadius");
        },
        /**
         * Inner radius of the cursor's circular line.
         * Absolute (px) or relative ([[Percent]]).
         *
         * @param value  Inner radius
         */
        set: function (value) {
            this.setPercentProperty("innerRadius", value, false, false, 10, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadarCursor.prototype, "pixelInnerRadius", {
        /**
         * Inner radius of the circular line in pixels.
         *
         * @return Inner radius (px)
         * @readonly
         */
        get: function () {
            var innerRadius = this.innerRadius;
            if (innerRadius instanceof Percent) {
                innerRadius = Percent_percent(100 * innerRadius.value * this.chart.innerRadiusModifyer);
            }
            return relativeRadiusToValue(innerRadius, this.truePixelRadius) || 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @ignore Exclude from docs
     */
    RadarCursor.prototype.fixPoint = function (point) {
        // overriding xy method
        return point;
    };
    return RadarCursor;
}(XYCursor_XYCursor));

/**
 * Register class in system, so that it can be instantiated using its name from
 * anywhere.
 *
 * @ignore
 */
registry.registeredClasses["RadarCursor"] = RadarCursor_RadarCursor;
//# sourceMappingURL=RadarCursor.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/charts.js
/**
 * Module: gauge
 */
/**
 * Elements: types
 */












/**
 * Elements: charts
 */



/**
 * Elements: series
 */





















/**
 * Elements: axes
 */

























/**
 * Elements: elements
 */





















/**
 * Elements: cursors
 */



//# sourceMappingURL=charts.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/themes/animated.js

var theme = function (object) {
    if (is(object, "SpriteState")) {
        object.transitionDuration = 400;
    }
    if (is(object, "Component")) {
        object.rangeChangeDuration = 500;
        object.interpolationDuration = 500;
        object.sequencedInterpolation = false;
        if (is(object, "SankeyDiagram")) {
            object.sequencedInterpolation = true;
        }
        if (is(object, "FunnelSeries")) {
            object.sequencedInterpolation = true;
        }
    }
    if (is(object, "Chart")) {
        object.defaultState.transitionDuration = 2000;
        object.hiddenState.transitionDuration = 1000;
    }
    if (is(object, "Tooltip")) {
        object.animationDuration = 400;
        object.defaultState.transitionDuration = 400;
        object.hiddenState.transitionDuration = 400;
    }
    if (is(object, "Scrollbar")) {
        object.animationDuration = 500;
    }
    if (is(object, "Series")) {
        object.defaultState.transitionDuration = 1000;
        object.hiddenState.transitionDuration = 700;
        object.hiddenState.properties.opacity = 1;
        object.showOnInit = true;
    }
    if (is(object, "MapSeries")) {
        object.hiddenState.properties.opacity = 0;
    }
    if (is(object, "PercentSeries")) {
        object.hiddenState.properties.opacity = 0;
    }
    if (is(object, "FunnelSlice")) {
        object.defaultState.transitionDuration = 800;
        object.hiddenState.transitionDuration = 1000;
        object.hiddenState.properties.opacity = 1;
    }
    if (is(object, "Slice")) {
        object.defaultState.transitionDuration = 700;
        object.hiddenState.transitionDuration = 1000;
        object.hiddenState.properties.opacity = 1;
    }
    if (is(object, "Preloader")) {
        object.hiddenState.transitionDuration = 2000;
    }
    if (is(object, "Column")) {
        object.defaultState.transitionDuration = 700;
        object.hiddenState.transitionDuration = 1000;
        object.hiddenState.properties.opacity = 1;
    }
    if (is(object, "Column3D")) {
        object.hiddenState.properties.opacity = 0;
    }
};
/* harmony default export */ var animated = (theme);
//# sourceMappingURL=animated.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/themes/animated.js

//# sourceMappingURL=animated.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/.internal/themes/material.js


var material_theme = function (object) {
    if (is(object, "ColorSet")) {
        object.list = [
            Color_color("#F44336"),
            Color_color("#E91E63"),
            Color_color("#9C27B0"),
            Color_color("#673AB7"),
            Color_color("#3F51B5"),
            Color_color("#2196F3"),
            Color_color("#03A9F4"),
            Color_color("#00BCD4"),
            Color_color("#009688"),
            Color_color("#4CAF50"),
            Color_color("#8BC34A"),
            Color_color("#CDDC39"),
            Color_color("#FFEB3B"),
            Color_color("#FFC107"),
            Color_color("#FF9800"),
            Color_color("#FF5722"),
            Color_color("#795548"),
            Color_color("#9E9E9E"),
            Color_color("#607D8B")
        ];
        object.minLightness = 0.2;
        object.maxLightness = 0.7;
        object.reuse = true;
    }
    if (is(object, "ResizeButton")) {
        object.background.cornerRadiusTopLeft = 20;
        object.background.cornerRadiusTopRight = 20;
        object.background.cornerRadiusBottomLeft = 20;
        object.background.cornerRadiusBottomRight = 20;
    }
    if (is(object, "Tooltip")) {
        object.animationDuration = 800;
    }
};
/* harmony default export */ var material = (material_theme);
//# sourceMappingURL=material.js.map
// CONCATENATED MODULE: ./node_modules/@amcharts/amcharts4/themes/material.js

//# sourceMappingURL=material.js.map
// CONCATENATED MODULE: ./src/components/InfectionGraph.js






class InfectionGraph_InfectionGraph {
  constructor(divId) {
    useTheme(material);
    useTheme(animated);
    this.chart = create(divId, XYChart_XYChart);
    this.chart.width = Percent_percent(98);
    this.chart.height = Percent_percent(98);
    // disable logo
    this.chart.logo.height = -15000;
  }

  render(data) {
    this.chart.data = data;
    this.chart.dateFormatter.inputDateFormat = "yyyy-MM-dd";
    let dateAxis = this.chart.xAxes.push(new DateAxis_DateAxis());
    dateAxis.renderer.minGridDistance = 60;
    dateAxis.startLocation = 0.5;
    dateAxis.endLocation = 0.5;
    dateAxis.baseInterval = {
      timeUnit: "day",
      count: 1
    }
    dateAxis.dateFormatter = new DateFormatter_DateFormatter();
    dateAxis.dateFormats.setKey("day", "MM/dd");
    let valueAxis = this.chart.yAxes.push(new ValueAxis_ValueAxis());
    valueAxis.tooltip.disabled = true;

    let death = this.chart.series.push(new LineSeries_LineSeries());
    death.name = "死亡者数";
    death.dataFields.dateX = "reported_date";
    death.dataFields.valueY = "total_death";
    death.tooltipHTML = "<span style='font-size:14px; color:#000000;'>死亡者数:<b>{valueY.value}</b></span>";
    death.tooltipText = "[#000]{valueY.value}[/]";
    death.tooltip.background.fill = Color_color("#FFF");
    death.tooltip.getFillFromObject = false;
    death.tooltip.getStrokeFromObject = true;
    death.tooltip.background.strokeWidth = 3;
    death.sequencedInterpolation = true;
    death.fill = Color_color("#999999");
    death.fillOpacity = 0.6;
    death.defaultState.transitionDuration = 1000;
    death.stacked = true;
    death.stroke = Color_color("#999999");
    death.strokeWidth = 2;

    let recovery = this.chart.series.push(new LineSeries_LineSeries());
    recovery.name = "回復者数";
    recovery.dataFields.dateX = "reported_date";
    recovery.dataFields.valueY = "total_recovered";
    recovery.tooltipHTML = "<span style='font-size:14px; color:#000000;'>回復者数:<b>{valueY.value}</b></span>";
    recovery.tooltipText = "[#000]{valueY.value}[/]";
    recovery.tooltip.background.fill = Color_color("#FFF");
    recovery.tooltip.getFillFromObject = false;
    recovery.tooltip.getStrokeFromObject = true;
    recovery.tooltip.background.strokeWidth = 3;
    recovery.sequencedInterpolation = true;
    recovery.fill = Color_color("#93c47d");
    recovery.fillOpacity = 0.6;
    recovery.stacked = true;
    recovery.stroke = Color_color("#93c47d");
    recovery.strokeWidth = 2;

    let infection = this.chart.series.push(new LineSeries_LineSeries());
    infection.dataFields.dateX = "reported_date";
    infection.name = "感染者数";
    infection.dataFields.valueY = "current_infected";
    infection.tooltipHTML = "<span style='font-size:14px; color:#000000;'>感染者数:<b>{valueY.value}</b></span>";
    infection.tooltipText = "[#000]{valueY.value}[/]";
    infection.tooltip.background.fill = Color_color("#FFF");
    infection.tooltip.getStrokeFromObject = true;
    infection.tooltip.background.strokeWidth = 3;
    infection.tooltip.getFillFromObject = false;
    infection.fill = Color_color("#e06666");
    infection.fillOpacity = 0.6;
    infection.stroke = Color_color("#e06666");
    infection.strokeWidth = 2;
    infection.stacked = true;

    this.chart.cursor = new XYCursor_XYCursor();
    this.chart.cursor.xAxis = dateAxis;
    // Add a legend
    this.chart.legend = new Legend_Legend();
    this.chart.legend.position = "top";
  }
}

// CONCATENATED MODULE: ./src/App.js




class App_App {
  constructor() {
    moment_default.a.locale('ja');
    this.apiDomain = 'http://localhost:8000/';
    this.japanInfectionInfo = {};
    this.prefInfectionInfo = {};
    this.behaviorInfo = {};
  }

  mount() {
    try {
      // 日本の感染情報を取得
      this.japanInfectionInfo = fetchFromAPI(`${this.apiDomain}/stats/infection/japan`);
      this.japanInfectionInfo.then(infectionInfo => {
        // グラフを表示
        const graph = new InfectionGraph_InfectionGraph("graph");
        console.log(infectionInfo);
        graph.render(infectionInfo);
        // 感染者情報を表示
        displayJapanStats(infectionInfo);
      });

      // 行動情報を取得
      this.behaviorInfo = fetchFromAPI(`${this.apiDomain}/stats/behavior`);
      this.behaviorInfo.then(behaviorInfo => {
        // TODO: 実装
        // displayBehaviorStats(behaviorInfo);
      });

      // 都道府県ごとの感染情報を取得
      this.prefInfectionInfo = fetchFromAPI(`${this.apiDomain}/stats/infection/prefectures`);
      this.prefInfectionInfo.then(infectionInfo => {
        // 東京都の感染情報の概要表示
        displayPrefectureStatsOverview(infectionInfo[12]);

        // イベントリスナーの登録
        for (let info of infectionInfo) {
          let prefCellElement = document.querySelector(`#${info.name_en}`);
          prefCellElement.addEventListener("mouseover", {info: info, handleEvent: handleEventDisplayStats});
        }

        // 各都道府県の感染情報テーブル表示
        displayPrefectureStats(infectionInfo);

        // グラフの表示
        const graph = new InfectionGraph_InfectionGraph("detail-graph");
        console.log(infectionInfo[0].daily);
        graph.render(infectionInfo[0].daily);
      });
    } catch (error) {
      console.error(`${error}`);
    }
  }
}

function fetchFromAPI(url) {
  return fetch(url, {
    method: 'GET',
    mode: 'cors'
  })
  .then(response => {
    if (!response.ok) {
      return Promise.reject(new Error(`${response.status}: ${response.statusText}`));
    } else {
      return response.json();
    }
  });
}

function displayJapanStats(infectionInfo) {
  // TODO: 修正
  if (infectionInfo.length === 0) {
    return
  }

  // 日時見出し
  const dateElement = document.querySelector("#date");

  dateElement.innerHTML = moment_default()(infectionInfo[0].reported_date).format('MMMMDo(dddd)');

  // 当日
  const infectionNumElement = document.querySelector("#jp-infection-num");
  const recoveryNumElement = document.querySelector("#jp-recovery-num");
  const deadNumElement = document.querySelector("#jp-dead-num");

  infectionNumElement.innerHTML = infectionInfo[0].new_infected + '人';
  recoveryNumElement.innerHTML = infectionInfo[0].total_recovered - infectionInfo[1].total_recovered + '人';
  deadNumElement.innerHTML = infectionInfo[0].total_death - infectionInfo[1].total_death + '人';

  // 累計
  const totalInfectionNumElement = document.querySelector("#jp-total-infection-num");
  const totalRecoveryNumElement = document.querySelector("#jp-total-recovery-num");
  const totalDeadNumElement = document.querySelector("#jp-total-dead-num");

  totalInfectionNumElement.innerHTML = infectionInfo[0].total_infected + '人';
  totalRecoveryNumElement.innerHTML = infectionInfo[0].total_recovered + '人';
  totalDeadNumElement.innerHTML = infectionInfo[0].total_death + '人';
}

function displayPrefectureStats(infectionInfo) {
  // 感染者数テーブル
  for (let info of infectionInfo) {
    let prefCellElement = document.querySelector(`#${info.name_en}`);
    if (info.daily.length > 0) {
      // データが存在している場合は現在感染者数を表示
      prefCellElement.innerHTML = info.daily[0].current_infected;
    } else {
      // データがない場合は不明
      prefCellElement.innerHTML = '不明';
    }
  }
}

// TODO: 実装
function displayBehaviorStats(behaviorInfo) {
  const stayHomeElement = document.querySelector("#jp-stay-home-ratio");
}

function handleEventDisplayStats(e) {
  displayPrefectureStatsOverview(this.info);
}

function displayPrefectureStatsOverview(info) {
  const prefNameElement = document.querySelector('#prefecture-name');
  prefNameElement.innerHTML = info.name;

  const infectionNumElement = document.querySelector("#infection-num");
  const recoveryNumElement = document.querySelector("#recovery-num");
  const deadNumElement = document.querySelector("#dead-num");

  const totalInfectionNumElement = document.querySelector("#total-infection-num");
  const totalRecoveryNumElement = document.querySelector("#total-recovery-num");
  const totalDeadNumElement = document.querySelector("#total-dead-num");

  if (info.daily.length > 1) {
    // データが存在している場合は現在感染者数を表示
    infectionNumElement.innerHTML = info.daily[0].new_infected + '人';
    recoveryNumElement.innerHTML = info.daily[0].total_recovered - info.daily[1].total_recovered + '人';
    deadNumElement.innerHTML = info.daily[0].total_death - info.daily[1].total_death + '人';

    totalInfectionNumElement.innerHTML = info.daily[0].total_infected + '人';
    totalRecoveryNumElement.innerHTML = info.daily[0].total_recovered + '人';
    totalDeadNumElement.innerHTML = info.daily[0].total_death + '人';
  } else {
    // データがない場合は不明
    infectionNumElement.innerHTML = '- 人';
    recoveryNumElement.innerHTML = '- 人';
    deadNumElement.innerHTML = '- 人';

    totalInfectionNumElement.innerHTML = '- 人';
    totalRecoveryNumElement.innerHTML = '- 人';
    totalDeadNumElement.innerHTML = '- 人';
  }
}

// CONCATENATED MODULE: ./src/index.js

const app = new App_App();
app.mount();


/***/ })
/******/ ]);